LF flay : etp -> skel -> eterm -> type =
| flay/t : flay et kt estar

| flay/pi : flay A As M ->
              ({x : eterm} flay (B x) Bs (N x)) ->
              flay (epi A B) (kpi As Bs) (epair M (elam A (\x. N x)))

| flay/sigma : flay A As M ->
                 ({x : eterm} flay (B x) Bs (N x)) ->
                 flay (esigma A B) (ksigma As Bs) (epair M (elam A (\x. N x)))

| flay/sing : flay (esing M) ksing M

| flay/one : flay eone kone estar
;
--name flay Dflay flay.

LF can-flay/e : etp -> type =
| can-flay/i:
  { K : skel } { M : eterm } flay A K M ->
    can-flay/e A
;

proof can-flay : (g : evar) { A : [g |- etp] } [g |- can-flay/e A] =
/ total 1 /
intros
{ g : evar, A : (g |- etp)
|
; split [_ |- A] as
  case eone:
  { g : evar
  | 
  ; solve [g |- can-flay/i _ _ flay/one]
  }
  case esing:
  { g : evar, M : (g |- eterm)
  | 
  ; solve [g |- can-flay/i _ _ (flay/sing )]
  }
  case esigma:
  { g : evar, A1 : (g |- etp), A2 : (g, z78 : eterm |- etp)
  | 
  ; split can-flay [g |- A1] as
    case can-flay/i:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, z78 : eterm |- etp),
      Dskel : ( |- skel),
      M : (g |- eterm),
      Dflay : (g |- flay A1 Dskel[] M)
    | 
    ; split can-flay [g, x : eterm |- A2] as
      case can-flay/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, z78 : eterm |- etp),
        Dskel : ( |- skel),
        M : (g |- eterm),
        Dflay : (g |- flay A1 Dskel[] M),
        Dskel1 : ( |- skel),
        M1 : (g, x : eterm |- eterm),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M1)
      | 
      ; solve [g |- can-flay/i _ _ (flay/sigma Dflay (\x. Dflay1))]
      }
    }
  }
  case epi:
  { g : evar, A1 : (g |- etp), A2 : (g, z77 : eterm |- etp)
  | 
  ; split can-flay [g |- A1] as
    case can-flay/i:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, z77 : eterm |- etp),
      Dskel : ( |- skel),
      M : (g |- eterm),
      Dflay : (g |- flay A1 Dskel[] M)
    | 
    ; split can-flay [g, x : eterm |- A2] as
      case can-flay/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, z77 : eterm |- etp),
        Dskel : ( |- skel),
        M : (g |- eterm),
        Dflay : (g |- flay A1 Dskel[] M),
        Dskel1 : ( |- skel),
        M1 : (g, x : eterm |- eterm),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M1)
      | 
      ; solve [g |- can-flay/i _ _ (flay/pi Dflay (\x. Dflay1))]
      }
    }
  }
  case et:
  { g : evar
  | 
  ; solve [g |- can-flay/i _ _ flay/t]
  }
}
;
