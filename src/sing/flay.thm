% Definitions

LF eexpand : eterm -> etp -> eterm -> type =
| eexpand/t : eexpand R et R

| eexpand/pi :
  ({ x : eterm } eexpand x A (M x)) ->
  ({ x : eterm } eexpand (eapp R (M x)) (B x) (N x)) ->
    eexpand R (epi A B) (elam A N)

| eexpand/sigma :
  eexpand (epi1 R) A M ->
  eexpand (epi2 R) (B (epi1 R)) N ->
    eexpand R (esigma A B) (epair M N)

| eexpand/sing : eexpand R (esing R') R'

| eexpand/one : eexpand R eone estar
;
--name eexpand Dexpand expand.

LF skof : skel -> etp -> (eterm -> etp) -> type =
| skof/t : skof kt eone (\l. et)

| skof/pi :
  skof As C (\y. A y) ->
  skof Bs D (\z. B z) ->
  ({ y : eterm } { x : eterm } eexpand x (A y) (X y x)) ->
    skof
      (kpi As Bs)
      (esigma C (\y. epi (A y) (\l. D)))
      (\w. epi (A (epi1 w)) (\x. B (eapp (epi2 w) (X (epi1 w) x))))

| skof/sigma :
  skof As C (\y. A y) ->
  skof Bs D (\z. B z) ->
  ({ y : eterm } { x : eterm } eexpand x (A y) (X y x)) ->
    skof
      (ksigma As Bs)
      (esigma C (\y. epi (A y) (\l. D)))
      (\w. esigma (A (epi1 w)) (\x. B (eapp (epi2 w) (X (epi1 w) x))))

| skof/sing : skof ksing et (\x. esing x)

| skof/one : skof kone eone (\l. eone)
;
--name skof Dskof skof.

LF flay : etp -> skel -> eterm -> type =
| flay/t : flay et kt estar

| flay/pi : flay A As M ->
              ({x : eterm} flay (B x) Bs (N x)) ->
              flay (epi A B) (kpi As Bs) (epair M (elam A (\x. N x)))

| flay/sigma : flay A As M ->
                 ({x : eterm} flay (B x) Bs (N x)) ->
                 flay (esigma A B) (ksigma As Bs) (epair M (elam A (\x. N x)))

| flay/sing : flay (esing M) ksing M

| flay/one : flay eone kone estar
;
--name flay Dflay flay.

% Equality

proof eexpand-resp :
  (g : evar)
  [g |- eterm-eq R R'] ->
  [g |- etp-eq A A'] ->
  [g |- eterm-eq M M'] ->
  [g |- eexpand R A M] ->
    [g |- eexpand R' A' M'] =
/ total /
intros
{ g : evar,
  R : (g |- eterm),
  R' : (g |- eterm),
  A : (g |- etp),
  A' : (g |- etp),
  M : (g |- eterm),
  M' : (g |- eterm)
| eq : [g |- eterm-eq R R'],
  eq1 : [g |- etp-eq A A'],
  eq2 : [g |- eterm-eq M M'],
  expand : [g |- eexpand R A M]
; split eq as
  case eterm-eq/i:
  { g : evar,
    R' : (g |- eterm),
    A : (g |- etp),
    A' : (g |- etp),
    M : (g |- eterm),
    M' : (g |- eterm)
  | eq : [g |- eterm-eq R' R'],
    eq1 : [g |- etp-eq A A'],
    eq2 : [g |- eterm-eq M M'],
    expand : [g |- eexpand R' A M]
  ; split eq1 as
    case etp-eq/i:
    { g : evar,
      R' : (g |- eterm),
      A' : (g |- etp),
      M : (g |- eterm),
      M' : (g |- eterm)
    | eq : [g |- eterm-eq R' R'],
      eq1 : [g |- etp-eq A' A'],
      eq2 : [g |- eterm-eq M M'],
      expand : [g |- eexpand R' A' M]
    ; split eq2 as
      case eterm-eq/i:
      { g : evar, R' : (g |- eterm), A' : (g |- etp), M' : (g |- eterm)
      | eq : [g |- eterm-eq R' R'],
        eq1 : [g |- etp-eq A' A'],
        eq2 : [g |- eterm-eq M' M'],
        expand : [g |- eexpand R' A' M']
      ; solve expand
      }
    }
  }
}
;

proof flay-resp :
  (g : evar)
  [g |- etp-eq A A'] ->
  [ |- skel-eq K K'] ->
  [g |- eterm-eq M M'] ->
  [g |- flay A K[] M] ->
    [g |- flay A' K'[] M'] =
/ total /
intros
{ g : evar,
  A : (g |- etp),
  A' : (g |- etp),
  K : ( |- skel),
  K' : ( |- skel),
  M : (g |- eterm),
  M' : (g |- eterm)
| eq : [g |- etp-eq A A'],
  eq1 : [ |- skel-eq K K'],
  eq2 : [g |- eterm-eq M M'],
  flay : [g |- flay A K[] M]
; split eq as
  case etp-eq/i:
  { g : evar,
    A' : (g |- etp),
    K : ( |- skel),
    K' : ( |- skel),
    M : (g |- eterm),
    M' : (g |- eterm)
  | eq : [g |- etp-eq A' A'],
    eq1 : [ |- skel-eq K K'],
    eq2 : [g |- eterm-eq M M'],
    flay : [g |- flay A' K[] M]
  ; split eq1 as
    case skel-eq/i:
    { g : evar,
      A' : (g |- etp),
      K' : ( |- skel),
      M : (g |- eterm),
      M' : (g |- eterm)
    | eq : [g |- etp-eq A' A'],
      eq1 : [ |- skel-eq K' K'],
      eq2 : [g |- eterm-eq M M'],
      flay : [g |- flay A' K'[] M]
    ; split eq2 as
      case eterm-eq/i:
      { g : evar, A' : (g |- etp), K' : ( |- skel), M' : (g |- eterm)
      | eq : [g |- etp-eq A' A'],
        eq1 : [ |- skel-eq K' K'],
        eq2 : [g |- eterm-eq M' M'],
        flay : [g |- flay A' K'[] M']
      ; solve flay
      }
    }
  }
}
;

proof skof-resp :
  (g : evar)
  [ |- skel-eq K K'] ->
  [g |- etp-eq C C'] ->
  [g, x : eterm |- etp-eq (A[x]) (A'[x])] ->
  [g |- skof K[] C (\x. A[x])] ->
  [g |- skof K'[] C' (\x. A'[x])] =
/ total /
intros
{ g : evar,
  K : ( |- skel),
  K' : ( |- skel),
  C : (g |- etp),
  C' : (g |- etp),
  A : (x : eterm |- etp),
  A' : (x : eterm |- etp)
| eq : [ |- skel-eq K K'],
  eq1 : [g |- etp-eq C C'],
  eq2 : [g, x : eterm |- etp-eq (A[x]) (A'[x])],
  skof : [g |- skof K[] C (\x. A[x])]
; split eq as
  case skel-eq/i:
  { g : evar,
    K' : ( |- skel),
    C : (g |- etp),
    C' : (g |- etp),
    A : (x : eterm |- etp),
    A' : (x : eterm |- etp)
  | eq : [ |- skel-eq K' K'],
    eq1 : [g |- etp-eq C C'],
    eq2 : [g, x : eterm |- etp-eq (A[x]) (A'[x])],
    skof : [g |- skof K'[] C (\x. A[x])]
  ; split eq1 as
    case etp-eq/i:
    { g : evar,
      K' : ( |- skel),
      C' : (g |- etp),
      A : (x : eterm |- etp),
      A' : (x : eterm |- etp)
    | eq : [ |- skel-eq K' K'],
      eq1 : [g |- etp-eq C' C'],
      eq2 : [g, x : eterm |- etp-eq (A[x]) (A'[x])],
      skof : [g |- skof K'[] C' (\x. A[x])]
    ; split eq2 as
      case etp-eq/i:
      { g : evar, K' : ( |- skel), C' : (g |- etp), A' : (x : eterm |- etp)
      | eq : [ |- skel-eq K' K'],
        eq1 : [g |- etp-eq C' C'],
        eq2 : [g, x : eterm |- etp-eq (A'[x]) (A'[x])],
        skof : [g |- skof K'[] C' (\x. A'[x])]
      ; solve skof
      }
    }
  }
}
;

% Eexpand Theorems

LF esimp : etp -> stp -> type =
| esimp/t : esimp et st

| esimp/pi :
  esimp A S ->
  ({ x : eterm } esimp (B x) T) ->
    esimp (epi A B) (spi S T)

| esimp/sigma :
  esimp A S ->
  ({ x : eterm } esimp (B x) T) ->
    esimp (esigma A B) (ssigma S T)

| esimp/sing : esimp (esing R) st

| esimp/one : esimp eone sone
;
--name esimp Dsimp esimp.

LF can-esimp/e : etp -> type =
| can-esimp/i : { T : stp } esimp A T -> can-esimp/e A
;

proof can-esimp :
  (g : evar)
  { A : [g |- etp] }
  [g |- can-esimp/e A] =
/ total 1 /
intros
{ g : evar, A : (g |- etp)
|
; split [_ |- A] as
  case eone:
  { g : evar
  |
  ; solve [_ |- can-esimp/i _ esimp/one]
  }
  case esing:
  { g : evar, M : (g |- eterm)
  |
  ; solve [_ |- can-esimp/i _ (esimp/sing )]
  }
  case esigma:
  { g : evar, A1 : (g |- etp), A2 : (g, y149 : eterm |- etp)
  |
  ; split can-esimp [_ |- A1] as
    case can-esimp/i:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, y149 : eterm |- etp),
      T : ( |- stp),
      Dsimp : (g |- esimp A1 T[])
    |
    ; split can-esimp [_, y149 : eterm |- A2] as
      case can-esimp/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, y149 : eterm |- etp),
        T : ( |- stp),
        Dsimp : (g |- esimp A1 T[]),
        T1 : ( |- stp),
        Dsimp1 : (g, y149 : eterm |- esimp A2 T1[])
      |
      ; solve [_ |- can-esimp/i _ (esimp/sigma Dsimp (\x. Dsimp1))]
      }
    }
  }
  case epi:
  { g : evar, A1 : (g |- etp), A2 : (g, y148 : eterm |- etp)
  |
  ; split can-esimp [_ |- A1] as
    case can-esimp/i:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, y148 : eterm |- etp),
      T : ( |- stp),
      Dsimp : (g |- esimp A1 T[])
    |
    ; split can-esimp [_, y148 : eterm |- A2] as
      case can-esimp/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, y148 : eterm |- etp),
        T : ( |- stp),
        Dsimp : (g |- esimp A1 T[]),
        T1 : ( |- stp),
        Dsimp1 : (g, y148 : eterm |- esimp A2 T1[])
      |
      ; solve [_ |- can-esimp/i _ (esimp/pi Dsimp (\x. Dsimp1))]
      }
    }
  }
  case et:
  { g : evar
  |
  ; solve [_ |- can-esimp/i _ esimp/t]
  }
}
;

LF can-eexpand/e : eterm -> etp -> type =
| can-eexpand/i : { M : eterm } eexpand R A M -> can-eexpand/e R A
;

proof can-eexpand :
  (g : evar)
  { R : [g |- eterm] }
  { A : [g |- etp] }
  [g |- can-eexpand/e R A] =
/ trust / % FIXME: See issue #4
intros
{ g : evar, R : (g |- eterm), A : (g |- etp)
|
; split can-esimp [_ |- A] as
  case can-esimp/i:
  { g : evar,
    R : (g |- eterm),
    A : (g |- etp),
    T : ( |- stp),
    Dsimp : (g |- esimp A T[])
  |
  ; split [_ |- Dsimp] as
    case esimp/one:
    { g : evar, R : (g |- eterm)
    |
    ; solve [_ |- can-eexpand/i _ (eexpand/one )]
    }
    case esimp/sing:
    { g : evar, R : (g |- eterm), M : (g |- eterm)
    |
    ; solve [_ |- can-eexpand/i _ (eexpand/sing )]
    }
    case esimp/sigma:
    { g : evar,
      R : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, z329 : eterm |- etp),
      T1 : ( |- stp),
      T2 : ( |- stp),
      Dsimp1 : (g |- esimp A1 T1[]),
      Dsimp2 : (g, x : eterm |- esimp A2 T2[])
    |
    ; split can-eexpand [g |- epi1 R] [g |- A1] as
      case can-eexpand/i:
      { g : evar,
        R : (g |- eterm),
        A1 : (g |- etp),
        A2 : (g, z329 : eterm |- etp),
        T1 : ( |- stp),
        T2 : ( |- stp),
        Dsimp1 : (g |- esimp A1 T1[]),
        Dsimp2 : (g, x : eterm |- esimp A2 T2[]),
        M1 : (g |- eterm),
        Dexpand : (g |- eexpand (epi1 R) A1 M1)
      |
      ; split can-eexpand [g |- epi2 R] [g |- A2[.., epi1 R]] as
        case can-eexpand/i:
        { g : evar,
          R : (g |- eterm),
          A1 : (g |- etp),
          A2 : (g, z329 : eterm |- etp),
          T1 : ( |- stp),
          T2 : ( |- stp),
          Dsimp1 : (g |- esimp A1 T1[]),
          Dsimp2 : (g, x : eterm |- esimp A2 T2[]),
          M1 : (g |- eterm),
          Dexpand : (g |- eexpand (epi1 R) A1 M1),
          M3 : (g |- eterm),
          Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3)
        |
        ; solve [g |- can-eexpand/i _ (eexpand/sigma Dexpand Dexpand1)]
        }
      }
    }
    case esimp/pi:
    { g : evar,
      R : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, z328 : eterm |- etp),
      T1 : ( |- stp),
      T2 : ( |- stp),
      Dsimp1 : (g |- esimp A1 T1[]),
      Dsimp2 : (g, x : eterm |- esimp A2 T2[])
    |
    ; split
        can-eexpand
          [g, b : block (x : eterm) |- b.1]
          [g, b : block (x : eterm) |- A1[..]]
      as
      case can-eexpand/i:
      { g : evar,
        R : (g |- eterm),
        A1 : (g |- etp),
        A2 : (g, z328 : eterm |- etp),
        T1 : ( |- stp),
        T2 : ( |- stp),
        Dsimp1 : (g |- esimp A1 T1[]),
        Dsimp2 : (g, x : eterm |- esimp A2 T2[]),
        M1 : (g, y1 : eterm |- eterm),
        Dexpand : (g, x1 : eterm |- eexpand x1 (A1[..]) M1)
      |
      ; %{ FIXME: Wrong block projections after
            invert can-eexpand [g, b : block (x : eterm) |- eapp (R[..]) (M1[.., b.x])] [g, b |- A2[.., b.x]]
        }%
        ?
      }
    }
    case esimp/t:
    { g : evar, R : (g |- eterm)
    |
    ; solve [_ |- can-eexpand/i _ (eexpand/t )]
    }
  }
}
;

% Skof Theorems

LF can-skof/e : skel -> type =
| can-skof/i : { A : etp } { B : eterm -> etp } skof K A B -> can-skof/e K
;

proof can-skof :
  (g : evar)
  { K : [g |- skel] }
  [g |- can-skof/e K] =
/ total 1 /
intros
{ g : evar, K : (g |- skel)
|
; split [_ |- K] as
  case kone:
  { g : evar
  |
  ; solve [_ |- can-skof/i _ (\x. _) skof/one]
  }
  case ksing:
  { g : evar
  |
  ; solve [_ |- can-skof/i _ (\x. _) skof/sing]
  }
  case ksigma:
  { g : evar, Dskel : ( |- skel), Dskel1 : ( |- skel)
  |
  ; split can-skof [ |- Dskel] as
    case can-skof/i:
    { g : evar,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      A : ( |- etp),
      A1 : (z332 : eterm |- etp),
      Dskof : ( |- skof Dskel A (\z310. A1))
    |
    ; split can-skof [ |- Dskel1] as
      case can-skof/i:
      { g : evar,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        A : ( |- etp),
        A1 : (z332 : eterm |- etp),
        Dskof : ( |- skof Dskel A (\z310. A1)),
        A2 : ( |- etp),
        A3 : (z332 : eterm |- etp),
        Dskof1 : ( |- skof Dskel1 A2 (\z310. A3))
      |
      ; ?
      }
    }
  }
  case kpi:
  { g : evar, Dskel : ( |- skel), Dskel1 : ( |- skel)
  |
  ; split can-skof [ |- Dskel] as
    case can-skof/i:
    { g : evar,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      A : ( |- etp),
      A1 : (z332 : eterm |- etp),
      Dskof : ( |- skof Dskel A (\z310. A1))
    |
    ; split can-skof [ |- Dskel1] as
      case can-skof/i:
      { g : evar,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        A : ( |- etp),
        A1 : (z332 : eterm |- etp),
        Dskof : ( |- skof Dskel A (\z310. A1)),
        A2 : ( |- etp),
        A3 : (z332 : eterm |- etp),
        Dskof1 : ( |- skof Dskel1 A2 (\z310. A3))
      |
      ; %{ FIXME: Wrong projections after
            invert can-eexpand [_, b1 : block (x : eterm), b2 : block (y : eterm)|- b1.x] [g, b1, b2|-A1[b2.y]]
        }%
        ?
      }
    }
  }
  case kt:
  { g : evar
  |
  ; solve [_ |- can-skof/i _ (\x. _) skof/t]
  }
}
;

% Flay Theorems

LF can-flay/e : etp -> type =
| can-flay/i:
  { K : skel } { M : eterm } flay A K M ->
    can-flay/e A
;

proof can-flay : (g : evar) { A : [g |- etp] } [g |- can-flay/e A] =
/ total 1 /
intros
{ g : evar, A : (g |- etp)
|
; split [_ |- A] as
  case eone:
  { g : evar
  |
  ; solve [g |- can-flay/i _ _ flay/one]
  }
  case esing:
  { g : evar, M : (g |- eterm)
  |
  ; solve [g |- can-flay/i _ _ (flay/sing )]
  }
  case esigma:
  { g : evar, A1 : (g |- etp), A2 : (g, z78 : eterm |- etp)
  |
  ; split can-flay [g |- A1] as
    case can-flay/i:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, z78 : eterm |- etp),
      Dskel : ( |- skel),
      M : (g |- eterm),
      Dflay : (g |- flay A1 Dskel[] M)
    |
    ; split can-flay [g, x : eterm |- A2] as
      case can-flay/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, z78 : eterm |- etp),
        Dskel : ( |- skel),
        M : (g |- eterm),
        Dflay : (g |- flay A1 Dskel[] M),
        Dskel1 : ( |- skel),
        M1 : (g, x : eterm |- eterm),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M1)
      |
      ; solve [g |- can-flay/i _ _ (flay/sigma Dflay (\x. Dflay1))]
      }
    }
  }
  case epi:
  { g : evar, A1 : (g |- etp), A2 : (g, z77 : eterm |- etp)
  |
  ; split can-flay [g |- A1] as
    case can-flay/i:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, z77 : eterm |- etp),
      Dskel : ( |- skel),
      M : (g |- eterm),
      Dflay : (g |- flay A1 Dskel[] M)
    |
    ; split can-flay [g, x : eterm |- A2] as
      case can-flay/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, z77 : eterm |- etp),
        Dskel : ( |- skel),
        M : (g |- eterm),
        Dflay : (g |- flay A1 Dskel[] M),
        Dskel1 : ( |- skel),
        M1 : (g, x : eterm |- eterm),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M1)
      |
      ; solve [g |- can-flay/i _ _ (flay/pi Dflay (\x. Dflay1))]
      }
    }
  }
  case et:
  { g : evar
  |
  ; solve [g |- can-flay/i _ _ flay/t]
  }
}
;

LF flay-fun/e : skel -> skel -> eterm -> eterm -> type =
| flay-fun/i :
  skel-eq K1 K2 ->
  eterm-eq M1 M2 ->
    flay-fun/e K1 K2 M1 M2
;

proof flay-fun :
  (g : evar)
  [g |- flay A K1[] M1] ->
  [g |- flay A K2[] M2] ->
    [g |- flay-fun/e K1[] K2[] M1 M2] =
/ total 1 /
intros
{ g : evar,
  A : (g |- etp),
  K : ( |- skel),
  M : (g |- eterm),
  K1 : ( |- skel),
  M1 : (g |- eterm)
| x : [g |- flay A K[] M], flay : [g |- flay A K1[] M1]
; split x as
  case flay/one:
  { g : evar, K1 : ( |- skel), M1 : (g |- eterm)
  | x : [g |- flay eone kone estar], flay : [g |- flay eone K1[] M1]
  ; split flay as
    case flay/one:
    { g : evar
    | x : [g |- flay eone kone estar], flay : [g |- flay eone kone estar]
    ; solve [_ |- flay-fun/i (skel-eq/i ) (eterm-eq/i )]
    }
  }
  case flay/sing:
  { g : evar, M : (g |- eterm), K1 : ( |- skel), M1 : (g |- eterm)
  | x : [g |- flay (esing M) ksing M], flay : [g |- flay (esing M) K1[] M1]
  ; split flay as
    case flay/sing:
    { g : evar, M1 : (g |- eterm)
    | x : [g |- flay (esing M1) ksing M1],
      flay : [g |- flay (esing M1) ksing M1]
    ; solve [g |- flay-fun/i (skel-eq/i ) (eterm-eq/i )]
    }
  }
  case flay/sigma:
  { g : evar,
    A1 : (g |- etp),
    A2 : (g, z177 : eterm |- etp),
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    M2 : (g |- eterm),
    M3 : (g, y178 : eterm |- eterm),
    K1 : ( |- skel),
    M1 : (g |- eterm),
    Dflay : (g |- flay A1 Dskel[] M2),
    Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3)
  | x :
      [g |-
         flay
           (esigma A1 (\z78. A2))
           (ksigma Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
    flay : [g |- flay (esigma A1 (\z78. A2)) K1[] M1]
  ; split flay as
    case flay/sigma:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, z177 : eterm |- etp),
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      M2 : (g |- eterm),
      M3 : (g, y178 : eterm |- eterm),
      Dskel2 : ( |- skel),
      Dskel3 : ( |- skel),
      M4 : (g |- eterm),
      M5 : (g, z230 : eterm |- eterm),
      Dflay : (g |- flay A1 Dskel[] M2),
      Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
      Dflay2 : (g |- flay A1 Dskel2[] M4),
      Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5)
    | x :
        [g |-
           flay
             (esigma A1 (\x128. A2))
             (ksigma Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
      flay :
        [g |-
           flay
             (esigma A1 (\x128. A2))
             (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
    ; split flay-fun [g |- Dflay] [g |- Dflay2] as
      case flay-fun/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, z177 : eterm |- etp),
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        M2 : (g |- eterm),
        M3 : (g, y178 : eterm |- eterm),
        Dskel2 : ( |- skel),
        Dskel3 : ( |- skel),
        M4 : (g |- eterm),
        M5 : (g, z230 : eterm |- eterm),
        Dflay : (g |- flay A1 Dskel[] M2),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
        Dflay2 : (g |- flay A1 Dskel2[] M4),
        Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
        Deq : ( |- skel-eq Dskel Dskel2),
        Deq1 : (g |- eterm-eq M2 M4)
      | x :
          [g |-
             flay
               (esigma A1 (\x128. A2))
               (ksigma Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
        flay :
          [g |-
             flay
               (esigma A1 (\x128. A2))
               (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
      ; split flay-fun [g, x : eterm |- Dflay1] [g, x : eterm |- Dflay3] as
        case flay-fun/i:
        { g : evar,
          A1 : (g |- etp),
          A2 : (g, z177 : eterm |- etp),
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          M2 : (g |- eterm),
          M3 : (g, y178 : eterm |- eterm),
          Dskel2 : ( |- skel),
          Dskel3 : ( |- skel),
          M4 : (g |- eterm),
          M5 : (g, z230 : eterm |- eterm),
          Dflay : (g |- flay A1 Dskel[] M2),
          Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
          Dflay2 : (g |- flay A1 Dskel2[] M4),
          Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
          Deq : ( |- skel-eq Dskel Dskel2),
          Deq1 : (g |- eterm-eq M2 M4),
          Deq2 : ( |- skel-eq Dskel1 Dskel3),
          Deq3 : (g, x : eterm |- eterm-eq M3 M5)
        | x :
            [g |-
               flay
                 (esigma A1 (\x128. A2))
                 (ksigma Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
          flay :
            [g |-
               flay
                 (esigma A1 (\x128. A2))
                 (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
        ; split
skel-resp-skel2 [k1 : skel, k2 : skel |- ksigma k1 k2] [ |- Deq] [ |- Deq2] as
          case skel-eq/i:
          { g : evar,
            A1 : (g |- etp),
            A2 : (g, z177 : eterm |- etp),
            Dskel2 : ( |- skel),
            Dskel3 : ( |- skel),
            M2 : (g |- eterm),
            M3 : (g, y178 : eterm |- eterm),
            M4 : (g |- eterm),
            M5 : (g, z230 : eterm |- eterm),
            Dflay : (g |- flay A1 Dskel2[] M2),
            Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M3),
            Dflay2 : (g |- flay A1 Dskel2[] M4),
            Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
            Deq : ( |- skel-eq Dskel2 Dskel2),
            Deq1 : (g |- eterm-eq M2 M4),
            Deq2 : ( |- skel-eq Dskel3 Dskel3),
            Deq3 : (g, x : eterm |- eterm-eq M3 M5)
          | x :
              [g |-
                 flay
                   (esigma A1 (\x128. A2))
                   (ksigma Dskel2[] Dskel3[]) (epair M2 (elam A1 (\x. M3)))],
            flay :
              [g |-
                 flay
                   (esigma A1 (\x128. A2))
                   (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
          ; split [g |- Deq1] as
            case eterm-eq/i:
            { g : evar,
              A1 : (g |- etp),
              A2 : (g, z177 : eterm |- etp),
              Dskel2 : ( |- skel),
              Dskel3 : ( |- skel),
              M4 : (g |- eterm),
              M3 : (g, y178 : eterm |- eterm),
              M5 : (g, z230 : eterm |- eterm),
              Dflay : (g |- flay A1 Dskel2[] M4),
              Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M3),
              Dflay2 : (g |- flay A1 Dskel2[] M4),
              Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
              Deq : ( |- skel-eq Dskel2 Dskel2),
              Deq2 : ( |- skel-eq Dskel3 Dskel3),
              Deq3 : (g, x : eterm |- eterm-eq M3 M5)
            | x :
                [g |-
                   flay
                     (esigma A1 (\x128. A2))
                     (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M3)))],
              flay :
                [g |-
                   flay
                     (esigma A1 (\x128. A2))
                     (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
            ; split [g, x : eterm |- Deq3] as
              case eterm-eq/i:
              { g : evar,
                A1 : (g |- etp),
                A2 : (g, z177 : eterm |- etp),
                Dskel2 : ( |- skel),
                Dskel3 : ( |- skel),
                M4 : (g |- eterm),
                M5 : (g, z230 : eterm |- eterm),
                Dflay : (g |- flay A1 Dskel2[] M4),
                Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M5),
                Dflay2 : (g |- flay A1 Dskel2[] M4),
                Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
                Deq : ( |- skel-eq Dskel2 Dskel2),
                Deq2 : ( |- skel-eq Dskel3 Dskel3)
              | x :
                  [g |-
                     flay
                       (esigma A1 (\x128. A2))
                       (ksigma Dskel2[] Dskel3[])
                       (epair M4 (elam A1 (\x. M5)))],
                flay :
                  [g |-
                     flay
                       (esigma A1 (\x128. A2))
                       (ksigma Dskel2[] Dskel3[])
                       (epair M4 (elam A1 (\x. M5)))]
              ; solve [g |- flay-fun/i (skel-eq/i ) (eterm-eq/i )]
              }
            }
          }
        }
      }
    }
  }
  case flay/pi:
  { g : evar,
    A1 : (g |- etp),
    A2 : (g, x176 : eterm |- etp),
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    M2 : (g |- eterm),
    M3 : (g, z176 : eterm |- eterm),
    K1 : ( |- skel),
    M1 : (g |- eterm),
    Dflay : (g |- flay A1 Dskel[] M2),
    Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3)
  | x :
      [g |-
         flay
           (epi A1 (\z77. A2))
           (kpi Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
    flay : [g |- flay (epi A1 (\z77. A2)) K1[] M1]
  ; split flay as
    case flay/pi:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, x176 : eterm |- etp),
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      M2 : (g |- eterm),
      M3 : (g, z176 : eterm |- eterm),
      Dskel2 : ( |- skel),
      Dskel3 : ( |- skel),
      M4 : (g |- eterm),
      M5 : (g, z230 : eterm |- eterm),
      Dflay : (g |- flay A1 Dskel[] M2),
      Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
      Dflay2 : (g |- flay A1 Dskel2[] M4),
      Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5)
    | x :
        [g |-
           flay
             (epi A1 (\x127. A2))
             (kpi Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
      flay :
        [g |-
           flay
             (epi A1 (\x127. A2))
             (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
    ; split flay-fun [g |- Dflay] [g |- Dflay2] as
      case flay-fun/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, x176 : eterm |- etp),
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        M2 : (g |- eterm),
        M3 : (g, z176 : eterm |- eterm),
        Dskel2 : ( |- skel),
        Dskel3 : ( |- skel),
        M4 : (g |- eterm),
        M5 : (g, z230 : eterm |- eterm),
        Dflay : (g |- flay A1 Dskel[] M2),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
        Dflay2 : (g |- flay A1 Dskel2[] M4),
        Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
        Deq : ( |- skel-eq Dskel Dskel2),
        Deq1 : (g |- eterm-eq M2 M4)
      | x :
          [g |-
             flay
               (epi A1 (\x127. A2))
               (kpi Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
        flay :
          [g |-
             flay
               (epi A1 (\x127. A2))
               (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
      ; split flay-fun [g, x : eterm |- Dflay1] [g, x : eterm |- Dflay3] as
        case flay-fun/i:
        { g : evar,
          A1 : (g |- etp),
          A2 : (g, x176 : eterm |- etp),
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          M2 : (g |- eterm),
          M3 : (g, z176 : eterm |- eterm),
          Dskel2 : ( |- skel),
          Dskel3 : ( |- skel),
          M4 : (g |- eterm),
          M5 : (g, z230 : eterm |- eterm),
          Dflay : (g |- flay A1 Dskel[] M2),
          Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
          Dflay2 : (g |- flay A1 Dskel2[] M4),
          Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
          Deq : ( |- skel-eq Dskel Dskel2),
          Deq1 : (g |- eterm-eq M2 M4),
          Deq2 : ( |- skel-eq Dskel1 Dskel3),
          Deq3 : (g, x : eterm |- eterm-eq M3 M5)
        | x :
            [g |-
               flay
                 (epi A1 (\x127. A2))
                 (kpi Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
          flay :
            [g |-
               flay
                 (epi A1 (\x127. A2))
                 (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
        ; split
          skel-resp-skel2 [k1 : skel, k2 : skel |- kpi k1 k2] [ |- Deq]
            [ |- Deq2] as
          case skel-eq/i:
          { g : evar,
            A1 : (g |- etp),
            A2 : (g, x176 : eterm |- etp),
            Dskel2 : ( |- skel),
            Dskel3 : ( |- skel),
            M2 : (g |- eterm),
            M3 : (g, z176 : eterm |- eterm),
            M4 : (g |- eterm),
            M5 : (g, z230 : eterm |- eterm),
            Dflay : (g |- flay A1 Dskel2[] M2),
            Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M3),
            Dflay2 : (g |- flay A1 Dskel2[] M4),
            Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
            Deq : ( |- skel-eq Dskel2 Dskel2),
            Deq1 : (g |- eterm-eq M2 M4),
            Deq2 : ( |- skel-eq Dskel3 Dskel3),
            Deq3 : (g, x : eterm |- eterm-eq M3 M5)
          | x :
              [g |-
                 flay
                   (epi A1 (\x127. A2))
                   (kpi Dskel2[] Dskel3[]) (epair M2 (elam A1 (\x. M3)))],
            flay :
              [g |-
                 flay
                   (epi A1 (\x127. A2))
                   (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
          ; split [g |- Deq1] as
            case eterm-eq/i:
            { g : evar,
              A1 : (g |- etp),
              A2 : (g, x176 : eterm |- etp),
              Dskel2 : ( |- skel),
              Dskel3 : ( |- skel),
              M4 : (g |- eterm),
              M3 : (g, z176 : eterm |- eterm),
              M5 : (g, z230 : eterm |- eterm),
              Dflay : (g |- flay A1 Dskel2[] M4),
              Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M3),
              Dflay2 : (g |- flay A1 Dskel2[] M4),
              Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
              Deq : ( |- skel-eq Dskel2 Dskel2),
              Deq2 : ( |- skel-eq Dskel3 Dskel3),
              Deq3 : (g, x : eterm |- eterm-eq M3 M5)
            | x :
                [g |-
                   flay
                     (epi A1 (\x127. A2))
                     (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M3)))],
              flay :
                [g |-
                   flay
                     (epi A1 (\x127. A2))
                     (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
            ; split [g, x : eterm |- Deq3] as
              case eterm-eq/i:
              { g : evar,
                A1 : (g |- etp),
                A2 : (g, x176 : eterm |- etp),
                Dskel2 : ( |- skel),
                Dskel3 : ( |- skel),
                M4 : (g |- eterm),
                M5 : (g, z230 : eterm |- eterm),
                Dflay : (g |- flay A1 Dskel2[] M4),
                Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M5),
                Dflay2 : (g |- flay A1 Dskel2[] M4),
                Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
                Deq : ( |- skel-eq Dskel2 Dskel2),
                Deq2 : ( |- skel-eq Dskel3 Dskel3)
              | x :
                  [g |-
                     flay
                       (epi A1 (\x127. A2))
                       (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))],
                flay :
                  [g |-
                     flay
                       (epi A1 (\x127. A2))
                       (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
              ; solve [g |- flay-fun/i (skel-eq/i ) (eterm-eq/i )]
              }
            }
          }
        }
      }
    }
  }
  case flay/t:
  { g : evar, K1 : ( |- skel), M1 : (g |- eterm)
  | x : [g |- flay et kt estar], flay : [g |- flay et K1[] M1]
  ; split flay as
    case flay/t:
    { g : evar
    | x : [g |- flay et kt estar], flay : [g |- flay et kt estar]
    ; solve [g |- flay-fun/i (skel-eq/i ) (eterm-eq/i )]
    }
  }
}
;
