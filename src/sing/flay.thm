% Definitions

LF eexpand : eterm -> etp -> eterm -> type =
| eexpand/t : eexpand R et R

| eexpand/pi :
  ({ x : eterm } eexpand x A (M x)) ->
  ({ x : eterm } eexpand (eapp R (M x)) (B x) (N x)) ->
    eexpand R (epi A B) (elam A N)

| eexpand/sigma :
  eexpand (epi1 R) A M ->
  eexpand (epi2 R) (B (epi1 R)) N ->
    eexpand R (esigma A B) (epair M N)

| eexpand/sing : eexpand R (esing R') R'

| eexpand/one : eexpand R eone estar
;
--name eexpand Dexpand expand.

LF skof : skel -> etp -> (eterm -> etp) -> type =
| skof/t : skof kt eone (\l. et)

| skof/pi :
  skof As C (\y. A y) ->
  skof Bs D (\z. B z) ->
  ({ y : eterm } { x : eterm } eexpand x (A y) (X y x)) ->
    skof
      (kpi As Bs)
      (esigma C (\y. epi (A y) (\l. D)))
      (\w. epi (A (epi1 w)) (\x. B (eapp (epi2 w) (X (epi1 w) x))))

| skof/sigma :
  skof As C (\y. A y) ->
  skof Bs D (\z. B z) ->
  ({ y : eterm } { x : eterm } eexpand x (A y) (X y x)) ->
    skof
      (ksigma As Bs)
      (esigma C (\y. epi (A y) (\l. D)))
      (\w. esigma (A (epi1 w)) (\x. B (eapp (epi2 w) (X (epi1 w) x))))

| skof/sing : skof ksing et (\x. esing x)

| skof/one : skof kone eone (\l. eone)
;
--name skof Dskof skof.

LF flay : etp -> skel -> eterm -> type =
| flay/t : flay et kt estar

| flay/pi : flay A As M ->
              ({x : eterm} flay (B x) Bs (N x)) ->
              flay (epi A B) (kpi As Bs) (epair M (elam A (\x. N x)))

| flay/sigma : flay A As M ->
                 ({x : eterm} flay (B x) Bs (N x)) ->
                 flay (esigma A B) (ksigma As Bs) (epair M (elam A (\x. N x)))

| flay/sing : flay (esing M) ksing M

| flay/one : flay eone kone estar
;
--name flay Dflay flay.

% Equality

proof eexpand-resp :
  (g : evar)
  [g |- eterm-eq R R'] ->
  [g |- etp-eq A A'] ->
  [g |- eterm-eq M M'] ->
  [g |- eexpand R A M] ->
    [g |- eexpand R' A' M'] =
/ total /
intros
{ g : evar,
  R : (g |- eterm),
  R' : (g |- eterm),
  A : (g |- etp),
  A' : (g |- etp),
  M : (g |- eterm),
  M' : (g |- eterm)
| eq : [g |- eterm-eq R R'],
  eq1 : [g |- etp-eq A A'],
  eq2 : [g |- eterm-eq M M'],
  expand : [g |- eexpand R A M]
; split eq as
  case eterm-eq/i:
  { g : evar,
    R' : (g |- eterm),
    A : (g |- etp),
    A' : (g |- etp),
    M : (g |- eterm),
    M' : (g |- eterm)
  | eq : [g |- eterm-eq R' R'],
    eq1 : [g |- etp-eq A A'],
    eq2 : [g |- eterm-eq M M'],
    expand : [g |- eexpand R' A M]
  ; split eq1 as
    case etp-eq/i:
    { g : evar,
      R' : (g |- eterm),
      A' : (g |- etp),
      M : (g |- eterm),
      M' : (g |- eterm)
    | eq : [g |- eterm-eq R' R'],
      eq1 : [g |- etp-eq A' A'],
      eq2 : [g |- eterm-eq M M'],
      expand : [g |- eexpand R' A' M]
    ; split eq2 as
      case eterm-eq/i:
      { g : evar, R' : (g |- eterm), A' : (g |- etp), M' : (g |- eterm)
      | eq : [g |- eterm-eq R' R'],
        eq1 : [g |- etp-eq A' A'],
        eq2 : [g |- eterm-eq M' M'],
        expand : [g |- eexpand R' A' M']
      ; solve expand
      }
    }
  }
}
;

proof flay-resp :
  (g : evar)
  [g |- etp-eq A A'] ->
  [ |- skel-eq K K'] ->
  [g |- eterm-eq M M'] ->
  [g |- flay A K[] M] ->
    [g |- flay A' K'[] M'] =
/ total /
intros
{ g : evar,
  A : (g |- etp),
  A' : (g |- etp),
  K : ( |- skel),
  K' : ( |- skel),
  M : (g |- eterm),
  M' : (g |- eterm)
| eq : [g |- etp-eq A A'],
  eq1 : [ |- skel-eq K K'],
  eq2 : [g |- eterm-eq M M'],
  flay : [g |- flay A K[] M]
; split eq as
  case etp-eq/i:
  { g : evar,
    A' : (g |- etp),
    K : ( |- skel),
    K' : ( |- skel),
    M : (g |- eterm),
    M' : (g |- eterm)
  | eq : [g |- etp-eq A' A'],
    eq1 : [ |- skel-eq K K'],
    eq2 : [g |- eterm-eq M M'],
    flay : [g |- flay A' K[] M]
  ; split eq1 as
    case skel-eq/i:
    { g : evar,
      A' : (g |- etp),
      K' : ( |- skel),
      M : (g |- eterm),
      M' : (g |- eterm)
    | eq : [g |- etp-eq A' A'],
      eq1 : [ |- skel-eq K' K'],
      eq2 : [g |- eterm-eq M M'],
      flay : [g |- flay A' K'[] M]
    ; split eq2 as
      case eterm-eq/i:
      { g : evar, A' : (g |- etp), K' : ( |- skel), M' : (g |- eterm)
      | eq : [g |- etp-eq A' A'],
        eq1 : [ |- skel-eq K' K'],
        eq2 : [g |- eterm-eq M' M'],
        flay : [g |- flay A' K'[] M']
      ; solve flay
      }
    }
  }
}
;

proof skof-resp :
  (g : evar)
  [ |- skel-eq K K'] ->
  [g |- etp-eq C C'] ->
  [g, x : eterm |- etp-eq (A[x]) (A'[x])] ->
  [g |- skof K[] C (\x. A[x])] ->
  [g |- skof K'[] C' (\x. A'[x])] =
/ total /
intros
{ g : evar,
  K : ( |- skel),
  K' : ( |- skel),
  C : (g |- etp),
  C' : (g |- etp),
  A : (x : eterm |- etp),
  A' : (x : eterm |- etp)
| eq : [ |- skel-eq K K'],
  eq1 : [g |- etp-eq C C'],
  eq2 : [g, x : eterm |- etp-eq (A[x]) (A'[x])],
  skof : [g |- skof K[] C (\x. A[x])]
; split eq as
  case skel-eq/i:
  { g : evar,
    K' : ( |- skel),
    C : (g |- etp),
    C' : (g |- etp),
    A : (x : eterm |- etp),
    A' : (x : eterm |- etp)
  | eq : [ |- skel-eq K' K'],
    eq1 : [g |- etp-eq C C'],
    eq2 : [g, x : eterm |- etp-eq (A[x]) (A'[x])],
    skof : [g |- skof K'[] C (\x. A[x])]
  ; split eq1 as
    case etp-eq/i:
    { g : evar,
      K' : ( |- skel),
      C' : (g |- etp),
      A : (x : eterm |- etp),
      A' : (x : eterm |- etp)
    | eq : [ |- skel-eq K' K'],
      eq1 : [g |- etp-eq C' C'],
      eq2 : [g, x : eterm |- etp-eq (A[x]) (A'[x])],
      skof : [g |- skof K'[] C' (\x. A[x])]
    ; split eq2 as
      case etp-eq/i:
      { g : evar, K' : ( |- skel), C' : (g |- etp), A' : (x : eterm |- etp)
      | eq : [ |- skel-eq K' K'],
        eq1 : [g |- etp-eq C' C'],
        eq2 : [g, x : eterm |- etp-eq (A'[x]) (A'[x])],
        skof : [g |- skof K'[] C' (\x. A'[x])]
      ; solve skof
      }
    }
  }
}
;

% Eexpand Theorems

LF esimp : etp -> stp -> type =
| esimp/t : esimp et st

| esimp/pi :
  esimp A S ->
  ({ x : eterm } esimp (B x) T) ->
    esimp (epi A B) (spi S T)

| esimp/sigma :
  esimp A S ->
  ({ x : eterm } esimp (B x) T) ->
    esimp (esigma A B) (ssigma S T)

| esimp/sing : esimp (esing R) st

| esimp/one : esimp eone sone
;
--name esimp Dsimp esimp.

LF can-esimp/e : etp -> type =
| can-esimp/i : { T : stp } esimp A T -> can-esimp/e A
;

proof can-esimp :
  (g : evar)
  { A : [g |- etp] }
  [g |- can-esimp/e A] =
/ total 1 /
intros
{ g : evar, A : (g |- etp)
|
; split [_ |- A] as
  case eone:
  { g : evar
  |
  ; solve [_ |- can-esimp/i _ esimp/one]
  }
  case esing:
  { g : evar, M : (g |- eterm)
  |
  ; solve [_ |- can-esimp/i _ (esimp/sing )]
  }
  case esigma:
  { g : evar, A1 : (g |- etp), A2 : (g, y149 : eterm |- etp)
  |
  ; split can-esimp [_ |- A1] as
    case can-esimp/i:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, y149 : eterm |- etp),
      T : ( |- stp),
      Dsimp : (g |- esimp A1 T[])
    |
    ; split can-esimp [_, y149 : eterm |- A2] as
      case can-esimp/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, y149 : eterm |- etp),
        T : ( |- stp),
        Dsimp : (g |- esimp A1 T[]),
        T1 : ( |- stp),
        Dsimp1 : (g, y149 : eterm |- esimp A2 T1[])
      |
      ; solve [_ |- can-esimp/i _ (esimp/sigma Dsimp (\x. Dsimp1))]
      }
    }
  }
  case epi:
  { g : evar, A1 : (g |- etp), A2 : (g, y148 : eterm |- etp)
  |
  ; split can-esimp [_ |- A1] as
    case can-esimp/i:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, y148 : eterm |- etp),
      T : ( |- stp),
      Dsimp : (g |- esimp A1 T[])
    |
    ; split can-esimp [_, y148 : eterm |- A2] as
      case can-esimp/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, y148 : eterm |- etp),
        T : ( |- stp),
        Dsimp : (g |- esimp A1 T[]),
        T1 : ( |- stp),
        Dsimp1 : (g, y148 : eterm |- esimp A2 T1[])
      |
      ; solve [_ |- can-esimp/i _ (esimp/pi Dsimp (\x. Dsimp1))]
      }
    }
  }
  case et:
  { g : evar
  |
  ; solve [_ |- can-esimp/i _ esimp/t]
  }
}
;

LF can-eexpand/e : eterm -> etp -> type =
| can-eexpand/i : { M : eterm } eexpand R A M -> can-eexpand/e R A
;

proof can-eexpand :
  (g : evar)
  { R : [g |- eterm] }
  { A : [g |- etp] }
  [g |- can-eexpand/e R A] =
/ total 1 /
intros
{ g : evar, R : (g |- eterm), A : (g |- etp)
|
; split can-esimp [_ |- A] as
  case can-esimp/i:
  { g : evar,
    R : (g |- eterm),
    A : (g |- etp),
    T : ( |- stp),
    Dsimp : (g |- esimp A T[])
  |
  ; split [_ |- Dsimp] as
    case esimp/one:
    { g : evar, R : (g |- eterm)
    |
    ; solve [_ |- can-eexpand/i _ (eexpand/one )]
    }
    case esimp/sing:
    { g : evar, R : (g |- eterm), M : (g |- eterm)
    |
    ; solve [_ |- can-eexpand/i _ (eexpand/sing )]
    }
    case esimp/sigma:
    { g : evar,
      R : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, z329 : eterm |- etp),
      T1 : ( |- stp),
      T2 : ( |- stp),
      Dsimp1 : (g |- esimp A1 T1[]),
      Dsimp2 : (g, x : eterm |- esimp A2 T2[])
    |
    ; split can-eexpand [g |- epi1 R] [g |- A1] as
      case can-eexpand/i:
      { g : evar,
        R : (g |- eterm),
        A1 : (g |- etp),
        A2 : (g, z329 : eterm |- etp),
        T1 : ( |- stp),
        T2 : ( |- stp),
        Dsimp1 : (g |- esimp A1 T1[]),
        Dsimp2 : (g, x : eterm |- esimp A2 T2[]),
        M1 : (g |- eterm),
        Dexpand : (g |- eexpand (epi1 R) A1 M1)
      |
      ; split can-eexpand [g |- epi2 R] [g |- A2[.., epi1 R]] as
        case can-eexpand/i:
        { g : evar,
          R : (g |- eterm),
          A1 : (g |- etp),
          A2 : (g, z329 : eterm |- etp),
          T1 : ( |- stp),
          T2 : ( |- stp),
          Dsimp1 : (g |- esimp A1 T1[]),
          Dsimp2 : (g, x : eterm |- esimp A2 T2[]),
          M1 : (g |- eterm),
          Dexpand : (g |- eexpand (epi1 R) A1 M1),
          M3 : (g |- eterm),
          Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3)
        |
        ; solve [g |- can-eexpand/i _ (eexpand/sigma Dexpand Dexpand1)]
        }
      }
    }
    case esimp/pi:
    { g : evar,
      R : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, z328 : eterm |- etp),
      T1 : ( |- stp),
      T2 : ( |- stp),
      Dsimp1 : (g |- esimp A1 T1[]),
      Dsimp2 : (g, x : eterm |- esimp A2 T2[])
    |
    ; split can-eexpand [g, x : eterm |- x] [g, x : eterm |- A1[..]] as
      case can-eexpand/i:
      { g : evar,
        R : (g |- eterm),
        A1 : (g |- etp),
        A2 : (g, z328 : eterm |- etp),
        T1 : ( |- stp),
        T2 : ( |- stp),
        Dsimp1 : (g |- esimp A1 T1[]),
        Dsimp2 : (g, x : eterm |- esimp A2 T2[]),
        M1 : (g, x : eterm |- eterm),
        Dexpand : (g, x : eterm |- eexpand x (A1[..]) M1)
      |
      ; split
        can-eexpand [g, x : eterm |- eapp (R[..]) M1] [g, x : eterm |- A2] as
        case can-eexpand/i:
        { g : evar,
          R : (g |- eterm),
          A1 : (g |- etp),
          A2 : (g, z328 : eterm |- etp),
          T1 : ( |- stp),
          T2 : ( |- stp),
          Dsimp1 : (g |- esimp A1 T1[]),
          Dsimp2 : (g, x : eterm |- esimp A2 T2[]),
          M1 : (g, x : eterm |- eterm),
          Dexpand : (g, x : eterm |- eexpand x (A1[..]) M1),
          M3 : (g, x : eterm |- eterm),
          Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M1) A2 M3)
        |
        ; solve
            [g |- can-eexpand/i _ (eexpand/pi (\x. Dexpand) (\x. Dexpand1))]
        }
      }
    }
    case esimp/t:
    { g : evar, R : (g |- eterm)
    |
    ; solve [_ |- can-eexpand/i _ (eexpand/t )]
    }
  }
}
;

proof eexpand-fun :
  (g : evar)
  [g |- eexpand R A M] ->
  [g |- eexpand R A M'] ->
    [g |- eterm-eq M M'] =
/ total 1 /
intros
{ g : evar,
  R : (g |- eterm),
  A : (g |- etp),
  M : (g |- eterm),
  M' : (g |- eterm)
| x : [g |- eexpand R A M], expand : [g |- eexpand R A M']
; split x as
  case eexpand/one:
  { g : evar, R : (g |- eterm), M' : (g |- eterm)
  | x : [g |- eexpand R eone estar], expand : [g |- eexpand R eone M']
  ; split expand as
    case eexpand/one:
    { g : evar, R : (g |- eterm)
    | x : [g |- eexpand R eone estar], expand : [g |- eexpand R eone estar]
    ; solve [_ |- eterm-eq/i ]
    }
  }
  case eexpand/sing:
  { g : evar, R : (g |- eterm), M : (g |- eterm), M' : (g |- eterm)
  | x : [g |- eexpand R (esing M) M], expand : [g |- eexpand R (esing M) M']
  ; split expand as
    case eexpand/sing:
    { g : evar, R : (g |- eterm), M' : (g |- eterm)
    | x : [g |- eexpand R (esing M') M'],
      expand : [g |- eexpand R (esing M') M']
    ; solve [_ |- eterm-eq/i ]
    }
  }
  case eexpand/sigma:
  { g : evar,
    R : (g |- eterm),
    A1 : (g |- etp),
    A2 : (g, x309 : eterm |- etp),
    M2 : (g |- eterm),
    M3 : (g |- eterm),
    M' : (g |- eterm),
    Dexpand : (g |- eexpand (epi1 R) A1 M2),
    Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3)
  | x : [g |- eexpand R (esigma A1 (\y149. A2)) (epair M2 M3)],
    expand : [g |- eexpand R (esigma A1 (\y149. A2)) M']
  ; split expand as
    case eexpand/sigma:
    { g : evar,
      R : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, x309 : eterm |- etp),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M5 : (g |- eterm),
      M6 : (g |- eterm),
      Dexpand : (g |- eexpand (epi1 R) A1 M2),
      Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3),
      Dexpand2 : (g |- eexpand (epi1 R) A1 M5),
      Dexpand3 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M6)
    | x : [g |- eexpand R (esigma A1 (\y149. A2)) (epair M2 M3)],
      expand : [g |- eexpand R (esigma A1 (\y149. A2)) (epair M5 M6)]
    ; split eexpand-fun [_ |- Dexpand] [_ |- Dexpand2] as
      case eterm-eq/i:
      { g : evar,
        R : (g |- eterm),
        A1 : (g |- etp),
        A2 : (g, x309 : eterm |- etp),
        M5 : (g |- eterm),
        M3 : (g |- eterm),
        M6 : (g |- eterm),
        Dexpand : (g |- eexpand (epi1 R) A1 M5),
        Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3),
        Dexpand2 : (g |- eexpand (epi1 R) A1 M5),
        Dexpand3 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M6)
      | x : [g |- eexpand R (esigma A1 (\y149. A2)) (epair M5 M3)],
        expand : [g |- eexpand R (esigma A1 (\y149. A2)) (epair M5 M6)]
      ; split eexpand-fun [_ |- Dexpand1] [_ |- Dexpand3] as
        case eterm-eq/i:
        { g : evar,
          R : (g |- eterm),
          A1 : (g |- etp),
          A2 : (g, x309 : eterm |- etp),
          M5 : (g |- eterm),
          M6 : (g |- eterm),
          Dexpand : (g |- eexpand (epi1 R) A1 M5),
          Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M6),
          Dexpand2 : (g |- eexpand (epi1 R) A1 M5),
          Dexpand3 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M6)
        | x : [g |- eexpand R (esigma A1 (\y149. A2)) (epair M5 M6)],
          expand : [g |- eexpand R (esigma A1 (\y149. A2)) (epair M5 M6)]
        ; solve [_ |- eterm-eq/i ]
        }
      }
    }
  }
  case eexpand/pi:
  { g : evar,
    R : (g |- eterm),
    A1 : (g |- etp),
    A2 : (g, y308 : eterm |- etp),
    M3 : (g, x308 : eterm |- eterm),
    M' : (g |- eterm),
    M1 : (g, z307 : eterm |- eterm),
    Dexpand : (g, x : eterm |- eexpand x (A1[..]) M1),
    Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M1) A2 M3)
  | x : [g |- eexpand R (epi A1 (\y148. A2)) (elam A1 (\y152. M3))],
    expand : [g |- eexpand R (epi A1 (\y148. A2)) M']
  ; split expand as
    case eexpand/pi:
    { g : evar,
      R : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, y308 : eterm |- etp),
      M3 : (g, x308 : eterm |- eterm),
      M6 : (g, x308 : eterm |- eterm),
      M1 : (g, z307 : eterm |- eterm),
      Dexpand : (g, x : eterm |- eexpand x (A1[..]) M1),
      Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M1) A2 M3),
      M4 : (g, z307 : eterm |- eterm),
      Dexpand2 : (g, x : eterm |- eexpand x (A1[..]) M4),
      Dexpand3 : (g, x : eterm |- eexpand (eapp (R[..]) M4) A2 M6)
    | x : [g |- eexpand R (epi A1 (\y148. A2)) (elam A1 (\y152. M3))],
      expand : [g |- eexpand R (epi A1 (\y148. A2)) (elam A1 (\y152. M6))]
    ; split
      eexpand-fun [_, x : eterm |- Dexpand] [_, x : eterm |- Dexpand2] as
      case eterm-eq/i:
      { g : evar,
        R : (g |- eterm),
        A1 : (g |- etp),
        A2 : (g, y308 : eterm |- etp),
        M3 : (g, x308 : eterm |- eterm),
        M6 : (g, x308 : eterm |- eterm),
        M4 : (g, z307 : eterm |- eterm),
        Dexpand : (g, x : eterm |- eexpand x (A1[..]) M4),
        Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M4) A2 M3),
        Dexpand2 : (g, x : eterm |- eexpand x (A1[..]) M4),
        Dexpand3 : (g, x : eterm |- eexpand (eapp (R[..]) M4) A2 M6)
      | x : [g |- eexpand R (epi A1 (\y148. A2)) (elam A1 (\y152. M3))],
        expand : [g |- eexpand R (epi A1 (\y148. A2)) (elam A1 (\y152. M6))]
      ; split
        eexpand-fun [_, x : eterm |- Dexpand1] [_, x : eterm |- Dexpand3] as
        case eterm-eq/i:
        { g : evar,
          R : (g |- eterm),
          A1 : (g |- etp),
          A2 : (g, y308 : eterm |- etp),
          M6 : (g, x308 : eterm |- eterm),
          M4 : (g, z307 : eterm |- eterm),
          Dexpand : (g, x : eterm |- eexpand x (A1[..]) M4),
          Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M4) A2 M6),
          Dexpand2 : (g, x : eterm |- eexpand x (A1[..]) M4),
          Dexpand3 : (g, x : eterm |- eexpand (eapp (R[..]) M4) A2 M6)
        | x : [g |- eexpand R (epi A1 (\y148. A2)) (elam A1 (\y152. M6))],
          expand :
            [g |- eexpand R (epi A1 (\y148. A2)) (elam A1 (\y152. M6))]
        ; solve [_ |- eterm-eq/i ]
        }
      }
    }
  }
  case eexpand/t:
  { g : evar, M : (g |- eterm), M' : (g |- eterm)
  | x : [g |- eexpand M et M], expand : [g |- eexpand M et M']
  ; split expand as
    case eexpand/t:
    { g : evar, M' : (g |- eterm)
    | x : [g |- eexpand M' et M'], expand : [g |- eexpand M' et M']
    ; solve [_ |- eterm-eq/i ]
    }
  }
}
;

schema ebind+etopenblock =
  % ebind
  some [ea : etp]
  block (ex : eterm, ed : eof ex ea) +
  % etopenblock
  some [a : skel, x : eterm]
  block (xc : catom, d : etopenr sc a x);

proof eexpand-equiv :
  (g : ebind+etopenblock)
  [g |- eof R A] ->
  [g |- eexpand R A M] ->
    [g |- equiv R M A] =
/ trust / % FIXME: See issue #4
intros
{ g : ebind+etopenblock, R : (g |- eterm), A : (g |- etp), M : (g |- eterm)
| eof : [g |- eof R A], x : [g |- eexpand R A M]
; split x as
  case eexpand/one:
  { g : ebind+etopenblock, R : (g |- eterm)
  | eof : [g |- eof R eone], x : [g |- eexpand R eone estar]
  ; by eof as DofR unboxed;
    solve [_ |- equiv/one DofR eof/star]
  }
  case eexpand/sing:
  { g : ebind+etopenblock, R : (g |- eterm), M : (g |- eterm)
  | eof : [g |- eof R (esing M)], x : [g |- eexpand R (esing M) M]
  ; by eof as DofR unboxed;
    solve [_ |- equiv/symm (equiv/sing (equiv/symm (equiv/singelim DofR)))]
  }
  case eexpand/sigma:
  { g : ebind+etopenblock,
    R : (g |- eterm),
    A1 : (g |- etp),
    A2 : (g, x309 : eterm |- etp),
    M2 : (g |- eterm),
    M3 : (g |- eterm),
    Dexpand : (g |- eexpand (epi1 R) A1 M2),
    Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3)
  | eof : [g |- eof R (esigma A1 (\y149. A2))],
    x : [g |- eexpand R (esigma A1 (\y149. A2)) (epair M2 M3)]
  ; by eof as DofR unboxed;
    split eof-reg [_ |- DofR] as
    case ewf/sigma:
    { g : ebind+etopenblock,
      R : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, x309 : eterm |- etp),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      Dexpand : (g |- eexpand (epi1 R) A1 M2),
      Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3),
      DofR : (g |- eof R (esigma A1 (\y149. A2))),
      Dwf : (g |- ewf A1),
      Dwf1 : (g, x : eterm, y163 : eof x (A1[..]) |- ewf (A2[.., x]))
    | eof : [g |- eof R (esigma A1 (\y149. A2))],
      x : [g |- eexpand R (esigma A1 (\y149. A2)) (epair M2 M3)]
    ; by eexpand-equiv [_ |- eof/pi1 DofR] [_ |- Dexpand] as Dequiv1 unboxed;
      by eexpand-equiv [_ |- eof/pi2 DofR] [_ |- Dexpand1] as Dequiv2 unboxed;
      solve
  [g |-
     equiv/trans (equiv/extsigma (equiv/symm (equiv/beta1 (eof/pi1 DofR)
                                             (eof/pi2 DofR)))
                 (equiv/symm (equiv/beta2 (eof/pi1 DofR) (eof/pi2 DofR)))
                 (\x. \dx. Dwf1))
     (equiv/pair Dequiv1 Dequiv2 (\x. \dx. Dwf1))]
    }
  }
  case eexpand/pi:
  { g : ebind+etopenblock,
    R : (g |- eterm),
    A1 : (g |- etp),
    A2 : (g, y308 : eterm |- etp),
    M3 : (g, x308 : eterm |- eterm),
    M1 : (g, z307 : eterm |- eterm),
    Dexpand : (g, x : eterm |- eexpand x (A1[..]) M1),
    Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M1) A2 M3)
  | eof : [g |- eof R (epi A1 (\y148. A2))],
    x : [g |- eexpand R (epi A1 (\y148. A2)) (elam A1 (\y152. M3))]
  ; by eof as DofR unboxed;
    split eof-reg [g |- DofR] as
    case ewf/pi:
    { g : ebind+etopenblock,
      R : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, y308 : eterm |- etp),
      M3 : (g, x308 : eterm |- eterm),
      M1 : (g, z307 : eterm |- eterm),
      Dexpand : (g, x : eterm |- eexpand x (A1[..]) M1),
      Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M1) A2 M3),
      DofR : (g |- eof R (epi A1 (\y148. A2))),
      Dwf : (g |- ewf A1),
      Dwf1 : (g, x : eterm, z161 : eof x (A1[..]) |- ewf (A2[.., x]))
    | eof : [g |- eof R (epi A1 (\y148. A2))],
      x : [g |- eexpand R (epi A1 (\y148. A2)) (elam A1 (\y152. M3))]
    ; by eexpand-equiv [g, b : block (x : eterm, dx : eof x _) |- _]
     [g, b : block (x : eterm, dx : eof x _) |- Dexpand[.., b.1]]
as DequivX unboxed;
      split
      equiv-reg [g, b : block (x : eterm, dx : eof x (A1[..])) |- DequivX] as
      case equiv-reg/i:
      { g : ebind+etopenblock,
        R : (g |- eterm),
        A3 : (g |- etp),
        A2 : (g, y308 : eterm |- etp),
        M3 : (g, x308 : eterm |- eterm),
        M5 : (g, x : eterm |- eterm),
        Dexpand : (g, x : eterm |- eexpand x (A3[..]) M5),
        Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M5) A2 M3),
        DofR : (g |- eof R (epi A3 (\y148. A2))),
        Dwf : (g |- ewf A3),
        Dwf1 : (g, x : eterm, z161 : eof x (A3[..]) |- ewf (A2[.., x])),
        DequivX :
          (g, b : block (x : eterm, dx : eof x (A3[..])) |-
             equiv b.1 (M5[.., b.1]) (A3[..])),
        Dof : (g, x : eterm, y10 : eof x (A3[..]) |- eof x (A3[..])),
        Dof1 :
          (g, x : eterm, x10 : eof x (A3[..]) |- eof (M5[.., x]) (A3[..])),
        Dwf2 : (g, x : eterm, z10 : eof x (A3[..]) |- ewf (A3[..]))
      | eof : [g |- eof R (epi A3 (\y148. A2))],
        x : [g |- eexpand R (epi A3 (\y148. A2)) (elam A3 (\y152. M3))]
      ; by tfunctionality
     [g, b : block (y : eterm, dy : eof y (A3[..])), y : eterm,
      dy : eof y (A3[..]) |- Dwf1[.., y, dy]]
     [g, b : block (y : eterm, dy : eof y (A3[..])) |- DequivX]
as DequivBx unboxed;
        by [g, b : block (x : eterm, dx : eof x (A3[..])) |-
              eof/app (DofR[..]) (Dof1[.., b.1, b.2])]
        as DofX' unboxed;
        by [g, b : block (x : eterm, dx : eof x (A3[..])) |-
              eof/subsume DofX' (subtp/reflex (tequiv/symm DequivBx))]
        as DofX'' unboxed;
        by eexpand-equiv
             [g, b : block (x : eterm, dx : eof x (A3[..])) |- DofX'']
             [g, b : block (x : eterm, dx : eof x (A3[..])) |-
                Dexpand1[.., b.1]]
        as DequivRX unboxed;
        solve [g |-
      equiv/trans (equiv/extpi DofR
                  (eof/lam Dwf (\x. \dx. eof/app (DofR[..]) _))
                  (\x.
                     \dx.
                       equiv/symm (equiv/beta (\x1.
                                                 \dx1. eof/app (DofR[..]) _)
                                  _)))
      (equiv/lam (tequiv/reflex Dwf)
      (\x.
         \dx.
           equiv/trans (equiv/app (equiv/reflex (DofR[..])) _)
           (DequivRX[.., <x; dx>])))]
      }
    }
  }
  case eexpand/t:
  { g : ebind+etopenblock, M : (g |- eterm)
  | eof : [g |- eof M et], x : [g |- eexpand M et M]
  ; by eof as D unboxed;
    solve [g |- equiv/reflex D]
  }
}
;

proof eexpand-reg :
  (g : ebind+etopenblock)
  [g |- eof R A] ->
  [g |- eexpand R A M] ->
    [g |- eof M A] =
/ total /
intros
{ g : ebind+etopenblock, R : (g |- eterm), A : (g |- etp), M : (g |- eterm)
| eof : [g |- eof R A], expand : [g |- eexpand R A M]
; by eof as Dof unboxed;
  by expand as Dexpand unboxed;
  by eexpand-equiv [_ |- Dof] [_ |- Dexpand] as Dequiv unboxed;
  split equiv-reg [_ |- Dequiv] as
  case equiv-reg/i:
  { g : ebind+etopenblock,
    R : (g |- eterm),
    A : (g |- etp),
    M : (g |- eterm),
    Dof : (g |- eof R A),
    Dexpand : (g |- eexpand R A M),
    Dequiv : (g |- equiv R M A),
    Dof1 : (g |- eof R A),
    Dof2 : (g |- eof M A),
    Dwf : (g |- ewf A)
  | eof : [g |- eof R A], expand : [g |- eexpand R A M]
  ; solve [_ |- Dof2]
  }
}
;

% Skof Theorems

LF can-skof/e : skel -> type =
| can-skof/i : { A : etp } { B : eterm -> etp } skof K A B -> can-skof/e K
;

proof can-skof :
  (g : evar)
  { K : [g |- skel] }
  [g |- can-skof/e K] =
/ total 1 /
intros
{ g : evar, K : (g |- skel)
|
; split [_ |- K] as
  case kone:
  { g : evar
  |
  ; solve [_ |- can-skof/i _ (\x. _) skof/one]
  }
  case ksing:
  { g : evar
  |
  ; solve [_ |- can-skof/i _ (\x. _) skof/sing]
  }
  case ksigma:
  { g : evar, Dskel : ( |- skel), Dskel1 : ( |- skel)
  |
  ; split can-skof [ |- Dskel] as
    case can-skof/i:
    { g : evar,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      A : ( |- etp),
      A1 : (z332 : eterm |- etp),
      Dskof : ( |- skof Dskel A (\z310. A1))
    |
    ; split can-skof [ |- Dskel1] as
      case can-skof/i:
      { g : evar,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        A : ( |- etp),
        A1 : (z332 : eterm |- etp),
        Dskof : ( |- skof Dskel A (\z310. A1)),
        A2 : ( |- etp),
        A3 : (z332 : eterm |- etp),
        Dskof1 : ( |- skof Dskel1 A2 (\z310. A3))
      |
      ; split
can-eexpand [y : eterm, x : eterm |- x] [y : eterm, x : eterm |- A1[y]] as
        case can-eexpand/i:
        { g : evar,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          A : ( |- etp),
          A1 : (z332 : eterm |- etp),
          Dskof : ( |- skof Dskel A (\z310. A1[z310])),
          A2 : ( |- etp),
          A3 : (z332 : eterm |- etp),
          Dskof1 : ( |- skof Dskel1 A2 (\z310. A3)),
          M1 : (y : eterm, x : eterm |- eterm),
          Dexpand : (y : eterm, x : eterm |- eexpand x (A1[y]) M1)
        |
        ; solve
            [g |-
               can-skof/i _
               (\x. _) (skof/sigma Dskof[] Dskof1[] (\y. \x. Dexpand[y, x]))]
        }
      }
    }
  }
  case kpi:
  { g : evar, Dskel : ( |- skel), Dskel1 : ( |- skel)
  |
  ; split can-skof [ |- Dskel] as
    case can-skof/i:
    { g : evar,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      A : ( |- etp),
      A1 : (z332 : eterm |- etp),
      Dskof : ( |- skof Dskel A (\z310. A1))
    |
    ; split can-skof [ |- Dskel1] as
      case can-skof/i:
      { g : evar,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        A : ( |- etp),
        A1 : (z332 : eterm |- etp),
        Dskof : ( |- skof Dskel A (\z310. A1)),
        A2 : ( |- etp),
        A3 : (z332 : eterm |- etp),
        Dskof1 : ( |- skof Dskel1 A2 (\z310. A3))
      |
      ; split
can-eexpand [y : eterm, x : eterm |- x] [y : eterm, x : eterm |- A1[y]] as
        case can-eexpand/i:
        { g : evar,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          A : ( |- etp),
          A1 : (z332 : eterm |- etp),
          Dskof : ( |- skof Dskel A (\z310. A1[z310])),
          A2 : ( |- etp),
          A3 : (z332 : eterm |- etp),
          Dskof1 : ( |- skof Dskel1 A2 (\z310. A3)),
          M1 : (y : eterm, x : eterm |- eterm),
          Dexpand : (y : eterm, x : eterm |- eexpand x (A1[y]) M1)
        |
        ; solve
            [g |-
               can-skof/i _
               (\x. _) (skof/pi Dskof[] Dskof1[] (\y. \x. Dexpand[y, x]))]
        }
      }
    }
  }
  case kt:
  { g : evar
  |
  ; solve [_ |- can-skof/i _ (\x. _) skof/t]
  }
}
;

LF skof-fun/e : etp -> etp -> (eterm -> etp) -> (eterm -> etp) -> type =
| skof-fun/i :
  etp-eq A A' ->
  ({ x : eterm } etp-eq (B x) (B' x)) ->
    skof-fun/e A A' B B'
;

proof skof-fun :
  (g : evar)
  [g |- skof K A (\x. B)] ->
  [g |- skof K A' (\x. B')] ->
    [g |- skof-fun/e A A' (\x. B) (\x. B')] =
/ total 1 /
intros
{ g : evar,
  K : (g |- skel),
  A : (g |- etp),
  B : (g, x344 : eterm |- etp),
  A' : (g |- etp),
  B' : (g, x344 : eterm |- etp)
| x : [g |- skof K A (\x. B)], skof : [g |- skof K A' (\x. B')]
; split x as
  case skof/one:
  { g : evar, A' : (g |- etp), B' : (g, x344 : eterm |- etp)
  | x : [g |- skof kone eone (\x. eone)], skof : [g |- skof kone A' (\x. B')]
  ; split skof as
    case skof/one:
    { g : evar
    | x : [g |- skof kone eone (\x. eone)],
      skof : [g |- skof kone eone (\x. eone)]
    ; solve [_ |- skof-fun/i (etp-eq/i ) (\x. etp-eq/i )]
    }
  }
  case skof/sing:
  { g : evar, A' : (g |- etp), B' : (g, x344 : eterm |- etp)
  | x : [g |- skof ksing et (\x. esing x)],
    skof : [g |- skof ksing A' (\x. B')]
  ; split skof as
    case skof/sing:
    { g : evar
    | x : [g |- skof ksing et (\x. esing x)],
      skof : [g |- skof ksing et (\x. esing x)]
    ; solve [_ |- skof-fun/i (etp-eq/i ) (\x. etp-eq/i )]
    }
  }
  case skof/sigma:
  { g : evar,
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    A1 : (g |- etp),
    A2 : (g, y : eterm |- etp),
    A3 : (g |- etp),
    A4 : (g, x : eterm |- etp),
    M : (g, y : eterm, z : eterm |- eterm),
    A' : (g |- etp),
    B' : (g, x344 : eterm |- etp),
    Dskof : (g |- skof Dskel[] A1 (\y. A2)),
    Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
    Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M)
  | x :
      [g |-
         skof
           (ksigma Dskel[] Dskel1[])
           (esigma A1 (\y. epi A2 (\l. A3[..])))
           (\x.
              esigma (A2[.., epi1 x])
              (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
    skof : [g |- skof (ksigma Dskel[] Dskel1[]) A' (\x. B')]
  ; split skof as
    case skof/sigma:
    { g : evar,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      A1 : (g |- etp),
      A2 : (g, y : eterm |- etp),
      A3 : (g |- etp),
      A4 : (g, x : eterm |- etp),
      M : (g, y : eterm, z : eterm |- eterm),
      A5 : (g |- etp),
      A6 : (g, y : eterm |- etp),
      A7 : (g |- etp),
      A8 : (g, x : eterm |- etp),
      M1 : (g, y : eterm, z : eterm |- eterm),
      Dskof : (g |- skof Dskel[] A1 (\y. A2)),
      Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
      Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
      Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
      Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
      Dexpand1 : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1)
    | x :
        [g |-
           skof
             (ksigma Dskel[] Dskel1[])
             (esigma A1 (\y. epi A2 (\l. A3[..])))
             (\x.
                esigma (A2[.., epi1 x])
                (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
      skof :
        [g |-
           skof
             (ksigma Dskel[] Dskel1[])
             (esigma A5 (\y. epi A6 (\l. A7[..])))
             (\x.
                esigma (A6[.., epi1 x])
                (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
    ; split skof-fun [_ |- Dskof] [_ |- Dskof2] as
      case skof-fun/i:
      { g : evar,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        A1 : (g |- etp),
        A2 : (g, y : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, x : eterm |- etp),
        M : (g, y : eterm, z : eterm |- eterm),
        A5 : (g |- etp),
        A6 : (g, y : eterm |- etp),
        A7 : (g |- etp),
        A8 : (g, x : eterm |- etp),
        M1 : (g, y : eterm, z : eterm |- eterm),
        Dskof : (g |- skof Dskel[] A1 (\y. A2)),
        Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
        Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
        Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
        Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
        Dexpand1 : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1),
        Deq : (g |- etp-eq A1 A5),
        Deq1 : (g, x : eterm |- etp-eq A2 A6)
      | x :
          [g |-
             skof
               (ksigma Dskel[] Dskel1[])
               (esigma A1 (\y. epi A2 (\l. A3[..])))
               (\x.
                  esigma (A2[.., epi1 x])
                  (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
        skof :
          [g |-
             skof
               (ksigma Dskel[] Dskel1[])
               (esigma A5 (\y. epi A6 (\l. A7[..])))
               (\x.
                  esigma (A6[.., epi1 x])
                  (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
      ; split [_ |- Deq] as
        case etp-eq/i:
        { g : evar,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          A5 : (g |- etp),
          A2 : (g, y : eterm |- etp),
          A3 : (g |- etp),
          A4 : (g, x : eterm |- etp),
          M : (g, y : eterm, z : eterm |- eterm),
          A6 : (g, y : eterm |- etp),
          A7 : (g |- etp),
          A8 : (g, x : eterm |- etp),
          M1 : (g, y : eterm, z : eterm |- eterm),
          Dskof : (g |- skof Dskel[] A5 (\y. A2)),
          Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
          Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
          Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
          Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
          Dexpand1 : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1),
          Deq1 : (g, x : eterm |- etp-eq A2 A6)
        | x :
            [g |-
               skof
                 (ksigma Dskel[] Dskel1[])
                 (esigma A5 (\y. epi A2 (\l. A3[..])))
                 (\x.
                    esigma (A2[.., epi1 x])
                    (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
          skof :
            [g |-
               skof
                 (ksigma Dskel[] Dskel1[])
                 (esigma A5 (\y. epi A6 (\l. A7[..])))
                 (\x.
                    esigma (A6[.., epi1 x])
                    (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
        ; split [_, x : eterm |- Deq1] as
          case etp-eq/i:
          { g : evar,
            Dskel : ( |- skel),
            Dskel1 : ( |- skel),
            A5 : (g |- etp),
            A6 : (g, y : eterm |- etp),
            A3 : (g |- etp),
            A4 : (g, x : eterm |- etp),
            M : (g, y : eterm, z : eterm |- eterm),
            A7 : (g |- etp),
            A8 : (g, x : eterm |- etp),
            M1 : (g, y : eterm, z : eterm |- eterm),
            Dskof : (g |- skof Dskel[] A5 (\y. A6)),
            Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
            Dexpand : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M),
            Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
            Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
            Dexpand1 : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1)
          | x :
              [g |-
                 skof
                   (ksigma Dskel[] Dskel1[])
                   (esigma A5 (\y. epi A6 (\l. A3[..])))
                   (\x.
                      esigma (A6[.., epi1 x])
                      (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
            skof :
              [g |-
                 skof
                   (ksigma Dskel[] Dskel1[])
                   (esigma A5 (\y. epi A6 (\l. A7[..])))
                   (\x.
                      esigma (A6[.., epi1 x])
                      (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
          ; split skof-fun [_ |- Dskof1] [_ |- Dskof3] as
            case skof-fun/i:
            { g : evar,
              Dskel : ( |- skel),
              Dskel1 : ( |- skel),
              A5 : (g |- etp),
              A6 : (g, y : eterm |- etp),
              A3 : (g |- etp),
              A4 : (g, x : eterm |- etp),
              M : (g, y : eterm, z : eterm |- eterm),
              A7 : (g |- etp),
              A8 : (g, x : eterm |- etp),
              M1 : (g, y : eterm, z : eterm |- eterm),
              Dskof : (g |- skof Dskel[] A5 (\y. A6)),
              Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
              Dexpand : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M),
              Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
              Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
              Dexpand1 :
                (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1),
              Deq : (g |- etp-eq A3 A7),
              Deq1 : (g, x : eterm |- etp-eq A4 A8)
            | x :
                [g |-
                   skof
                     (ksigma Dskel[] Dskel1[])
                     (esigma A5 (\y. epi A6 (\l. A3[..])))
                     (\x.
                        esigma (A6[.., epi1 x])
                        (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
              skof :
                [g |-
                   skof
                     (ksigma Dskel[] Dskel1[])
                     (esigma A5 (\y. epi A6 (\l. A7[..])))
                     (\x.
                        esigma (A6[.., epi1 x])
                        (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
            ; split [_ |- Deq] as
              case etp-eq/i:
              { g : evar,
                Dskel : ( |- skel),
                Dskel1 : ( |- skel),
                A5 : (g |- etp),
                A6 : (g, y : eterm |- etp),
                A7 : (g |- etp),
                A4 : (g, x : eterm |- etp),
                M : (g, y : eterm, z : eterm |- eterm),
                A8 : (g, x : eterm |- etp),
                M1 : (g, y : eterm, z : eterm |- eterm),
                Dskof : (g |- skof Dskel[] A5 (\y. A6)),
                Dskof1 : (g |- skof Dskel1[] A7 (\z. A4)),
                Dexpand :
                  (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M),
                Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
                Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
                Dexpand1 :
                  (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1),
                Deq1 : (g, x : eterm |- etp-eq A4 A8)
              | x :
                  [g |-
                     skof
                       (ksigma Dskel[] Dskel1[])
                       (esigma A5 (\y. epi A6 (\l. A7[..])))
                       (\x.
                          esigma (A6[.., epi1 x])
                          (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
                skof :
                  [g |-
                     skof
                       (ksigma Dskel[] Dskel1[])
                       (esigma A5 (\y. epi A6 (\l. A7[..])))
                       (\x.
                          esigma (A6[.., epi1 x])
                          (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
              ; split [_, x : eterm |- Deq1] as
                case etp-eq/i:
                { g : evar,
                  Dskel : ( |- skel),
                  Dskel1 : ( |- skel),
                  A5 : (g |- etp),
                  A6 : (g, y : eterm |- etp),
                  A7 : (g |- etp),
                  A8 : (g, x : eterm |- etp),
                  M : (g, y : eterm, z : eterm |- eterm),
                  M1 : (g, y : eterm, z : eterm |- eterm),
                  Dskof : (g |- skof Dskel[] A5 (\y. A6)),
                  Dskof1 : (g |- skof Dskel1[] A7 (\z. A8)),
                  Dexpand :
                    (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M),
                  Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
                  Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
                  Dexpand1 :
                    (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1)
                | x :
                    [g |-
                       skof
                         (ksigma Dskel[] Dskel1[])
                         (esigma A5 (\y. epi A6 (\l. A7[..])))
                         (\x.
                            esigma (A6[.., epi1 x])
                            (\x1. A8[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
                  skof :
                    [g |-
                       skof
                         (ksigma Dskel[] Dskel1[])
                         (esigma A5 (\y. epi A6 (\l. A7[..])))
                         (\x.
                            esigma (A6[.., epi1 x])
                            (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
                ; split
                  eexpand-fun [_, y : eterm, x : eterm |- Dexpand]
                    [_, y : eterm, x : eterm |- Dexpand1] as
                  case eterm-eq/i:
                  { g : evar,
                    Dskel : ( |- skel),
                    Dskel1 : ( |- skel),
                    A5 : (g |- etp),
                    A6 : (g, y : eterm |- etp),
                    A7 : (g |- etp),
                    A8 : (g, x : eterm |- etp),
                    M1 : (g, y : eterm, z : eterm |- eterm),
                    Dskof : (g |- skof Dskel[] A5 (\y. A6)),
                    Dskof1 : (g |- skof Dskel1[] A7 (\z. A8)),
                    Dexpand :
                      (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1),
                    Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
                    Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
                    Dexpand1 :
                      (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1)
                  | x :
                      [g |-
                         skof
                           (ksigma Dskel[] Dskel1[])
                           (esigma A5 (\y. epi A6 (\l. A7[..])))
                           (\x.
                              esigma (A6[.., epi1 x])
                              (\x1.
                                 A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))],
                    skof :
                      [g |-
                         skof
                           (ksigma Dskel[] Dskel1[])
                           (esigma A5 (\y. epi A6 (\l. A7[..])))
                           (\x.
                              esigma (A6[.., epi1 x])
                              (\x1.
                                 A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
                  ; solve [_ |- skof-fun/i (etp-eq/i ) (\x. etp-eq/i )]
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  case skof/pi:
  { g : evar,
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    A1 : (g |- etp),
    A2 : (g, z : eterm |- etp),
    A3 : (g |- etp),
    A4 : (g, y : eterm |- etp),
    M : (g, z : eterm, x : eterm |- eterm),
    A' : (g |- etp),
    B' : (g, x344 : eterm |- etp),
    Dskof : (g |- skof Dskel[] A1 (\y. A2)),
    Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
    Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M)
  | x :
      [g |-
         skof
           (kpi Dskel[] Dskel1[])
           (esigma A1 (\y. epi A2 (\l. A3[..])))
           (\x.
              epi (A2[.., epi1 x])
              (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
    skof : [g |- skof (kpi Dskel[] Dskel1[]) A' (\x. B')]
  ; split skof as
    case skof/pi:
    { g : evar,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      A1 : (g |- etp),
      A2 : (g, z : eterm |- etp),
      A3 : (g |- etp),
      A4 : (g, y : eterm |- etp),
      M : (g, z : eterm, x : eterm |- eterm),
      A5 : (g |- etp),
      A6 : (g, z : eterm |- etp),
      A7 : (g |- etp),
      A8 : (g, y : eterm |- etp),
      M1 : (g, z : eterm, x : eterm |- eterm),
      Dskof : (g |- skof Dskel[] A1 (\y. A2)),
      Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
      Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
      Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
      Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
      Dexpand1 : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1)
    | x :
        [g |-
           skof
             (kpi Dskel[] Dskel1[])
             (esigma A1 (\y. epi A2 (\l. A3[..])))
             (\x.
                epi (A2[.., epi1 x])
                (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
      skof :
        [g |-
           skof
             (kpi Dskel[] Dskel1[])
             (esigma A5 (\y. epi A6 (\l. A7[..])))
             (\x.
                epi (A6[.., epi1 x])
                (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
    ; split skof-fun [_ |- Dskof] [_ |- Dskof2] as
      case skof-fun/i:
      { g : evar,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        A1 : (g |- etp),
        A2 : (g, z : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, y : eterm |- etp),
        M : (g, z : eterm, x : eterm |- eterm),
        A5 : (g |- etp),
        A6 : (g, z : eterm |- etp),
        A7 : (g |- etp),
        A8 : (g, y : eterm |- etp),
        M1 : (g, z : eterm, x : eterm |- eterm),
        Dskof : (g |- skof Dskel[] A1 (\y. A2)),
        Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
        Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
        Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
        Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
        Dexpand1 : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1),
        Deq : (g |- etp-eq A1 A5),
        Deq1 : (g, x : eterm |- etp-eq A2 A6)
      | x :
          [g |-
             skof
               (kpi Dskel[] Dskel1[])
               (esigma A1 (\y. epi A2 (\l. A3[..])))
               (\x.
                  epi (A2[.., epi1 x])
                  (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
        skof :
          [g |-
             skof
               (kpi Dskel[] Dskel1[])
               (esigma A5 (\y. epi A6 (\l. A7[..])))
               (\x.
                  epi (A6[.., epi1 x])
                  (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
      ; split [_ |- Deq] as
        case etp-eq/i:
        { g : evar,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          A5 : (g |- etp),
          A2 : (g, z : eterm |- etp),
          A3 : (g |- etp),
          A4 : (g, y : eterm |- etp),
          M : (g, z : eterm, x : eterm |- eterm),
          A6 : (g, z : eterm |- etp),
          A7 : (g |- etp),
          A8 : (g, y : eterm |- etp),
          M1 : (g, z : eterm, x : eterm |- eterm),
          Dskof : (g |- skof Dskel[] A5 (\y. A2)),
          Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
          Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
          Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
          Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
          Dexpand1 : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1),
          Deq1 : (g, x : eterm |- etp-eq A2 A6)
        | x :
            [g |-
               skof
                 (kpi Dskel[] Dskel1[])
                 (esigma A5 (\y. epi A2 (\l. A3[..])))
                 (\x.
                    epi (A2[.., epi1 x])
                    (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
          skof :
            [g |-
               skof
                 (kpi Dskel[] Dskel1[])
                 (esigma A5 (\y. epi A6 (\l. A7[..])))
                 (\x.
                    epi (A6[.., epi1 x])
                    (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
        ; split [_, x : eterm |- Deq1] as
          case etp-eq/i:
          { g : evar,
            Dskel : ( |- skel),
            Dskel1 : ( |- skel),
            A5 : (g |- etp),
            A6 : (g, z : eterm |- etp),
            A3 : (g |- etp),
            A4 : (g, y : eterm |- etp),
            M : (g, z : eterm, x : eterm |- eterm),
            A7 : (g |- etp),
            A8 : (g, y : eterm |- etp),
            M1 : (g, z : eterm, x : eterm |- eterm),
            Dskof : (g |- skof Dskel[] A5 (\y. A6)),
            Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
            Dexpand : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M),
            Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
            Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
            Dexpand1 : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1)
          | x :
              [g |-
                 skof
                   (kpi Dskel[] Dskel1[])
                   (esigma A5 (\y. epi A6 (\l. A3[..])))
                   (\x.
                      epi (A6[.., epi1 x])
                      (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
            skof :
              [g |-
                 skof
                   (kpi Dskel[] Dskel1[])
                   (esigma A5 (\y. epi A6 (\l. A7[..])))
                   (\x.
                      epi (A6[.., epi1 x])
                      (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
          ; split skof-fun [_ |- Dskof1] [_ |- Dskof3] as
            case skof-fun/i:
            { g : evar,
              Dskel : ( |- skel),
              Dskel1 : ( |- skel),
              A5 : (g |- etp),
              A6 : (g, z : eterm |- etp),
              A3 : (g |- etp),
              A4 : (g, y : eterm |- etp),
              M : (g, z : eterm, x : eterm |- eterm),
              A7 : (g |- etp),
              A8 : (g, y : eterm |- etp),
              M1 : (g, z : eterm, x : eterm |- eterm),
              Dskof : (g |- skof Dskel[] A5 (\y. A6)),
              Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
              Dexpand : (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M),
              Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
              Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
              Dexpand1 :
                (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1),
              Deq : (g |- etp-eq A3 A7),
              Deq1 : (g, x : eterm |- etp-eq A4 A8)
            | x :
                [g |-
                   skof
                     (kpi Dskel[] Dskel1[])
                     (esigma A5 (\y. epi A6 (\l. A3[..])))
                     (\x.
                        epi (A6[.., epi1 x])
                        (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
              skof :
                [g |-
                   skof
                     (kpi Dskel[] Dskel1[])
                     (esigma A5 (\y. epi A6 (\l. A7[..])))
                     (\x.
                        epi (A6[.., epi1 x])
                        (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
            ; split [_ |- Deq] as
              case etp-eq/i:
              { g : evar,
                Dskel : ( |- skel),
                Dskel1 : ( |- skel),
                A5 : (g |- etp),
                A6 : (g, z : eterm |- etp),
                A7 : (g |- etp),
                A4 : (g, y : eterm |- etp),
                M : (g, z : eterm, x : eterm |- eterm),
                A8 : (g, y : eterm |- etp),
                M1 : (g, z : eterm, x : eterm |- eterm),
                Dskof : (g |- skof Dskel[] A5 (\y. A6)),
                Dskof1 : (g |- skof Dskel1[] A7 (\z. A4)),
                Dexpand :
                  (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M),
                Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
                Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
                Dexpand1 :
                  (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1),
                Deq1 : (g, x : eterm |- etp-eq A4 A8)
              | x :
                  [g |-
                     skof
                       (kpi Dskel[] Dskel1[])
                       (esigma A5 (\y. epi A6 (\l. A7[..])))
                       (\x.
                          epi (A6[.., epi1 x])
                          (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
                skof :
                  [g |-
                     skof
                       (kpi Dskel[] Dskel1[])
                       (esigma A5 (\y. epi A6 (\l. A7[..])))
                       (\x.
                          epi (A6[.., epi1 x])
                          (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
              ; split [_, x : eterm |- Deq1] as
                case etp-eq/i:
                { g : evar,
                  Dskel : ( |- skel),
                  Dskel1 : ( |- skel),
                  A5 : (g |- etp),
                  A6 : (g, z : eterm |- etp),
                  A7 : (g |- etp),
                  A8 : (g, y : eterm |- etp),
                  M : (g, z : eterm, x : eterm |- eterm),
                  M1 : (g, z : eterm, x : eterm |- eterm),
                  Dskof : (g |- skof Dskel[] A5 (\y. A6)),
                  Dskof1 : (g |- skof Dskel1[] A7 (\z. A8)),
                  Dexpand :
                    (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M),
                  Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
                  Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
                  Dexpand1 :
                    (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1)
                | x :
                    [g |-
                       skof
                         (kpi Dskel[] Dskel1[])
                         (esigma A5 (\y. epi A6 (\l. A7[..])))
                         (\x.
                            epi (A6[.., epi1 x])
                            (\x1. A8[.., eapp (epi2 x) (M[.., epi1 x, x1])]))],
                  skof :
                    [g |-
                       skof
                         (kpi Dskel[] Dskel1[])
                         (esigma A5 (\y. epi A6 (\l. A7[..])))
                         (\x.
                            epi (A6[.., epi1 x])
                            (\x1. A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
                ; split
                  eexpand-fun [_, y : eterm, x : eterm |- Dexpand]
                    [_, y : eterm, x : eterm |- Dexpand1] as
                  case eterm-eq/i:
                  { g : evar,
                    Dskel : ( |- skel),
                    Dskel1 : ( |- skel),
                    A5 : (g |- etp),
                    A6 : (g, z : eterm |- etp),
                    A7 : (g |- etp),
                    A8 : (g, y : eterm |- etp),
                    M1 : (g, z : eterm, x : eterm |- eterm),
                    Dskof : (g |- skof Dskel[] A5 (\y. A6)),
                    Dskof1 : (g |- skof Dskel1[] A7 (\z. A8)),
                    Dexpand :
                      (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1),
                    Dskof2 : (g |- skof Dskel[] A5 (\y. A6)),
                    Dskof3 : (g |- skof Dskel1[] A7 (\z. A8)),
                    Dexpand1 :
                      (g, y : eterm, x : eterm |- eexpand x (A6[.., y]) M1)
                  | x :
                      [g |-
                         skof
                           (kpi Dskel[] Dskel1[])
                           (esigma A5 (\y. epi A6 (\l. A7[..])))
                           (\x.
                              epi (A6[.., epi1 x])
                              (\x1.
                                 A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))],
                    skof :
                      [g |-
                         skof
                           (kpi Dskel[] Dskel1[])
                           (esigma A5 (\y. epi A6 (\l. A7[..])))
                           (\x.
                              epi (A6[.., epi1 x])
                              (\x1.
                                 A8[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
                  ; solve [_ |- skof-fun/i (etp-eq/i ) (\x. etp-eq/i )]
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  case skof/t:
  { g : evar, A' : (g |- etp), B' : (g, x344 : eterm |- etp)
  | x : [g |- skof kt eone (\x. et)], skof : [g |- skof kt A' (\x. B')]
  ; split skof as
    case skof/t:
    { g : evar
    | x : [g |- skof kt eone (\x. et)], skof : [g |- skof kt eone (\x. et)]
    ; solve [_ |- skof-fun/i (etp-eq/i ) (\x. etp-eq/i )]
    }
  }
}
;

LF skof-reg/e : etp -> (eterm -> etp) -> type =
| skof-reg/i :
  ewf A -> ({ x : eterm } eof x A -> ewf (B x)) -> skof-reg/e A B
;

schema ebind+topenblock =
  % ebind
  some [ea : etp]
  block (ex : eterm, ed : eof ex ea) +
  % topenblock
  some [a : tp, r : atom]
  block (xc : catom, d : topenr xc a r);

proof skof-reg :
  (g : ebind+topenblock)
  [g |- skof K A (\x. B)] ->
    [g |- skof-reg/e A (\x. B)] =
/ total 1 /
intros
{ g : ebind+topenblock,
  K : (g |- skel),
  A : (g |- etp),
  B : (g, z310 : eterm |- etp)
| x : [g |- skof K A (\x. B)]
; split x as
  case skof/one:
  { g : ebind+topenblock
  | x : [g |- skof kone eone (\x. eone)]
  ; solve [_ |- skof-reg/i ewf/one (\x. \dx. ewf/one)]
  }
  case skof/sing:
  { g : ebind+topenblock
  | x : [g |- skof ksing et (\x. esing x)]
  ; solve [_ |- skof-reg/i ewf/t (\x. \dx. ewf/sing _)]
  }
  case skof/sigma:
  { g : ebind+topenblock,
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    A1 : (g |- etp),
    A2 : (g, x314 : eterm |- etp),
    A3 : (g |- etp),
    A4 : (g, z314 : eterm |- etp),
    M : (g, x315 : eterm, y315 : eterm |- eterm),
    Dskof : (g |- skof Dskel[] A1 (\y. A2)),
    Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
    Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M)
  | x :
      [g |-
         skof
           (ksigma Dskel[] Dskel1[])
           (esigma A1 (\y. epi A2 (\l. A3[..])))
           (\x.
              esigma (A2[.., epi1 x])
              (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
  ; split skof-reg [g |- Dskof] as
    case skof-reg/i:
    { g : ebind+topenblock,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      A1 : (g |- etp),
      A2 : (g, x314 : eterm |- etp),
      A3 : (g |- etp),
      A4 : (g, z314 : eterm |- etp),
      M : (g, x315 : eterm, y315 : eterm |- eterm),
      Dskof : (g |- skof Dskel[] A1 (\y. A2)),
      Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
      Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
      Dwf : (g |- ewf A1),
      Dwf1 : (g, x : eterm, z337 : eof x (A1[..]) |- ewf (A2[.., x]))
    | x :
        [g |-
           skof
             (ksigma Dskel[] Dskel1[])
             (esigma A1 (\y. epi A2 (\l. A3[..])))
             (\x.
                esigma (A2[.., epi1 x])
                (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
    ; split skof-reg [g |- Dskof1] as
      case skof-reg/i:
      { g : ebind+topenblock,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        A1 : (g |- etp),
        A2 : (g, x314 : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, z314 : eterm |- etp),
        M : (g, x315 : eterm, y315 : eterm |- eterm),
        Dskof : (g |- skof Dskel[] A1 (\y. A2)),
        Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
        Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
        Dwf : (g |- ewf A1),
        Dwf1 : (g, x : eterm, z337 : eof x (A1[..]) |- ewf (A2[.., x])),
        Dwf2 : (g |- ewf A3),
        Dwf3 : (g, x : eterm, z337 : eof x (A3[..]) |- ewf (A4[.., x]))
      | x :
          [g |-
             skof
               (ksigma Dskel[] Dskel1[])
               (esigma A1 (\y. epi A2 (\l. A3[..])))
               (\x.
                  esigma (A2[.., epi1 x])
                  (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
      ; by [g |-
      ewf/sigma Dwf (\x. \dx. ewf/pi (Dwf1[.., x, _]) (\x1. \dx1. Dwf2[..]))]
as Dwf' unboxed;
        by [g, x : eterm |-
      ewf/sigma (Dwf1[.., epi1 x, _])
      (\x1. \dx. Dwf3[.., eapp (epi2 x) (M[.., epi1 x, x1]), _])]
as Dwf'' unboxed;
        solve [g |- skof-reg/i Dwf' (\x. \dx. Dwf''[.., x])]
      }
    }
  }
  case skof/pi:
  { g : ebind+topenblock,
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    A1 : (g |- etp),
    A2 : (g, y312 : eterm |- etp),
    A3 : (g |- etp),
    A4 : (g, x312 : eterm |- etp),
    M : (g, y313 : eterm, z312 : eterm |- eterm),
    Dskof : (g |- skof Dskel[] A1 (\y. A2)),
    Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
    Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M)
  | x :
      [g |-
         skof
           (kpi Dskel[] Dskel1[])
           (esigma A1 (\y. epi A2 (\l. A3[..])))
           (\x.
              epi (A2[.., epi1 x])
              (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
  ; split skof-reg [g |- Dskof] as
    case skof-reg/i:
    { g : ebind+topenblock,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      A1 : (g |- etp),
      A2 : (g, y312 : eterm |- etp),
      A3 : (g |- etp),
      A4 : (g, x312 : eterm |- etp),
      M : (g, y313 : eterm, z312 : eterm |- eterm),
      Dskof : (g |- skof Dskel[] A1 (\y. A2)),
      Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
      Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
      Dwf : (g |- ewf A1),
      Dwf1 : (g, x : eterm, z337 : eof x (A1[..]) |- ewf (A2[.., x]))
    | x :
        [g |-
           skof
             (kpi Dskel[] Dskel1[])
             (esigma A1 (\y. epi A2 (\l. A3[..])))
             (\x.
                epi (A2[.., epi1 x])
                (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
    ; split skof-reg [g |- Dskof1] as
      case skof-reg/i:
      { g : ebind+topenblock,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        A1 : (g |- etp),
        A2 : (g, y312 : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, x312 : eterm |- etp),
        M : (g, y313 : eterm, z312 : eterm |- eterm),
        Dskof : (g |- skof Dskel[] A1 (\y. A2)),
        Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
        Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
        Dwf : (g |- ewf A1),
        Dwf1 : (g, x : eterm, z337 : eof x (A1[..]) |- ewf (A2[.., x])),
        Dwf2 : (g |- ewf A3),
        Dwf3 : (g, x : eterm, z337 : eof x (A3[..]) |- ewf (A4[.., x]))
      | x :
          [g |-
             skof
               (kpi Dskel[] Dskel1[])
               (esigma A1 (\y. epi A2 (\l. A3[..])))
               (\x.
                  epi (A2[.., epi1 x])
                  (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
      ; by [g |-
      ewf/sigma Dwf (\x. \dx. ewf/pi (Dwf1[.., x, _]) (\x1. \dx1. Dwf2[..]))]
as Dwf' unboxed;
        by [g, x : eterm |-
      ewf/pi (Dwf1[.., epi1 x, _])
      (\x1. \dx. Dwf3[.., eapp (epi2 x) (M[.., epi1 x, x1]), _])]
as Dwf'' unboxed;
        solve [g |- skof-reg/i Dwf' (\x. \dx. Dwf''[.., x])]
      }
    }
  }
  case skof/t:
  { g : ebind+topenblock
  | x : [g |- skof kt eone (\x. et)]
  ; solve [g |- skof-reg/i ewf/one (\x. \dx. ewf/t)]
  }
}
;

% Flay Theorems

LF flay-sound/e : etp -> (eterm -> etp) -> etp -> eterm -> type =
| flay-sound/i : eof M B -> tequiv A (A' M) -> flay-sound/e A A' B M
;

proof flay-sound :
  (g : ebind)
  [g |- ewf A] ->
  [g |- flay A K M] ->
  [g |- skof K B (\x. A')] ->
    [g |- flay-sound/e A (\x. A') B M] =
/ total 1 /
intros
{ g : ebind,
  A : (g |- etp),
  K : (g |- skel),
  M : (g |- eterm),
  B : (g |- etp),
  A' : (g, z310 : eterm |- etp)
| x : [g |- ewf A], flay : [g |- flay A K M], skof : [g |- skof K B (\x. A')]
; split x as
  case ewf/one:
  { g : ebind,
    K : (g |- skel),
    M : (g |- eterm),
    B : (g |- etp),
    A' : (g, z310 : eterm |- etp)
  | x : [g |- ewf eone],
    flay : [g |- flay eone K M],
    skof : [g |- skof K B (\x. A')]
  ; split flay as
    case flay/one:
    { g : ebind, B : (g |- etp), A' : (g, z310 : eterm |- etp)
    | x : [g |- ewf eone],
      flay : [g |- flay eone kone estar],
      skof : [g |- skof kone B (\x. A')]
    ; split skof as
      case skof/one:
      { g : ebind
      | x : [g |- ewf eone],
        flay : [g |- flay eone kone estar],
        skof : [g |- skof kone eone (\x. eone)]
      ; solve [g |- flay-sound/i eof/star (tequiv/reflex ewf/one)]
      }
    }
  }
  case ewf/sing:
  { g : ebind,
    M1 : (g |- eterm),
    K : (g |- skel),
    M : (g |- eterm),
    B : (g |- etp),
    A' : (g, z310 : eterm |- etp),
    Dof : (g |- eof M1 et)
  | x : [g |- ewf (esing M1)],
    flay : [g |- flay (esing M1) K M],
    skof : [g |- skof K B (\x. A')]
  ; split flay as
    case flay/sing:
    { g : ebind,
      M : (g |- eterm),
      B : (g |- etp),
      A' : (g, z310 : eterm |- etp),
      Dof : (g |- eof M et)
    | x : [g |- ewf (esing M)],
      flay : [g |- flay (esing M) ksing M],
      skof : [g |- skof ksing B (\x. A')]
    ; split skof as
      case skof/sing:
      { g : ebind, M : (g |- eterm), Dof : (g |- eof M et)
      | x : [g |- ewf (esing M)],
        flay : [g |- flay (esing M) ksing M],
        skof : [g |- skof ksing et (\x. esing x)]
      ; solve [g |- flay-sound/i Dof (tequiv/reflex (ewf/sing Dof))]
      }
    }
  }
  case ewf/sigma:
  { g : ebind,
    A1 : (g |- etp),
    A2 : (g, x163 : eterm |- etp),
    K : (g |- skel),
    M : (g |- eterm),
    B : (g |- etp),
    A' : (g, z310 : eterm |- etp),
    Dwf : (g |- ewf A1),
    Dwf1 : (g, x : eterm, y163 : eof x (A1[..]) |- ewf (A2[.., x]))
  | x : [g |- ewf (esigma A1 (\y149. A2))],
    flay : [g |- flay (esigma A1 (\y149. A2)) K M],
    skof : [g |- skof K B (\x. A')]
  ; split flay as
    case flay/sigma:
    { g : ebind,
      A1 : (g |- etp),
      A2 : (g, x163 : eterm |- etp),
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      M1 : (g |- eterm),
      M2 : (g, y319 : eterm |- eterm),
      B : (g |- etp),
      A' : (g, z310 : eterm |- etp),
      Dwf : (g |- ewf A1),
      Dwf1 : (g, x : eterm, y163 : eof x (A1[..]) |- ewf (A2[.., x])),
      Dflay : (g |- flay A1 Dskel[] M1),
      Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M2)
    | x : [g |- ewf (esigma A1 (\y149. A2))],
      flay :
        [g |-
           flay
             (esigma A1 (\y149. A2))
             (ksigma Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M2)))],
      skof : [g |- skof (ksigma Dskel[] Dskel1[]) B (\x. A')]
    ; split skof as
      case skof/sigma:
      { g : ebind,
        A1 : (g |- etp),
        A2 : (g, x163 : eterm |- etp),
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        M1 : (g |- eterm),
        M2 : (g, y319 : eterm |- eterm),
        A3 : (g |- etp),
        A4 : (g, x314 : eterm |- etp),
        A5 : (g |- etp),
        A6 : (g, z314 : eterm |- etp),
        M3 : (g, x315 : eterm, y315 : eterm |- eterm),
        Dwf : (g |- ewf A1),
        Dwf1 : (g, x : eterm, y163 : eof x (A1[..]) |- ewf (A2[.., x])),
        Dflay : (g |- flay A1 Dskel[] M1),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M2),
        Dskof : (g |- skof Dskel[] A3 (\y. A4)),
        Dskof1 : (g |- skof Dskel1[] A5 (\z. A6)),
        Dexpand : (g, y : eterm, x : eterm |- eexpand x (A4[.., y]) M3)
      | x : [g |- ewf (esigma A1 (\y149. A2))],
        flay :
          [g |-
             flay
               (esigma A1 (\y149. A2))
               (ksigma Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M2)))],
        skof :
          [g |-
             skof
               (ksigma Dskel[] Dskel1[])
               (esigma A3 (\y. epi A4 (\l. A5[..])))
               (\x.
                  esigma (A4[.., epi1 x])
                  (\x1. A6[.., eapp (epi2 x) (M3[.., epi1 x, x1])]))]
      ; split flay-sound [g |- Dwf] [g |- Dflay] [g |- Dskof] as
        case flay-sound/i:
        { g : ebind,
          A1 : (g |- etp),
          A2 : (g, x163 : eterm |- etp),
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          M1 : (g |- eterm),
          M2 : (g, y319 : eterm |- eterm),
          A3 : (g |- etp),
          A4 : (g, x314 : eterm |- etp),
          A5 : (g |- etp),
          A6 : (g, z314 : eterm |- etp),
          M3 : (g, x315 : eterm, y315 : eterm |- eterm),
          Dwf : (g |- ewf A1),
          Dwf1 : (g, x : eterm, y163 : eof x (A1[..]) |- ewf (A2[.., x])),
          Dflay : (g |- flay A1 Dskel[] M1),
          Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M2),
          Dskof : (g |- skof Dskel[] A3 (\y. A4)),
          Dskof1 : (g |- skof Dskel1[] A5 (\z. A6)),
          Dexpand : (g, y : eterm, x : eterm |- eexpand x (A4[.., y]) M3),
          Dof : (g |- eof M1 A3),
          Dtequiv : (g |- tequiv A1 (A4[.., M1]))
        | x : [g |- ewf (esigma A1 (\y149. A2))],
          flay :
            [g |-
               flay
                 (esigma A1 (\y149. A2))
                 (ksigma Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M2)))],
          skof :
            [g |-
               skof
                 (ksigma Dskel[] Dskel1[])
                 (esigma A3 (\y. epi A4 (\l. A5[..])))
                 (\x.
                    esigma (A4[.., epi1 x])
                    (\x1. A6[.., eapp (epi2 x) (M3[.., epi1 x, x1])]))]
        ; split
          flay-sound
            [g, b : block (x : eterm, dx : eof x (A1[..])) |-
               Dwf1[.., b.1, b.2]]
            [g, b : block (x : eterm, dx : eof x (A1[..])) |-
               Dflay1[.., b.1]]
            [g, b : block (x : eterm, dx : eof x (A1[..])) |- Dskof1[..]] as
          case flay-sound/i:
          { g : ebind,
            A1 : (g |- etp),
            A8 : (g, x : eterm |- etp),
            Dskel : ( |- skel),
            Dskel1 : ( |- skel),
            M1 : (g |- eterm),
            M4 : (g, x : eterm |- eterm),
            A3 : (g |- etp),
            A4 : (g, x314 : eterm |- etp),
            A7 : (g |- etp),
            A9 : (g, x343 : eterm |- etp),
            M3 : (g, x315 : eterm, y315 : eterm |- eterm),
            Dwf : (g |- ewf A1),
            Dwf1 : (g, x : eterm, y163 : eof x (A1[..]) |- ewf (A8[.., x])),
            Dflay : (g |- flay A1 Dskel[] M1),
            Dflay1 : (g, x : eterm |- flay A8 Dskel1[] M4),
            Dskof : (g |- skof Dskel[] A3 (\y. A4)),
            Dskof1 : (g |- skof Dskel1[] A7 (\z. A9)),
            Dexpand : (g, y : eterm, x : eterm |- eexpand x (A4[.., y]) M3),
            Dof : (g |- eof M1 A3),
            Dtequiv : (g |- tequiv A1 (A4[.., M1])),
            Dof1 :
              (g, x : eterm, x8 : eof x (A1[..]) |- eof (M4[.., x]) (A7[..])),
            Dtequiv1 :
              (g, x : eterm, z8 : eof x (A1[..]) |-
                 tequiv (A8[.., x]) (A9[.., (M4[.., x])]))
          | x : [g |- ewf (esigma A1 (\y149. A8))],
            flay :
              [g |-
                 flay
                   (esigma A1 (\y149. A8))
                   (ksigma Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M4)))],
            skof :
              [g |-
                 skof
                   (ksigma Dskel[] Dskel1[])
                   (esigma A3 (\y. epi A4 (\l. A7[..])))
                   (\x.
                      esigma (A4[.., epi1 x])
                      (\x1. A9[.., eapp (epi2 x) (M3[.., epi1 x, x1])]))]
          ; split skof-reg [g |- Dskof] as
            case skof-reg/i:
            { g : ebind,
              A1 : (g |- etp),
              A8 : (g, x : eterm |- etp),
              Dskel : ( |- skel),
              Dskel1 : ( |- skel),
              M1 : (g |- eterm),
              M4 : (g, x : eterm |- eterm),
              A3 : (g |- etp),
              A4 : (g, x314 : eterm |- etp),
              A7 : (g |- etp),
              A9 : (g, x343 : eterm |- etp),
              M3 : (g, x315 : eterm, y315 : eterm |- eterm),
              Dwf : (g |- ewf A1),
              Dwf1 :
                (g, x : eterm, y163 : eof x (A1[..]) |- ewf (A8[.., x])),
              Dflay : (g |- flay A1 Dskel[] M1),
              Dflay1 : (g, x : eterm |- flay A8 Dskel1[] M4),
              Dskof : (g |- skof Dskel[] A3 (\y. A4)),
              Dskof1 : (g |- skof Dskel1[] A7 (\z. A9)),
              Dexpand : (g, y : eterm, x : eterm |- eexpand x (A4[.., y]) M3),
              Dof : (g |- eof M1 A3),
              Dtequiv : (g |- tequiv A1 (A4[.., M1])),
              Dof1 :
                (g, x : eterm, x8 : eof x (A1[..]) |-
                   eof (M4[.., x]) (A7[..])),
              Dtequiv1 :
                (g, x : eterm, z8 : eof x (A1[..]) |-
                   tequiv (A8[.., x]) (A9[.., (M4[.., x])])),
              Dwf2 : (g |- ewf A3),
              Dwf3 :
                (g, x : eterm, z337 : eof x (A3[..]) |- ewf (A4[.., x]))
            | x : [g |- ewf (esigma A1 (\y149. A8))],
              flay :
                [g |-
                   flay
                     (esigma A1 (\y149. A8))
                     (ksigma Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M4)))],
              skof :
                [g |-
                   skof
                     (ksigma Dskel[] Dskel1[])
                     (esigma A3 (\y. epi A4 (\l. A7[..])))
                     (\x.
                        esigma (A4[.., epi1 x])
                        (\x1. A9[.., eapp (epi2 x) (M3[.., epi1 x, x1])]))]
            ; split skof-reg [g |- Dskof1] as
              case skof-reg/i:
              { g : ebind,
                A1 : (g |- etp),
                A8 : (g, x : eterm |- etp),
                Dskel : ( |- skel),
                Dskel1 : ( |- skel),
                M1 : (g |- eterm),
                M4 : (g, x : eterm |- eterm),
                A3 : (g |- etp),
                A4 : (g, x314 : eterm |- etp),
                A7 : (g |- etp),
                A9 : (g, x343 : eterm |- etp),
                M3 : (g, x315 : eterm, y315 : eterm |- eterm),
                Dwf : (g |- ewf A1),
                Dwf1 :
                  (g, x : eterm, y163 : eof x (A1[..]) |- ewf (A8[.., x])),
                Dflay : (g |- flay A1 Dskel[] M1),
                Dflay1 : (g, x : eterm |- flay A8 Dskel1[] M4),
                Dskof : (g |- skof Dskel[] A3 (\y. A4)),
                Dskof1 : (g |- skof Dskel1[] A7 (\z. A9)),
                Dexpand :
                  (g, y : eterm, x : eterm |- eexpand x (A4[.., y]) M3),
                Dof : (g |- eof M1 A3),
                Dtequiv : (g |- tequiv A1 (A4[.., M1])),
                Dof1 :
                  (g, x : eterm, x8 : eof x (A1[..]) |-
                     eof (M4[.., x]) (A7[..])),
                Dtequiv1 :
                  (g, x : eterm, z8 : eof x (A1[..]) |-
                     tequiv (A8[.., x]) (A9[.., (M4[.., x])])),
                Dwf2 : (g |- ewf A3),
                Dwf3 :
                  (g, x : eterm, z337 : eof x (A3[..]) |- ewf (A4[.., x])),
                Dwf4 : (g |- ewf A7),
                Dwf5 :
                  (g, x : eterm, z337 : eof x (A7[..]) |- ewf (A9[.., x]))
              | x : [g |- ewf (esigma A1 (\y149. A8))],
                flay :
                  [g |-
                     flay
                       (esigma A1 (\y149. A8))
                       (ksigma Dskel[] Dskel1[])
                       (epair M1 (elam A1 (\x. M4)))],
                skof :
                  [g |-
                     skof
                       (ksigma Dskel[] Dskel1[])
                       (esigma A3 (\y. epi A4 (\l. A7[..])))
                       (\x.
                          esigma (A4[.., epi1 x])
                          (\x1. A9[.., eapp (epi2 x) (M3[.., epi1 x, x1])]))]
              ; by [g |-
                      eof/pair Dof
                      (eof/subsume (eof/lam Dwf (\x. \dx. Dof1))
                      (subtp/reflex (tequiv/pi Dtequiv
                                    (\x. \dx. tequiv/reflex (Dwf4[..])))))
                      (\y. \e. ewf/pi Dwf3 (\x. \dx. Dwf4[..]))]
                as Dof' unboxed;
                by tfunctionality [g, y : eterm, dy : eof y (A3[..]) |- Dwf3]
     [g |- equiv/symm (equiv/beta1 Dof (eof/lam Dwf (\x. \dx. Dof1)))]
as DequivA' unboxed;
                by eexpand-equiv
                     [g, b1 : block (y : eterm, dy : eof y (A3[..])),
                      b2 : block (x : eterm, dx : eof x (A4[.., b1.1])) |-
                        b2.2]
                     [g, b1 : block (y : eterm, dy : eof y (A3[..])),
                      b2 : block (x : eterm, dx : eof x (A4[.., b1.1])) |-
                        Dexpand[.., b1.1, b2.1]]
                as DequivX unboxed;
                by [g, b : block (x : eterm, dx : eof x (A1[..])) |-
                      DequivX[..,
                              <epi1 (epair (M1[..])
                                    (elam (A1[..]) (\x. M4[.., x]))); eof/pi1
                              (eof/pair (Dof[..])
                              (eof/lam (Dwf[..]) (\x. \dx. Dof1[.., x, dx]))
                              (\l1.
                                 \l2. ewf/pi (Dwf[..]) (\l3. \l4. Dwf4[..])))>,
                              <b.1; eof/subsume b.2
                              (subtp/reflex (tequiv/trans (Dtequiv[..])
                                            (DequivA'[..])))>]]
                as DequivX' unboxed;
                by tfunctionality
                     [g, b : block (x : eterm, dx : eof x (A1[..])),
                      y : eterm,
                      dy : eof y (A7[..]) |- Dwf5[.., y, dy]]
                     [g, b : block (x : eterm, dx : eof x (A1[..])) |-
                        equiv/symm (equiv/trans (equiv/app (equiv/beta2
                                                           (Dof[..])
                                                           (eof/lam (Dwf[..])
                                                           (\x.
                                                              \dx.
                                                                Dof1[
                                                                .., x, dx])))
                                                (equiv/subsume (equiv/symm
                                                               DequivX')
                                                (subtp/reflex (tequiv/symm
                                                              (tequiv/trans
                                                              (Dtequiv[
                                                              ..])
                                                              (DequivA'[..]))))))
                                   (equiv/beta (\x. \dx. Dof1[.., x, dx])
                                   b.2))]
                as DequivB' unboxed;
                solve
                  [g |-
                     flay-sound/i (eof/pair Dof
                                  (eof/subsume (eof/lam Dwf (\x. \dx. Dof1))
                                  (subtp/reflex (tequiv/pi Dtequiv
                                                (\l1.
                                                   \l2.
                                                     tequiv/reflex (Dwf4[..])))))
                                  (\y. \dy. ewf/pi Dwf3 (\l1. \l2. Dwf4[..])))
                     (tequiv/sigma (tequiv/trans Dtequiv DequivA')
                     (\x. \dx. tequiv/trans Dtequiv1 (DequivB'[.., <x; dx>])))]
              }
            }
          }
        }
      }
    }
  }
  case ewf/pi:
  { g : ebind,
    A1 : (g |- etp),
    A2 : (g, y162 : eterm |- etp),
    K : (g |- skel),
    M : (g |- eterm),
    B : (g |- etp),
    A' : (g, z310 : eterm |- etp),
    Dwf : (g |- ewf A1),
    Dwf1 : (g, x : eterm, z161 : eof x (A1[..]) |- ewf (A2[.., x]))
  | x : [g |- ewf (epi A1 (\y148. A2))],
    flay : [g |- flay (epi A1 (\y148. A2)) K M],
    skof : [g |- skof K B (\x. A')]
  ; split flay as
    case flay/pi:
    { g : ebind,
      A1 : (g |- etp),
      A2 : (g, y162 : eterm |- etp),
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      M1 : (g |- eterm),
      M2 : (g, z317 : eterm |- eterm),
      B : (g |- etp),
      A' : (g, z310 : eterm |- etp),
      Dwf : (g |- ewf A1),
      Dwf1 : (g, x : eterm, z161 : eof x (A1[..]) |- ewf (A2[.., x])),
      Dflay : (g |- flay A1 Dskel[] M1),
      Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M2)
    | x : [g |- ewf (epi A1 (\y148. A2))],
      flay :
        [g |-
           flay
             (epi A1 (\y148. A2))
             (kpi Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M2)))],
      skof : [g |- skof (kpi Dskel[] Dskel1[]) B (\x. A')]
    ; split skof as
      case skof/pi:
      { g : ebind,
        A1 : (g |- etp),
        A2 : (g, y162 : eterm |- etp),
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        M1 : (g |- eterm),
        M2 : (g, z317 : eterm |- eterm),
        A3 : (g |- etp),
        A4 : (g, y312 : eterm |- etp),
        A5 : (g |- etp),
        A6 : (g, x312 : eterm |- etp),
        M3 : (g, y313 : eterm, z312 : eterm |- eterm),
        Dwf : (g |- ewf A1),
        Dwf1 : (g, x : eterm, z161 : eof x (A1[..]) |- ewf (A2[.., x])),
        Dflay : (g |- flay A1 Dskel[] M1),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M2),
        Dskof : (g |- skof Dskel[] A3 (\y. A4)),
        Dskof1 : (g |- skof Dskel1[] A5 (\z. A6)),
        Dexpand : (g, y : eterm, x : eterm |- eexpand x (A4[.., y]) M3)
      | x : [g |- ewf (epi A1 (\y148. A2))],
        flay :
          [g |-
             flay
               (epi A1 (\y148. A2))
               (kpi Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M2)))],
        skof :
          [g |-
             skof
               (kpi Dskel[] Dskel1[])
               (esigma A3 (\y. epi A4 (\l. A5[..])))
               (\x.
                  epi (A4[.., epi1 x])
                  (\x1. A6[.., eapp (epi2 x) (M3[.., epi1 x, x1])]))]
      ; split flay-sound [g |- Dwf] [g |- Dflay] [g |- Dskof] as
        case flay-sound/i:
        { g : ebind,
          A1 : (g |- etp),
          A2 : (g, y162 : eterm |- etp),
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          M1 : (g |- eterm),
          M2 : (g, z317 : eterm |- eterm),
          A3 : (g |- etp),
          A4 : (g, y312 : eterm |- etp),
          A5 : (g |- etp),
          A6 : (g, x312 : eterm |- etp),
          M3 : (g, y313 : eterm, z312 : eterm |- eterm),
          Dwf : (g |- ewf A1),
          Dwf1 : (g, x : eterm, z161 : eof x (A1[..]) |- ewf (A2[.., x])),
          Dflay : (g |- flay A1 Dskel[] M1),
          Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M2),
          Dskof : (g |- skof Dskel[] A3 (\y. A4)),
          Dskof1 : (g |- skof Dskel1[] A5 (\z. A6)),
          Dexpand : (g, y : eterm, x : eterm |- eexpand x (A4[.., y]) M3),
          Dof : (g |- eof M1 A3),
          Dtequiv : (g |- tequiv A1 (A4[.., M1]))
        | x : [g |- ewf (epi A1 (\y148. A2))],
          flay :
            [g |-
               flay
                 (epi A1 (\y148. A2))
                 (kpi Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M2)))],
          skof :
            [g |-
               skof
                 (kpi Dskel[] Dskel1[])
                 (esigma A3 (\y. epi A4 (\l. A5[..])))
                 (\x.
                    epi (A4[.., epi1 x])
                    (\x1. A6[.., eapp (epi2 x) (M3[.., epi1 x, x1])]))]
        ; split
          flay-sound
            [g, b : block (x : eterm, dx : eof x (A1[..])) |-
               Dwf1[.., b.1, b.2]]
            [g, b : block (x : eterm, dx : eof x (A1[..])) |-
               Dflay1[.., b.1]]
            [g, b : block (x : eterm, dx : eof x (A1[..])) |- Dskof1[..]] as
          case flay-sound/i:
          { g : ebind,
            A1 : (g |- etp),
            A8 : (g, x : eterm |- etp),
            Dskel : ( |- skel),
            Dskel1 : ( |- skel),
            M1 : (g |- eterm),
            M4 : (g, x : eterm |- eterm),
            A3 : (g |- etp),
            A4 : (g, y312 : eterm |- etp),
            A7 : (g |- etp),
            A9 : (g, x343 : eterm |- etp),
            M3 : (g, y313 : eterm, z312 : eterm |- eterm),
            Dwf : (g |- ewf A1),
            Dwf1 : (g, x : eterm, z161 : eof x (A1[..]) |- ewf (A8[.., x])),
            Dflay : (g |- flay A1 Dskel[] M1),
            Dflay1 : (g, x : eterm |- flay A8 Dskel1[] M4),
            Dskof : (g |- skof Dskel[] A3 (\y. A4)),
            Dskof1 : (g |- skof Dskel1[] A7 (\z. A9)),
            Dexpand : (g, y : eterm, x : eterm |- eexpand x (A4[.., y]) M3),
            Dof : (g |- eof M1 A3),
            Dtequiv : (g |- tequiv A1 (A4[.., M1])),
            Dof1 :
              (g, x : eterm, z8 : eof x (A1[..]) |- eof (M4[.., x]) (A7[..])),
            Dtequiv1 :
              (g, x : eterm, y9 : eof x (A1[..]) |-
                 tequiv (A8[.., x]) (A9[.., (M4[.., x])]))
          | x : [g |- ewf (epi A1 (\y148. A8))],
            flay :
              [g |-
                 flay
                   (epi A1 (\y148. A8))
                   (kpi Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M4)))],
            skof :
              [g |-
                 skof
                   (kpi Dskel[] Dskel1[])
                   (esigma A3 (\y. epi A4 (\l. A7[..])))
                   (\x.
                      epi (A4[.., epi1 x])
                      (\x1. A9[.., eapp (epi2 x) (M3[.., epi1 x, x1])]))]
          ; split skof-reg [g |- Dskof] as
            case skof-reg/i:
            { g : ebind,
              A1 : (g |- etp),
              A8 : (g, x : eterm |- etp),
              Dskel : ( |- skel),
              Dskel1 : ( |- skel),
              M1 : (g |- eterm),
              M4 : (g, x : eterm |- eterm),
              A3 : (g |- etp),
              A4 : (g, y312 : eterm |- etp),
              A7 : (g |- etp),
              A9 : (g, x343 : eterm |- etp),
              M3 : (g, y313 : eterm, z312 : eterm |- eterm),
              Dwf : (g |- ewf A1),
              Dwf1 :
                (g, x : eterm, z161 : eof x (A1[..]) |- ewf (A8[.., x])),
              Dflay : (g |- flay A1 Dskel[] M1),
              Dflay1 : (g, x : eterm |- flay A8 Dskel1[] M4),
              Dskof : (g |- skof Dskel[] A3 (\y. A4)),
              Dskof1 : (g |- skof Dskel1[] A7 (\z. A9)),
              Dexpand : (g, y : eterm, x : eterm |- eexpand x (A4[.., y]) M3),
              Dof : (g |- eof M1 A3),
              Dtequiv : (g |- tequiv A1 (A4[.., M1])),
              Dof1 :
                (g, x : eterm, z8 : eof x (A1[..]) |-
                   eof (M4[.., x]) (A7[..])),
              Dtequiv1 :
                (g, x : eterm, y9 : eof x (A1[..]) |-
                   tequiv (A8[.., x]) (A9[.., (M4[.., x])])),
              Dwf2 : (g |- ewf A3),
              Dwf3 :
                (g, x : eterm, z337 : eof x (A3[..]) |- ewf (A4[.., x]))
            | x : [g |- ewf (epi A1 (\y148. A8))],
              flay :
                [g |-
                   flay
                     (epi A1 (\y148. A8))
                     (kpi Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M4)))],
              skof :
                [g |-
                   skof
                     (kpi Dskel[] Dskel1[])
                     (esigma A3 (\y. epi A4 (\l. A7[..])))
                     (\x.
                        epi (A4[.., epi1 x])
                        (\x1. A9[.., eapp (epi2 x) (M3[.., epi1 x, x1])]))]
            ; split skof-reg [g |- Dskof1] as
              case skof-reg/i:
              { g : ebind,
                A1 : (g |- etp),
                A8 : (g, x : eterm |- etp),
                Dskel : ( |- skel),
                Dskel1 : ( |- skel),
                M1 : (g |- eterm),
                M4 : (g, x : eterm |- eterm),
                A3 : (g |- etp),
                A4 : (g, y312 : eterm |- etp),
                A7 : (g |- etp),
                A9 : (g, x343 : eterm |- etp),
                M3 : (g, y313 : eterm, z312 : eterm |- eterm),
                Dwf : (g |- ewf A1),
                Dwf1 :
                  (g, x : eterm, z161 : eof x (A1[..]) |- ewf (A8[.., x])),
                Dflay : (g |- flay A1 Dskel[] M1),
                Dflay1 : (g, x : eterm |- flay A8 Dskel1[] M4),
                Dskof : (g |- skof Dskel[] A3 (\y. A4)),
                Dskof1 : (g |- skof Dskel1[] A7 (\z. A9)),
                Dexpand :
                  (g, y : eterm, x : eterm |- eexpand x (A4[.., y]) M3),
                Dof : (g |- eof M1 A3),
                Dtequiv : (g |- tequiv A1 (A4[.., M1])),
                Dof1 :
                  (g, x : eterm, z8 : eof x (A1[..]) |-
                     eof (M4[.., x]) (A7[..])),
                Dtequiv1 :
                  (g, x : eterm, y9 : eof x (A1[..]) |-
                     tequiv (A8[.., x]) (A9[.., (M4[.., x])])),
                Dwf2 : (g |- ewf A3),
                Dwf3 :
                  (g, x : eterm, z337 : eof x (A3[..]) |- ewf (A4[.., x])),
                Dwf4 : (g |- ewf A7),
                Dwf5 :
                  (g, x : eterm, z337 : eof x (A7[..]) |- ewf (A9[.., x]))
              | x : [g |- ewf (epi A1 (\y148. A8))],
                flay :
                  [g |-
                     flay
                       (epi A1 (\y148. A8))
                       (kpi Dskel[] Dskel1[]) (epair M1 (elam A1 (\x. M4)))],
                skof :
                  [g |-
                     skof
                       (kpi Dskel[] Dskel1[])
                       (esigma A3 (\y. epi A4 (\l. A7[..])))
                       (\x.
                          epi (A4[.., epi1 x])
                          (\x1. A9[.., eapp (epi2 x) (M3[.., epi1 x, x1])]))]
              ; by tfunctionality [g, y : eterm, dy : eof y (A3[..]) |- Dwf3]
     [g |- equiv/symm (equiv/beta1 Dof (eof/lam Dwf (\x. \dx. Dof1)))]
as DequivA' unboxed;
                by eexpand-equiv
                     [g, b1 : block (y : eterm, dy : eof y (A3[..])),
                      b2 : block (x : eterm, dx : eof x (A4[.., b1.1])) |-
                        b2.2]
                     [g, b1 : block (y : eterm, dy : eof y (A3[..])),
                      b2 : block (x : eterm, dx : eof x (A4[.., b1.1])) |-
                        Dexpand[.., b1.1, b2.1]]
                as DequivX unboxed;
                by [g, b : block (x : eterm, dx : eof x (A1[..])) |-
                      DequivX[..,
                              <epi1 (epair (M1[..])
                                    (elam (A1[..]) (\x. M4[.., x]))); eof/pi1
                              (eof/pair (Dof[..])
                              (eof/lam (Dwf[..]) (\x. \dx. Dof1[.., x, dx]))
                              (\l1.
                                 \l2. ewf/pi (Dwf[..]) (\l3. \l4. Dwf4[..])))>,
                              <b.1; eof/subsume b.2
                              (subtp/reflex (tequiv/trans (Dtequiv[..])
                                            (DequivA'[..])))>]]
                as DequivX' unboxed;
                by tfunctionality
                     [g, b : block (x : eterm, dx : eof x (A1[..])),
                      y : eterm,
                      dy : eof y (A7[..]) |- Dwf5[.., y, dy]]
                     [g, b : block (x : eterm, dx : eof x (A1[..])) |-
                        equiv/symm (equiv/trans (equiv/app (equiv/beta2
                                                           (Dof[..])
                                                           (eof/lam (Dwf[..])
                                                           (\x.
                                                              \dx.
                                                                Dof1[
                                                                .., x, dx])))
                                                (equiv/subsume (equiv/symm
                                                               DequivX')
                                                (subtp/reflex (tequiv/symm
                                                              (tequiv/trans
                                                              (Dtequiv[
                                                              ..])
                                                              (DequivA'[..]))))))
                                   (equiv/beta (\x. \dx. Dof1[.., x, dx])
                                   b.2))]
                as DequivB' unboxed;
                solve
  [g |-
     flay-sound/i (eof/pair Dof
                  (eof/subsume (eof/lam Dwf (\x. \dx. Dof1))
                  (subtp/reflex (tequiv/pi Dtequiv
                                (\l1. \l2. tequiv/reflex (Dwf4[..])))))
                  (\y. \dy. ewf/pi Dwf3 (\l1. \l2. Dwf4[..])))
     (tequiv/pi (tequiv/trans Dtequiv DequivA')
     (\x. \dx. tequiv/trans Dtequiv1 (DequivB'[.., <x; dx>])))]
              }
            }
          }
        }
      }
    }
  }
  case ewf/t:
  { g : ebind,
    K : (g |- skel),
    M : (g |- eterm),
    B : (g |- etp),
    A' : (g, z310 : eterm |- etp)
  | x : [g |- ewf et],
    flay : [g |- flay et K M],
    skof : [g |- skof K B (\x. A')]
  ; split flay as
    case flay/t:
    { g : ebind, B : (g |- etp), A' : (g, z310 : eterm |- etp)
    | x : [g |- ewf et],
      flay : [g |- flay et kt estar],
      skof : [g |- skof kt B (\x. A')]
    ; split skof as
      case skof/t:
      { g : ebind
      | x : [g |- ewf et],
        flay : [g |- flay et kt estar],
        skof : [g |- skof kt eone (\x. et)]
      ; solve [g |- flay-sound/i eof/star (tequiv/reflex ewf/t)]
      }
    }
  }
}
;

LF can-flay/e : etp -> type =
| can-flay/i:
  { K : skel } { M : eterm } flay A K M ->
    can-flay/e A
;

proof can-flay : (g : evar) { A : [g |- etp] } [g |- can-flay/e A] =
/ total 1 /
intros
{ g : evar, A : (g |- etp)
|
; split [_ |- A] as
  case eone:
  { g : evar
  |
  ; solve [g |- can-flay/i _ _ flay/one]
  }
  case esing:
  { g : evar, M : (g |- eterm)
  |
  ; solve [g |- can-flay/i _ _ (flay/sing )]
  }
  case esigma:
  { g : evar, A1 : (g |- etp), A2 : (g, z78 : eterm |- etp)
  |
  ; split can-flay [g |- A1] as
    case can-flay/i:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, z78 : eterm |- etp),
      Dskel : ( |- skel),
      M : (g |- eterm),
      Dflay : (g |- flay A1 Dskel[] M)
    |
    ; split can-flay [g, x : eterm |- A2] as
      case can-flay/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, z78 : eterm |- etp),
        Dskel : ( |- skel),
        M : (g |- eterm),
        Dflay : (g |- flay A1 Dskel[] M),
        Dskel1 : ( |- skel),
        M1 : (g, x : eterm |- eterm),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M1)
      |
      ; solve [g |- can-flay/i _ _ (flay/sigma Dflay (\x. Dflay1))]
      }
    }
  }
  case epi:
  { g : evar, A1 : (g |- etp), A2 : (g, z77 : eterm |- etp)
  |
  ; split can-flay [g |- A1] as
    case can-flay/i:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, z77 : eterm |- etp),
      Dskel : ( |- skel),
      M : (g |- eterm),
      Dflay : (g |- flay A1 Dskel[] M)
    |
    ; split can-flay [g, x : eterm |- A2] as
      case can-flay/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, z77 : eterm |- etp),
        Dskel : ( |- skel),
        M : (g |- eterm),
        Dflay : (g |- flay A1 Dskel[] M),
        Dskel1 : ( |- skel),
        M1 : (g, x : eterm |- eterm),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M1)
      |
      ; solve [g |- can-flay/i _ _ (flay/pi Dflay (\x. Dflay1))]
      }
    }
  }
  case et:
  { g : evar
  |
  ; solve [g |- can-flay/i _ _ flay/t]
  }
}
;

LF flay-fun/e : skel -> skel -> eterm -> eterm -> type =
| flay-fun/i :
  skel-eq K1 K2 ->
  eterm-eq M1 M2 ->
    flay-fun/e K1 K2 M1 M2
;

proof flay-fun :
  (g : evar)
  [g |- flay A K1[] M1] ->
  [g |- flay A K2[] M2] ->
    [g |- flay-fun/e K1[] K2[] M1 M2] =
/ total 1 /
intros
{ g : evar,
  A : (g |- etp),
  K : ( |- skel),
  M : (g |- eterm),
  K1 : ( |- skel),
  M1 : (g |- eterm)
| x : [g |- flay A K[] M], flay : [g |- flay A K1[] M1]
; split x as
  case flay/one:
  { g : evar, K1 : ( |- skel), M1 : (g |- eterm)
  | x : [g |- flay eone kone estar], flay : [g |- flay eone K1[] M1]
  ; split flay as
    case flay/one:
    { g : evar
    | x : [g |- flay eone kone estar], flay : [g |- flay eone kone estar]
    ; solve [_ |- flay-fun/i (skel-eq/i ) (eterm-eq/i )]
    }
  }
  case flay/sing:
  { g : evar, M : (g |- eterm), K1 : ( |- skel), M1 : (g |- eterm)
  | x : [g |- flay (esing M) ksing M], flay : [g |- flay (esing M) K1[] M1]
  ; split flay as
    case flay/sing:
    { g : evar, M1 : (g |- eterm)
    | x : [g |- flay (esing M1) ksing M1],
      flay : [g |- flay (esing M1) ksing M1]
    ; solve [g |- flay-fun/i (skel-eq/i ) (eterm-eq/i )]
    }
  }
  case flay/sigma:
  { g : evar,
    A1 : (g |- etp),
    A2 : (g, z177 : eterm |- etp),
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    M2 : (g |- eterm),
    M3 : (g, y178 : eterm |- eterm),
    K1 : ( |- skel),
    M1 : (g |- eterm),
    Dflay : (g |- flay A1 Dskel[] M2),
    Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3)
  | x :
      [g |-
         flay
           (esigma A1 (\z78. A2))
           (ksigma Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
    flay : [g |- flay (esigma A1 (\z78. A2)) K1[] M1]
  ; split flay as
    case flay/sigma:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, z177 : eterm |- etp),
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      M2 : (g |- eterm),
      M3 : (g, y178 : eterm |- eterm),
      Dskel2 : ( |- skel),
      Dskel3 : ( |- skel),
      M4 : (g |- eterm),
      M5 : (g, z230 : eterm |- eterm),
      Dflay : (g |- flay A1 Dskel[] M2),
      Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
      Dflay2 : (g |- flay A1 Dskel2[] M4),
      Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5)
    | x :
        [g |-
           flay
             (esigma A1 (\x128. A2))
             (ksigma Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
      flay :
        [g |-
           flay
             (esigma A1 (\x128. A2))
             (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
    ; split flay-fun [g |- Dflay] [g |- Dflay2] as
      case flay-fun/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, z177 : eterm |- etp),
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        M2 : (g |- eterm),
        M3 : (g, y178 : eterm |- eterm),
        Dskel2 : ( |- skel),
        Dskel3 : ( |- skel),
        M4 : (g |- eterm),
        M5 : (g, z230 : eterm |- eterm),
        Dflay : (g |- flay A1 Dskel[] M2),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
        Dflay2 : (g |- flay A1 Dskel2[] M4),
        Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
        Deq : ( |- skel-eq Dskel Dskel2),
        Deq1 : (g |- eterm-eq M2 M4)
      | x :
          [g |-
             flay
               (esigma A1 (\x128. A2))
               (ksigma Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
        flay :
          [g |-
             flay
               (esigma A1 (\x128. A2))
               (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
      ; split flay-fun [g, x : eterm |- Dflay1] [g, x : eterm |- Dflay3] as
        case flay-fun/i:
        { g : evar,
          A1 : (g |- etp),
          A2 : (g, z177 : eterm |- etp),
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          M2 : (g |- eterm),
          M3 : (g, y178 : eterm |- eterm),
          Dskel2 : ( |- skel),
          Dskel3 : ( |- skel),
          M4 : (g |- eterm),
          M5 : (g, z230 : eterm |- eterm),
          Dflay : (g |- flay A1 Dskel[] M2),
          Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
          Dflay2 : (g |- flay A1 Dskel2[] M4),
          Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
          Deq : ( |- skel-eq Dskel Dskel2),
          Deq1 : (g |- eterm-eq M2 M4),
          Deq2 : ( |- skel-eq Dskel1 Dskel3),
          Deq3 : (g, x : eterm |- eterm-eq M3 M5)
        | x :
            [g |-
               flay
                 (esigma A1 (\x128. A2))
                 (ksigma Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
          flay :
            [g |-
               flay
                 (esigma A1 (\x128. A2))
                 (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
        ; split
skel-resp-skel2 [k1 : skel, k2 : skel |- ksigma k1 k2] [ |- Deq] [ |- Deq2] as
          case skel-eq/i:
          { g : evar,
            A1 : (g |- etp),
            A2 : (g, z177 : eterm |- etp),
            Dskel2 : ( |- skel),
            Dskel3 : ( |- skel),
            M2 : (g |- eterm),
            M3 : (g, y178 : eterm |- eterm),
            M4 : (g |- eterm),
            M5 : (g, z230 : eterm |- eterm),
            Dflay : (g |- flay A1 Dskel2[] M2),
            Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M3),
            Dflay2 : (g |- flay A1 Dskel2[] M4),
            Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
            Deq : ( |- skel-eq Dskel2 Dskel2),
            Deq1 : (g |- eterm-eq M2 M4),
            Deq2 : ( |- skel-eq Dskel3 Dskel3),
            Deq3 : (g, x : eterm |- eterm-eq M3 M5)
          | x :
              [g |-
                 flay
                   (esigma A1 (\x128. A2))
                   (ksigma Dskel2[] Dskel3[]) (epair M2 (elam A1 (\x. M3)))],
            flay :
              [g |-
                 flay
                   (esigma A1 (\x128. A2))
                   (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
          ; split [g |- Deq1] as
            case eterm-eq/i:
            { g : evar,
              A1 : (g |- etp),
              A2 : (g, z177 : eterm |- etp),
              Dskel2 : ( |- skel),
              Dskel3 : ( |- skel),
              M4 : (g |- eterm),
              M3 : (g, y178 : eterm |- eterm),
              M5 : (g, z230 : eterm |- eterm),
              Dflay : (g |- flay A1 Dskel2[] M4),
              Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M3),
              Dflay2 : (g |- flay A1 Dskel2[] M4),
              Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
              Deq : ( |- skel-eq Dskel2 Dskel2),
              Deq2 : ( |- skel-eq Dskel3 Dskel3),
              Deq3 : (g, x : eterm |- eterm-eq M3 M5)
            | x :
                [g |-
                   flay
                     (esigma A1 (\x128. A2))
                     (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M3)))],
              flay :
                [g |-
                   flay
                     (esigma A1 (\x128. A2))
                     (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
            ; split [g, x : eterm |- Deq3] as
              case eterm-eq/i:
              { g : evar,
                A1 : (g |- etp),
                A2 : (g, z177 : eterm |- etp),
                Dskel2 : ( |- skel),
                Dskel3 : ( |- skel),
                M4 : (g |- eterm),
                M5 : (g, z230 : eterm |- eterm),
                Dflay : (g |- flay A1 Dskel2[] M4),
                Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M5),
                Dflay2 : (g |- flay A1 Dskel2[] M4),
                Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
                Deq : ( |- skel-eq Dskel2 Dskel2),
                Deq2 : ( |- skel-eq Dskel3 Dskel3)
              | x :
                  [g |-
                     flay
                       (esigma A1 (\x128. A2))
                       (ksigma Dskel2[] Dskel3[])
                       (epair M4 (elam A1 (\x. M5)))],
                flay :
                  [g |-
                     flay
                       (esigma A1 (\x128. A2))
                       (ksigma Dskel2[] Dskel3[])
                       (epair M4 (elam A1 (\x. M5)))]
              ; solve [g |- flay-fun/i (skel-eq/i ) (eterm-eq/i )]
              }
            }
          }
        }
      }
    }
  }
  case flay/pi:
  { g : evar,
    A1 : (g |- etp),
    A2 : (g, x176 : eterm |- etp),
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    M2 : (g |- eterm),
    M3 : (g, z176 : eterm |- eterm),
    K1 : ( |- skel),
    M1 : (g |- eterm),
    Dflay : (g |- flay A1 Dskel[] M2),
    Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3)
  | x :
      [g |-
         flay
           (epi A1 (\z77. A2))
           (kpi Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
    flay : [g |- flay (epi A1 (\z77. A2)) K1[] M1]
  ; split flay as
    case flay/pi:
    { g : evar,
      A1 : (g |- etp),
      A2 : (g, x176 : eterm |- etp),
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      M2 : (g |- eterm),
      M3 : (g, z176 : eterm |- eterm),
      Dskel2 : ( |- skel),
      Dskel3 : ( |- skel),
      M4 : (g |- eterm),
      M5 : (g, z230 : eterm |- eterm),
      Dflay : (g |- flay A1 Dskel[] M2),
      Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
      Dflay2 : (g |- flay A1 Dskel2[] M4),
      Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5)
    | x :
        [g |-
           flay
             (epi A1 (\x127. A2))
             (kpi Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
      flay :
        [g |-
           flay
             (epi A1 (\x127. A2))
             (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
    ; split flay-fun [g |- Dflay] [g |- Dflay2] as
      case flay-fun/i:
      { g : evar,
        A1 : (g |- etp),
        A2 : (g, x176 : eterm |- etp),
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        M2 : (g |- eterm),
        M3 : (g, z176 : eterm |- eterm),
        Dskel2 : ( |- skel),
        Dskel3 : ( |- skel),
        M4 : (g |- eterm),
        M5 : (g, z230 : eterm |- eterm),
        Dflay : (g |- flay A1 Dskel[] M2),
        Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
        Dflay2 : (g |- flay A1 Dskel2[] M4),
        Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
        Deq : ( |- skel-eq Dskel Dskel2),
        Deq1 : (g |- eterm-eq M2 M4)
      | x :
          [g |-
             flay
               (epi A1 (\x127. A2))
               (kpi Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
        flay :
          [g |-
             flay
               (epi A1 (\x127. A2))
               (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
      ; split flay-fun [g, x : eterm |- Dflay1] [g, x : eterm |- Dflay3] as
        case flay-fun/i:
        { g : evar,
          A1 : (g |- etp),
          A2 : (g, x176 : eterm |- etp),
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          M2 : (g |- eterm),
          M3 : (g, z176 : eterm |- eterm),
          Dskel2 : ( |- skel),
          Dskel3 : ( |- skel),
          M4 : (g |- eterm),
          M5 : (g, z230 : eterm |- eterm),
          Dflay : (g |- flay A1 Dskel[] M2),
          Dflay1 : (g, x : eterm |- flay A2 Dskel1[] M3),
          Dflay2 : (g |- flay A1 Dskel2[] M4),
          Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
          Deq : ( |- skel-eq Dskel Dskel2),
          Deq1 : (g |- eterm-eq M2 M4),
          Deq2 : ( |- skel-eq Dskel1 Dskel3),
          Deq3 : (g, x : eterm |- eterm-eq M3 M5)
        | x :
            [g |-
               flay
                 (epi A1 (\x127. A2))
                 (kpi Dskel[] Dskel1[]) (epair M2 (elam A1 (\x. M3)))],
          flay :
            [g |-
               flay
                 (epi A1 (\x127. A2))
                 (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
        ; split
          skel-resp-skel2 [k1 : skel, k2 : skel |- kpi k1 k2] [ |- Deq]
            [ |- Deq2] as
          case skel-eq/i:
          { g : evar,
            A1 : (g |- etp),
            A2 : (g, x176 : eterm |- etp),
            Dskel2 : ( |- skel),
            Dskel3 : ( |- skel),
            M2 : (g |- eterm),
            M3 : (g, z176 : eterm |- eterm),
            M4 : (g |- eterm),
            M5 : (g, z230 : eterm |- eterm),
            Dflay : (g |- flay A1 Dskel2[] M2),
            Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M3),
            Dflay2 : (g |- flay A1 Dskel2[] M4),
            Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
            Deq : ( |- skel-eq Dskel2 Dskel2),
            Deq1 : (g |- eterm-eq M2 M4),
            Deq2 : ( |- skel-eq Dskel3 Dskel3),
            Deq3 : (g, x : eterm |- eterm-eq M3 M5)
          | x :
              [g |-
                 flay
                   (epi A1 (\x127. A2))
                   (kpi Dskel2[] Dskel3[]) (epair M2 (elam A1 (\x. M3)))],
            flay :
              [g |-
                 flay
                   (epi A1 (\x127. A2))
                   (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
          ; split [g |- Deq1] as
            case eterm-eq/i:
            { g : evar,
              A1 : (g |- etp),
              A2 : (g, x176 : eterm |- etp),
              Dskel2 : ( |- skel),
              Dskel3 : ( |- skel),
              M4 : (g |- eterm),
              M3 : (g, z176 : eterm |- eterm),
              M5 : (g, z230 : eterm |- eterm),
              Dflay : (g |- flay A1 Dskel2[] M4),
              Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M3),
              Dflay2 : (g |- flay A1 Dskel2[] M4),
              Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
              Deq : ( |- skel-eq Dskel2 Dskel2),
              Deq2 : ( |- skel-eq Dskel3 Dskel3),
              Deq3 : (g, x : eterm |- eterm-eq M3 M5)
            | x :
                [g |-
                   flay
                     (epi A1 (\x127. A2))
                     (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M3)))],
              flay :
                [g |-
                   flay
                     (epi A1 (\x127. A2))
                     (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
            ; split [g, x : eterm |- Deq3] as
              case eterm-eq/i:
              { g : evar,
                A1 : (g |- etp),
                A2 : (g, x176 : eterm |- etp),
                Dskel2 : ( |- skel),
                Dskel3 : ( |- skel),
                M4 : (g |- eterm),
                M5 : (g, z230 : eterm |- eterm),
                Dflay : (g |- flay A1 Dskel2[] M4),
                Dflay1 : (g, x : eterm |- flay A2 Dskel3[] M5),
                Dflay2 : (g |- flay A1 Dskel2[] M4),
                Dflay3 : (g, x : eterm |- flay A2 Dskel3[] M5),
                Deq : ( |- skel-eq Dskel2 Dskel2),
                Deq2 : ( |- skel-eq Dskel3 Dskel3)
              | x :
                  [g |-
                     flay
                       (epi A1 (\x127. A2))
                       (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))],
                flay :
                  [g |-
                     flay
                       (epi A1 (\x127. A2))
                       (kpi Dskel2[] Dskel3[]) (epair M4 (elam A1 (\x. M5)))]
              ; solve [g |- flay-fun/i (skel-eq/i ) (eterm-eq/i )]
              }
            }
          }
        }
      }
    }
  }
  case flay/t:
  { g : evar, K1 : ( |- skel), M1 : (g |- eterm)
  | x : [g |- flay et kt estar], flay : [g |- flay et K1[] M1]
  ; split flay as
    case flay/t:
    { g : evar
    | x : [g |- flay et kt estar], flay : [g |- flay et kt estar]
    ; solve [g |- flay-fun/i (skel-eq/i ) (eterm-eq/i )]
    }
  }
}
;

proof flay-equiv1 :
  (g : ebind)
  [g |- tequiv A1 A2] ->
  [g |- flay A1 K1[] M1] ->
  [g |- flay A2 K2[] M2] ->
    [ |- skel-eq K1 K2] =
/ total 1 /
intros
{ g : ebind,
  A : (g |- etp),
  A1 : (g |- etp),
  K : ( |- skel),
  M : (g |- eterm),
  K1 : ( |- skel),
  M1 : (g |- eterm)
| x : [g |- tequiv A A1],
  flay : [g |- flay A K[] M],
  flay1 : [g |- flay A1 K1[] M1]
; split x as
  case tequiv/trans:
  { g : ebind,
    A : (g |- etp),
    A1 : (g |- etp),
    K : ( |- skel),
    M : (g |- eterm),
    K1 : ( |- skel),
    M1 : (g |- eterm),
    A3 : (g |- etp),
    Dtequiv : (g |- tequiv A A3),
    Dtequiv1 : (g |- tequiv A3 A1)
  | x : [g |- tequiv A A1],
    flay : [g |- flay A K[] M],
    flay1 : [g |- flay A1 K1[] M1]
  ; by flay as D1 unboxed;
    by flay1 as D3 unboxed;
    split can-flay [_ |- A3] as
    case can-flay/i:
    { g : ebind,
      A : (g |- etp),
      A1 : (g |- etp),
      K : ( |- skel),
      M : (g |- eterm),
      K1 : ( |- skel),
      M1 : (g |- eterm),
      A3 : (g |- etp),
      D12 : (g |- tequiv A A3),
      D23 : (g |- tequiv A3 A1),
      D1 : (g |- flay A K[] M),
      D3 : (g |- flay A1 K1[] M1),
      Dskel : ( |- skel),
      M2 : (g |- eterm),
      Dflay : (g |- flay A3 Dskel[] M2)
    | x : [g |- tequiv A A1],
      flay : [g |- flay A K[] M],
      flay1 : [g |- flay A1 K1[] M1]
    ; split flay-equiv1 [_ |- D12] [_ |- D1] [_ |- Dflay] as
      case skel-eq/i:
      { g : ebind,
        A : (g |- etp),
        A1 : (g |- etp),
        Dskel : ( |- skel),
        M : (g |- eterm),
        K1 : ( |- skel),
        M1 : (g |- eterm),
        A3 : (g |- etp),
        D12 : (g |- tequiv A A3),
        D23 : (g |- tequiv A3 A1),
        D1 : (g |- flay A Dskel[] M),
        D3 : (g |- flay A1 K1[] M1),
        M2 : (g |- eterm),
        D2 : (g |- flay A3 Dskel[] M2)
      | x : [g |- tequiv A A1],
        flay : [g |- flay A Dskel[] M],
        flay1 : [g |- flay A1 K1[] M1]
      ; split flay-equiv1 [_ |- D23] [_ |- D2] [_ |- D3] as
        case skel-eq/i:
        { g : ebind,
          A : (g |- etp),
          A1 : (g |- etp),
          K1 : ( |- skel),
          M : (g |- eterm),
          M1 : (g |- eterm),
          A3 : (g |- etp),
          D12 : (g |- tequiv A A3),
          D23 : (g |- tequiv A3 A1),
          D1 : (g |- flay A K1[] M),
          D3 : (g |- flay A1 K1[] M1),
          M2 : (g |- eterm),
          D2 : (g |- flay A3 K1[] M2)
        | x : [g |- tequiv A A1],
          flay : [g |- flay A K1[] M],
          flay1 : [g |- flay A1 K1[] M1]
        ; solve [ |- skel-eq/i ]
        }
      }
    }
  }
  case tequiv/symm:
  { g : ebind,
    A : (g |- etp),
    A1 : (g |- etp),
    K : ( |- skel),
    M : (g |- eterm),
    K1 : ( |- skel),
    M1 : (g |- eterm),
    Dtequiv : (g |- tequiv A1 A)
  | x : [g |- tequiv A A1],
    flay : [g |- flay A K[] M],
    flay1 : [g |- flay A1 K1[] M1]
  ; by flay as D1 unboxed;
    by flay1 as D2 unboxed;
    split flay-equiv1 [_ |- Dtequiv] [_ |- D2] [_ |- D1] as
    case skel-eq/i:
    { g : ebind,
      A : (g |- etp),
      A1 : (g |- etp),
      K : ( |- skel),
      M : (g |- eterm),
      M1 : (g |- eterm),
      D : (g |- tequiv A1 A),
      D1 : (g |- flay A K[] M),
      D2 : (g |- flay A1 K[] M1)
    | x : [g |- tequiv A A1],
      flay : [g |- flay A K[] M],
      flay1 : [g |- flay A1 K[] M1]
    ; solve [ |- skel-eq/i ]
    }
  }
  case tequiv/reflex:
  { g : ebind,
    A1 : (g |- etp),
    K : ( |- skel),
    M : (g |- eterm),
    K1 : ( |- skel),
    M1 : (g |- eterm),
    Dwf : (g |- ewf A1)
  | x : [g |- tequiv A1 A1],
    flay : [g |- flay A1 K[] M],
    flay1 : [g |- flay A1 K1[] M1]
  ; split flay-fun flay flay1 as
    case flay-fun/i:
    { g : ebind,
      A1 : (g |- etp),
      K : ( |- skel),
      M : (g |- eterm),
      K1 : ( |- skel),
      M1 : (g |- eterm),
      Dwf : (g |- ewf A1),
      Deq : ( |- skel-eq K K1),
      Deq1 : (g |- eterm-eq M M1)
    | x : [g |- tequiv A1 A1],
      flay : [g |- flay A1 K[] M],
      flay1 : [g |- flay A1 K1[] M1]
    ; solve [ |- Deq]
    }
  }
  case tequiv/sing:
  { g : ebind,
    M2 : (g |- eterm),
    M3 : (g |- eterm),
    K : ( |- skel),
    M : (g |- eterm),
    K1 : ( |- skel),
    M1 : (g |- eterm),
    Dequiv : (g |- equiv M2 M3 et)
  | x : [g |- tequiv (esing M2) (esing M3)],
    flay : [g |- flay (esing M2) K[] M],
    flay1 : [g |- flay (esing M3) K1[] M1]
  ; split flay as
    case flay/sing:
    { g : ebind,
      M : (g |- eterm),
      M3 : (g |- eterm),
      K1 : ( |- skel),
      M1 : (g |- eterm),
      Dequiv : (g |- equiv M M3 et)
    | x : [g |- tequiv (esing M) (esing M3)],
      flay : [g |- flay (esing M) ksing M],
      flay1 : [g |- flay (esing M3) K1[] M1]
    ; split flay1 as
      case flay/sing:
      { g : ebind,
        M : (g |- eterm),
        M1 : (g |- eterm),
        Dequiv : (g |- equiv M M1 et)
      | x : [g |- tequiv (esing M) (esing M1)],
        flay : [g |- flay (esing M) ksing M],
        flay1 : [g |- flay (esing M1) ksing M1]
      ; solve [ |- skel-eq/i ]
      }
    }
  }
  case tequiv/sigma:
  { g : ebind,
    A2 : (g |- etp),
    A4 : (g, y196 : eterm |- etp),
    A3 : (g |- etp),
    A5 : (g, x196 : eterm |- etp),
    K : ( |- skel),
    M : (g |- eterm),
    K1 : ( |- skel),
    M1 : (g |- eterm),
    Dtequiv : (g |- tequiv A2 A3),
    Dtequiv1 :
      (g, x : eterm, z195 : eof x (A2[..]) |- tequiv (A4[.., x]) (A5[.., x]))
  | x : [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
    flay : [g |- flay (esigma A2 (\y149. A4)) K[] M],
    flay1 : [g |- flay (esigma A3 (\y149. A5)) K1[] M1]
  ; split flay as
    case flay/sigma:
    { g : ebind,
      A2 : (g |- etp),
      A4 : (g, y196 : eterm |- etp),
      A3 : (g |- etp),
      A5 : (g, x196 : eterm |- etp),
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      M2 : (g |- eterm),
      M3 : (g, y319 : eterm |- eterm),
      K1 : ( |- skel),
      M1 : (g |- eterm),
      Dtequiv : (g |- tequiv A2 A3),
      Dtequiv1 :
        (g, x : eterm, z195 : eof x (A2[..]) |-
           tequiv (A4[.., x]) (A5[.., x])),
      Dflay : (g |- flay A2 Dskel[] M2),
      Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3)
    | x : [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
      flay :
        [g |-
           flay
             (esigma A2 (\y149. A4))
             (ksigma Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
      flay1 : [g |- flay (esigma A3 (\y149. A5)) K1[] M1]
    ; split flay1 as
      case flay/sigma:
      { g : ebind,
        A2 : (g |- etp),
        A4 : (g, y196 : eterm |- etp),
        A3 : (g |- etp),
        A5 : (g, x196 : eterm |- etp),
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        M2 : (g |- eterm),
        M3 : (g, y319 : eterm |- eterm),
        Dskel2 : ( |- skel),
        Dskel3 : ( |- skel),
        M4 : (g |- eterm),
        M5 : (g, y319 : eterm |- eterm),
        Dtequiv : (g |- tequiv A2 A3),
        Dtequiv1 :
          (g, x : eterm, z195 : eof x (A2[..]) |-
             tequiv (A4[.., x]) (A5[.., x])),
        Dflay : (g |- flay A2 Dskel[] M2),
        Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
        Dflay2 : (g |- flay A3 Dskel2[] M4),
        Dflay3 : (g, x : eterm |- flay A5 Dskel3[] M5)
      | x : [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
        flay :
          [g |-
             flay
               (esigma A2 (\y149. A4))
               (ksigma Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
        flay1 :
          [g |-
             flay
               (esigma A3 (\y149. A5))
               (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A3 (\x. M5)))]
      ; split flay-equiv1 [_ |- Dtequiv] [_ |- Dflay] [_ |- Dflay2] as
        case skel-eq/i:
        { g : ebind,
          A2 : (g |- etp),
          A4 : (g, y196 : eterm |- etp),
          A3 : (g |- etp),
          A5 : (g, x196 : eterm |- etp),
          Dskel2 : ( |- skel),
          Dskel1 : ( |- skel),
          M2 : (g |- eterm),
          M3 : (g, y319 : eterm |- eterm),
          Dskel3 : ( |- skel),
          M4 : (g |- eterm),
          M5 : (g, y319 : eterm |- eterm),
          Dtequiv : (g |- tequiv A2 A3),
          Dtequiv1 :
            (g, x : eterm, z195 : eof x (A2[..]) |-
               tequiv (A4[.., x]) (A5[.., x])),
          Dflay : (g |- flay A2 Dskel2[] M2),
          Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
          Dflay2 : (g |- flay A3 Dskel2[] M4),
          Dflay3 : (g, x : eterm |- flay A5 Dskel3[] M5)
        | x : [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
          flay :
            [g |-
               flay
                 (esigma A2 (\y149. A4))
                 (ksigma Dskel2[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
          flay1 :
            [g |-
               flay
                 (esigma A3 (\y149. A5))
                 (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A3 (\x. M5)))]
        ; split
          flay-equiv1
            [_, b : block (x : eterm, dx : eof x (A2[..])) |-
               Dtequiv1[.., b.1, b.2]]
            [_, b : block (x : eterm, dx : eof x (A2[..])) |-
               Dflay1[.., b.1]]
            [_, b : block (x : eterm, dx : eof x (A2[..])) |-
               Dflay3[.., b.1]] as
          case skel-eq/i:
          { g : ebind,
            A2 : (g |- etp),
            A4 : (g, y196 : eterm |- etp),
            A3 : (g |- etp),
            A5 : (g, x196 : eterm |- etp),
            Dskel2 : ( |- skel),
            Dskel3 : ( |- skel),
            M2 : (g |- eterm),
            M3 : (g, y319 : eterm |- eterm),
            M4 : (g |- eterm),
            M5 : (g, y319 : eterm |- eterm),
            Dtequiv : (g |- tequiv A2 A3),
            Dtequiv1 :
              (g, x : eterm, z195 : eof x (A2[..]) |-
                 tequiv (A4[.., x]) (A5[.., x])),
            Dflay : (g |- flay A2 Dskel2[] M2),
            Dflay1 : (g, x : eterm |- flay A4 Dskel3[] M3),
            Dflay2 : (g |- flay A3 Dskel2[] M4),
            Dflay3 : (g, x : eterm |- flay A5 Dskel3[] M5)
          | x : [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
            flay :
              [g |-
                 flay
                   (esigma A2 (\y149. A4))
                   (ksigma Dskel2[] Dskel3[]) (epair M2 (elam A2 (\x. M3)))],
            flay1 :
              [g |-
                 flay
                   (esigma A3 (\y149. A5))
                   (ksigma Dskel2[] Dskel3[]) (epair M4 (elam A3 (\x. M5)))]
          ; solve [ |- skel-eq/i ]
          }
        }
      }
    }
  }
  case tequiv/pi:
  { g : ebind,
    A2 : (g |- etp),
    A4 : (g, x194 : eterm |- etp),
    A3 : (g |- etp),
    A5 : (g, z194 : eterm |- etp),
    K : ( |- skel),
    M : (g |- eterm),
    K1 : ( |- skel),
    M1 : (g |- eterm),
    Dtequiv : (g |- tequiv A2 A3),
    Dtequiv1 :
      (g, x : eterm, y194 : eof x (A2[..]) |- tequiv (A4[.., x]) (A5[.., x]))
  | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
    flay : [g |- flay (epi A2 (\y148. A4)) K[] M],
    flay1 : [g |- flay (epi A3 (\y148. A5)) K1[] M1]
  ; split flay as
    case flay/pi:
    { g : ebind,
      A2 : (g |- etp),
      A4 : (g, x194 : eterm |- etp),
      A3 : (g |- etp),
      A5 : (g, z194 : eterm |- etp),
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      M2 : (g |- eterm),
      M3 : (g, z317 : eterm |- eterm),
      K1 : ( |- skel),
      M1 : (g |- eterm),
      Dtequiv : (g |- tequiv A2 A3),
      Dtequiv1 :
        (g, x : eterm, y194 : eof x (A2[..]) |-
           tequiv (A4[.., x]) (A5[.., x])),
      Dflay : (g |- flay A2 Dskel[] M2),
      Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3)
    | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
      flay :
        [g |-
           flay
             (epi A2 (\y148. A4))
             (kpi Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
      flay1 : [g |- flay (epi A3 (\y148. A5)) K1[] M1]
    ; split flay1 as
      case flay/pi:
      { g : ebind,
        A2 : (g |- etp),
        A4 : (g, x194 : eterm |- etp),
        A3 : (g |- etp),
        A5 : (g, z194 : eterm |- etp),
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        M2 : (g |- eterm),
        M3 : (g, z317 : eterm |- eterm),
        Dskel2 : ( |- skel),
        Dskel3 : ( |- skel),
        M4 : (g |- eterm),
        M5 : (g, z317 : eterm |- eterm),
        Dtequiv : (g |- tequiv A2 A3),
        Dtequiv1 :
          (g, x : eterm, y194 : eof x (A2[..]) |-
             tequiv (A4[.., x]) (A5[.., x])),
        Dflay : (g |- flay A2 Dskel[] M2),
        Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
        Dflay2 : (g |- flay A3 Dskel2[] M4),
        Dflay3 : (g, x : eterm |- flay A5 Dskel3[] M5)
      | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
        flay :
          [g |-
             flay
               (epi A2 (\y148. A4))
               (kpi Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
        flay1 :
          [g |-
             flay
               (epi A3 (\y148. A5))
               (kpi Dskel2[] Dskel3[]) (epair M4 (elam A3 (\x. M5)))]
      ; split flay-equiv1 [_ |- Dtequiv] [_ |- Dflay] [_ |- Dflay2] as
        case skel-eq/i:
        { g : ebind,
          A2 : (g |- etp),
          A4 : (g, x194 : eterm |- etp),
          A3 : (g |- etp),
          A5 : (g, z194 : eterm |- etp),
          Dskel2 : ( |- skel),
          Dskel1 : ( |- skel),
          M2 : (g |- eterm),
          M3 : (g, z317 : eterm |- eterm),
          Dskel3 : ( |- skel),
          M4 : (g |- eterm),
          M5 : (g, z317 : eterm |- eterm),
          Dtequiv : (g |- tequiv A2 A3),
          Dtequiv1 :
            (g, x : eterm, y194 : eof x (A2[..]) |-
               tequiv (A4[.., x]) (A5[.., x])),
          Dflay : (g |- flay A2 Dskel2[] M2),
          Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
          Dflay2 : (g |- flay A3 Dskel2[] M4),
          Dflay3 : (g, x : eterm |- flay A5 Dskel3[] M5)
        | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
          flay :
            [g |-
               flay
                 (epi A2 (\y148. A4))
                 (kpi Dskel2[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
          flay1 :
            [g |-
               flay
                 (epi A3 (\y148. A5))
                 (kpi Dskel2[] Dskel3[]) (epair M4 (elam A3 (\x. M5)))]
        ; split
          flay-equiv1
            [_, b : block (x : eterm, dx : eof x (A2[..])) |-
               Dtequiv1[.., b.1, b.2]]
            [_, b : block (x : eterm, dx : eof x (A2[..])) |-
               Dflay1[.., b.1]]
            [_, b : block (x : eterm, dx : eof x (A2[..])) |-
               Dflay3[.., b.1]] as
          case skel-eq/i:
          { g : ebind,
            A2 : (g |- etp),
            A4 : (g, x194 : eterm |- etp),
            A3 : (g |- etp),
            A5 : (g, z194 : eterm |- etp),
            Dskel2 : ( |- skel),
            Dskel3 : ( |- skel),
            M2 : (g |- eterm),
            M3 : (g, z317 : eterm |- eterm),
            M4 : (g |- eterm),
            M5 : (g, z317 : eterm |- eterm),
            Dtequiv : (g |- tequiv A2 A3),
            Dtequiv1 :
              (g, x : eterm, y194 : eof x (A2[..]) |-
                 tequiv (A4[.., x]) (A5[.., x])),
            Dflay : (g |- flay A2 Dskel2[] M2),
            Dflay1 : (g, x : eterm |- flay A4 Dskel3[] M3),
            Dflay2 : (g |- flay A3 Dskel2[] M4),
            Dflay3 : (g, x : eterm |- flay A5 Dskel3[] M5)
          | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
            flay :
              [g |-
                 flay
                   (epi A2 (\y148. A4))
                   (kpi Dskel2[] Dskel3[]) (epair M2 (elam A2 (\x. M3)))],
            flay1 :
              [g |-
                 flay
                   (epi A3 (\y148. A5))
                   (kpi Dskel2[] Dskel3[]) (epair M4 (elam A3 (\x. M5)))]
          ; solve [ |- skel-eq/i ]
          }
        }
      }
    }
  }
}
;

proof flay-equiv2 :
  (g : ebind)
  [g |- tequiv A1 A2] ->
  [g |- flay A1 K[] M1] ->
  [g |- flay A2 K[] M2] ->
  [g |- skof K[] C (\x. C')] ->
    [g |- equiv M1 M2 C] =
/ total 1 /
intros
{ g : ebind,
  A : (g |- etp),
  A1 : (g |- etp),
  K : ( |- skel),
  M : (g |- eterm),
  M1 : (g |- eterm),
  C : (g |- etp),
  C' : (g, z310 : eterm |- etp)
| x : [g |- tequiv A A1],
  flay : [g |- flay A K[] M],
  flay1 : [g |- flay A1 K[] M1],
  skof : [g |- skof K[] C (\x. C')]
; split x as
  case tequiv/trans:
  { g : ebind,
    A : (g |- etp),
    A1 : (g |- etp),
    K : ( |- skel),
    M : (g |- eterm),
    M1 : (g |- eterm),
    C : (g |- etp),
    C' : (g, z310 : eterm |- etp),
    A3 : (g |- etp),
    Dtequiv : (g |- tequiv A A3),
    Dtequiv1 : (g |- tequiv A3 A1)
  | x : [g |- tequiv A A1],
    flay : [g |- flay A K[] M],
    flay1 : [g |- flay A1 K[] M1],
    skof : [g |- skof K[] C (\x. C')]
  ; split can-flay [_ |- A3] as
    case can-flay/i:
    { g : ebind,
      A : (g |- etp),
      A1 : (g |- etp),
      K : ( |- skel),
      M : (g |- eterm),
      M1 : (g |- eterm),
      C : (g |- etp),
      C' : (g, z310 : eterm |- etp),
      A3 : (g |- etp),
      Dtequiv : (g |- tequiv A A3),
      Dtequiv1 : (g |- tequiv A3 A1),
      Dskel : ( |- skel),
      M2 : (g |- eterm),
      Dflay : (g |- flay A3 Dskel[] M2)
    | x : [g |- tequiv A A1],
      flay : [g |- flay A K[] M],
      flay1 : [g |- flay A1 K[] M1],
      skof : [g |- skof K[] C (\x. C')]
    ; split flay-equiv1 [_ |- tequiv/symm Dtequiv] [_ |- Dflay] flay as
      case skel-eq/i:
      { g : ebind,
        A : (g |- etp),
        A1 : (g |- etp),
        K : ( |- skel),
        M : (g |- eterm),
        M1 : (g |- eterm),
        C : (g |- etp),
        C' : (g, z310 : eterm |- etp),
        A3 : (g |- etp),
        Dtequiv : (g |- tequiv A A3),
        Dtequiv1 : (g |- tequiv A3 A1),
        M2 : (g |- eterm),
        Dflay : (g |- flay A3 K[] M2)
      | x : [g |- tequiv A A1],
        flay : [g |- flay A K[] M],
        flay1 : [g |- flay A1 K[] M1],
        skof : [g |- skof K[] C (\x. C')]
      ; by flay-equiv2 [_ |- Dtequiv] flay [_ |- Dflay] skof
        as Dequiv12 unboxed;
        by flay-equiv2 [_ |- Dtequiv1] [_ |- Dflay] flay1 skof
        as Dequiv23 unboxed;
        solve [_ |- equiv/trans Dequiv12 Dequiv23]
      }
    }
  }
  case tequiv/symm:
  { g : ebind,
    A : (g |- etp),
    A1 : (g |- etp),
    K : ( |- skel),
    M : (g |- eterm),
    M1 : (g |- eterm),
    C : (g |- etp),
    C' : (g, z310 : eterm |- etp),
    Dtequiv : (g |- tequiv A1 A)
  | x : [g |- tequiv A A1],
    flay : [g |- flay A K[] M],
    flay1 : [g |- flay A1 K[] M1],
    skof : [g |- skof K[] C (\x. C')]
  ; by flay-equiv2 [_ |- Dtequiv] flay1 flay skof as Dequiv unboxed;
    solve [_ |- equiv/symm Dequiv]
  }
  case tequiv/reflex:
  { g : ebind,
    A1 : (g |- etp),
    K : ( |- skel),
    M : (g |- eterm),
    M1 : (g |- eterm),
    C : (g |- etp),
    C' : (g, z310 : eterm |- etp),
    Dwf : (g |- ewf A1)
  | x : [g |- tequiv A1 A1],
    flay : [g |- flay A1 K[] M],
    flay1 : [g |- flay A1 K[] M1],
    skof : [g |- skof K[] C (\x. C')]
  ; split flay-fun flay flay1 as
    case flay-fun/i:
    { g : ebind,
      A1 : (g |- etp),
      K : ( |- skel),
      M : (g |- eterm),
      M1 : (g |- eterm),
      C : (g |- etp),
      C' : (g, z310 : eterm |- etp),
      Dwf : (g |- ewf A1),
      Deq : ( |- skel-eq K K),
      Deq1 : (g |- eterm-eq M M1)
    | x : [g |- tequiv A1 A1],
      flay : [g |- flay A1 K[] M],
      flay1 : [g |- flay A1 K[] M1],
      skof : [g |- skof K[] C (\x. C')]
    ; split [_ |- Deq1] as
      case eterm-eq/i:
      { g : ebind,
        A1 : (g |- etp),
        K : ( |- skel),
        M1 : (g |- eterm),
        C : (g |- etp),
        C' : (g, z310 : eterm |- etp),
        Dwf : (g |- ewf A1),
        Deq : ( |- skel-eq K K)
      | x : [g |- tequiv A1 A1],
        flay : [g |- flay A1 K[] M1],
        flay1 : [g |- flay A1 K[] M1],
        skof : [g |- skof K[] C (\x. C')]
      ; split flay-sound [_ |- Dwf] flay skof as
        case flay-sound/i:
        { g : ebind,
          A1 : (g |- etp),
          K : ( |- skel),
          M1 : (g |- eterm),
          C : (g |- etp),
          C' : (g, z310 : eterm |- etp),
          Dwf : (g |- ewf A1),
          Deq : ( |- skel-eq K K),
          Dof : (g |- eof M1 C),
          Dtequiv : (g |- tequiv A1 (C'[.., M1]))
        | x : [g |- tequiv A1 A1],
          flay : [g |- flay A1 K[] M1],
          flay1 : [g |- flay A1 K[] M1],
          skof : [g |- skof K[] C (\x. C')]
        ; solve [_ |- equiv/reflex Dof]
        }
      }
    }
  }
  case tequiv/sing:
  { g : ebind,
    M2 : (g |- eterm),
    M3 : (g |- eterm),
    K : ( |- skel),
    M : (g |- eterm),
    M1 : (g |- eterm),
    C : (g |- etp),
    C' : (g, z310 : eterm |- etp),
    Dequiv : (g |- equiv M2 M3 et)
  | x : [g |- tequiv (esing M2) (esing M3)],
    flay : [g |- flay (esing M2) K[] M],
    flay1 : [g |- flay (esing M3) K[] M1],
    skof : [g |- skof K[] C (\x. C')]
  ; split flay as
    case flay/sing:
    { g : ebind,
      M : (g |- eterm),
      M3 : (g |- eterm),
      M1 : (g |- eterm),
      C : (g |- etp),
      C' : (g, z310 : eterm |- etp),
      Dequiv : (g |- equiv M M3 et)
    | x : [g |- tequiv (esing M) (esing M3)],
      flay : [g |- flay (esing M) ksing M],
      flay1 : [g |- flay (esing M3) ksing M1],
      skof : [g |- skof ksing C (\x. C')]
    ; split flay1 as
      case flay/sing:
      { g : ebind,
        M : (g |- eterm),
        M1 : (g |- eterm),
        C : (g |- etp),
        C' : (g, z310 : eterm |- etp),
        Dequiv : (g |- equiv M M1 et)
      | x : [g |- tequiv (esing M) (esing M1)],
        flay : [g |- flay (esing M) ksing M],
        flay1 : [g |- flay (esing M1) ksing M1],
        skof : [g |- skof ksing C (\x. C')]
      ; split skof as
        case skof/sing:
        { g : ebind,
          M : (g |- eterm),
          M1 : (g |- eterm),
          Dequiv : (g |- equiv M M1 et)
        | x : [g |- tequiv (esing M) (esing M1)],
          flay : [g |- flay (esing M) ksing M],
          flay1 : [g |- flay (esing M1) ksing M1],
          skof : [g |- skof ksing et (\x. esing x)]
        ; solve [_ |- Dequiv]
        }
      }
    }
  }
  case tequiv/sigma:
  { g : ebind,
    A2 : (g |- etp),
    A4 : (g, y196 : eterm |- etp),
    A3 : (g |- etp),
    A5 : (g, x196 : eterm |- etp),
    K : ( |- skel),
    M : (g |- eterm),
    M1 : (g |- eterm),
    C : (g |- etp),
    C' : (g, z310 : eterm |- etp),
    Dtequiv : (g |- tequiv A2 A3),
    Dtequiv1 :
      (g, x : eterm, z195 : eof x (A2[..]) |- tequiv (A4[.., x]) (A5[.., x]))
  | x : [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
    flay : [g |- flay (esigma A2 (\y149. A4)) K[] M],
    flay1 : [g |- flay (esigma A3 (\y149. A5)) K[] M1],
    skof : [g |- skof K[] C (\x. C')]
  ; split flay as
    case flay/sigma:
    { g : ebind,
      A2 : (g |- etp),
      A4 : (g, y196 : eterm |- etp),
      A3 : (g |- etp),
      A5 : (g, x196 : eterm |- etp),
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      M2 : (g |- eterm),
      M3 : (g, y319 : eterm |- eterm),
      M1 : (g |- eterm),
      C : (g |- etp),
      C' : (g, z310 : eterm |- etp),
      Dtequiv : (g |- tequiv A2 A3),
      Dtequiv1 :
        (g, x : eterm, z195 : eof x (A2[..]) |-
           tequiv (A4[.., x]) (A5[.., x])),
      Dflay : (g |- flay A2 Dskel[] M2),
      Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3)
    | x : [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
      flay :
        [g |-
           flay
             (esigma A2 (\y149. A4))
             (ksigma Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
      flay1 :
        [g |- flay (esigma A3 (\y149. A5)) (ksigma Dskel[] Dskel1[]) M1],
      skof : [g |- skof (ksigma Dskel[] Dskel1[]) C (\x. C')]
    ; split flay1 as
      case flay/sigma:
      { g : ebind,
        A2 : (g |- etp),
        A4 : (g, y196 : eterm |- etp),
        A3 : (g |- etp),
        A5 : (g, x196 : eterm |- etp),
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        M2 : (g |- eterm),
        M3 : (g, y319 : eterm |- eterm),
        M4 : (g |- eterm),
        M5 : (g, y319 : eterm |- eterm),
        C : (g |- etp),
        C' : (g, z310 : eterm |- etp),
        Dtequiv : (g |- tequiv A2 A3),
        Dtequiv1 :
          (g, x : eterm, z195 : eof x (A2[..]) |-
             tequiv (A4[.., x]) (A5[.., x])),
        Dflay : (g |- flay A2 Dskel[] M2),
        Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
        Dflay2 : (g |- flay A3 Dskel[] M4),
        Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5)
      | x : [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
        flay :
          [g |-
             flay
               (esigma A2 (\y149. A4))
               (ksigma Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
        flay1 :
          [g |-
             flay
               (esigma A3 (\y149. A5))
               (ksigma Dskel[] Dskel1[]) (epair M4 (elam A3 (\x. M5)))],
        skof : [g |- skof (ksigma Dskel[] Dskel1[]) C (\x. C')]
      ; split skof as
        case skof/sigma:
        { g : ebind,
          A2 : (g |- etp),
          A4 : (g, y196 : eterm |- etp),
          A3 : (g |- etp),
          A5 : (g, x196 : eterm |- etp),
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          M2 : (g |- eterm),
          M3 : (g, y319 : eterm |- eterm),
          M4 : (g |- eterm),
          M5 : (g, y319 : eterm |- eterm),
          A6 : (g |- etp),
          A7 : (g, x314 : eterm |- etp),
          A8 : (g |- etp),
          A9 : (g, z314 : eterm |- etp),
          M6 : (g, x315 : eterm, y315 : eterm |- eterm),
          Dtequiv : (g |- tequiv A2 A3),
          Dtequiv1 :
            (g, x : eterm, z195 : eof x (A2[..]) |-
               tequiv (A4[.., x]) (A5[.., x])),
          Dflay : (g |- flay A2 Dskel[] M2),
          Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
          Dflay2 : (g |- flay A3 Dskel[] M4),
          Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5),
          Dskof : (g |- skof Dskel[] A6 (\y. A7)),
          Dskof1 : (g |- skof Dskel1[] A8 (\z. A9)),
          Dexpand : (g, y : eterm, x : eterm |- eexpand x (A7[.., y]) M6)
        | x : [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
          flay :
            [g |-
               flay
                 (esigma A2 (\y149. A4))
                 (ksigma Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
          flay1 :
            [g |-
               flay
                 (esigma A3 (\y149. A5))
                 (ksigma Dskel[] Dskel1[]) (epair M4 (elam A3 (\x. M5)))],
          skof :
            [g |-
               skof
                 (ksigma Dskel[] Dskel1[])
                 (esigma A6 (\y. epi A7 (\l. A8[..])))
                 (\x.
                    esigma (A7[.., epi1 x])
                    (\x1. A9[.., eapp (epi2 x) (M6[.., epi1 x, x1])]))]
        ; by flay-equiv2 [_ |- Dtequiv] [_ |- Dflay] [_ |- Dflay2]
               [_ |- Dskof]
          as DequivM unboxed;
          by flay-equiv2
               [_, b : block (x : eterm, dx : eof x (A2[..])) |-
                  Dtequiv1[.., b.1, b.2]]
               [_, b : block (x : eterm, dx : eof x (A2[..])) |-
                  Dflay1[.., b.1]]
               [_, b : block (x : eterm, dx : eof x (A2[..])) |-
                  Dflay3[.., b.1]]
               [_, b : block (x : eterm, dx : eof x (A2[..])) |- Dskof1[..]]
          as DequivN unboxed;
          split tequiv-reg [_ |- Dtequiv] as
          case tequiv-reg/i:
          { g : ebind,
            A2 : (g |- etp),
            A4 : (g, y196 : eterm |- etp),
            A3 : (g |- etp),
            A5 : (g, x196 : eterm |- etp),
            Dskel : ( |- skel),
            Dskel1 : ( |- skel),
            M2 : (g |- eterm),
            M3 : (g, y319 : eterm |- eterm),
            M4 : (g |- eterm),
            M5 : (g, y319 : eterm |- eterm),
            A6 : (g |- etp),
            A7 : (g, x314 : eterm |- etp),
            A8 : (g |- etp),
            A9 : (g, z314 : eterm |- etp),
            M6 : (g, x315 : eterm, y315 : eterm |- eterm),
            Dtequiv : (g |- tequiv A2 A3),
            Dtequiv1 :
              (g, x : eterm, z195 : eof x (A2[..]) |-
                 tequiv (A4[.., x]) (A5[.., x])),
            Dflay : (g |- flay A2 Dskel[] M2),
            Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
            Dflay2 : (g |- flay A3 Dskel[] M4),
            Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5),
            Dskof : (g |- skof Dskel[] A6 (\y. A7)),
            Dskof1 : (g |- skof Dskel1[] A8 (\z. A9)),
            Dexpand : (g, y : eterm, x : eterm |- eexpand x (A7[.., y]) M6),
            DequivM : (g |- equiv M2 M4 A6),
            DequivN :
              (g, b : block (x : eterm, dx : eof x (A2[..])) |-
                 equiv (M3[.., b.1]) (M5[.., b.1]) (A8[..])),
            Dwf : (g |- ewf A2),
            Dwf1 : (g |- ewf A3)
          | x : [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
            flay :
              [g |-
                 flay
                   (esigma A2 (\y149. A4))
                   (ksigma Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
            flay1 :
              [g |-
                 flay
                   (esigma A3 (\y149. A5))
                   (ksigma Dskel[] Dskel1[]) (epair M4 (elam A3 (\x. M5)))],
            skof :
              [g |-
                 skof
                   (ksigma Dskel[] Dskel1[])
                   (esigma A6 (\y. epi A7 (\l. A8[..])))
                   (\x.
                      esigma (A7[.., epi1 x])
                      (\x1. A9[.., eapp (epi2 x) (M6[.., epi1 x, x1])]))]
          ; split flay-sound [_ |- Dwf] [_ |- Dflay] [_ |- Dskof] as
            case flay-sound/i:
            { g : ebind,
              A2 : (g |- etp),
              A4 : (g, y196 : eterm |- etp),
              A3 : (g |- etp),
              A5 : (g, x196 : eterm |- etp),
              Dskel : ( |- skel),
              Dskel1 : ( |- skel),
              M2 : (g |- eterm),
              M3 : (g, y319 : eterm |- eterm),
              M4 : (g |- eterm),
              M5 : (g, y319 : eterm |- eterm),
              A6 : (g |- etp),
              A7 : (g, x314 : eterm |- etp),
              A8 : (g |- etp),
              A9 : (g, z314 : eterm |- etp),
              M6 : (g, x315 : eterm, y315 : eterm |- eterm),
              Dtequiv : (g |- tequiv A2 A3),
              Dtequiv1 :
                (g, x : eterm, z195 : eof x (A2[..]) |-
                   tequiv (A4[.., x]) (A5[.., x])),
              Dflay : (g |- flay A2 Dskel[] M2),
              Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
              Dflay2 : (g |- flay A3 Dskel[] M4),
              Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5),
              Dskof : (g |- skof Dskel[] A6 (\y. A7)),
              Dskof1 : (g |- skof Dskel1[] A8 (\z. A9)),
              Dexpand : (g, y : eterm, x : eterm |- eexpand x (A7[.., y]) M6),
              DequivM : (g |- equiv M2 M4 A6),
              DequivN :
                (g, b : block (x : eterm, dx : eof x (A2[..])) |-
                   equiv (M3[.., b.1]) (M5[.., b.1]) (A8[..])),
              Dwf : (g |- ewf A2),
              Dwf1 : (g |- ewf A3),
              Dof : (g |- eof M2 A6),
              Dtequiv2 : (g |- tequiv A2 (A7[.., M2]))
            | x :
                [g |- tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
              flay :
                [g |-
                   flay
                     (esigma A2 (\y149. A4))
                     (ksigma Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
              flay1 :
                [g |-
                   flay
                     (esigma A3 (\y149. A5))
                     (ksigma Dskel[] Dskel1[]) (epair M4 (elam A3 (\x. M5)))],
              skof :
                [g |-
                   skof
                     (ksigma Dskel[] Dskel1[])
                     (esigma A6 (\y. epi A7 (\l. A8[..])))
                     (\x.
                        esigma (A7[.., epi1 x])
                        (\x1. A9[.., eapp (epi2 x) (M6[.., epi1 x, x1])]))]
            ; split skof-reg [_ |- Dskof] as
              case skof-reg/i:
              { g : ebind,
                A2 : (g |- etp),
                A4 : (g, y196 : eterm |- etp),
                A3 : (g |- etp),
                A5 : (g, x196 : eterm |- etp),
                Dskel : ( |- skel),
                Dskel1 : ( |- skel),
                M2 : (g |- eterm),
                M3 : (g, y319 : eterm |- eterm),
                M4 : (g |- eterm),
                M5 : (g, y319 : eterm |- eterm),
                A6 : (g |- etp),
                A7 : (g, x314 : eterm |- etp),
                A8 : (g |- etp),
                A9 : (g, z314 : eterm |- etp),
                M6 : (g, x315 : eterm, y315 : eterm |- eterm),
                Dtequiv : (g |- tequiv A2 A3),
                Dtequiv1 :
                  (g, x : eterm, z195 : eof x (A2[..]) |-
                     tequiv (A4[.., x]) (A5[.., x])),
                Dflay : (g |- flay A2 Dskel[] M2),
                Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
                Dflay2 : (g |- flay A3 Dskel[] M4),
                Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5),
                Dskof : (g |- skof Dskel[] A6 (\y. A7)),
                Dskof1 : (g |- skof Dskel1[] A8 (\z. A9)),
                Dexpand :
                  (g, y : eterm, x : eterm |- eexpand x (A7[.., y]) M6),
                DequivM : (g |- equiv M2 M4 A6),
                DequivN :
                  (g, b : block (x : eterm, dx : eof x (A2[..])) |-
                     equiv (M3[.., b.1]) (M5[.., b.1]) (A8[..])),
                Dwf : (g |- ewf A2),
                Dwf1 : (g |- ewf A3),
                Dof : (g |- eof M2 A6),
                Dtequiv2 : (g |- tequiv A2 (A7[.., M2])),
                Dwf2 : (g |- ewf A6),
                Dwf3 :
                  (g, x : eterm, z337 : eof x (A6[..]) |- ewf (A7[.., x]))
              | x :
                  [g |-
                     tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
                flay :
                  [g |-
                     flay
                       (esigma A2 (\y149. A4))
                       (ksigma Dskel[] Dskel1[])
                       (epair M2 (elam A2 (\x. M3)))],
                flay1 :
                  [g |-
                     flay
                       (esigma A3 (\y149. A5))
                       (ksigma Dskel[] Dskel1[])
                       (epair M4 (elam A3 (\x. M5)))],
                skof :
                  [g |-
                     skof
                       (ksigma Dskel[] Dskel1[])
                       (esigma A6 (\y. epi A7 (\l. A8[..])))
                       (\x.
                          esigma (A7[.., epi1 x])
                          (\x1. A9[.., eapp (epi2 x) (M6[.., epi1 x, x1])]))]
              ; split skof-reg [_ |- Dskof1] as
                case skof-reg/i:
                { g : ebind,
                  A2 : (g |- etp),
                  A4 : (g, y196 : eterm |- etp),
                  A3 : (g |- etp),
                  A5 : (g, x196 : eterm |- etp),
                  Dskel : ( |- skel),
                  Dskel1 : ( |- skel),
                  M2 : (g |- eterm),
                  M3 : (g, y319 : eterm |- eterm),
                  M4 : (g |- eterm),
                  M5 : (g, y319 : eterm |- eterm),
                  A6 : (g |- etp),
                  A7 : (g, x314 : eterm |- etp),
                  A8 : (g |- etp),
                  A9 : (g, z314 : eterm |- etp),
                  M6 : (g, x315 : eterm, y315 : eterm |- eterm),
                  Dtequiv : (g |- tequiv A2 A3),
                  Dtequiv1 :
                    (g, x : eterm, z195 : eof x (A2[..]) |-
                       tequiv (A4[.., x]) (A5[.., x])),
                  Dflay : (g |- flay A2 Dskel[] M2),
                  Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
                  Dflay2 : (g |- flay A3 Dskel[] M4),
                  Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5),
                  Dskof : (g |- skof Dskel[] A6 (\y. A7)),
                  Dskof1 : (g |- skof Dskel1[] A8 (\z. A9)),
                  Dexpand :
                    (g, y : eterm, x : eterm |- eexpand x (A7[.., y]) M6),
                  DequivM : (g |- equiv M2 M4 A6),
                  DequivN :
                    (g, b : block (x : eterm, dx : eof x (A2[..])) |-
                       equiv (M3[.., b.1]) (M5[.., b.1]) (A8[..])),
                  Dwf : (g |- ewf A2),
                  Dwf1 : (g |- ewf A3),
                  Dof : (g |- eof M2 A6),
                  Dtequiv2 : (g |- tequiv A2 (A7[.., M2])),
                  Dwf2 : (g |- ewf A6),
                  Dwf3 :
                    (g, x : eterm, z337 : eof x (A6[..]) |- ewf (A7[.., x])),
                  Dwf4 : (g |- ewf A8),
                  Dwf5 :
                    (g, x : eterm, z337 : eof x (A8[..]) |- ewf (A9[.., x]))
                | x :
                    [g |-
                       tequiv (esigma A2 (\y149. A4)) (esigma A3 (\y149. A5))],
                  flay :
                    [g |-
                       flay
                         (esigma A2 (\y149. A4))
                         (ksigma Dskel[] Dskel1[])
                         (epair M2 (elam A2 (\x. M3)))],
                  flay1 :
                    [g |-
                       flay
                         (esigma A3 (\y149. A5))
                         (ksigma Dskel[] Dskel1[])
                         (epair M4 (elam A3 (\x. M5)))],
                  skof :
                    [g |-
                       skof
                         (ksigma Dskel[] Dskel1[])
                         (esigma A6 (\y. epi A7 (\l. A8[..])))
                         (\x.
                            esigma (A7[.., epi1 x])
                            (\x1. A9[.., eapp (epi2 x) (M6[.., epi1 x, x1])]))]
                ; solve
  [g |-
     equiv/pair DequivM
     (equiv/subsume (equiv/lam Dtequiv (\x. \dx. DequivN[.., <x; dx>]))
     (subtp/reflex (tequiv/pi Dtequiv2 (\x. \dx. tequiv/reflex (Dwf4[..])))))
     (\x. \dx. ewf/pi Dwf3 (\x1. \dx1. Dwf4[..]))]
                }
              }
            }
          }
        }
      }
    }
  }
  case tequiv/pi:
  { g : ebind,
    A2 : (g |- etp),
    A4 : (g, x194 : eterm |- etp),
    A3 : (g |- etp),
    A5 : (g, z194 : eterm |- etp),
    K : ( |- skel),
    M : (g |- eterm),
    M1 : (g |- eterm),
    C : (g |- etp),
    C' : (g, z310 : eterm |- etp),
    Dtequiv : (g |- tequiv A2 A3),
    Dtequiv1 :
      (g, x : eterm, y194 : eof x (A2[..]) |- tequiv (A4[.., x]) (A5[.., x]))
  | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
    flay : [g |- flay (epi A2 (\y148. A4)) K[] M],
    flay1 : [g |- flay (epi A3 (\y148. A5)) K[] M1],
    skof : [g |- skof K[] C (\x. C')]
  ; split flay as
    case flay/pi:
    { g : ebind,
      A2 : (g |- etp),
      A4 : (g, x194 : eterm |- etp),
      A3 : (g |- etp),
      A5 : (g, z194 : eterm |- etp),
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      M2 : (g |- eterm),
      M3 : (g, z317 : eterm |- eterm),
      M1 : (g |- eterm),
      C : (g |- etp),
      C' : (g, z310 : eterm |- etp),
      Dtequiv : (g |- tequiv A2 A3),
      Dtequiv1 :
        (g, x : eterm, y194 : eof x (A2[..]) |-
           tequiv (A4[.., x]) (A5[.., x])),
      Dflay : (g |- flay A2 Dskel[] M2),
      Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3)
    | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
      flay :
        [g |-
           flay
             (epi A2 (\y148. A4))
             (kpi Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
      flay1 : [g |- flay (epi A3 (\y148. A5)) (kpi Dskel[] Dskel1[]) M1],
      skof : [g |- skof (kpi Dskel[] Dskel1[]) C (\x. C')]
    ; split flay1 as
      case flay/pi:
      { g : ebind,
        A2 : (g |- etp),
        A4 : (g, x194 : eterm |- etp),
        A3 : (g |- etp),
        A5 : (g, z194 : eterm |- etp),
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        M2 : (g |- eterm),
        M3 : (g, z317 : eterm |- eterm),
        M4 : (g |- eterm),
        M5 : (g, z317 : eterm |- eterm),
        C : (g |- etp),
        C' : (g, z310 : eterm |- etp),
        Dtequiv : (g |- tequiv A2 A3),
        Dtequiv1 :
          (g, x : eterm, y194 : eof x (A2[..]) |-
             tequiv (A4[.., x]) (A5[.., x])),
        Dflay : (g |- flay A2 Dskel[] M2),
        Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
        Dflay2 : (g |- flay A3 Dskel[] M4),
        Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5)
      | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
        flay :
          [g |-
             flay
               (epi A2 (\y148. A4))
               (kpi Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
        flay1 :
          [g |-
             flay
               (epi A3 (\y148. A5))
               (kpi Dskel[] Dskel1[]) (epair M4 (elam A3 (\x. M5)))],
        skof : [g |- skof (kpi Dskel[] Dskel1[]) C (\x. C')]
      ; split skof as
        case skof/pi:
        { g : ebind,
          A2 : (g |- etp),
          A4 : (g, x194 : eterm |- etp),
          A3 : (g |- etp),
          A5 : (g, z194 : eterm |- etp),
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          M2 : (g |- eterm),
          M3 : (g, z317 : eterm |- eterm),
          M4 : (g |- eterm),
          M5 : (g, z317 : eterm |- eterm),
          A6 : (g |- etp),
          A7 : (g, y312 : eterm |- etp),
          A8 : (g |- etp),
          A9 : (g, x312 : eterm |- etp),
          M6 : (g, y313 : eterm, z312 : eterm |- eterm),
          Dtequiv : (g |- tequiv A2 A3),
          Dtequiv1 :
            (g, x : eterm, y194 : eof x (A2[..]) |-
               tequiv (A4[.., x]) (A5[.., x])),
          Dflay : (g |- flay A2 Dskel[] M2),
          Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
          Dflay2 : (g |- flay A3 Dskel[] M4),
          Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5),
          Dskof : (g |- skof Dskel[] A6 (\y. A7)),
          Dskof1 : (g |- skof Dskel1[] A8 (\z. A9)),
          Dexpand : (g, y : eterm, x : eterm |- eexpand x (A7[.., y]) M6)
        | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
          flay :
            [g |-
               flay
                 (epi A2 (\y148. A4))
                 (kpi Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
          flay1 :
            [g |-
               flay
                 (epi A3 (\y148. A5))
                 (kpi Dskel[] Dskel1[]) (epair M4 (elam A3 (\x. M5)))],
          skof :
            [g |-
               skof
                 (kpi Dskel[] Dskel1[])
                 (esigma A6 (\y. epi A7 (\l. A8[..])))
                 (\x.
                    epi (A7[.., epi1 x])
                    (\x1. A9[.., eapp (epi2 x) (M6[.., epi1 x, x1])]))]
        ; by flay-equiv2 [g |- Dtequiv] [g |- Dflay] [g |- Dflay2] [g |- Dskof]
as DequivM unboxed;
          by flay-equiv2
               [g, b : block (x : eterm, dx : eof x (A2[..])) |-
                  Dtequiv1[.., b.1, b.2]]
               [g, b : block (x : eterm, dx : eof x (A2[..])) |-
                  Dflay1[.., b.1]]
               [g, b : block (x : eterm, dx : eof x (A2[..])) |-
                  Dflay3[.., b.1]]
               [g, b : block (x : eterm, dx : eof x (A2[..])) |- Dskof1[..]]
          as DequivN unboxed;
          split tequiv-reg [g |- Dtequiv] as
          case tequiv-reg/i:
          { g : ebind,
            A2 : (g |- etp),
            A4 : (g, x194 : eterm |- etp),
            A3 : (g |- etp),
            A5 : (g, z194 : eterm |- etp),
            Dskel : ( |- skel),
            Dskel1 : ( |- skel),
            M2 : (g |- eterm),
            M3 : (g, z317 : eterm |- eterm),
            M4 : (g |- eterm),
            M5 : (g, z317 : eterm |- eterm),
            A6 : (g |- etp),
            A7 : (g, y312 : eterm |- etp),
            A8 : (g |- etp),
            A9 : (g, x312 : eterm |- etp),
            M6 : (g, y313 : eterm, z312 : eterm |- eterm),
            Dtequiv : (g |- tequiv A2 A3),
            Dtequiv1 :
              (g, x : eterm, y194 : eof x (A2[..]) |-
                 tequiv (A4[.., x]) (A5[.., x])),
            Dflay : (g |- flay A2 Dskel[] M2),
            Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
            Dflay2 : (g |- flay A3 Dskel[] M4),
            Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5),
            Dskof : (g |- skof Dskel[] A6 (\y. A7)),
            Dskof1 : (g |- skof Dskel1[] A8 (\z. A9)),
            Dexpand : (g, y : eterm, x : eterm |- eexpand x (A7[.., y]) M6),
            DequivM : (g |- equiv M2 M4 A6),
            DequivN :
              (g, b : block (x : eterm, dx : eof x (A2[..])) |-
                 equiv (M3[.., b.1]) (M5[.., b.1]) (A8[..])),
            Dwf : (g |- ewf A2),
            Dwf1 : (g |- ewf A3)
          | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
            flay :
              [g |-
                 flay
                   (epi A2 (\y148. A4))
                   (kpi Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
            flay1 :
              [g |-
                 flay
                   (epi A3 (\y148. A5))
                   (kpi Dskel[] Dskel1[]) (epair M4 (elam A3 (\x. M5)))],
            skof :
              [g |-
                 skof
                   (kpi Dskel[] Dskel1[])
                   (esigma A6 (\y. epi A7 (\l. A8[..])))
                   (\x.
                      epi (A7[.., epi1 x])
                      (\x1. A9[.., eapp (epi2 x) (M6[.., epi1 x, x1])]))]
          ; split flay-sound [g |- Dwf] [g |- Dflay] [g |- Dskof] as
            case flay-sound/i:
            { g : ebind,
              A2 : (g |- etp),
              A4 : (g, x194 : eterm |- etp),
              A3 : (g |- etp),
              A5 : (g, z194 : eterm |- etp),
              Dskel : ( |- skel),
              Dskel1 : ( |- skel),
              M2 : (g |- eterm),
              M3 : (g, z317 : eterm |- eterm),
              M4 : (g |- eterm),
              M5 : (g, z317 : eterm |- eterm),
              A6 : (g |- etp),
              A7 : (g, y312 : eterm |- etp),
              A8 : (g |- etp),
              A9 : (g, x312 : eterm |- etp),
              M6 : (g, y313 : eterm, z312 : eterm |- eterm),
              Dtequiv : (g |- tequiv A2 A3),
              Dtequiv1 :
                (g, x : eterm, y194 : eof x (A2[..]) |-
                   tequiv (A4[.., x]) (A5[.., x])),
              Dflay : (g |- flay A2 Dskel[] M2),
              Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
              Dflay2 : (g |- flay A3 Dskel[] M4),
              Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5),
              Dskof : (g |- skof Dskel[] A6 (\y. A7)),
              Dskof1 : (g |- skof Dskel1[] A8 (\z. A9)),
              Dexpand : (g, y : eterm, x : eterm |- eexpand x (A7[.., y]) M6),
              DequivM : (g |- equiv M2 M4 A6),
              DequivN :
                (g, b : block (x : eterm, dx : eof x (A2[..])) |-
                   equiv (M3[.., b.1]) (M5[.., b.1]) (A8[..])),
              Dwf : (g |- ewf A2),
              Dwf1 : (g |- ewf A3),
              Dof : (g |- eof M2 A6),
              Dtequiv2 : (g |- tequiv A2 (A7[.., M2]))
            | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
              flay :
                [g |-
                   flay
                     (epi A2 (\y148. A4))
                     (kpi Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
              flay1 :
                [g |-
                   flay
                     (epi A3 (\y148. A5))
                     (kpi Dskel[] Dskel1[]) (epair M4 (elam A3 (\x. M5)))],
              skof :
                [g |-
                   skof
                     (kpi Dskel[] Dskel1[])
                     (esigma A6 (\y. epi A7 (\l. A8[..])))
                     (\x.
                        epi (A7[.., epi1 x])
                        (\x1. A9[.., eapp (epi2 x) (M6[.., epi1 x, x1])]))]
            ; split skof-reg [g |- Dskof] as
              case skof-reg/i:
              { g : ebind,
                A2 : (g |- etp),
                A4 : (g, x194 : eterm |- etp),
                A3 : (g |- etp),
                A5 : (g, z194 : eterm |- etp),
                Dskel : ( |- skel),
                Dskel1 : ( |- skel),
                M2 : (g |- eterm),
                M3 : (g, z317 : eterm |- eterm),
                M4 : (g |- eterm),
                M5 : (g, z317 : eterm |- eterm),
                A6 : (g |- etp),
                A7 : (g, y312 : eterm |- etp),
                A8 : (g |- etp),
                A9 : (g, x312 : eterm |- etp),
                M6 : (g, y313 : eterm, z312 : eterm |- eterm),
                Dtequiv : (g |- tequiv A2 A3),
                Dtequiv1 :
                  (g, x : eterm, y194 : eof x (A2[..]) |-
                     tequiv (A4[.., x]) (A5[.., x])),
                Dflay : (g |- flay A2 Dskel[] M2),
                Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
                Dflay2 : (g |- flay A3 Dskel[] M4),
                Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5),
                Dskof : (g |- skof Dskel[] A6 (\y. A7)),
                Dskof1 : (g |- skof Dskel1[] A8 (\z. A9)),
                Dexpand :
                  (g, y : eterm, x : eterm |- eexpand x (A7[.., y]) M6),
                DequivM : (g |- equiv M2 M4 A6),
                DequivN :
                  (g, b : block (x : eterm, dx : eof x (A2[..])) |-
                     equiv (M3[.., b.1]) (M5[.., b.1]) (A8[..])),
                Dwf : (g |- ewf A2),
                Dwf1 : (g |- ewf A3),
                Dof : (g |- eof M2 A6),
                Dtequiv2 : (g |- tequiv A2 (A7[.., M2])),
                Dwf2 : (g |- ewf A6),
                Dwf3 :
                  (g, x : eterm, z337 : eof x (A6[..]) |- ewf (A7[.., x]))
              | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
                flay :
                  [g |-
                     flay
                       (epi A2 (\y148. A4))
                       (kpi Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
                flay1 :
                  [g |-
                     flay
                       (epi A3 (\y148. A5))
                       (kpi Dskel[] Dskel1[]) (epair M4 (elam A3 (\x. M5)))],
                skof :
                  [g |-
                     skof
                       (kpi Dskel[] Dskel1[])
                       (esigma A6 (\y. epi A7 (\l. A8[..])))
                       (\x.
                          epi (A7[.., epi1 x])
                          (\x1. A9[.., eapp (epi2 x) (M6[.., epi1 x, x1])]))]
              ; split skof-reg [g |- Dskof1] as
                case skof-reg/i:
                { g : ebind,
                  A2 : (g |- etp),
                  A4 : (g, x194 : eterm |- etp),
                  A3 : (g |- etp),
                  A5 : (g, z194 : eterm |- etp),
                  Dskel : ( |- skel),
                  Dskel1 : ( |- skel),
                  M2 : (g |- eterm),
                  M3 : (g, z317 : eterm |- eterm),
                  M4 : (g |- eterm),
                  M5 : (g, z317 : eterm |- eterm),
                  A6 : (g |- etp),
                  A7 : (g, y312 : eterm |- etp),
                  A8 : (g |- etp),
                  A9 : (g, x312 : eterm |- etp),
                  M6 : (g, y313 : eterm, z312 : eterm |- eterm),
                  Dtequiv : (g |- tequiv A2 A3),
                  Dtequiv1 :
                    (g, x : eterm, y194 : eof x (A2[..]) |-
                       tequiv (A4[.., x]) (A5[.., x])),
                  Dflay : (g |- flay A2 Dskel[] M2),
                  Dflay1 : (g, x : eterm |- flay A4 Dskel1[] M3),
                  Dflay2 : (g |- flay A3 Dskel[] M4),
                  Dflay3 : (g, x : eterm |- flay A5 Dskel1[] M5),
                  Dskof : (g |- skof Dskel[] A6 (\y. A7)),
                  Dskof1 : (g |- skof Dskel1[] A8 (\z. A9)),
                  Dexpand :
                    (g, y : eterm, x : eterm |- eexpand x (A7[.., y]) M6),
                  DequivM : (g |- equiv M2 M4 A6),
                  DequivN :
                    (g, b : block (x : eterm, dx : eof x (A2[..])) |-
                       equiv (M3[.., b.1]) (M5[.., b.1]) (A8[..])),
                  Dwf : (g |- ewf A2),
                  Dwf1 : (g |- ewf A3),
                  Dof : (g |- eof M2 A6),
                  Dtequiv2 : (g |- tequiv A2 (A7[.., M2])),
                  Dwf2 : (g |- ewf A6),
                  Dwf3 :
                    (g, x : eterm, z337 : eof x (A6[..]) |- ewf (A7[.., x])),
                  Dwf4 : (g |- ewf A8),
                  Dwf5 :
                    (g, x : eterm, z337 : eof x (A8[..]) |- ewf (A9[.., x]))
                | x : [g |- tequiv (epi A2 (\y148. A4)) (epi A3 (\y148. A5))],
                  flay :
                    [g |-
                       flay
                         (epi A2 (\y148. A4))
                         (kpi Dskel[] Dskel1[]) (epair M2 (elam A2 (\x. M3)))],
                  flay1 :
                    [g |-
                       flay
                         (epi A3 (\y148. A5))
                         (kpi Dskel[] Dskel1[]) (epair M4 (elam A3 (\x. M5)))],
                  skof :
                    [g |-
                       skof
                         (kpi Dskel[] Dskel1[])
                         (esigma A6 (\y. epi A7 (\l. A8[..])))
                         (\x.
                            epi (A7[.., epi1 x])
                            (\x1. A9[.., eapp (epi2 x) (M6[.., epi1 x, x1])]))]
                ; solve
                    [g |-
                       equiv/pair DequivM
                       (equiv/subsume (equiv/lam Dtequiv
                                      (\x. \dx. DequivN[.., <x; dx>]))
                       (subtp/reflex (tequiv/pi Dtequiv2
                                     (\x. \dx. tequiv/reflex (Dwf4[..])))))
                       (\x. \dx. ewf/pi Dwf3 (\x1. \dx1. Dwf4[..]))]
                }
              }
            }
          }
        }
      }
    }
  }
}
;

LF flay-equiv/e : skel -> skel -> eterm -> eterm -> etp -> type =
| flay-equiv/i : skel-eq K1 K2 -> equiv M1 M2 C -> flay-equiv/e K1 K2 M1 M2 C
;

proof flay-equiv :
  (g : ebind)
  [g |- tequiv A1 A2] ->
  [g |- flay A1 K1[] M1] ->
  [g |- flay A2 K2[] M2] ->
  [g |- skof K1[] C (\x. C')] ->
    [g |- flay-equiv/e K1[] K2[] M1 M2 C] =
/ total /
intros
{ g : ebind,
  A : (g |- etp),
  A1 : (g |- etp),
  K : ( |- skel),
  M : (g |- eterm),
  K1 : ( |- skel),
  M1 : (g |- eterm),
  C : (g |- etp),
  C' : (g, z310 : eterm |- etp)
| tequiv : [g |- tequiv A A1],
  flay : [g |- flay A K[] M],
  flay1 : [g |- flay A1 K1[] M1],
  skof : [g |- skof K[] C (\x. C')]
; split flay-equiv1 tequiv flay flay1 as
  case skel-eq/i:
  { g : ebind,
    A : (g |- etp),
    A1 : (g |- etp),
    K1 : ( |- skel),
    M : (g |- eterm),
    M1 : (g |- eterm),
    C : (g |- etp),
    C' : (g, z310 : eterm |- etp)
  | tequiv : [g |- tequiv A A1],
    flay : [g |- flay A K1[] M],
    flay1 : [g |- flay A1 K1[] M1],
    skof : [g |- skof K1[] C (\x. C')]
  ; by flay-equiv2 tequiv flay flay1 skof as Dequiv unboxed;
    solve [_ |- flay-equiv/i (skel-eq/i ) Dequiv]
  }
}
;
