LF flay : etp -> skel -> eterm -> type =
| flay/t : flay et kt estar

| flay/pi : flay A As M ->
              ({x : eterm} flay (B x) Bs (N x)) ->
              flay (epi A B) (kpi As Bs) (epair M (elam A (\x. N x)))

| flay/sigma : flay A As M ->
                 ({x : eterm} flay (B x) Bs (N x)) ->
                 flay (esigma A B) (ksigma As Bs) (epair M (elam A (\x. N x)))

| flay/sing : flay (esing M) ksing M

| flay/one : flay eone kone estar
;
--name flay Dflay.

LF can-flay/existKM : etp -> type =
| can-flay/existKM/i : {K : skel} {M : eterm} flay A K M -> can-flay/existKM A
;

proof can-flay/existKM/i : (g : evar) {K : [ |- skel]} {M : [g |- eterm]}
                           [g |- flay A K[] M] -> [g |- can-flay/existKM A] =
/ total /
?
;

proof can-flay : (g : evar) {A : [g |- etp]} [g |- can-flay/existKM A] =
/ total 1 /
?
;
