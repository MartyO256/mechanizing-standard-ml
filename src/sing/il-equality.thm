% atom-eq as an equivalence relation

LF atom-eq : atom -> atom -> type =
| atom-eq/i : atom-eq R R
;

proof atom-eq-symm : [ |- atom-eq R R'] -> [ |- atom-eq R' R] =
/ total /
intros
{ R : ( |- atom), R' : ( |- atom)
| x : [ |- atom-eq R R']
; split x as
  case atom-eq/i:
  { R' : ( |- atom)
  | x : [ |- atom-eq R' R']
  ; solve x
  }
}
;

proof atom-eq-trans : [ |- atom-eq R1 R2] ->
                        [ |- atom-eq R2 R3] -> [ |- atom-eq R1 R3] =
/ total /
intros
{ R : ( |- atom), R1 : ( |- atom), R2 : ( |- atom)
| x : [ |- atom-eq R R1], x1 : [ |- atom-eq R1 R2]
; split x as
  case atom-eq/i:
  { R1 : ( |- atom), R2 : ( |- atom)
  | x : [ |- atom-eq R1 R1], x1 : [ |- atom-eq R1 R2]
  ; solve x1
  }
}
;

% term-eq as an equivalence relation

LF term-eq : term -> term -> type =
| term-eq/i : term-eq M M
;

proof term-eq-symm : [ |- term-eq M N] -> [ |- term-eq N M] =
/ total /
intros
{ M : ( |- term), N : ( |- term)
| x : [ |- term-eq M N]
; split x as
  case term-eq/i:
  { N : ( |- term)
  | x : [ |- term-eq N N]
  ; solve x
  }
}
;

proof term-eq-trans : [ |- term-eq M N] ->
                        [ |- term-eq N O] -> [ |- term-eq M O] =
/ total /
intros
{ M : ( |- term), N : ( |- term), O : ( |- term)
| x : [ |- term-eq M N], x1 : [ |- term-eq N O]
; split x as
  case term-eq/i:
  { N : ( |- term), O : ( |- term)
  | x : [ |- term-eq N N], x1 : [ |- term-eq N O]
  ; solve x1
  }
}
;

% tp-eq as an equivalence relation

LF tp-eq : tp -> tp -> type =
| tp-eq/i : tp-eq T T
;

proof tp-eq-symm : [ |- tp-eq A B] -> [ |- tp-eq B A] =
/ total /
intros
{ A : ( |- tp), B : ( |- tp)
| x : [ |- tp-eq A B]
; split x as
  case tp-eq/i:
  { B : ( |- tp)
  | x : [ |- tp-eq B B]
  ; solve x
  }
}
;

proof tp-eq-trans : [ |- tp-eq A B] -> [ |- tp-eq B C] -> [ |- tp-eq A C] =
/ total /
intros
{ A : ( |- tp), B : ( |- tp), C : ( |- tp)
| x : [ |- tp-eq A B], x1 : [ |- tp-eq B C]
; split x as
  case tp-eq/i:
  { B : ( |- tp), C : ( |- tp)
  | x : [ |- tp-eq B B], x1 : [ |- tp-eq B C]
  ; solve x1
  }
}
;

% Respective equality

proof app-resp : [ |- atom-eq R R'] ->
                   [ |- term-eq M M'] -> [ |- atom-eq (app R M) (app R' M')] =
/ total /
intros
{ R : ( |- atom), R' : ( |- atom), M : ( |- term), M' : ( |- term)
| x : [ |- atom-eq R R'], x1 : [ |- term-eq M M']
; split x as
  case atom-eq/i:
  { R' : ( |- atom), M : ( |- term), M' : ( |- term)
  | x : [ |- atom-eq R' R'], x1 : [ |- term-eq M M']
  ; split x1 as
    case term-eq/i:
    { R' : ( |- atom), M' : ( |- term)
    | x : [ |- atom-eq R' R'], x1 : [ |- term-eq M' M']
    ; solve [ |- atom-eq/i ]
    }
  }
}
;

proof atom-resp-atom : { R : [ x : atom |- atom] } [ |- atom-eq Q Q'] ->
                         [ |- atom-eq (R[Q]) (R[Q'])] =
/ total /
intros
{ Q : ( |- atom), Q' : ( |- atom), R : (x : atom |- atom)
| x : [ |- atom-eq Q Q']
; split x as
  case atom-eq/i:
  { Q' : ( |- atom), R : (x : atom |- atom)
  | x : [ |- atom-eq Q' Q']
  ; solve [ |- atom-eq/i ]
  }
}
;

proof term-resp-term : { M : [ x : term |- term] } [ |- term-eq N N'] ->
                         [ |- term-eq (M[N]) (M[N'])] =
/ total /
intros
{ N : ( |- term), N' : ( |- term), M : (x : term |- term)
| x : [ |- term-eq N N']
; split x as
  case term-eq/i:
  { N' : ( |- term), M : (x : term |- term)
  | x : [ |- term-eq N' N']
  ; solve [ |- term-eq/i ]
  }
}
;

proof tp-resp-tp : { A : [ x : tp |- tp] } [ |- tp-eq B B'] ->
                     [ |- tp-eq (A[B]) (A[B'])] =
/ total /
intros
{ B : ( |- tp), B' : ( |- tp), A : (x : tp |- tp)
| x : [ |- tp-eq B B']
; split x as
  case tp-eq/i:
  { B' : ( |- tp), A : (x : tp |- tp)
  | x : [ |- tp-eq B' B']
  ; solve [ |- tp-eq/i ]
  }
}
;

proof term-resp-atom : { M : [ x : atom |- term] } [ |- atom-eq R R'] ->
                         [ |- term-eq (M[R]) (M[R'])] =
/ total /
intros
{ R : ( |- atom), R' : ( |- atom), M : (x : atom |- term)
| x : [ |- atom-eq R R']
; split x as
  case atom-eq/i:
  { R' : ( |- atom), M : (x : atom |- term)
  | x : [ |- atom-eq R' R']
  ; solve [ |- term-eq/i ]
  }
}
;

proof tp-resp-atom : { A : [ x : atom |- tp] } [ |- atom-eq R R'] ->
                       [ |- tp-eq (A[R]) (A[R'])] =
/ total /
intros
{ R : ( |- atom), R' : ( |- atom), A : (x : atom |- tp)
| x : [ |- atom-eq R R']
; split x as
  case atom-eq/i:
  { R' : ( |- atom), A : (x : atom |- tp)
  | x : [ |- atom-eq R' R']
  ; solve [ |- tp-eq/i ]
  }
}
;

proof tp-resp-term : { A : [ x : term |- tp] } [ |- term-eq M M'] ->
                       [ |- tp-eq (A[M]) (A[M'])] =
/ total /
intros
{ M : ( |- term), M' : ( |- term), A : (x : term |- tp)
| x : [ |- term-eq M M']
; split x as
  case term-eq/i:
  { M' : ( |- term), A : (x : term |- tp)
  | x : [ |- term-eq M' M']
  ; solve [ |- tp-eq/i ]
  }
}
;

% Cdr lemmas

proof atom-eq-cdr-app : [ |- atom-eq (app R M) (app R' M')] ->
                          [ |- atom-eq R R'] -> [ |- term-eq M M'] =
/ total /
intros
{ R : ( |- atom), M : ( |- term), R' : ( |- atom), M' : ( |- term)
| x : [ |- atom-eq (app R M) (app R' M')], x1 : [ |- atom-eq R R']
; split x as
  case atom-eq/i:
  { R' : ( |- atom), M' : ( |- term)
  | x : [ |- atom-eq (app R' M') (app R' M')], x1 : [ |- atom-eq R' R']
  ; solve [ |- term-eq/i ]
  }
}
;
