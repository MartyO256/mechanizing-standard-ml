% Leq

proof leq-trans : [ |- leq N1 N2] -> [ |- leq N2 N3] -> [ |- leq N1 N3] =
/ total /
intros
{ N1 : ( |- nat), N2 : ( |- nat), N3 : ( |- nat)
| p1 : [ |- leq N1 N2], p2 : [ |- leq N2 N3]
; split p1 as
  case leq/s:
  { N4 : ( |- nat), N5 : ( |- nat), N3 : ( |- nat), X : ( |- leq N4 N5)
  | p1 : [ |- leq (succ N4) (succ N5)], p2 : [ |- leq (succ N5) N3]
  ; split p2 as
    case leq/s:
    { N4 : ( |- nat),
      N5 : ( |- nat),
      N7 : ( |- nat),
      X : ( |- leq N4 N5),
      X1 : ( |- leq N5 N7)
    | p1 : [ |- leq (succ N4) (succ N5)], p2 : [ |- leq (succ N5) (succ N7)]
    ; by leq-trans p1 p2 as l;
      solve l
    }
  }
  case leq/z:
  { N2 : ( |- nat), N3 : ( |- nat)
  | p1 : [ |- leq zero N2], p2 : [ |- leq N2 N3]
  ; solve [ |- leq/z ]
  }
}
;

proof leq-reflex : { N : [ |- nat] } [ |- leq N N] =
/ total /
intros
{ N : ( |- nat)
| 
; split [ |- N] as
  case succ:
  { N1 : ( |- nat)
  | 
  ; by leq-reflex [ |- N1] as L unboxed;
    solve [ |- leq/s L]
  }
  case zero:
  { 
  | 
  ; solve [ |- leq/z ]
  }
}
;

