% Term Inversion

proof inversion-tm/abort/tm-of : [ |- tm-of F (tm/abort E T) T'] ->
                                   [ |- tm-of F E void] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con), T' : ( |- con)
| x : [ |- tm-of F (tm/abort E T) T']
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    T' : ( |- con),
    C : ( |- con),
    X1 : ( |- cn-equiv C T' t),
    X2 : ( |- tm-of F (tm/abort E T) C)
  | x : [ |- tm-of F (tm/abort E T) T']
  ; solve inversion-tm/abort/tm-of [ |- X2]
  }
  case tm-of/abort:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    X1 : ( |- cn-of T' t),
    X2 : ( |- tm-of F E void)
  | x : [ |- tm-of F (tm/abort E T') T']
  ; solve [ |- X2]
  }
  case tm-of/var:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    T' : ( |- con),
    X1 : ( |- tm-assm (tm/abort E T) T')
  | x : [ |- tm-of F (tm/abort E T) T']
  ; impossible [ |- X1]
  }
}
;

proof inversion-tm/abort/cn-equiv : [ |- tm-of F (tm/abort E T) T'] ->
                                      [ |- cn-equiv T T' t] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con), T' : ( |- con)
| x : [ |- tm-of F (tm/abort E T) T']
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    T' : ( |- con),
    C : ( |- con),
    X1 : ( |- cn-equiv C T' t),
    X2 : ( |- tm-of F (tm/abort E T) C)
  | x : [ |- tm-of F (tm/abort E T) T']
  ; by inversion-tm/abort/cn-equiv [ |- X2] as L unboxed;
    solve [ |- cn-equiv/trans L X1]
  }
  case tm-of/abort:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    X1 : ( |- cn-of T' t),
    X2 : ( |- tm-of F E void)
  | x : [ |- tm-of F (tm/abort E T') T']
  ; solve [ |- cn-equiv/refl X1]
  }
  case tm-of/var:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    T' : ( |- con),
    X1 : ( |- tm-assm (tm/abort E T) T')
  | x : [ |- tm-of F (tm/abort E T) T']
  ; impossible [ |- X1]
  }
}
;

proof inversion-tm/deref : [ |- tm-of F (tm/deref E) T] ->
                             [ |- tm-of F E (ref T)] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/deref E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/deref E) C)
  | x : [ |- tm-of F (tm/deref E) T]
  ; by inversion-tm/deref [ |- X1] as Q1 unboxed;
    by [ |- cn-equiv/ref X] as Q2 unboxed;
    solve [ |- tm-of/equiv Q2 Q1]
  }
  case tm-of/deref:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- tm-of F E (ref T))
  | x : [ |- tm-of F (tm/deref E) T]
  ; solve [ |- X]
  }
  case tm-of/var:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- tm-assm (tm/deref E) T)
  | x : [ |- tm-of F (tm/deref E) T]
  ; impossible [ |- X]
  }
}
;

proof inversion-tm/newtag : [ |- tm-of F (tm/newtag T') T] ->
                              [ |- cn-equiv (tag T') T t] =
/ total 1 /
intros
{ F : ( |- sttp), T' : ( |- con), T : ( |- con)
| x : [ |- tm-of F (tm/newtag T') T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    T' : ( |- con),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/newtag T') C)
  | x : [ |- tm-of F (tm/newtag T') T]
  ; by inversion-tm/newtag [ |- X1] as Q unboxed;
    solve [ |- cn-equiv/trans Q X]
  }
  case tm-of/newtag:
  { F : ( |- sttp), T' : ( |- con), X : ( |- cn-of T' t)
  | x : [ |- tm-of F (tm/newtag T') (tag T')]
  ; solve [ |- cn-equiv/refl (cn-of/tag X)]
  }
  case tm-of/var:
  { F : ( |- sttp),
    T' : ( |- con),
    T : ( |- con),
    X : ( |- tm-assm (tm/newtag T') T)
  | x : [ |- tm-of F (tm/newtag T') T]
  ; impossible [ |- X]
  }
}
;
LF inversion-tm/out/existsL : type =
| inversion-tm/out/existsL/i : { L : label } tm-of F E (labeled L T) ->
                                 inversion-tm/out/existsL
;

proof inversion-tm/out/existsL/i : { L : [ |- label] }
                                     [ |- tm-of F E (labeled L T)] ->
                                       [ |- inversion-tm/out/existsL ] =
/ total /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con), L : ( |- label)
| x : [ |- tm-of F E (labeled L T)]
; by x as X unboxed;
  solve [ |- inversion-tm/out/existsL/i L X]
}
;

proof inversion-tm/out : [ |- tm-of F (tm/out E) T] ->
                           [ |- inversion-tm/out/existsL] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/out E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/out E) C)
  | x : [ |- tm-of F (tm/out E) T]
  ; by inversion-tm/out [ |- X1] as q;
    solve q
  }
  case tm-of/out:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- label),
    X1 : ( |- tm-of F E (labeled X T))
  | x : [ |- tm-of F (tm/out E) T]
  ; suffices by inversion-tm/out/existsL/i [ |- X] toshow
    [ |- tm-of F E (labeled X T)] {
      solve [ |- X1]
    }
  }
  case tm-of/var:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- tm-assm (tm/out E) T)
  | x : [ |- tm-of F (tm/out E) T]
  ; impossible [ |- X]
  }
}
;

proof inversion-tm/raise/cn-equiv : [ |- tm-of F (tm/raise E T') T] ->
                                      [ |- cn-equiv T' T t] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T' : ( |- con), T : ( |- con)
| x : [ |- tm-of F (tm/raise E T') T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/raise E T') C)
  | x : [ |- tm-of F (tm/raise E T') T]
  ; by inversion-tm/raise/cn-equiv [ |- X1] as Q unboxed;
    solve [ |- cn-equiv/trans Q X]
  }
  case tm-of/raise:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- cn-of T t),
    X1 : ( |- tm-of F E tagged)
  | x : [ |- tm-of F (tm/raise E T) T]
  ; solve [ |- cn-equiv/refl X]
  }
  case tm-of/var:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    T : ( |- con),
    X : ( |- tm-assm (tm/raise E T') T)
  | x : [ |- tm-of F (tm/raise E T') T]
  ; impossible [ |- X]
  }
}

and proof inversion-tm/raise/tm-of : [ |- tm-of F (tm/raise E T') T] ->
                                   [ |- tm-of F E tagged] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T' : ( |- con), T : ( |- con)
| x : [ |- tm-of F (tm/raise E T') T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/raise E T') C)
  | x : [ |- tm-of F (tm/raise E T') T]
  ; solve inversion-tm/raise/tm-of [ |- X1]
  }
  case tm-of/raise:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- cn-of T t),
    X1 : ( |- tm-of F E tagged)
  | x : [ |- tm-of F (tm/raise E T) T]
  ; solve [ |- X1]
  }
  case tm-of/var:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    T : ( |- con),
    X : ( |- tm-assm (tm/raise E T') T)
  | x : [ |- tm-of F (tm/raise E T') T]
  ; impossible [ |- X]
  }
}
;

proof inversion-tm/snd : [ |- tm-of F (tm/snd M) T] ->
                           [ |- md-of impure F M (sg/datom T)] =
/ total 1 /
intros
{ F : ( |- sttp), M : ( |- module'), T : ( |- con)
| x : [ |- tm-of F (tm/snd M) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    M : ( |- module'),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/snd M) C)
  | x : [ |- tm-of F (tm/snd M) T]
  ; by [ |- sg-equiv/datom X] as Q1 unboxed;
    by inversion-tm/snd [ |- X1] as Q2 unboxed;
    by md-of/equiv [ |- Q1] [ |- Q2] as q;
    solve q
  }
  case tm-of/snd:
  { F : ( |- sttp),
    M : ( |- module'),
    T : ( |- con),
    P : ( |- purity),
    X : ( |- md-of P F M (sg/datom T))
  | x : [ |- tm-of F (tm/snd M) T]
  ; solve md-of-forget [ |- X]
  }
  case tm-of/var:
  { F : ( |- sttp),
    M : ( |- module'),
    T : ( |- con),
    X : ( |- tm-assm (tm/snd M) T)
  | x : [ |- tm-of F (tm/snd M) T]
  ; impossible [ |- X]
  }
}
;
