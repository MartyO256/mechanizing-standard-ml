% Term Inversion

LF inversion-tm/abort/e : sttp -> term -> con -> con -> type =
| inversion-tm/abort/i :
  tm-of F E void ->
  cn-equiv T T' t ->
    inversion-tm/abort/e F E T T'
;

proof inversion-tm/abort :
  [ |- tm-of F (tm/abort E T) T'] ->
    [ |- inversion-tm/abort/e F E T T'] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con), T' : ( |- con)
| x : [ |- tm-of F (tm/abort E T) T']
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    T' : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/abort E T) C),
    Dequiv : ( |- cn-equiv C T' t)
  | x : [ |- tm-of F (tm/abort E T) T']
  ; split inversion-tm/abort [ |- Dof] as
    case inversion-tm/abort/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      T' : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/abort E T) C),
      Dequiv : ( |- cn-equiv C T' t),
      Dof1 : ( |- tm-of F E void),
      Dequiv1 : ( |- cn-equiv T C t)
    | x : [ |- tm-of F (tm/abort E T) T']
    ; solve [ |- inversion-tm/abort/i Dof1 (cn-equiv/trans Dequiv1 Dequiv)]
    }
  }
  case tm-of/abort:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    Dof : ( |- cn-of T' t),
    Dof1 : ( |- tm-of F E void)
  | x : [ |- tm-of F (tm/abort E T') T']
  ; solve [ |- inversion-tm/abort/i Dof1 (cn-equiv/refl Dof)]
  }
}
;

LF inversion-tm/pair/e : sttp -> term -> term -> con -> type =
| inversion-tm/pair/i :
  { T1 : con } { T2 : con }
  cn-equiv (prod T1 T2) T t ->
  tm-of F E1 T1 ->
  tm-of F E2 T2 ->
    inversion-tm/pair/e F E1 E2 T
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/pair :
  [ |- tm-of F (tm/pair E1 E2) T] ->
    [ |- inversion-tm/pair/e F E1 E2 T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/pair E E1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/pair E E1) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/pair E E1) T]
  ; split inversion-tm/pair [ |- Dof] as
    case inversion-tm/pair/i:
    { F : ( |- sttp),
      E : ( |- term),
      E1 : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/pair E E1) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      C3 : ( |- con),
      Dequiv1 : ( |- cn-equiv (prod C2 C3) C t),
      Dof1 : ( |- tm-of F E C2),
      Dof2 : ( |- tm-of F E1 C3)
    | x : [ |- tm-of F (tm/pair E E1) T]
    ; by [ |- cn-equiv/trans Dequiv1 Dequiv] as Dequiv2 unboxed;
      solve [ |- inversion-tm/pair/i C2 C3 Dequiv2 Dof1 Dof2]
    }
  }
  case tm-of/pair:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    C : ( |- con),
    C1 : ( |- con),
    Dof : ( |- tm-of F E C),
    Dof1 : ( |- tm-of F E1 C1)
  | x : [ |- tm-of F (tm/pair E E1) (prod C C1)]
  ; ?
  }
}
;

LF inversion-tm/pi1/e : sttp -> term -> con -> type =
| inversion-tm/pi1/i :
  { T2 : con } tm-of F E (prod T1 T2) ->
    inversion-tm/pi1/e F E T1
;

% TODO: Depends on `tm-of-reg`, `inversion-prod/1`
proof inversion-tm/pi1 :
  [ |- tm-of F (tm/pi1 E) T1] ->
    [ |- inversion-tm/pi1/e F E T1] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/pi1 E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/pi1 E) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/pi1 E) T]
  ; split inversion-tm/pi1 [ |- Dof] as
    case inversion-tm/pi1/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/pi1 E) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dof1 : ( |- tm-of F E (prod C C2))
    | x : [ |- tm-of F (tm/pi1 E) T]
    ; ?
    }
  }
  case tm-of/pi1:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C1 : ( |- con),
    Dof : ( |- tm-of F E (prod T C1))
  | x : [ |- tm-of F (tm/pi1 E) T]
  ; solve [ |- inversion-tm/pi1/i _ Dof]
  }
}
;

LF inversion-tm/pi2/e : sttp -> term -> con -> type =
| inversion-tm/pi2/i :
  { T1 : con }
  tm-of F E (prod T1 T2) ->
    inversion-tm/pi2/e F E T2
;

% TODO: Depends on `tm-of-reg`, `inversion-prod/2`
proof inversion-tm/pi2 :
  [ |- tm-of F (tm/pi2 E) T2] ->
    [ |- inversion-tm/pi2/e F E T2] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/pi2 E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/pi2 E) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/pi2 E) T]
  ; split inversion-tm/pi2 [ |- Dof] as
    case inversion-tm/pi2/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/pi2 E) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dof1 : ( |- tm-of F E (prod C2 C))
    | x : [ |- tm-of F (tm/pi2 E) T]
    ; ?
    }
  }
  case tm-of/pi2:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F E (prod C T))
  | x : [ |- tm-of F (tm/pi2 E) T]
  ; solve [ |- inversion-tm/pi2/i _ Dof]
  }
}
;

LF inversion-tm/in1/e : sttp -> term -> con -> con -> type =
| inversion-tm/in1/i :
  { T1 : con }
  cn-equiv (plus T1 T2) T t  ->
  tm-of F E T1 ->
  cn-of T2 t ->
    inversion-tm/in1/e F E T T2
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/in1 :
  [ |- tm-of F (tm/in1 E T2) T] ->
    [ |- inversion-tm/in1/e F E T T2] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con), T1 : ( |- con)
| x : [ |- tm-of F (tm/in1 E T) T1]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    T1 : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/in1 E T) C),
    Dequiv : ( |- cn-equiv C T1 t)
  | x : [ |- tm-of F (tm/in1 E T) T1]
  ; split inversion-tm/in1 [ |- Dof] as
    case inversion-tm/in1/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      T1 : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/in1 E T) C),
      Dequiv : ( |- cn-equiv C T1 t),
      C3 : ( |- con),
      Dequiv1 : ( |- cn-equiv (plus C3 T) C t),
      Dof1 : ( |- tm-of F E C3),
      Dof2 : ( |- cn-of T t)
    | x : [ |- tm-of F (tm/in1 E T) T1]
    ; solve
        [ |- inversion-tm/in1/i C3 (cn-equiv/trans Dequiv1 Dequiv) Dof1 Dof2]
    }
  }
  case tm-of/in1:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F E C),
    Dof1 : ( |- cn-of T t)
  | x : [ |- tm-of F (tm/in1 E T) (plus C T)]
  ; ?
  }
}
;

LF inversion-tm/in2/e : sttp -> term -> con -> con -> type =
| inversion-tm/in2/i :
  { T2 : con }
  cn-equiv (plus T1 T2) T t ->
  tm-of F E T2 ->
  cn-of T1 t ->
    inversion-tm/in2/e F E T1 T
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/in2 :
  [ |- tm-of F (tm/in2 E T1) T] ->
    [ |- inversion-tm/in2/e F E T1 T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con), T1 : ( |- con)
| x : [ |- tm-of F (tm/in2 E T) T1]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    T1 : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/in2 E T) C),
    Dequiv : ( |- cn-equiv C T1 t)
  | x : [ |- tm-of F (tm/in2 E T) T1]
  ; split inversion-tm/in2 [ |- Dof] as
    case inversion-tm/in2/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      T1 : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/in2 E T) C),
      Dequiv : ( |- cn-equiv C T1 t),
      C3 : ( |- con),
      Dequiv1 : ( |- cn-equiv (plus T C3) C t),
      Dof1 : ( |- tm-of F E C3),
      Dof2 : ( |- cn-of T t)
    | x : [ |- tm-of F (tm/in2 E T) T1]
    ; solve
        [ |- inversion-tm/in2/i C3 (cn-equiv/trans Dequiv1 Dequiv) Dof1 Dof2]
    }
  }
  case tm-of/in2:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F E C),
    Dof1 : ( |- cn-of T t)
  | x : [ |- tm-of F (tm/in2 E T) (plus T C)]
  ; ?
  }
}
;

LF inversion-tm/case/e :
  sttp -> term -> (term -> term) -> (term -> term) -> con -> type =
| inversion-tm/case/i :
  { T1 : con } { T2 : con }
  tm-of F E (plus T1 T2) ->
  ({ x : term } { u : { F': sttp } tm-of F' x T1 } tm-of F (E1 x) T) ->
  ({ x : term } { u : { F': sttp } tm-of F' x T2 } tm-of F (E2 x) T) ->
    inversion-tm/case/e F E E1 E2 T
;

proof inversion-tm/case/i :
  { T1 : [ |- con] } { T2 : [ |- con] }
  [ |- tm-of F E (plus T1 T2)] ->
  [x : term, u : { F': sttp } tm-of F' x T1[] |- tm-of F[] (E1[x]) T[]] ->
  [x : term, u : { F': sttp } tm-of F' x T2[] |- tm-of F[] (E2[x]) T[]] ->
    [ |- inversion-tm/case/e F E (\x. E1) (\x. E2) T] =
/ total /
intros
{ F : ( |- sttp),
  E : ( |- term),
  E1 : (x : term |- term),
  T : ( |- con),
  E2 : (x : term |- term),
  T1 : ( |- con),
  T2 : ( |- con)
| tof : [ |- tm-of F E (plus T1 T2)],
  tof1 :
    [x : term, u : {F' : sttp}  tm-of F' x T1[] |- tm-of F[] (E1[x]) T[]],
  tof2 :
    [x : term, u : {F' : sttp}  tm-of F' x T2[] |- tm-of F[] (E2[x]) T[]]
; by tof as Dof unboxed;
  by tof1 as Dof1 unboxed;
  by tof2 as Dof2 unboxed;
  solve [ |- inversion-tm/case/i T1 T2 Dof (\x. \u. Dof1) (\x. \u. Dof2)]
}
;

proof inversion-tm/case :
  [ |- tm-of F (tm/case E (\x. E1) (\x. E2)) T] ->
    [ |- inversion-tm/case/e F E (\x. E1) (\x. E2) T] =
/ total 1 /
intros
{ F : ( |- sttp),
  E : ( |- term),
  E1 : (x120 : term |- term),
  E2 : (y120 : term |- term),
  T : ( |- con)
| x : [ |- tm-of F (tm/case E (\x. E1) (\x. E2)) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : (x120 : term |- term),
    E2 : (y120 : term |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/case E (\x. E1) (\x. E2)) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/case E (\x. E1) (\x. E2)) T]
  ; split inversion-tm/case [ |- Dof] as
    case inversion-tm/case/i:
    { F : ( |- sttp),
      E : ( |- term),
      E1 : (x120 : term |- term),
      E2 : (y120 : term |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/case E (\x. E1) (\x. E2)) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      C3 : ( |- con),
      Dof1 : ( |- tm-of F E (plus C2 C3)),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x C2[] |- tm-of F[] (E1[x]) C[]),
      Dof3 :
        (x : term, u : {F' : sttp}  tm-of F' x C3[] |- tm-of F[] (E2[x]) C[])
    | x : [ |- tm-of F (tm/case E (\x. E1) (\x. E2)) T]
    ; solve
        [ |-
           inversion-tm/case/i C2
           C3
           Dof1
           (\x. \u. tm-of/equiv Dof2 Dequiv[])
           (\x. \u. tm-of/equiv Dof3 Dequiv[])]
    }
  }
  case tm-of/case:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : (x120 : term |- term),
    E2 : (y120 : term |- term),
    T : ( |- con),
    C : ( |- con),
    C1 : ( |- con),
    Dof : ( |- tm-of F E (plus C C1)),
    Dof1 :
      (x : term, u : {F' : sttp}  tm-of F' x C[] |- tm-of F[] (E1[x]) T[]),
    Dof2 :
      (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E2[x]) T[])
  | x : [ |- tm-of F (tm/case E (\x. E1) (\x. E2)) T]
  ; solve [ |- inversion-tm/case/i C C1 Dof (\x. \u. Dof1) (\x. \u. Dof2)]
  }
}
;

LF inversion-tm/lam/e : sttp -> (term -> term) -> con -> con -> type =
| inversion-tm/lam/i :
  { T2 : con }
  cn-equiv (arrow T1 T2) T t ->
  ({ x : term } { u : { F': sttp } tm-of F' x T1 } tm-of F (E x) T2) ->
    inversion-tm/lam/e F E T1 T
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/lam :
  [ |- tm-of F (tm/lam T1 (\x. E)) T] ->
    [ |- inversion-tm/lam/e F (\x. E) T1 T] =
/ total 1 /
intros
{ F : ( |- sttp), T : ( |- con), E : (z116 : term |- term), T1 : ( |- con)
| x : [ |- tm-of F (tm/lam T (\x. E)) T1]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    T : ( |- con),
    E : (z116 : term |- term),
    T1 : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/lam T (\x. E)) C),
    Dequiv : ( |- cn-equiv C T1 t)
  | x : [ |- tm-of F (tm/lam T (\x. E)) T1]
  ; split inversion-tm/lam [ |- Dof] as
    case inversion-tm/lam/i:
    { F : ( |- sttp),
      T : ( |- con),
      E : (z116 : term |- term),
      T1 : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/lam T (\x. E)) C),
      Dequiv : ( |- cn-equiv C T1 t),
      C3 : ( |- con),
      Dequiv1 : ( |- cn-equiv (arrow T C3) C t),
      Dof1 :
        (x : term, u : {F' : sttp}  tm-of F' x T[] |- tm-of F[] (E[x]) C3[])
    | x : [ |- tm-of F (tm/lam T (\x. E)) T1]
    ; solve
        [ |-
           inversion-tm/lam/i C3
           (cn-equiv/trans Dequiv1 Dequiv) (\x. \u. Dof1)]
    }
  }
  case tm-of/lam:
  { F : ( |- sttp),
    T : ( |- con),
    E : (z116 : term |- term),
    C1 : ( |- con),
    Dof : ( |- cn-of T t),
    Dof1 :
      (x : term, u : {F' : sttp}  tm-of F' x T[] |- tm-of F[] (E[x]) C1[])
  | x : [ |- tm-of F (tm/lam T (\x. E)) (arrow T C1)]
  ; ?
  }
}
;

LF inversion-tm/app/e : sttp -> term -> term -> con -> type =
| inversion-tm/app/i :
  { T' : con }
  tm-of F E1 (arrow T' T) ->
  tm-of F E2 T' ->
    inversion-tm/app/e F E1 E2 T
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/app :
  [ |- tm-of F (tm/app E1 E2) T] ->
    [ |- inversion-tm/app/e F E1 E2 T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/app E E1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/app E E1) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/app E E1) T]
  ; split inversion-tm/app [ |- Dof] as
    case inversion-tm/app/i:
    { F : ( |- sttp),
      E : ( |- term),
      E1 : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/app E E1) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dof1 : ( |- tm-of F E (arrow C2 C)),
      Dof2 : ( |- tm-of F E1 C2)
    | x : [ |- tm-of F (tm/app E E1) T]
    ; ?
    }
  }
  case tm-of/app:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F E (arrow C T)),
    Dof1 : ( |- tm-of F E1 C)
  | x : [ |- tm-of F (tm/app E E1) T]
  ; solve [ |- inversion-tm/app/i C Dof Dof1]
  }
}
;

LF inversion-tm/refloc/e : sttp -> location -> con -> type =
| inversion-tm/refloc/i :
  { T' : con }
  cn-equiv (ref T') T t ->
  st-lookup F L (et/ref T') ->
  cn-of T' t ->
    inversion-tm/refloc/e F L T
;

proof inversion-tm/refloc :
  [ |- tm-of F (tm/refloc L) T] ->
    [ |- inversion-tm/refloc/e F L T] =
/ total 1 /
intros
{ F : ( |- sttp), L : ( |- location), T : ( |- con)
| x : [ |- tm-of F (tm/refloc L) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    L : ( |- location),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/refloc L) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/refloc L) T]
  ; split inversion-tm/refloc [ |- Dof] as
    case inversion-tm/refloc/i:
    { F : ( |- sttp),
      L : ( |- location),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/refloc L) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dequiv1 : ( |- cn-equiv (ref C2) C t),
      Dlookup : ( |- st-lookup F L (et/ref C2)),
      Dof1 : ( |- cn-of C2 t)
    | x : [ |- tm-of F (tm/refloc L) T]
    ; solve
        [ |-
           inversion-tm/refloc/i C2
           (cn-equiv/trans Dequiv1 Dequiv) Dlookup Dof1]
    }
  }
  case tm-of/refloc:
  { F : ( |- sttp),
    L : ( |- location),
    C : ( |- con),
    Dlookup : ( |- st-lookup F L (et/ref C)),
    Dof : ( |- cn-of C t)
  | x : [ |- tm-of F (tm/refloc L) (ref C)]
  ; solve
      [ |-
         inversion-tm/refloc/i C (cn-equiv/refl (cn-of/ref Dof)) Dlookup Dof]
  }
}
;

LF inversion-tm/ref/e : sttp -> term -> con -> type =
| inversion-tm/ref/i :
  { T' : con }
  cn-equiv (ref T') T t ->
  tm-of F E T' ->
    inversion-tm/ref/e F E T
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/ref :
  [ |- tm-of F (tm/ref E) T] ->
    [ |- inversion-tm/ref/e F E T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/ref E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/ref E) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/ref E) T]
  ; split inversion-tm/ref [ |- Dof] as
    case inversion-tm/ref/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/ref E) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dequiv1 : ( |- cn-equiv (ref C2) C t),
      Dof1 : ( |- tm-of F E C2)
    | x : [ |- tm-of F (tm/ref E) T]
    ; solve [ |- inversion-tm/ref/i C2 (cn-equiv/trans Dequiv1 Dequiv) Dof1]
    }
  }
  case tm-of/ref:
  { F : ( |- sttp), E : ( |- term), C : ( |- con), Dof : ( |- tm-of F E C)
  | x : [ |- tm-of F (tm/ref E) (ref C)]
  ; ?
  }
}
;

proof inversion-tm/deref : [ |- tm-of F (tm/deref E) T] ->
                             [ |- tm-of F E (ref T)] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/deref E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/deref E) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/deref E) T]
  ; by [ |- cn-equiv/ref Dequiv] as Dequiv1 unboxed;
    by inversion-tm/deref [ |- Dof] as Dof1 unboxed;
    solve [ |- tm-of/equiv Dof1 Dequiv1]
  }
  case tm-of/deref:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    Dof : ( |- tm-of F E (ref T))
  | x : [ |- tm-of F (tm/deref E) T]
  ; solve [ |- Dof]
  }
}
;

LF inversion-tm/assign/e : sttp -> term -> term -> con -> type =
| inversion-tm/assign/i :
  { T' : con }
  cn-equiv unit T t ->
  tm-of F E1 (ref T') ->
  tm-of F E2 T' ->
    inversion-tm/assign/e F E1 E2 T
;

proof inversion-tm/assign :
  [ |- tm-of F (tm/assign E1 E2) T] ->
    [ |- inversion-tm/assign/e F E1 E2 T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/assign E E1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/assign E E1) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/assign E E1) T]
  ; split inversion-tm/assign [ |- Dof] as
    case inversion-tm/assign/i:
    { F : ( |- sttp),
      E : ( |- term),
      E1 : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/assign E E1) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dequiv1 : ( |- cn-equiv unit C t),
      Dof1 : ( |- tm-of F E (ref C2)),
      Dof2 : ( |- tm-of F E1 C2)
    | x : [ |- tm-of F (tm/assign E E1) T]
    ; solve
        [ |-
           inversion-tm/assign/i C2 (cn-equiv/trans Dequiv1 Dequiv) Dof1 Dof2]
    }
  }
  case tm-of/assign:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    C : ( |- con),
    Dof : ( |- tm-of F E (ref C)),
    Dof1 : ( |- tm-of F E1 C)
  | x : [ |- tm-of F (tm/assign E E1) unit]
  ; solve [ |- inversion-tm/assign/i C (cn-equiv/refl cn-of/unit) Dof Dof1]
  }
}
;

LF inversion-tm/tagloc/e : sttp -> location -> con -> type =
| inversion-tm/tagloc/i :
  { T' : con }
  cn-equiv (tag T') T t ->
  st-lookup F L (et/tag T') ->
  cn-of T' t ->
    inversion-tm/tagloc/e F L T
;

proof inversion-tm/tagloc :
  [ |- tm-of F (tm/tagloc L) T] ->
    [ |- inversion-tm/tagloc/e F L T] =
/ total 1 /
intros
{ F : ( |- sttp), L : ( |- location), T : ( |- con)
| x : [ |- tm-of F (tm/tagloc L) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    L : ( |- location),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/tagloc L) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/tagloc L) T]
  ; split inversion-tm/tagloc [ |- Dof] as
    case inversion-tm/tagloc/i:
    { F : ( |- sttp),
      L : ( |- location),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/tagloc L) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dequiv1 : ( |- cn-equiv (tag C2) C t),
      Dlookup : ( |- st-lookup F L (et/tag C2)),
      Dof1 : ( |- cn-of C2 t)
    | x : [ |- tm-of F (tm/tagloc L) T]
    ; solve
        [ |-
           inversion-tm/tagloc/i C2
           (cn-equiv/trans Dequiv1 Dequiv) Dlookup Dof1]
    }
  }
  case tm-of/tagloc:
  { F : ( |- sttp),
    L : ( |- location),
    C : ( |- con),
    Dlookup : ( |- st-lookup F L (et/tag C)),
    Dof : ( |- cn-of C t)
  | x : [ |- tm-of F (tm/tagloc L) (tag C)]
  ; solve
      [ |-
         inversion-tm/tagloc/i C (cn-equiv/refl (cn-of/tag Dof)) Dlookup Dof]
  }
}
;

proof inversion-tm/newtag : [ |- tm-of F (tm/newtag T') T] ->
                              [ |- cn-equiv (tag T') T t] =
/ total 1 /
intros
{ F : ( |- sttp), T' : ( |- con), T : ( |- con)
| x : [ |- tm-of F (tm/newtag T') T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    T' : ( |- con),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/newtag T') C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/newtag T') T]
  ; by inversion-tm/newtag [ |- Dof] as Dequiv1 unboxed;
    solve [ |- cn-equiv/trans Dequiv1 Dequiv]
  }
  case tm-of/newtag:
  { F : ( |- sttp), T' : ( |- con), Dof : ( |- cn-of T' t)
  | x : [ |- tm-of F (tm/newtag T') (tag T')]
  ; solve [ |- cn-equiv/refl (cn-of/tag Dof)]
  }
}
;

LF inversion-tm/tag/e : sttp -> term -> term -> con -> type =
| inversion-tm/tag/i :
  { T' : con }
  cn-equiv tagged T t ->
  tm-of F E1 (tag T') ->
  tm-of F E2 T' ->
    inversion-tm/tag/e F E1 E2 T
;

proof inversion-tm/tag :
  [ |- tm-of F (tm/tag E1 E2) T] ->
    [ |- inversion-tm/tag/e F E1 E2 T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/tag E E1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/tag E E1) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/tag E E1) T]
  ; split inversion-tm/tag [ |- Dof] as
    case inversion-tm/tag/i:
    { F : ( |- sttp),
      E : ( |- term),
      E1 : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/tag E E1) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dequiv1 : ( |- cn-equiv tagged C t),
      Dof1 : ( |- tm-of F E (tag C2)),
      Dof2 : ( |- tm-of F E1 C2)
    | x : [ |- tm-of F (tm/tag E E1) T]
    ; solve
        [ |- inversion-tm/tag/i C2 (cn-equiv/trans Dequiv1 Dequiv) Dof1 Dof2]
    }
  }
  case tm-of/tag:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    C : ( |- con),
    Dof : ( |- tm-of F E (tag C)),
    Dof1 : ( |- tm-of F E1 C)
  | x : [ |- tm-of F (tm/tag E E1) tagged]
  ; solve [ |- inversion-tm/tag/i C (cn-equiv/refl cn-of/tagged) Dof Dof1]
  }
}
;

LF inversion-tm/iftag/e :
  sttp -> term -> term -> (term -> term) -> term -> con -> type =
| inversion-tm/iftag/i :
  { T' : con }
  tm-of F E1 tagged ->
  tm-of F E2 (tag T') ->
  ({ x : term } { u : { F' : sttp } tm-of F' x T' } tm-of F (E3 x) T) ->
  tm-of F E4 T ->
    inversion-tm/iftag/e F E1 E2 E3 E4 T
;

proof inversion-tm/iftag :
  [ |- tm-of F (tm/iftag E1 E2 (\x. E3) E4) T] ->
    [ |- inversion-tm/iftag/e F E1 E2 (\x. E3) E4 T] =
/ total 1 /
intros
{ F : ( |- sttp),
  E : ( |- term),
  E1 : ( |- term),
  E2 : (y125 : term |- term),
  E3 : ( |- term),
  T : ( |- con)
| x : [ |- tm-of F (tm/iftag E E1 (\x. E2) E3) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    E2 : (y125 : term |- term),
    E3 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/iftag E E1 (\x. E2) E3) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/iftag E E1 (\x. E2) E3) T]
  ; split inversion-tm/iftag [ |- Dof] as
    case inversion-tm/iftag/i:
    { F : ( |- sttp),
      E : ( |- term),
      E1 : ( |- term),
      E2 : (y125 : term |- term),
      E3 : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/iftag E E1 (\x. E2) E3) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dof1 : ( |- tm-of F E tagged),
      Dof2 : ( |- tm-of F E1 (tag C2)),
      Dof3 :
        (x : term, u : {F' : sttp}  tm-of F' x C2[] |- tm-of F[] (E2[x]) C[]),
      Dof4 : ( |- tm-of F E3 C)
    | x : [ |- tm-of F (tm/iftag E E1 (\x. E2) E3) T]
    ; solve
        [ |-
           inversion-tm/iftag/i C2
           Dof1
           Dof2 (\x. \u. tm-of/equiv Dof3 Dequiv[]) (tm-of/equiv Dof4 Dequiv)]
    }
  }
  case tm-of/iftag:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    E2 : (y125 : term |- term),
    E3 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F E tagged),
    Dof1 : ( |- tm-of F E1 (tag C)),
    Dof2 :
      (x : term, u : {F' : sttp}  tm-of F' x C[] |- tm-of F[] (E2[x]) T[]),
    Dof3 : ( |- tm-of F E3 T)
  | x : [ |- tm-of F (tm/iftag E E1 (\x. E2) E3) T]
  ; solve [ |- inversion-tm/iftag/i C Dof Dof1 (\x. \u. Dof2) Dof3]
  }
}
;

LF inversion-tm/roll/e :
  sttp -> term -> kind -> (con -> con -> con) -> con -> con -> type =
| inversion-tm/roll/i :
  cn-equiv (rec' K C1 C2) T t ->
  tm-of F E (C1 (lam K (\a. rec' K C1 a)) C2) ->
  kd-wf K ->
  ({ a : con } cn-of a (pi K (\l. t)) ->
   { b : con } cn-of b K ->
     cn-of (C1 a b) t) ->
  cn-of C2 K ->
    inversion-tm/roll/e F E K C1 C2 T
;

proof inversion-tm/roll :
  [ |- tm-of F (tm/roll E K (\c1. \c2. C1) C2) T] ->
    [ |- inversion-tm/roll/e F E K (\c1. \c2. C1) C2 T] =
/ total 1 /
intros
{ F : ( |- sttp),
  E : ( |- term),
  K : ( |- kind),
  C : (z126 : con, y127 : con |- con),
  C1 : ( |- con),
  T : ( |- con)
| x : [ |- tm-of F (tm/roll E K (\c1. \c2. C) C1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    K : ( |- kind),
    C : (z126 : con, y127 : con |- con),
    C1 : ( |- con),
    T : ( |- con),
    C2 : ( |- con),
    Dof : ( |- tm-of F (tm/roll E K (\c1. \c2. C) C1) C2),
    Dequiv : ( |- cn-equiv C2 T t)
  | x : [ |- tm-of F (tm/roll E K (\c1. \c2. C) C1) T]
  ; split inversion-tm/roll [ |- Dof] as
    case inversion-tm/roll/i:
    { F : ( |- sttp),
      E : ( |- term),
      K : ( |- kind),
      C : (z126 : con, y127 : con |- con),
      C1 : ( |- con),
      T : ( |- con),
      C2 : ( |- con),
      Dof : ( |- tm-of F (tm/roll E K (\c1. \c2. C) C1) C2),
      Dequiv : ( |- cn-equiv C2 T t),
      Dequiv1 : ( |- cn-equiv (rec' K (\x105. \z105. C) C1) C2 t),
      Dof1 :
        ( |-
           tm-of
             F
             E (C[lam K (\a. rec' K[] (\x105. \z105. C[x105, z105]) a), C1])),
      Dwf : ( |- kd-wf K),
      Dof2 :
        (a : con, y672 : cn-of a (pi K[] (\l. t)), b : con,
         x672 : cn-of b K[] |- cn-of (C[a, b]) t),
      Dof3 : ( |- cn-of C1 K)
    | x : [ |- tm-of F (tm/roll E K (\c1. \c2. C) C1) T]
    ; solve
        [ |-
           inversion-tm/roll/i (cn-equiv/trans Dequiv1 Dequiv)
           Dof1 Dwf (\a. \da. \b. \db. Dof2) Dof3]
    }
  }
  case tm-of/roll:
  { F : ( |- sttp),
    E : ( |- term),
    K : ( |- kind),
    C : (z126 : con, y127 : con |- con),
    C1 : ( |- con),
    Dof :
      ( |-
         tm-of
           F E (C[lam K (\a. rec' K[] (\x105. \z105. C[x105, z105]) a), C1])),
    Dwf : ( |- kd-wf K),
    Dof1 :
      (a : con, x217 : cn-of a (pi K[] (\l. t)), b : con, z217 : cn-of b K[] |-
         cn-of (C[a, b]) t),
    Dof2 : ( |- cn-of C1 K)
  | x :
      [ |-
         tm-of F (tm/roll E K (\c1. \c2. C) C1) (rec' K (\x105. \z105. C) C1)]
  ; solve
      [ |-
         inversion-tm/roll/i (cn-equiv/refl (cn-of/rec Dwf
                                            (\a. \da. \b. \db. Dof1) Dof2))
         Dof Dwf (\a. \da. \b. \db. Dof1) Dof2]
  }
}
;

LF inversion-tm/unroll/e : sttp -> term -> con -> type =
| inversion-tm/unroll/i :
  { K : kind } { C1 : con -> con -> con } { C2 : con }
  cn-equiv (C1 (lam K (\a. rec' K C1 a)) C2) T t ->
  tm-of F E (rec' K C1 C2) ->
    inversion-tm/unroll/e F E T
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/unroll :
  [ |- tm-of F (tm/unroll E) T] ->
    [ |- inversion-tm/unroll/e F E T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/unroll E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/unroll E) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/unroll E) T]
  ; split inversion-tm/unroll [ |- Dof] as
    case inversion-tm/unroll/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/unroll E) C),
      Dequiv : ( |- cn-equiv C T t),
      K : ( |- kind),
      C2 : (y675 : con, x675 : con |- con),
      C3 : ( |- con),
      Dequiv1 :
        ( |-
           cn-equiv
             (C2[lam K (\a. rec' K[] (\x105. \z105. C2[x105, z105]) a), C3])
             C t),
      Dof1 : ( |- tm-of F E (rec' K (\x105. \z105. C2) C3))
    | x : [ |- tm-of F (tm/unroll E) T]
    ; solve
        [ |-
           inversion-tm/unroll/i K
           (\c1. \c2. C2) C3 (cn-equiv/trans Dequiv1 Dequiv) Dof1]
    }
  }
  case tm-of/unroll:
  { F : ( |- sttp),
    E : ( |- term),
    C : (a46 : con, a45 : con |- con),
    C1 : ( |- con),
    K : ( |- kind),
    Dof : ( |- tm-of F E (rec' K (\x105. \z105. C) C1))
  | x :
      [ |-
         tm-of
           F
           (tm/unroll E)
           (C[lam K (\a. rec' K[] (\x105. \z105. C[x105, z105]) a), C1])]
  ; ?
  }
}
;

LF inversion-tm/in/e : sttp -> label -> term -> con -> type =
| inversion-tm/in/i :
  { T' : con }
  cn-equiv (labeled I T') T t ->
  tm-of F E T' ->
    inversion-tm/in/e F I E T
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/in :
  [ |- tm-of F (tm/in I E) T] ->
    [ |- inversion-tm/in/e F I E T] =
/ total 1 /
intros
{ F : ( |- sttp), I : ( |- label), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/in I E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    I : ( |- label),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/in I E) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/in I E) T]
  ; split inversion-tm/in [ |- Dof] as
    case inversion-tm/in/i:
    { F : ( |- sttp),
      I : ( |- label),
      E : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/in I E) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dequiv1 : ( |- cn-equiv (labeled I C2) C t),
      Dof1 : ( |- tm-of F E C2)
    | x : [ |- tm-of F (tm/in I E) T]
    ; solve [ |- inversion-tm/in/i C2 (cn-equiv/trans Dequiv1 Dequiv) Dof1]
    }
  }
  case tm-of/in:
  { F : ( |- sttp),
    I : ( |- label),
    E : ( |- term),
    C : ( |- con),
    Dof : ( |- tm-of F E C)
  | x : [ |- tm-of F (tm/in I E) (labeled I C)]
  ; ?
  }
}
;

LF inversion-tm/out/e : sttp -> term -> con -> type =
| inversion-tm/out/i :
  { L : label }
  tm-of F E (labeled L T) ->
    inversion-tm/out/e F E T
;

proof inversion-tm/out :
  [ |- tm-of F (tm/out E) T] ->
    [ |- inversion-tm/out/e F E T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/out E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/out E) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/out E) T]
  ; split inversion-tm/out [ |- Dof] as
    case inversion-tm/out/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/out E) C),
      Dequiv : ( |- cn-equiv C T t),
      X : ( |- label),
      Dof1 : ( |- tm-of F E (labeled X C))
    | x : [ |- tm-of F (tm/out E) T]
    ; by [ |- cn-equiv/labeled Dequiv] as Dequiv1 unboxed;
      by [ |- tm-of/equiv Dof1 Dequiv1] as Dof2 unboxed;
      solve [ |- inversion-tm/out/i X Dof2]
    }
  }
  case tm-of/out:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- label),
    Dof : ( |- tm-of F E (labeled X T))
  | x : [ |- tm-of F (tm/out E) T]
  ; solve [ |- inversion-tm/out/i X Dof]
  }
}
;

LF inversion-tm/raise/e : sttp -> term -> con -> con -> type =
| inversion-tm/raise/i :
  cn-equiv T' T t ->
  tm-of F E tagged ->
    inversion-tm/raise/e F E T' T
;

proof inversion-tm/raise :
  [ |- tm-of F (tm/raise E T') T] ->
    [ |- inversion-tm/raise/e F E T' T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T' : ( |- con), T : ( |- con)
| x : [ |- tm-of F (tm/raise E T') T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/raise E T') C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/raise E T') T]
  ; split inversion-tm/raise [ |- Dof] as
    case inversion-tm/raise/i:
    { F : ( |- sttp),
      E : ( |- term),
      T' : ( |- con),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/raise E T') C),
      Dequiv : ( |- cn-equiv C T t),
      Dequiv1 : ( |- cn-equiv T' C t),
      Dof1 : ( |- tm-of F E tagged)
    | x : [ |- tm-of F (tm/raise E T') T]
    ; solve [ |- inversion-tm/raise/i (cn-equiv/trans Dequiv1 Dequiv) Dof1]
    }
  }
  case tm-of/raise:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    Dof : ( |- tm-of F E tagged),
    Dof1 : ( |- cn-of T t)
  | x : [ |- tm-of F (tm/raise E T) T]
  ; solve [ |- inversion-tm/raise/i (cn-equiv/refl Dof1) Dof]
  }
}
;

LF inversion-tm/try/e : sttp -> term -> (term -> term) -> con -> type =
| inversion-tm/try/i :
  tm-of F E1 T ->
  ({ x : term } { u : { F' : sttp } tm-of F' x tagged } tm-of F (E2 x) T) ->
    inversion-tm/try/e F E1 E2 T
;

proof inversion-tm/try :
  [ |- tm-of F (tm/try E1 (\x. E2)) T] ->
    [ |- inversion-tm/try/e F E1 (\x. E2) T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : (y130 : term |- term), T : ( |- con)
| x : [ |- tm-of F (tm/try E (\x. E1)) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : (y130 : term |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/try E (\x. E1)) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/try E (\x. E1)) T]
  ; split inversion-tm/try [ |- Dof] as
    case inversion-tm/try/i:
    { F : ( |- sttp),
      E : ( |- term),
      E1 : (y130 : term |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/try E (\x. E1)) C),
      Dequiv : ( |- cn-equiv C T t),
      Dof1 : ( |- tm-of F E C),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x tagged |-
           tm-of F[] (E1[x]) C[])
    | x : [ |- tm-of F (tm/try E (\x. E1)) T]
    ; solve
        [ |-
           inversion-tm/try/i (tm-of/equiv Dof1 Dequiv)
           (\x. \u. tm-of/equiv Dof2 Dequiv[])]
    }
  }
  case tm-of/try:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : (y130 : term |- term),
    T : ( |- con),
    Dof : ( |- tm-of F E T),
    Dof1 :
      (x : term, u : {F' : sttp}  tm-of F' x tagged |- tm-of F[] (E1[x]) T[])
  | x : [ |- tm-of F (tm/try E (\x. E1)) T]
  ; solve [ |- inversion-tm/try/i Dof (\x. \u. Dof1)]
  }
}
;

LF inversion-tm/lett/e : sttp -> term -> (term -> term) -> con -> type =
| inversion-tm/lett/i :
  { T1 : con }
  tm-of F E1 T1 ->
  ({ x : term } { u : { F' : sttp } tm-of F' x T1 } tm-of F (E2 x) T) ->
    inversion-tm/lett/e F E1 E2 T
;

proof inversion-tm/lett :
  [ |- tm-of F (tm/lett E1 (\x. E2)) T] ->
    [ |- inversion-tm/lett/e F E1 (\x. E2) T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : (y131 : term |- term), T : ( |- con)
| x : [ |- tm-of F (tm/lett E (\x. E1)) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : (y131 : term |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/lett E (\x. E1)) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/lett E (\x. E1)) T]
  ; split inversion-tm/lett [ |- Dof] as
    case inversion-tm/lett/i:
    { F : ( |- sttp),
      E : ( |- term),
      E1 : (y131 : term |- term),
      T : ( |- con),
      C : ( |- con),
      Dof : ( |- tm-of F (tm/lett E (\x. E1)) C),
      Dequiv : ( |- cn-equiv C T t),
      C2 : ( |- con),
      Dof1 : ( |- tm-of F E C2),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x C2[] |- tm-of F[] (E1[x]) C[])
    | x : [ |- tm-of F (tm/lett E (\x. E1)) T]
    ; solve
        [ |- inversion-tm/lett/i C2 Dof1 (\x. \u. tm-of/equiv Dof2 Dequiv[])]
    }
  }
  case tm-of/lett:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : (y131 : term |- term),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F E C),
    Dof1 :
      (x : term, u : {F' : sttp}  tm-of F' x C[] |- tm-of F[] (E1[x]) T[])
  | x : [ |- tm-of F (tm/lett E (\x. E1)) T]
  ; solve [ |- inversion-tm/lett/i C Dof (\x. \u. Dof1)]
  }
}
;

proof inversion-tm/snd : [ |- tm-of F (tm/snd M) T] ->
                           [ |- md-of impure F M (sg/datom T)] =
/ total 1 /
intros
{ F : ( |- sttp), M : ( |- module'), T : ( |- con)
| x : [ |- tm-of F (tm/snd M) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    M : ( |- module'),
    T : ( |- con),
    C : ( |- con),
    Dof : ( |- tm-of F (tm/snd M) C),
    Dequiv : ( |- cn-equiv C T t)
  | x : [ |- tm-of F (tm/snd M) T]
  ; by [ |- sg-equiv/datom Dequiv] as DequivS unboxed;
    by inversion-tm/snd [ |- Dof] as DofM unboxed;
    solve md-of/equiv [ |- DequivS] [ |- DofM]
  }
  case tm-of/snd:
  { F : ( |- sttp),
    M : ( |- module'),
    T : ( |- con),
    P : ( |- purity),
    Dof : ( |- md-of P F M (sg/datom T))
  | x : [ |- tm-of F (tm/snd M) T]
  ; solve md-of-forget [ |- Dof]
  }
}
;

% Module Inversion

LF inversion-md/satom/e : con -> sg -> type =
| inversion-md/satom/i :
  { K : kind }
  cn-of C K ->
  sg-sub (sg/satom K) S ->
    inversion-md/satom/e C S
;

proof inversion-md/satom :
  [ |- md-of P F (md/satom C) S] ->
    [ |- inversion-md/satom/e C S] =
/ total /
intros
{ P : ( |- purity), F : ( |- sttp), C : ( |- con), S : ( |- sg)
| mof : [ |- md-of P F (md/satom C) S]
; by mof as Dof unboxed;
  split md-ofp-complete [ |- Dof] as
  case md-ofp-complete/i:
  { P : ( |- purity),
    F : ( |- sttp),
    C : ( |- con),
    S : ( |- sg),
    Dof : ( |- md-of P F (md/satom C) S),
    P2 : ( |- purity),
    S2 : ( |- sg),
    Dofp : ( |- md-ofp P2 F (md/satom C) S2),
    Dsub : ( |- sg-sub S2 S),
    Dpsub : ( |- purity-sub P2 P)
  | mof : [ |- md-of P F (md/satom C) S]
  ; split [ |- Dofp] as
    case md-ofp/satom:
    { P : ( |- purity),
      F : ( |- sttp),
      C : ( |- con),
      S : ( |- sg),
      Dof : ( |- md-of P F (md/satom C) S),
      K : ( |- kind),
      Dofp1 : ( |- cn-ofp C K),
      Dsub : ( |- sg-sub (sg/satom K) S),
      Dpsub : ( |- purity-sub pure P)
    | mof : [ |- md-of P F (md/satom C) S]
    ; by cn-ofp-sound [ |- Dofp1] as Dof' unboxed;
      solve [ |- inversion-md/satom/i _ Dof' Dsub]
    }
  }
}
;

LF inversion-md/datom/e : sttp -> term -> con -> sg -> type =
| inversion-md/datom/i :
  tm-of F E T ->
  sg-sub (sg/datom T) S ->
    inversion-md/datom/e F E T S
;

proof inversion-md/datom :
  [ |- md-of P F (md/datom E T) S] ->
    [ |- inversion-md/datom/e F E T S] =
/ trust / % FIXME: See issue #4
intros
{ P : ( |- purity),
  F : ( |- sttp),
  E : ( |- term),
  T : ( |- con),
  S : ( |- sg)
| mof : [ |- md-of P F (md/datom E T) S]
; by mof as Dof unboxed;
  split md-ofp-complete [ |- Dof] as
  case md-ofp-complete/i:
  { P : ( |- purity),
    F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    S : ( |- sg),
    Dof : ( |- md-of P F (md/datom E T) S),
    P2 : ( |- purity),
    S2 : ( |- sg),
    Dofp : ( |- md-ofp P2 F (md/datom E T) S2),
    Dsub : ( |- sg-sub S2 S),
    Dpsub : ( |- purity-sub P2 P)
  | mof : [ |- md-of P F (md/datom E T) S]
  ; split inversion-md/datom-invert [ |- Dofp] [ |- Dsub] as
    case inversion-md/datom/i:
    { P : ( |- purity),
      F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      S : ( |- sg),
      Dof : ( |- md-of P F (md/datom E T) S),
      P' : ( |- purity),
      S' : ( |- sg),
      Dofp : ( |- md-ofp P' F (md/datom E T) S'),
      Dsub : ( |- sg-sub S' S),
      Dpsub : ( |- purity-sub P' P),
      Dof1 : ( |- tm-of F E T),
      Dsub1 : ( |- sg-sub (sg/datom T) S)
    | mof : [ |- md-of P F (md/datom E T) S]
    ; solve [ |- inversion-md/datom/i Dof1 Dsub1]
    }
  }
}

and proof inversion-md/datom-invert :
  [ |- md-ofp P F (md/datom E T) S'] ->
  [ |- sg-sub S' S] ->
    [ |- inversion-md/datom/e F E T S] =
/ trust / % FIXME: See issue #4
intros
{ P : ( |- purity),
  F : ( |- sttp),
  E : ( |- term),
  T : ( |- con),
  S' : ( |- sg),
  S : ( |- sg)
| ofp : [ |- md-ofp P F (md/datom E T) S'], sub : [ |- sg-sub S' S]
; split ofp as
  case md-ofp/datom:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    S : ( |- sg),
    Dof : ( |- tm-of F E T)
  | ofp : [ |- md-ofp pure F (md/datom E T) (sg/datom T)],
    sub : [ |- sg-sub (sg/datom T) S]
  ; by sub as Dsub unboxed;
    solve [ |- inversion-md/datom/i Dof Dsub]
  }
}
;

LF inversion-md/pair/e : purity -> sttp -> module' -> module' -> sg -> type =
| inversion-md/pair/i :
  { S1 : sg } { S2 : sg }
  md-of P F M1 S1 ->
  md-of P F M2 S2 ->
  sg-sub (sg/sigma S1 (\l. S2)) S ->
    inversion-md/pair/e P F M1 M2 S
;

proof inversion-md/pair :
  [ |- md-of P F (md/pair M1 M2) S] ->
    [ |- inversion-md/pair/e P F M1 M2 S] =
/ total /
?
;

LF inversion-md/dpair/e :
  purity -> sttp -> module' -> (con -> module' -> module') -> sg -> type =
| inversion-md/dpair/i :
  { S1 : sg } { S2 : con -> sg } { K1 : kind }
  md-of P F M1 S1 ->
  sg-fst S1 K1 ->
  ({ a : con } cn-of a K1 ->
   { m : module' } { P' : purity } { F' : sttp } md-of P' F' m S1 ->
   md-fst m a ->
   md-of P F (M2 a m) (S2 a)) ->
  sg-sub (sg/sigma S1 S2) S ->
    inversion-md/dpair/e P F M1 M2 S
;

proof inversion-md/dpair :
  [ |- md-of P F (md/dpair M1 (\a. \m. M2)) S] ->
    [ |- inversion-md/dpair/e P F M1 (\a. \m. M2) S] =
/ trust / % FIXME: See issue #4
?

and proof inversion-md/dpair-ofp :
  [ |- md-ofp P F (md/dpair M1 (\a. \m. M2)) S] ->
    [ |- inversion-md/dpair/e P F M1 (\a. \m. M2) S] =
/ trust / % FIXME: See issue #4
?
;

LF inversion-md/pi1/e : sttp -> module' -> sg -> type =
| inversion-md/pi1/i :
  { S2 : sg }
  md-of pure F M (sg/sigma S1 (\l. S2)) ->
    inversion-md/pi1/e F M S1
;

proof inversion-md/pi1 :
  [ |- md-of P F (md/pi1 M) S1] ->
    [ |- inversion-md/pi1/e F M S1] =
/ total /
?
;

LF inversion-md/pi2/e : sttp -> module' -> sg -> type =
| inversion-md/pi2/i :
  { S1 : sg }
  md-of pure F M (sg/sigma S1 (\l. S2)) ->
    inversion-md/pi2/e F M S1
;

proof inversion-md/pi2 :
  [ |- md-of P F (md/pi2 M) S2] ->
    [ |- inversion-md/pi1/e F M S2] =
/ total /
?
;

LF inversion-md/lam/e :
  purity -> sttp -> sg -> (con -> module' -> module') -> sg -> type =
| inversion-md/lam/i :
  { K1 : kind }
  sg-wf S1 ->
  sg-fst S1 K1 ->
  ({ a : con } cn-of a K1 ->
   { m : module' } { P' : purity } { F' : sttp } md-of P F m S1 ->
   md-of impure F (M a m) ( S2 a)) ->
  sg-sub (sg/pi S1 S2) S ->
    inversion-md/lam/e P F S1 M S
;

LF inversion-md/lam-invert/e :
  purity -> sttp -> sg -> (con -> module' -> module') -> sg -> type =
| inversion-md/lam-invert/i :
  { K1 : kind } { K1s : con -> kind } { S2 : con -> sg }
  sg-wf S1 ->
  sg-fst S1 K1 ->
  ({ a : con } cn-of a K1 ->
   { m : module' } { P' : purity } { F' : sttp } md-of P F m S1 ->
   md-fst m a ->
   cn-ofp a (K1s a) ->
   md-ofp P' F (M a m) (S2 a)) ->
  sg-sub (sg/pi S1 S2) S ->
    inversion-md/lam-invert/e P F S1 M S
;


proof inversion-md/lam :
  [ |- md-of P F (md/lam S1 (\a. \m. M)) S] ->
    [ |- inversion-md/lam/e P F S1 (\a. \m. M) S] =
/ trust / % FIXME: See issue #4
?

and proof inversion-md/lam-invert :
  [ |- md-ofp P F (md/lam S1 (\a. \m. M)) S'] ->
  [ |- sg-sub S' S] ->
    [ |- inversion-md/lam-invert/e P F S1 (\a. \m. M) S] =
/ trust / % FIXME: See issue #4
?
;

LF inversion-md/app/e : purity -> sttp -> module' -> module' -> sg -> type =
| inversion-md/app/i :
  { S1 : sg } { S2 : con -> sg } { C2 : con }
  md-of impure F M1 (sg/pi S1 S2) ->
  md-of pure F M2 S1 ->
  md-fst M2 C2 ->
  sg-sub (S2 C2) S ->
  purity-sub impure P ->
    inversion-md/app/e P F M1 M2 S
;

proof inversion-md/app :
  [ |- md-of P F (md/app M1 M2) S] ->
    [ |- inversion-md/app/e P F M1 M2 S] =
/ total /
?
;

LF inversion-md/in/e : purity -> sttp -> name -> module' -> sg -> type =
| inversion-md/in/i :
  { S' : sg }
  md-of P F M S' ->
  sg-sub (sg/named L S') S ->
    inversion-md/in/e P F L M S
;

LF inversion-md/in-factor/e : purity -> sttp -> name -> module' -> sg -> type =
| inversion-md/in-factor/i :
  { S' : sg }
  md-ofp P F M S' ->
  sg-sub (sg/named L S') S ->
    inversion-md/in-factor/e P F L M S
;

proof inversion-md/in :
  [ |- md-of P F (md/in L M) S] ->
    [ |- inversion-md/in/e P F L M S] =
/ trust / % FIXME: See issue #4
?

and proof inversion-md/in-factor :
  [ |- md-ofp P F (md/in L M) S] ->
    [ |- inversion-md/in-factor/e P F L M S] =
/ trust / % FIXME: See issue #4
?
;

LF inversion-md/out/e : purity -> sttp -> module' -> sg -> type =
| inversion-md/out/i :
  { L : name }
  md-of P F M (sg/named L S) ->
    inversion-md/out/e P F M S
;

proof inversion-md/out :
  [ |- md-of P F (md/out M) S] ->
    [ |- inversion-md/out/e P F M S] =
/ total /
?
;

LF inversion-md/let/e :
  purity -> sttp -> module' -> (con -> module' -> module') -> sg -> sg -> type =
| inversion-md/let/i :
  { S1 : sg } { K1 : kind }
  md-of impure F M1 S1 ->
  sg-fst S1 K1 ->
  ({ a : con } cn-of a K1 ->
   { m : module' } { P' : purity } { F' : sttp } md-of P' F' m S1 ->
   md-fst m a -> md-of impure F (M2 a m) S) ->
  sg-sub S S' ->
  purity-sub impure P ->
    inversion-md/let/e P F M1 M2 S S'
;

LF inversion-md/let-invert/e :
  purity -> sttp -> module' -> (con -> module' -> module') -> sg -> sg -> type =
| inversion-md/let-invert/i :
  { P1 : purity } { P2 : purity } { S1 : sg } { K1 : kind }
  md-of P1 F M1 S1 ->
  sg-fst S1 K1 ->
  ({ a : con } cn-of a K1 ->
   { m : module' } { P' : purity } { F' : sttp } md-of P' F' m S1 ->
   md-fst m a ->
   md-of P2 F (M2 a m) S) ->
  sg-sub S S' ->
  purity-sub impure P ->
    inversion-md/let-invert/e P F M1 M2 S S'
;

proof inversion-md/let :
  [ |- md-of P F (md/let M1 (\a. \m. M2) S) S'] ->
    [ |- inversion-md/let/e P F M1 (\a. \m. M2) S S'] =
/ trust / % FIXME: See issue #4
?

and proof inversion-md/let-invert :
  [ |- md-ofp P F (md/let M1 (\a. \m. M2) S) S''] ->
  [ |- sg-sub S'' S'] ->
    [ |- inversion-md/let-invert/e P F M1 (\a. \m. M2) S S'] =
/ trust / % FIXME: See issue #4
?
;

LF inversion-md/letp/e :
  purity -> sttp -> module' -> (con -> module' -> module') -> sg -> type =
| inversion-md/letp/i :
  { S1 : sg } { S2 : con -> sg } { K1 : kind } { C1 : con }
  md-of pure F M1 S1 ->
  sg-fst S1 K1 ->
  md-fst M1 C1 ->
  ({ a : con } cn-of a K1 ->
   { m : module' } { P' : purity } { F' : sttp } md-of P' F' m S1 ->
   md-fst m a ->
   md-of P F (M2 a m) (S2 a)) ->
  sg-sub (S2 C1) S ->
    inversion-md/letp/e P F M1 M2 S
;

proof inversion-md/letp :
  [ |- md-of P F (md/letp M1 (\a. \m. M2)) S] ->
    [ |- inversion-md/letp/e P F M1 (\a. \m. M2) S] =
/ total /
?
;

LF inversion-md/lete/e :
  purity -> sttp -> term -> con -> (term -> module') -> sg -> type =
| inversion-md/lete/i :
  tm-of F E T ->
  ({ x : term } { F' : sttp } tm-of F' x T -> md-of P F (M x) S) ->
    inversion-md/lete/e P F E T M S
;

proof inversion-md/lete :
  [ |- md-of P F (md/lete E T (\x. M)) S] ->
    [ |- inversion-md/lete/e P F E T (\x. M) S] =
/ total /
?
;

LF inversion-md/seal/e : purity -> sttp -> module' -> sg -> sg -> type =
| inversion-md/seal/i :
  md-of impure F M S ->
  sg-sub S S' ->
  purity-sub impure P ->
    inversion-md/seal/e P F M S S'
;

LF inversion-md/seal-invert/e : purity -> sttp -> module' -> sg -> type =
| inversion-md/seal-invert/i :
  { P' : purity }
  md-of P' F M S ->
  sg-sub S S' ->
  purity-sub impure P ->
    inversion-md/seal-invert/e P F M S
;

proof inversion-md/seal :
  [ |- md-of P F (md/seal M S) S'] ->
    [ |- inversion-md/seal/e P F M S S'] =
/ trust / % FIXME: See issue #4
?

and proof inversion-md/seal-invert :
  [ |- md-ofp P F (md/seal M S) S''] ->
  [ |- sg-sub S'' S'] ->
    [ |- inversion-md/seal-invert/e P F M S] =
/ trust / % FIXME: See issue #4
?
;
