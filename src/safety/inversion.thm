% Term Inversion

proof inversion-tm/abort/tm-of : [ |- tm-of F (tm/abort E T) T'] ->
                                   [ |- tm-of F E void] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con), T' : ( |- con)
| x : [ |- tm-of F (tm/abort E T) T']
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    T' : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T' t),
    X1 : ( |- tm-of F (tm/abort E T) C)
  | x : [ |- tm-of F (tm/abort E T) T']
  ; solve inversion-tm/abort/tm-of [ |- X1]
  }
  case tm-of/abort:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    X : ( |- cn-of T' t),
    X1 : ( |- tm-of F E void)
  | x : [ |- tm-of F (tm/abort E T') T']
  ; solve [ |- X1]
  }
}
;

proof inversion-tm/abort/cn-equiv : [ |- tm-of F (tm/abort E T) T'] ->
                                      [ |- cn-equiv T T' t] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con), T' : ( |- con)
| x : [ |- tm-of F (tm/abort E T) T']
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    T' : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T' t),
    X1 : ( |- tm-of F (tm/abort E T) C)
  | x : [ |- tm-of F (tm/abort E T) T']
  ; by inversion-tm/abort/cn-equiv [ |- X1] as Q unboxed;
    solve [ |- cn-equiv/trans Q X]
  }
  case tm-of/abort:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    X : ( |- cn-of T' t),
    X1 : ( |- tm-of F E void)
  | x : [ |- tm-of F (tm/abort E T') T']
  ; solve [ |- cn-equiv/refl X]
  }
}
;

LF inversion-tm/pair/cn-equiv/existT1T2 : con -> type =
| inversion-tm/pair/cn-equiv/existT1T2/i :
  { T1 : con } {T2 : con} cn-equiv (prod T1 T2) T t ->
    inversion-tm/pair/cn-equiv/existT1T2 T
;

proof inversion-tm/pair/cn-equiv/existT1T2/i :
  { T1 : [ |- con] } { T2 : [ |- con] } [ |- cn-equiv (prod T1 T2) T t] ->
    [ |- inversion-tm/pair/cn-equiv/existT1T2 T] =
/ total /
intros
{ T : ( |- con), T1 : ( |- con), T2 : ( |- con)
| x : [ |- cn-equiv (prod T1 T2) T t]
; by x as X unboxed;
  solve [ |- inversion-tm/pair/cn-equiv/existT1T2/i T1 T2 X]
}
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/pair/cn-equiv :
  [ |- tm-of F (tm/pair E1 E2) T] ->
    [ |- inversion-tm/pair/cn-equiv/existT1T2 T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/pair E E1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/pair E E1) C)
  | x : [ |- tm-of F (tm/pair E E1) T]
  ; by inversion-tm/pair/cn-equiv [ |- X1] as q;
    split q as
    case inversion-tm/pair/cn-equiv/existT1T2/i:
    { F : ( |- sttp),
      E : ( |- term),
      E1 : ( |- term),
      T : ( |- con),
      C : ( |- con),
      X : ( |- cn-equiv C T t),
      X1 : ( |- tm-of F (tm/pair E E1) C),
      C2 : ( |- con),
      C3 : ( |- con),
      X2 : ( |- cn-equiv (prod C2 C3) C t)
    | x : [ |- tm-of F (tm/pair E E1) T],
      q : [ |- inversion-tm/pair/cn-equiv/existT1T2 C]
    ; suffices by inversion-tm/pair/cn-equiv/existT1T2/i [ |- C2] [ |- C3] toshow
      [ |- cn-equiv (prod C2 C3) T t] {
        solve [ |- cn-equiv/trans X2 X]
      }
    }
  }
  case tm-of/pair:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    C : ( |- con),
    C1 : ( |- con),
    X : ( |- tm-of F E C),
    X1 : ( |- tm-of F E1 C1)
  | x : [ |- tm-of F (tm/pair E E1) (prod C C1)]
  ; ?
  }
}
;

LF inversion-tm/pair/tm-of/existsT : sttp -> term -> type =
| inversion-tm/pair/tm-of/existsT/i :
  { T : con } tm-of F E T ->
    inversion-tm/pair/tm-of/existsT F E
;

proof inversion-tm/pair/tm-of/existsT/i :
  { T : [ |- con] } [ |- tm-of F E T] ->
    [ |- inversion-tm/pair/tm-of/existsT F E] =
/ total /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F E T]
; by x as X unboxed;
  solve [ |- inversion-tm/pair/tm-of/existsT/i T X]
}
;

proof inversion-tm/pair/tm-of1 :
  [ |- tm-of F (tm/pair E1 E2) T] ->
    [ |- inversion-tm/pair/tm-of/existsT F E1] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/pair E E1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/pair E E1) C)
  | x : [ |- tm-of F (tm/pair E E1) T]
  ; solve inversion-tm/pair/tm-of1 [ |- X1]
  }
  case tm-of/pair:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    C : ( |- con),
    C1 : ( |- con),
    X : ( |- tm-of F E C),
    X1 : ( |- tm-of F E1 C1)
  | x : [ |- tm-of F (tm/pair E E1) (prod C C1)]
  ; suffices by inversion-tm/pair/tm-of/existsT/i [ |- C] toshow
    [ |- tm-of F E C] {
      solve [ |- X]
    }
  }
}

and proof inversion-tm/pair/tm-of2 :
  [ |- tm-of F (tm/pair E1 E2) T] ->
    [ |- inversion-tm/pair/tm-of/existsT F E2] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/pair E E1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/pair E E1) C)
  | x : [ |- tm-of F (tm/pair E E1) T]
  ; solve inversion-tm/pair/tm-of2 [ |- X1]
  }
  case tm-of/pair:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    C : ( |- con),
    C1 : ( |- con),
    X : ( |- tm-of F E C),
    X1 : ( |- tm-of F E1 C1)
  | x : [ |- tm-of F (tm/pair E E1) (prod C C1)]
  ; suffices by inversion-tm/pair/tm-of/existsT/i [ |- C1] toshow
    [ |- tm-of F E1 C1] {
      solve [ |- X1]
    }
  }
}
;

LF inversion-tm/pi1/existsT2 : sttp -> term -> con -> type =
| inversion-tm/pi1/existsT2/i :
  { T2 : con } tm-of F E (prod T1 T2) ->
    inversion-tm/pi1/existsT2 F E T1
;

proof inversion-tm/pi1/existsT2/i :
  { T2 : [ |- con] } [ |- tm-of F E (prod T1 T2)] ->
    [ |- inversion-tm/pi1/existsT2 F E T1] =
/ total /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con), T1 : ( |- con)
| x : [ |- tm-of F E (prod T T1)]
; by x as X unboxed;
  solve [ |- inversion-tm/pi1/existsT2/i T1 X]
}
;

% TODO: Depends on `tm-of-reg`, `inversion-prod/1`
proof inversion-tm/pi1 :
  [ |- tm-of F (tm/pi1 E) T1] ->
    [ |- inversion-tm/pi1/existsT2 F E T1] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/pi1 E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/pi1 E) C)
  | x : [ |- tm-of F (tm/pi1 E) T]
  ; by inversion-tm/pi1 [ |- X1] as q;
    split q as
    case inversion-tm/pi1/existsT2/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      C : ( |- con),
      X : ( |- cn-equiv C T t),
      X1 : ( |- tm-of F (tm/pi1 E) C),
      C2 : ( |- con),
      X2 : ( |- tm-of F E (prod C C2))
    | x : [ |- tm-of F (tm/pi1 E) T],
      q : [ |- inversion-tm/pi1/existsT2 F E C]
    ; ?
    }
  }
  case tm-of/pi1:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C1 : ( |- con),
    X : ( |- tm-of F E (prod T C1))
  | x : [ |- tm-of F (tm/pi1 E) T]
  ; suffices by inversion-tm/pi1/existsT2/i [ |- C1] toshow
    [ |- tm-of F E (prod T C1)] {
      solve [ |- X]
    }
  }
}
;


LF inversion-tm/refloc/cn-equiv/existsT' : con -> type =
| inversion-tm/refloc/cn-equiv/existsT'/i :
  { T' : con } cn-equiv (ref T') T t ->
    inversion-tm/refloc/cn-equiv/existsT' T
;

proof inversion-tm/refloc/cn-equiv/existsT'/i :
  { T' : [ |- con] } [ |- cn-equiv (ref T') T t] ->
    [ |- inversion-tm/refloc/cn-equiv/existsT' T] =
/ total /
intros
{ T : ( |- con), T' : ( |- con)
| x : [ |- cn-equiv (ref T') T t]
; by x as X unboxed;
  solve [ |- inversion-tm/refloc/cn-equiv/existsT'/i T' X]
}
;

proof inversion-tm/refloc/cn-equiv :
  [ |- tm-of F (tm/refloc L) T] ->
    [ |- inversion-tm/refloc/cn-equiv/existsT' T] =
/ total 1 /
intros
{ F : ( |- sttp), L : ( |- location), T : ( |- con)
| x : [ |- tm-of F (tm/refloc L) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    L : ( |- location),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/refloc L) C)
  | x : [ |- tm-of F (tm/refloc L) T]
  ; by inversion-tm/refloc/cn-equiv [ |- X1] as q;
    split q as
    case inversion-tm/refloc/cn-equiv/existsT'/i:
    { F : ( |- sttp),
      L : ( |- location),
      T : ( |- con),
      C : ( |- con),
      X : ( |- cn-equiv C T t),
      X1 : ( |- tm-of F (tm/refloc L) C),
      C2 : ( |- con),
      X2 : ( |- cn-equiv (ref C2) C t)
    | x : [ |- tm-of F (tm/refloc L) T],
      q : [ |- inversion-tm/refloc/cn-equiv/existsT' C]
    ; suffices by inversion-tm/refloc/cn-equiv/existsT'/i [ |- C2] toshow
      [ |- cn-equiv (ref C2) T t] {
        solve [ |- cn-equiv/trans X2 X]
      }
    }
  }
  case tm-of/refloc:
  { F : ( |- sttp),
    L : ( |- location),
    C : ( |- con),
    X1 : ( |- cn-of C t),
    X2 : ( |- st-lookup F L (et/ref C))
  | x : [ |- tm-of F (tm/refloc L) (ref C)]
  ; suffices by inversion-tm/refloc/cn-equiv/existsT'/i [ |- C] toshow
    [ |- cn-equiv (ref C) (ref C) t] {
      solve [ |- cn-equiv/refl (cn-of/ref X1)]
    }
  }
}
;

LF inversion-tm/refloc/st-lookup/existsT' : sttp -> location -> type =
| inversion-tm/refloc/st-lookup/existsT'/i :
  { T' : con } st-lookup F L (et/ref T') ->
    inversion-tm/refloc/st-lookup/existsT' F L
;

proof inversion-tm/refloc/st-lookup :
  [ |- tm-of F (tm/refloc L) T] ->
    [ |- inversion-tm/refloc/st-lookup/existsT' F L] =
/ total 1 /
intros
{ F : ( |- sttp), L : ( |- location), T : ( |- con)
| x : [ |- tm-of F (tm/refloc L) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    L : ( |- location),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/refloc L) C)
  | x : [ |- tm-of F (tm/refloc L) T]
  ; solve inversion-tm/refloc/st-lookup [ |- X1]
  }
  case tm-of/refloc:
  { F : ( |- sttp),
    L : ( |- location),
    C : ( |- con),
    X1 : ( |- cn-of C t),
    X2 : ( |- st-lookup F L (et/ref C))
  | x : [ |- tm-of F (tm/refloc L) (ref C)]
  ; solve [ |- inversion-tm/refloc/st-lookup/existsT'/i C X2]
  }
}
;

LF inversion-tm/refloc/cn-of/existsT' : type =
| inversion-tm/refloc/cn-of/existsT'/i : { T' : con } cn-of T' t ->
                                           inversion-tm/refloc/cn-of/existsT'
;

proof inversion-tm/refloc/cn-of :
  [ |- tm-of F (tm/refloc L) T] ->
    [ |- inversion-tm/refloc/cn-of/existsT'] =
/ total 1 /
intros
{ F : ( |- sttp), L : ( |- location), T : ( |- con)
| x : [ |- tm-of F (tm/refloc L) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    L : ( |- location),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/refloc L) C)
  | x : [ |- tm-of F (tm/refloc L) T]
  ; solve inversion-tm/refloc/cn-of [ |- X1]
  }
  case tm-of/refloc:
  { F : ( |- sttp),
    L : ( |- location),
    C : ( |- con),
    X1 : ( |- cn-of C t),
    X2 : ( |- st-lookup F L (et/ref C))
  | x : [ |- tm-of F (tm/refloc L) (ref C)]
  ; solve [ |- inversion-tm/refloc/cn-of/existsT'/i C X1]
  }
}
;

proof inversion-tm/deref : [ |- tm-of F (tm/deref E) T] ->
                             [ |- tm-of F E (ref T)] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/deref E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/deref E) C)
  | x : [ |- tm-of F (tm/deref E) T]
  ; by [ |- cn-equiv/ref X] as Q1 unboxed;
    by inversion-tm/deref [ |- X1] as Q2 unboxed;
    solve [ |- tm-of/equiv Q1 Q2]
  }
  case tm-of/deref:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- tm-of F E (ref T))
  | x : [ |- tm-of F (tm/deref E) T]
  ; solve [ |- X]
  }
}
;

LF inversion-tm/tagloc/cn-equiv/existsT' : con -> type =
| inversion-tm/tagloc/cn-equiv/existsT'/i :
  { T' : con} cn-equiv (tag T') T t ->
    inversion-tm/tagloc/cn-equiv/existsT' T
;

proof inversion-tm/tagloc/cn-equiv/existsT'/i :
  { T' : [ |- con] } [ |- cn-equiv (tag T') T t] ->
    [ |- inversion-tm/tagloc/cn-equiv/existsT' T] =
/ total /
intros
{ T : ( |- con), T' : ( |- con)
| x : [ |- cn-equiv (tag T') T t]
; by x as X unboxed;
  solve [ |- inversion-tm/tagloc/cn-equiv/existsT'/i T' X]
}
;

proof inversion-tm/tagloc/cn-equiv :
  [ |- tm-of F (tm/tagloc L) T] ->
    [ |- inversion-tm/tagloc/cn-equiv/existsT' T] =
/ total 1 /
intros
{ F : ( |- sttp), L : ( |- location), T : ( |- con)
| x : [ |- tm-of F (tm/tagloc L) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    L : ( |- location),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/tagloc L) C)
  | x : [ |- tm-of F (tm/tagloc L) T]
  ; by inversion-tm/tagloc/cn-equiv [ |- X1] as q;
    split q as
    case inversion-tm/tagloc/cn-equiv/existsT'/i:
    { F : ( |- sttp),
      L : ( |- location),
      T : ( |- con),
      C : ( |- con),
      X : ( |- cn-equiv C T t),
      X1 : ( |- tm-of F (tm/tagloc L) C),
      C2 : ( |- con),
      X2 : ( |- cn-equiv (tag C2) C t)
    | x : [ |- tm-of F (tm/tagloc L) T],
      q : [ |- inversion-tm/tagloc/cn-equiv/existsT' C]
    ; suffices by inversion-tm/tagloc/cn-equiv/existsT'/i [ |- C2] toshow
      [ |- cn-equiv (tag C2) T t] {
        solve [ |- cn-equiv/trans X2 X]
      }
    }
  }
  case tm-of/tagloc:
  { F : ( |- sttp),
    L : ( |- location),
    C : ( |- con),
    X1 : ( |- cn-of C t),
    X2 : ( |- st-lookup F L (et/tag C))
  | x : [ |- tm-of F (tm/tagloc L) (tag C)]
  ; suffices by inversion-tm/tagloc/cn-equiv/existsT'/i [ |- C] toshow
    [ |- cn-equiv (tag C) (tag C) t] {
      solve [ |- cn-equiv/refl (cn-of/tag X1)]
    }
  }
}
;

LF inversion-tm/tagloc/st-lookup/existsT' : sttp -> location -> type =
| inversion-tm/tagloc/st-lookup/existsT'/i :
  { T' : con } st-lookup F L (et/tag T') ->
    inversion-tm/tagloc/st-lookup/existsT' F L
;

proof inversion-tm/tagloc/st-lookup :
  [ |- tm-of F (tm/tagloc L) T] ->
    [ |- inversion-tm/tagloc/st-lookup/existsT' F L] =
/ total 1 /
intros
{ F : ( |- sttp), L : ( |- location), T : ( |- con)
| x : [ |- tm-of F (tm/tagloc L) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    L : ( |- location),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/tagloc L) C)
  | x : [ |- tm-of F (tm/tagloc L) T]
  ; solve inversion-tm/tagloc/st-lookup [ |- X1]
  }
  case tm-of/tagloc:
  { F : ( |- sttp),
    L : ( |- location),
    C : ( |- con),
    X1 : ( |- cn-of C t),
    X2 : ( |- st-lookup F L (et/tag C))
  | x : [ |- tm-of F (tm/tagloc L) (tag C)]
  ; solve [ |- inversion-tm/tagloc/st-lookup/existsT'/i C X2]
  }
}
;

LF inversion-tm/tagloc/cn-of/existsT' : type =
| inversion-tm/tagloc/cn-of/existsT'/i : { T' : con } cn-of T' t ->
                                           inversion-tm/tagloc/cn-of/existsT'
;

proof inversion-tm/tagloc/cn-of :
  [ |- tm-of F (tm/tagloc L) T] ->
    [ |- inversion-tm/tagloc/cn-of/existsT'] =
/ total 1 /
intros
{ F : ( |- sttp), L : ( |- location), T : ( |- con)
| x : [ |- tm-of F (tm/tagloc L) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    L : ( |- location),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/tagloc L) C)
  | x : [ |- tm-of F (tm/tagloc L) T]
  ; solve inversion-tm/tagloc/cn-of [ |- X1]
  }
  case tm-of/tagloc:
  { F : ( |- sttp),
    L : ( |- location),
    C : ( |- con),
    X1 : ( |- cn-of C t),
    X2 : ( |- st-lookup F L (et/tag C))
  | x : [ |- tm-of F (tm/tagloc L) (tag C)]
  ; solve [ |- inversion-tm/tagloc/cn-of/existsT'/i C X1]
  }
}
;

proof inversion-tm/newtag : [ |- tm-of F (tm/newtag T') T] ->
                              [ |- cn-equiv (tag T') T t] =
/ total 1 /
intros
{ F : ( |- sttp), T' : ( |- con), T : ( |- con)
| x : [ |- tm-of F (tm/newtag T') T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    T' : ( |- con),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/newtag T') C)
  | x : [ |- tm-of F (tm/newtag T') T]
  ; by inversion-tm/newtag [ |- X1] as Q unboxed;
    solve [ |- cn-equiv/trans Q X]
  }
  case tm-of/newtag:
  { F : ( |- sttp), T' : ( |- con), X : ( |- cn-of T' t)
  | x : [ |- tm-of F (tm/newtag T') (tag T')]
  ; solve [ |- cn-equiv/refl (cn-of/tag X)]
  }
}
;

proof inversion-tm/tag/cn-equiv : [ |- tm-of F (tm/tag E1 E2) T] ->
                                    [ |- cn-equiv tagged T t] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/tag E E1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/tag E E1) C)
  | x : [ |- tm-of F (tm/tag E E1) T]
  ; by inversion-tm/tag/cn-equiv [ |- X1] as Q unboxed;
    solve [ |- cn-equiv/trans Q X]
  }
  case tm-of/tag:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    C : ( |- con),
    X : ( |- tm-of F E1 C),
    X1 : ( |- tm-of F E (tag C))
  | x : [ |- tm-of F (tm/tag E E1) tagged]
  ; solve [ |- cn-equiv/refl cn-of/tagged]
  }
}
;

LF inversion-tm/tag/tm-of1/existsT' : sttp -> term -> type =
| inversion-tm/tag/tm-of1/existsT'/i :
  { T' : con } tm-of F E1 (tag T') ->
    inversion-tm/tag/tm-of1/existsT' F E1
;

proof inversion-tm/tag/tm-of1 :
  [ |- tm-of F (tm/tag E1 E2) T] ->
    [ |- inversion-tm/tag/tm-of1/existsT' F E1] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/tag E E1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/tag E E1) C)
  | x : [ |- tm-of F (tm/tag E E1) T]
  ; solve inversion-tm/tag/tm-of1 [ |- X1]
  }
  case tm-of/tag:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    C : ( |- con),
    X : ( |- tm-of F E1 C),
    X1 : ( |- tm-of F E (tag C))
  | x : [ |- tm-of F (tm/tag E E1) tagged]
  ; solve [ |- inversion-tm/tag/tm-of1/existsT'/i C X1]
  }
}
;

LF inversion-tm/tag/tm-of2/existsT' : sttp -> term -> type =
| inversion-tm/tag/tm-of2/existsT'/i :
  { T' : con } tm-of F E2 T' ->
    inversion-tm/tag/tm-of2/existsT' F E2
;

proof inversion-tm/tag/tm-of2 :
  [ |- tm-of F (tm/tag E1 E2) T] ->
    [ |- inversion-tm/tag/tm-of2/existsT' F E2] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), E1 : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/tag E E1) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/tag E E1) C)
  | x : [ |- tm-of F (tm/tag E E1) T]
  ; solve inversion-tm/tag/tm-of2 [ |- X1]
  }
  case tm-of/tag:
  { F : ( |- sttp),
    E : ( |- term),
    E1 : ( |- term),
    C : ( |- con),
    X : ( |- tm-of F E1 C),
    X1 : ( |- tm-of F E (tag C))
  | x : [ |- tm-of F (tm/tag E E1) tagged]
  ; solve [ |- inversion-tm/tag/tm-of2/existsT'/i C X]
  }
}
;

LF inversion-tm/out/existsL : sttp -> term -> con -> type =
| inversion-tm/out/existsL/i : { L : label } tm-of F E (labeled L T) ->
                                 inversion-tm/out/existsL F E T
;

proof inversion-tm/out : [ |- tm-of F (tm/out E) T] ->
                           [ |- inversion-tm/out/existsL F E T] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con)
| x : [ |- tm-of F (tm/out E) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/out E) C)
  | x : [ |- tm-of F (tm/out E) T]
  ; by inversion-tm/out [ |- X1] as q;
    split q as
    case inversion-tm/out/existsL/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      C : ( |- con),
      X : ( |- cn-equiv C T t),
      X1 : ( |- tm-of F (tm/out E) C),
      X2 : ( |- label),
      X3 : ( |- tm-of F E (labeled X2 C))
    | x : [ |- tm-of F (tm/out E) T],
      q : [ |- inversion-tm/out/existsL F E C]
    ; by [ |- cn-equiv/labeled X] as Q1 unboxed;
      by [ |- tm-of/equiv Q1 X3] as Q2 unboxed;
      solve [ |- inversion-tm/out/existsL/i X2 Q2]
    }
  }
  case tm-of/out:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- label),
    X1 : ( |- tm-of F E (labeled X T))
  | x : [ |- tm-of F (tm/out E) T]
  ; solve [ |- inversion-tm/out/existsL/i X X1]
  }
}
;

proof inversion-tm/raise/cn-equiv : [ |- tm-of F (tm/raise E T') T] ->
                                      [ |- cn-equiv T' T t] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T' : ( |- con), T : ( |- con)
| x : [ |- tm-of F (tm/raise E T') T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/raise E T') C)
  | x : [ |- tm-of F (tm/raise E T') T]
  ; by inversion-tm/raise/cn-equiv [ |- X1] as Q unboxed;
    solve [ |- cn-equiv/trans Q X]
  }
  case tm-of/raise:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- cn-of T t),
    X1 : ( |- tm-of F E tagged)
  | x : [ |- tm-of F (tm/raise E T) T]
  ; solve [ |- cn-equiv/refl X]
  }
}

and proof inversion-tm/raise/tm-of : [ |- tm-of F (tm/raise E T') T] ->
                                   [ |- tm-of F E tagged] =
/ total 1 /
intros
{ F : ( |- sttp), E : ( |- term), T' : ( |- con), T : ( |- con)
| x : [ |- tm-of F (tm/raise E T') T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    E : ( |- term),
    T' : ( |- con),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/raise E T') C)
  | x : [ |- tm-of F (tm/raise E T') T]
  ; solve inversion-tm/raise/tm-of [ |- X1]
  }
  case tm-of/raise:
  { F : ( |- sttp),
    E : ( |- term),
    T : ( |- con),
    X : ( |- cn-of T t),
    X1 : ( |- tm-of F E tagged)
  | x : [ |- tm-of F (tm/raise E T) T]
  ; solve [ |- X1]
  }
}
;

proof inversion-tm/snd : [ |- tm-of F (tm/snd M) T] ->
                           [ |- md-of impure F M (sg/datom T)] =
/ total 1 /
intros
{ F : ( |- sttp), M : ( |- module'), T : ( |- con)
| x : [ |- tm-of F (tm/snd M) T]
; split x as
  case tm-of/equiv:
  { F : ( |- sttp),
    M : ( |- module'),
    T : ( |- con),
    C : ( |- con),
    X : ( |- cn-equiv C T t),
    X1 : ( |- tm-of F (tm/snd M) C)
  | x : [ |- tm-of F (tm/snd M) T]
  ; by [ |- sg-equiv/datom X] as Q1 unboxed;
    by inversion-tm/snd [ |- X1] as Q2 unboxed;
    solve md-of/equiv [ |- Q1] [ |- Q2]
  }
  case tm-of/snd:
  { F : ( |- sttp),
    M : ( |- module'),
    T : ( |- con),
    P : ( |- purity),
    X : ( |- md-of P F M (sg/datom T))
  | x : [ |- tm-of F (tm/snd M) T]
  ; solve md-of-forget [ |- X]
  }
}
;
