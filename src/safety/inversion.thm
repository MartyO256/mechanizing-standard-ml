% Term Inversion

proof inversion-tm/abort/tm-of : [ |- tm-of F (tm/abort E T) T'] ->
                                   [ |- tm-of F E void] =
/ total 1 /
?
;

proof inversion-tm/abort/cn-equiv : [ |- tm-of F (tm/abort E T) T'] ->
                                      [ |- cn-equiv T T' t] =
/ total 1 /
?
;

LF inversion-tm/pair/cn-equiv/existT1T2 : con -> type =
| inversion-tm/pair/cn-equiv/existT1T2/i :
  { T1 : con } {T2 : con} cn-equiv (prod T1 T2) T t ->
    inversion-tm/pair/cn-equiv/existT1T2 T
;

proof inversion-tm/pair/cn-equiv/existT1T2/i :
  { T1 : [ |- con] } { T2 : [ |- con] } [ |- cn-equiv (prod T1 T2) T t] ->
    [ |- inversion-tm/pair/cn-equiv/existT1T2 T] =
/ total /
?
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/pair/cn-equiv :
  [ |- tm-of F (tm/pair E1 E2) T] ->
    [ |- inversion-tm/pair/cn-equiv/existT1T2 T] =
/ total 1 /
?
;

LF inversion-tm/pair/tm-of/existsT : sttp -> term -> type =
| inversion-tm/pair/tm-of/existsT/i :
  { T : con } tm-of F E T ->
    inversion-tm/pair/tm-of/existsT F E
;

proof inversion-tm/pair/tm-of/existsT/i :
  { T : [ |- con] } [ |- tm-of F E T] ->
    [ |- inversion-tm/pair/tm-of/existsT F E] =
/ total /
?
;

proof inversion-tm/pair/tm-of1 :
  [ |- tm-of F (tm/pair E1 E2) T] ->
    [ |- inversion-tm/pair/tm-of/existsT F E1] =
/ total 1 /
?
;

proof inversion-tm/pair/tm-of2 :
  [ |- tm-of F (tm/pair E1 E2) T] ->
    [ |- inversion-tm/pair/tm-of/existsT F E2] =
/ total 1 /
?
;

LF inversion-tm/pi1/existsT2 : sttp -> term -> con -> type =
| inversion-tm/pi1/existsT2/i :
  { T2 : con } tm-of F E (prod T1 T2) ->
    inversion-tm/pi1/existsT2 F E T1
;

proof inversion-tm/pi1/existsT2/i :
  { T2 : [ |- con] } [ |- tm-of F E (prod T1 T2)] ->
    [ |- inversion-tm/pi1/existsT2 F E T1] =
/ total /
?
;

% TODO: Depends on `tm-of-reg`, `inversion-prod/1`
proof inversion-tm/pi1 :
  [ |- tm-of F (tm/pi1 E) T1] ->
    [ |- inversion-tm/pi1/existsT2 F E T1] =
/ total 1 /
?
;

LF inversion-tm/pi2/existsT1 : sttp -> term -> con -> type =
| inversion-tm/pi2/existsT1/i :
  { T1 : con } tm-of F E (prod T1 T2) ->
    inversion-tm/pi2/existsT1 F E T2
;

proof inversion-tm/pi2/existsT1/i :
  { T1 : [ |- con] } [ |- tm-of F E (prod T1 T2)] ->
    [ |- inversion-tm/pi2/existsT1 F E T2] =
/ total /
?
;

% TODO: Depends on `tm-of-reg`, `inversion-prod/2`
proof inversion-tm/pi2 :
  [ |- tm-of F (tm/pi2 E) T2] ->
    [ |- inversion-tm/pi2/existsT1 F E T2] =
/ total 1 /
?
;

LF inversion-tm/in1/cn-equiv/existsT1 : con -> con -> type =
| inversion-tm/in1/cn-equiv/existsT1/i :
  { T1 : con } cn-equiv (plus T1 T2) T t ->
    inversion-tm/in1/cn-equiv/existsT1 T2 T
;

proof inversion-tm/in1/cn-equiv/existsT1/i :
  { T1 : [ |- con] } [ |- cn-equiv (plus T1 T2) T t] ->
    [ |- inversion-tm/in1/cn-equiv/existsT1 T2 T] =
/ total /
?
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/in1/cn-equiv :
  [ |- tm-of F (tm/in1 E T2) T] ->
    [ |- inversion-tm/in1/cn-equiv/existsT1 T2 T] =
/ total 1 /
?
;

LF inversion-tm/in1/tm-of/existsT1 : sttp -> term -> type =
| inversion-tm/in1/tm-of/existsT1/i :
  { T1 : con } tm-of F E T1 ->
    inversion-tm/in1/tm-of/existsT1 F E
;

proof inversion-tm/in1/tm-of/existsT1/i :
  { T1 : [ |- con] } [ |- tm-of F E T1] ->
    [ |- inversion-tm/in1/tm-of/existsT1 F E] =
/ total /
?
;

proof inversion-tm/in1/tm-of :
  [ |- tm-of F (tm/in1 E T2) T] ->
    [ |- inversion-tm/in1/tm-of/existsT1 F E] =
/ total 1 /
?
;

proof inversion-tm/in1/cn-of :
  [ |- tm-of F (tm/in1 E T2) T] ->
    [ |- cn-of T2 t] =
/ total 1 /
?
;

LF inversion-tm/in2/cn-equiv/existsT2 : con -> con -> type =
| inversion-tm/in2/cn-equiv/existsT2/i :
  { T2 : con } cn-equiv (plus T1 T2) T t ->
    inversion-tm/in2/cn-equiv/existsT2 T1 T
;

proof inversion-tm/in2/cn-equiv/existsT2/i :
  { T2 : [ |- con] } [ |- cn-equiv (plus T1 T2) T t] ->
    [ |- inversion-tm/in2/cn-equiv/existsT2 T1 T] =
/ total /
?
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/in2/cn-equiv :
  [ |- tm-of F (tm/in2 E T1) T] ->
    [ |- inversion-tm/in2/cn-equiv/existsT2 T1 T] =
/ total 1 /
?
;

LF inversion-tm/in2/tm-of/existsT2 : sttp -> term -> type =
| inversion-tm/in2/tm-of/existsT2/i :
  { T2 : con } tm-of F E T2 ->
    inversion-tm/in2/tm-of/existsT2 F E
;

proof inversion-tm/in2/tm-of/existsT2/i :
  { T2 : [ |- con] } [ |- tm-of F E T2] ->
    [ |- inversion-tm/in2/tm-of/existsT2 F E] =
/ total /
?
;

proof inversion-tm/in2/tm-of :
  [ |- tm-of F (tm/in2 E T1) T] ->
    [ |- inversion-tm/in2/tm-of/existsT2 F E] =
/ total 1 /
?
;

proof inversion-tm/in2/cn-of :
  [ |- tm-of F (tm/in2 E T1) T] ->
    [ |- cn-of T1 t] =
/ total 1 /
?
;

LF inversion-tm/case/tm-ofE/existT1T2 : sttp -> term -> type =
| inversion-tm/case/tm-ofE/existT1T2/i :
  { T1 : con } { T2 : con } tm-of F E (plus T1 T2) ->
    inversion-tm/case/tm-ofE/existT1T2 F E
;

proof inversion-tm/case/tm-ofE/existT1T2/i :
  { T1 : [ |- con] } { T2 : [ |- con] } [ |- tm-of F E (plus T1 T2)] ->
    [ |- inversion-tm/case/tm-ofE/existT1T2 F E] =
/ total /
?
;

proof inversion-tm/case/tm-ofE :
  [ |- tm-of F (tm/case E (\x. E1) (\x. E2)) T] ->
    [ |- inversion-tm/case/tm-ofE/existT1T2 F E] =
/ total 1 /
?
;

LF inversion-tm/case/tm-ofE12/existT12 : sttp -> (term -> term) -> con -> type =
| inversion-tm/case/tm-ofE12/existT12/i :
  { T' : con }
  ({ x : term } { u : { F': sttp } tm-of F' x T' } tm-of F (E x) T) ->
    inversion-tm/case/tm-ofE12/existT12 F E T
;

proof inversion-tm/case/tm-ofE12/existT12/i :
  { T' : [ |- con] }
  [x : term, u : {F' : sttp} tm-of F' x T'[] |- tm-of F[] (E[x]) T[]] ->
    [ |- inversion-tm/case/tm-ofE12/existT12 F (\x. E) T] =
/ total /
?
;

proof inversion-tm/case/tm-ofE1 :
  [ |- tm-of F (tm/case E (\x. E1) (\x. E2)) T] ->
    [ |- inversion-tm/case/tm-ofE12/existT12 F (\x. E1) T] =
/ total 1 /
?
;

proof inversion-tm/case/tm-ofE2 :
  [ |- tm-of F (tm/case E (\x. E1) (\x. E2)) T] ->
    [ |- inversion-tm/case/tm-ofE12/existT12 F (\x. E2) T] =
/ total 1 /
?
;

LF inversion-tm/lam/cn-equiv/existsT2 : con -> con -> type =
| inversion-tm/lam/cn-equiv/existsT2/i :
  { T2 : con } cn-equiv (arrow T1 T2) T t ->
    inversion-tm/lam/cn-equiv/existsT2 T1 T
;

proof inversion-tm/lam/cn-equiv/existsT2/i :
  { T2 : [ |- con] } [ |- cn-equiv (arrow T1 T2) T t] ->
    [ |- inversion-tm/lam/cn-equiv/existsT2 T1 T] =
/ total /
?
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/lam/cn-equiv :
  [ |- tm-of F (tm/lam T1 (\x. E[x])) T] ->
    [ |- inversion-tm/lam/cn-equiv/existsT2 T1 T] =
/ total 1 /
?
;

LF inversion-tm/lam/tm-of/existsT2 : sttp -> (term -> term) -> con -> con -> type =
| inversion-tm/lam/tm-of/existsT2/i :
  { T2 : con }
  ({ x : term } { u : { F': sttp } tm-of F' x T1 } tm-of F (E x) T2) ->
    inversion-tm/lam/tm-of/existsT2 F E T1 T
;

proof inversion-tm/lam/tm-of/existsT2/i :
  { T2 : [ |- con] }
  [x : term, u : { F' : sttp} tm-of F' x T1[] |- tm-of F[] (E[x]) T2[]] ->
    [ |- inversion-tm/lam/tm-of/existsT2 F (\x. E) T1 T] =
/ total /
?
;

proof inversion-tm/lam/tm-of :
  [ |- tm-of F (tm/lam T1 (\x. E[x])) T] ->
    [ |- inversion-tm/lam/tm-of/existsT2 F (\x. E) T1 T] =
/ total 1 /
?
;

LF inversion-tm/app/1/existsT' : sttp -> term -> con -> type =
| inversion-tm/app/1/existsT'/i :
  { T' : con } tm-of F E1 (arrow T' T) ->
    inversion-tm/app/1/existsT' F E1 T
;

proof inversion-tm/app/1/existsT'/i :
  { T' : [ |- con] } [ |- tm-of F E1 (arrow T' T)] ->
    [ |- inversion-tm/app/1/existsT' F E1 T] =
/ total /
?
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/app/1 :
  [ |- tm-of F (tm/app E1 E2) T] ->
    [ |- inversion-tm/app/1/existsT' F E1 T] =
/ total 1 /
?
;

LF inversion-tm/app/2/existsT' : sttp -> term -> type =
| inversion-tm/app/2/existsT'/i :
  { T' : con } tm-of F E2 T' ->
    inversion-tm/app/2/existsT' F E2
;

proof inversion-tm/app/2/existsT'/i :
  { T' : [ |- con] } [ |- tm-of F E2 T'] ->
    [ |- inversion-tm/app/2/existsT' F E2] =
/ total /
?
;

proof inversion-tm/app/2 :
  [ |- tm-of F (tm/app E1 E2) T] ->
    [ |- inversion-tm/app/2/existsT' F E2] =
/ total 1 /
?
;

LF inversion-tm/refloc/cn-equiv/existsT' : con -> type =
| inversion-tm/refloc/cn-equiv/existsT'/i :
  { T' : con } cn-equiv (ref T') T t ->
    inversion-tm/refloc/cn-equiv/existsT' T
;

proof inversion-tm/refloc/cn-equiv/existsT'/i :
  { T' : [ |- con] } [ |- cn-equiv (ref T') T t] ->
    [ |- inversion-tm/refloc/cn-equiv/existsT' T] =
/ total /
?
;

proof inversion-tm/refloc/cn-equiv :
  [ |- tm-of F (tm/refloc L) T] ->
    [ |- inversion-tm/refloc/cn-equiv/existsT' T] =
/ total 1 /
?
;

LF inversion-tm/refloc/st-lookup/existsT' : sttp -> location -> type =
| inversion-tm/refloc/st-lookup/existsT'/i :
  { T' : con } st-lookup F L (et/ref T') ->
    inversion-tm/refloc/st-lookup/existsT' F L
;

proof inversion-tm/refloc/st-lookup :
  [ |- tm-of F (tm/refloc L) T] ->
    [ |- inversion-tm/refloc/st-lookup/existsT' F L] =
/ total 1 /
?
;

LF inversion-tm/refloc/cn-of/existsT' : type =
| inversion-tm/refloc/cn-of/existsT'/i : { T' : con } cn-of T' t ->
                                           inversion-tm/refloc/cn-of/existsT'
;

proof inversion-tm/refloc/cn-of :
  [ |- tm-of F (tm/refloc L) T] ->
    [ |- inversion-tm/refloc/cn-of/existsT'] =
/ total 1 /
?
;

LF inversion-tm/ref/cn-equiv/existsT' : con -> type =
| inversion-tm/ref/cn-equiv/existsT'/i :
  { T' : con } cn-equiv (ref T') T t ->
    inversion-tm/ref/cn-equiv/existsT' T
;

proof inversion-tm/ref/cn-equiv/existsT'/i :
  { T' : [ |- con] } [ |- cn-equiv (ref T') T t] ->
    [ |- inversion-tm/ref/cn-equiv/existsT' T] =
/ total /
?
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/ref/cn-equiv :
  [ |- tm-of F (tm/ref E) T] ->
    [ |- inversion-tm/ref/cn-equiv/existsT' T] =
/ total 1 /
?
;

LF inversion-tm/ref/tm-of/existsT' : sttp -> term -> type =
| inversion-tm/ref/tm-of/existsT'/i :
  { T' : con } tm-of F E T' ->
    inversion-tm/ref/tm-of/existsT' F E
;

proof inversion-tm/ref/tm-of/existsT'/i :
  { T' : [ |- con] } [ |- tm-of F E T'] ->
    [ |- inversion-tm/ref/tm-of/existsT' F E] =
/ total /
?
;

proof inversion-tm/ref/tm-of :
  [ |- tm-of F (tm/ref E) T] ->
    [ |- inversion-tm/ref/tm-of/existsT' F E] =
/ total 1 /
?
;

proof inversion-tm/deref : [ |- tm-of F (tm/deref E) T] ->
                             [ |- tm-of F E (ref T)] =
/ total 1 /
?
;

proof inversion-tm/assign/cn-equiv :
  [ |- tm-of F (tm/assign E1 E2) T] ->
    [ |- cn-equiv unit T t] =
/ total 1 /
?
;

LF inversion-tm/assign/tm-of1/existsT' : sttp -> term -> type =
| inversion-tm/assign/tm-of1/existsT'/i :
  { T' : con } tm-of F E1 (ref T') ->
    inversion-tm/assign/tm-of1/existsT' F E1
;

proof inversion-tm/assign/tm-of1/existsT'/i :
  { T' : [ |- con] } [ |- tm-of F E1 (ref T')] ->
    [ |- inversion-tm/assign/tm-of1/existsT' F E1] =
/ total /
?
;

proof inversion-tm/assign/tm-of1 :
  [ |- tm-of F (tm/assign E1 E2) T] ->
    [ |- inversion-tm/assign/tm-of1/existsT' F E1] =
/ total 1 /
?
;

LF inversion-tm/assign/tm-of2/existsT' : sttp -> term -> type =
| inversion-tm/assign/tm-of2/existsT'/i :
  { T' : con } tm-of F E2 T' ->
    inversion-tm/assign/tm-of2/existsT' F E2
;

proof inversion-tm/assign/tm-of2/existsT'/i :
  { T' : [ |- con] } [ |- tm-of F E2 T'] ->
    [ |- inversion-tm/assign/tm-of2/existsT' F E2] =
/ total /
?
;

proof inversion-tm/assign/tm-of2 :
  [ |- tm-of F (tm/assign E1 E2) T] ->
    [ |- inversion-tm/assign/tm-of2/existsT' F E2] =
/ total 1 /
?
;

LF inversion-tm/tagloc/cn-equiv/existsT' : con -> type =
| inversion-tm/tagloc/cn-equiv/existsT'/i :
  { T' : con} cn-equiv (tag T') T t ->
    inversion-tm/tagloc/cn-equiv/existsT' T
;

proof inversion-tm/tagloc/cn-equiv/existsT'/i :
  { T' : [ |- con] } [ |- cn-equiv (tag T') T t] ->
    [ |- inversion-tm/tagloc/cn-equiv/existsT' T] =
/ total /
?
;

proof inversion-tm/tagloc/cn-equiv :
  [ |- tm-of F (tm/tagloc L) T] ->
    [ |- inversion-tm/tagloc/cn-equiv/existsT' T] =
/ total 1 /
?
;

LF inversion-tm/tagloc/st-lookup/existsT' : sttp -> location -> type =
| inversion-tm/tagloc/st-lookup/existsT'/i :
  { T' : con } st-lookup F L (et/tag T') ->
    inversion-tm/tagloc/st-lookup/existsT' F L
;

proof inversion-tm/tagloc/st-lookup :
  [ |- tm-of F (tm/tagloc L) T] ->
    [ |- inversion-tm/tagloc/st-lookup/existsT' F L] =
/ total 1 /
?
;

LF inversion-tm/tagloc/cn-of/existsT' : type =
| inversion-tm/tagloc/cn-of/existsT'/i : { T' : con } cn-of T' t ->
                                           inversion-tm/tagloc/cn-of/existsT'
;

proof inversion-tm/tagloc/cn-of :
  [ |- tm-of F (tm/tagloc L) T] ->
    [ |- inversion-tm/tagloc/cn-of/existsT'] =
/ total 1 /
?
;

proof inversion-tm/newtag : [ |- tm-of F (tm/newtag T') T] ->
                              [ |- cn-equiv (tag T') T t] =
/ total 1 /
?
;

proof inversion-tm/tag/cn-equiv : [ |- tm-of F (tm/tag E1 E2) T] ->
                                    [ |- cn-equiv tagged T t] =
/ total 1 /
?
;

LF inversion-tm/tag/tm-of1/existsT' : sttp -> term -> type =
| inversion-tm/tag/tm-of1/existsT'/i :
  { T' : con } tm-of F E1 (tag T') ->
    inversion-tm/tag/tm-of1/existsT' F E1
;

proof inversion-tm/tag/tm-of1 :
  [ |- tm-of F (tm/tag E1 E2) T] ->
    [ |- inversion-tm/tag/tm-of1/existsT' F E1] =
/ total 1 /
?
;

LF inversion-tm/tag/tm-of2/existsT' : sttp -> term -> type =
| inversion-tm/tag/tm-of2/existsT'/i :
  { T' : con } tm-of F E2 T' ->
    inversion-tm/tag/tm-of2/existsT' F E2
;

proof inversion-tm/tag/tm-of2 :
  [ |- tm-of F (tm/tag E1 E2) T] ->
    [ |- inversion-tm/tag/tm-of2/existsT' F E2] =
/ total 1 /
?
;

proof inversion-tm/iftag/1 :
  [ |- tm-of F (tm/iftag E1 E2 (\x. E3) E4) T] ->
    [ |- tm-of F E1 tagged] =
/ total 1 /
?
;

LF inversion-tm/iftag/2/existsT' : sttp -> term -> type =
| inversion-tm/iftag/2/existsT'/i :
  { T' : con } tm-of F E2 (tag T') ->
    inversion-tm/iftag/2/existsT' F E2
;

proof inversion-tm/iftag/2/existsT'/i :
  { T' : [ |- con] } [ |- tm-of F E2 (tag T')] ->
    [ |- inversion-tm/iftag/2/existsT' F E2] =
/ total /
?
;

proof inversion-tm/iftag/2 :
  [ |- tm-of F (tm/iftag E1 E2 (\x. E3) E4) T] ->
    [ |- inversion-tm/iftag/2/existsT' F E2] =
/ total 1 /
?
;

LF inversion-tm/iftag/3/existsT' : sttp -> (term -> term) -> con -> type =
| inversion-tm/iftag/3/existsT'/i :
  { T' : con }
  ({ x : term } { u : { F' : sttp } tm-of F' x T'} tm-of F (E3 x) T) ->
    inversion-tm/iftag/3/existsT' F E3 T
;

proof inversion-tm/iftag/3/existsT'/i :
  { T' : [ |- con] }
  [x : term, u : { F' : sttp } tm-of F' x T'[] |- tm-of F[] (E3[x]) T[]] ->
    [ |- inversion-tm/iftag/3/existsT' F (\x. E3) T] =
/ total /
?
;

proof inversion-tm/iftag/3 :
  [ |- tm-of F (tm/iftag E1 E2 (\x. E3) E4) T] ->
    [ |- inversion-tm/iftag/3/existsT' F (\x. E3) T] =
/ total 1 /
?
;

proof inversion-tm/iftag/4 :
  [ |- tm-of F (tm/iftag E1 E2 (\x. E3) E4) T] ->
    [ |- tm-of F E4 T] =
/ total 1 /
?
;

proof inversion-tm/roll/cn-equiv :
  [ |- tm-of F (tm/roll E K (\c1. \c2. C1) C2) T] ->
    [ |- cn-equiv (rec' K (\c1. \c2. C1) C2) T t] =
/ total 1 /
?
;

proof inversion-tm/roll/tm-of :
  [ |- tm-of F (tm/roll E K (\c1. \c2. C1) C2) T] ->
    [ |- tm-of F E (C1[lam K[] (\a. rec' K[] (\c1. \c2. C1[c1, c2]) a), C2[]])] =
/ total 1 /
?
;

proof inversion-tm/roll/kd-wf :
  [ |- tm-of F (tm/roll E K (\c1. \c2. C1) C2) T] ->
    [ |- kd-wf K] =
/ total 1 /
?
;

proof inversion-tm/roll/cn-of1 :
  [ |- tm-of F (tm/roll E K (\c1. \c2. C1) C2) T] ->
    [a : con, da : cn-of a (pi K[] (\l. t)),
     b : con, db : cn-of b K[] |- cn-of (C1[a, b]) t] =
/ total 1 /
?
;

proof inversion-tm/roll/cn-of2 :
  [ |- tm-of F (tm/roll E K (\c1. \c2. C1) C2) T] ->
    [ |- cn-of C2 K] =
/ total 1 /
?
;

LF inversion-tm/unroll/cn-equiv/existKC1C2 : con -> type =
| inversion-tm/unroll/cn-equiv/existKC1C2/i :
  { K : kind } { C1 : con -> con -> con } { C2 : con }
  cn-equiv (C1 (lam K (\a. rec' K C1 a)) C2) T t ->
    inversion-tm/unroll/cn-equiv/existKC1C2 T
;


proof inversion-tm/unroll/cn-equiv/existKC1C2/i :
  { K : [ |- kind] } { C1 : [c1 : con, c2 : con |- con] } { C2 : [ |- con] }
  [ |- cn-equiv
    (C1[lam K[] (\a. rec' K[] (\c1. \c2. C1[c1, c2]) a), C2[]]) T t] ->
    [ |- inversion-tm/unroll/cn-equiv/existKC1C2 T] =
/ total /
?
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/unroll/cn-equiv :
  [ |- tm-of F (tm/unroll E) T] ->
    [ |- inversion-tm/unroll/cn-equiv/existKC1C2 T] =
/ total 1 /
?
;

LF inversion-tm/unroll/tm-of/existKC1C2 : sttp -> term -> type =
| inversion-tm/unroll/tm-of/existKC1C2/i :
  { K : kind } { C1 : con -> con -> con } { C2 : con }
  tm-of F E (rec' K C1 C2) ->
    inversion-tm/unroll/tm-of/existKC1C2 F E
;

proof inversion-tm/unroll/tm-of/existKC1C2/i :
  { K : [ |- kind] } { C1 : [c1 : con, c2 : con |- con] } { C2 : [ |- con] }
  [ |- tm-of F E (rec' K (\c1. \c2. C1) C2)] ->
    [ |- inversion-tm/unroll/tm-of/existKC1C2 F E] =
/ total /
?
;

proof inversion-tm/unroll/tm-of :
  [ |- tm-of F (tm/unroll E) T] ->
    [ |- inversion-tm/unroll/tm-of/existKC1C2 F E] =
/ total 1 /
?
;

LF inversion-tm/in/cn-equiv/existsT' : label -> con -> type =
| inversion-tm/in/cn-equiv/existsT'/i :
  { T' : con } cn-equiv (labeled I T') T t ->
    inversion-tm/in/cn-equiv/existsT' I T
;

proof inversion-tm/in/cn-equiv/existsT'/i :
  { T' : [ |- con] } [ |- cn-equiv (labeled I T') T t] ->
    [ |- inversion-tm/in/cn-equiv/existsT' I T] =
/ total /
?
;

% TODO: Depends on `tm-of-reg`
proof inversion-tm/in/cn-equiv :
  [ |- tm-of F (tm/in I E) T] ->
    [ |- inversion-tm/in/cn-equiv/existsT' I T] =
/ total 1 /
?
;

LF inversion-tm/in/tm-of/existsT' : sttp -> term -> type =
| inversion-tm/in/tm-of/existsT'/i :
  { T' : con } tm-of F E T' ->
    inversion-tm/in/tm-of/existsT' F E
;

proof inversion-tm/in/tm-of/existsT'/i :
  { T' : [ |- con] } [ |- tm-of F E T'] ->
    [ |- inversion-tm/in/tm-of/existsT' F E] =
/ total /
?
;

proof inversion-tm/in/tm-of :
  [ |- tm-of F (tm/in I E) T] ->
    [ |- inversion-tm/in/tm-of/existsT' F E] =
/ total 1 /
?
;

LF inversion-tm/out/existsL : sttp -> term -> con -> type =
| inversion-tm/out/existsL/i : { L : label } tm-of F E (labeled L T) ->
                                 inversion-tm/out/existsL F E T
;

proof inversion-tm/out : [ |- tm-of F (tm/out E) T] ->
                           [ |- inversion-tm/out/existsL F E T] =
/ total 1 /
?
;

proof inversion-tm/raise/cn-equiv : [ |- tm-of F (tm/raise E T') T] ->
                                      [ |- cn-equiv T' T t] =
/ total 1 /
?
;

proof inversion-tm/raise/tm-of : [ |- tm-of F (tm/raise E T') T] ->
                                   [ |- tm-of F E tagged] =
/ total 1 /
?
;

proof inversion-tm/try/tm-of1 :
  [ |- tm-of F (tm/try E1 (\x. E2)) T] ->
    [ |- tm-of F E1 T] =
/ total 1 /
?
;

proof inversion-tm/try/tm-of2 :
  [ |- tm-of F (tm/try E1 (\x. E2)) T] ->
    [x : term, u : { F' : sttp } tm-of F' x tagged |- tm-of F[] (E2[x]) T[]] =
/ total 1 /
?
;

LF inversion-tm/lett/tm-of1/existsT1 : sttp -> term -> type =
| inversion-tm/lett/tm-of1/existsT1/i :
  { T1 : con } tm-of F E1 T1 ->
    inversion-tm/lett/tm-of1/existsT1 F E1
;

proof inversion-tm/lett/tm-of1/existsT1/i :
  { T1 : [ |- con] } [ |- tm-of F E1 T1] ->
    [ |- inversion-tm/lett/tm-of1/existsT1 F E1] =
/ total /
?
;

proof inversion-tm/lett/tm-of1 :
  [ |- tm-of F (tm/lett E1 (\x. E2)) T] ->
    [ |- inversion-tm/lett/tm-of1/existsT1 F E1] =
/ total 1 /
?
;

LF inversion-tm/lett/tm-of2/existsT1 : sttp -> (term -> term) -> con -> type =
| inversion-tm/lett/tm-of2/existsT1/i :
  { T1 : con }
  ({ x : term } { u : { F' : sttp } tm-of F' x T1 } tm-of F (E2 x) T) ->
    inversion-tm/lett/tm-of2/existsT1 F E2 T
;

proof inversion-tm/lett/tm-of2/existsT1/i :
  { T1 : [ |- con] }
  [x : term, u : { F' : sttp } tm-of F' x T1[] |- tm-of F[] (E2[x]) T[]] ->
    [ |- inversion-tm/lett/tm-of2/existsT1 F (\x. E2) T] =
/ total /
?
;

proof inversion-tm/lett/tm-of2 :
  [ |- tm-of F (tm/lett E1 (\x. E2)) T] ->
    [ |- inversion-tm/lett/tm-of2/existsT1 F (\x. E2) T] =
/ total 1 /
?
;

proof inversion-tm/snd : [ |- tm-of F (tm/snd M) T] ->
                           [ |- md-of impure F M (sg/datom T)] =
/ total 1 /
?
;
