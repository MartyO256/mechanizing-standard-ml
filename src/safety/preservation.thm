% Monotonicity

LF extends : sttp -> sttp -> type =
| extends/nil : extends F F
| extends/cons : extends F1 F2 -> extends F1 (st/cons F2 _ _)
;

proof monotonicity-lookup : [ |- st-lookup F L ET] ->
                              [ |- extends F F'] -> [ |- st-lookup F' L ET] =
/ total 2 /
intros
{ F : ( |- sttp), L : ( |- location), ET : ( |- entp), F' : ( |- sttp)
| x : [ |- st-lookup F L ET], x1 : [ |- extends F F']
; split x1 as
  case extends/cons:
  { F : ( |- sttp),
    L : ( |- location),
    ET : ( |- entp),
    F2 : ( |- sttp),
    X : ( |- location),
    ET1 : ( |- entp),
    X1 : ( |- extends F F2)
  | x : [ |- st-lookup F L ET], x1 : [ |- extends F (st/cons F2 X ET1)]
  ; by monotonicity-lookup x [ |- X1] as Q unboxed;
    solve [ |- st-lookup/miss Q]
  }
  case extends/nil:
  { F' : ( |- sttp), L : ( |- location), ET : ( |- entp)
  | x : [ |- st-lookup F' L ET], x1 : [ |- extends F' F']
  ; solve x
  }
}
;

% Preservation

proof preservation-tm/tm-of : [ |- tm-of F E T] ->
                                [ |- store-of F ST F] ->
                                  [ |- step ST E ST' E'] ->
                                    [ |- tm-of F' E' T] =
/ total 1 /
?
;

proof preservation-tm/tm-of : [ |- tm-of F E T] ->
                                [ |- store-of F ST F] ->
                                  [ |- step ST E ST' E'] ->
                                    [ |- store-of F' ST' F'] =
/ total 1 /
?
;

proof preservation-tm/tm-of : [ |- tm-of F E T] ->
                                [ |- store-of F ST F] ->
                                  [ |- step ST E ST' E'] ->
                                    [ |- extends F F'] =
/ total 1 /
?
;
