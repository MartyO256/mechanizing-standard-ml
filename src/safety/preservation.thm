% Monotonicity

LF extends : sttp -> sttp -> type =
| extends/nil : extends F F
| extends/cons : extends F1 F2 -> extends F1 (st/cons F2 _ _)
;
--name extends Dextends extends.

proof monotonicity-lookup :
  [ |- st-lookup F L ET] ->
  [ |- extends F F'] ->
    [ |- st-lookup F' L ET] =
/ total 2 /
intros
{ F : ( |- sttp), L : ( |- location), ET : ( |- entp), F' : ( |- sttp)
| lookup : [ |- st-lookup F L ET], x : [ |- extends F F']
; split x as
  case extends/cons:
  { F : ( |- sttp),
    L : ( |- location),
    ET : ( |- entp),
    F2 : ( |- sttp),
    X : ( |- location),
    ET1 : ( |- entp),
    Dextends : ( |- extends F F2)
  | lookup : [ |- st-lookup F L ET], x : [ |- extends F (st/cons F2 X ET1)]
  ; by monotonicity-lookup lookup [ |- Dextends] as Q unboxed;
    solve [ |- st-lookup/miss Q]
  }
  case extends/nil:
  { F' : ( |- sttp), L : ( |- location), ET : ( |- entp)
  | lookup : [ |- st-lookup F' L ET], x : [ |- extends F' F']
  ; solve lookup
  }
}
;

% Locations

proof loc-lt-antisymm : [ |- loc-lt L L] -> [ |- false] =
/ total /
intros
{ L : ( |- location)
| lt : [ |- loc-lt L L]
; split lt as
  case loc-lt/i:
  { N : ( |- nat), Dlt : ( |- lt N N)
  | lt : [ |- loc-lt (location/i N) (location/i N)]
  ; suffices by lt-antisymm toshow
    [ |- lt N N] {
      solve [ |- Dlt]
    }
  }
}
;

proof loc-lt-trans :
  [ |- loc-lt L1 L2] ->
  [ |- loc-lt L2 L3] ->
    [ |- loc-lt L1 L3] =
/ total /
intros
{ L : ( |- location), L1 : ( |- location), L2 : ( |- location)
| lt : [ |- loc-lt L L1], lt1 : [ |- loc-lt L1 L2]
; split lt as
  case loc-lt/i:
  { N : ( |- nat), N1 : ( |- nat), L2 : ( |- location), Dlt : ( |- lt N N1)
  | lt : [ |- loc-lt (location/i N) (location/i N1)],
    lt1 : [ |- loc-lt (location/i N1) L2]
  ; split lt1 as
    case loc-lt/i:
    { N : ( |- nat),
      N1 : ( |- nat),
      N3 : ( |- nat),
      Dlt : ( |- lt N N1),
      Dlt1 : ( |- lt N1 N3)
    | lt : [ |- loc-lt (location/i N) (location/i N1)],
      lt1 : [ |- loc-lt (location/i N1) (location/i N3)]
    ; by lt-trans [ |- Dlt] [ |- Dlt1] as Dlt2 unboxed;
      solve [ |- loc-lt/i Dlt2]
    }
  }
}
;

proof loc-succ-lt : [ |- loc-succ L L'] -> [ |- loc-lt L L'] =
/ total /
intros
{ L : ( |- location), L' : ( |- location)
| succ : [ |- loc-succ L L']
; split succ as
  case loc-succ/i:
  { N : ( |- nat)
  | succ : [ |- loc-succ (location/i N) (location/i (succ N))]
  ; suffices by loc-lt/i toshow
    [ |- lt N (succ N)] {
      suffices by lt-succ [ |- N] toshow
    }
  }
}
;

% Stores

proof store-bounds-increase :
  [ |- store-bounds ST L] ->
  [ |- loc-lt L L'] ->
    [ |- store-bounds ST L'] =
/ total 1 /
intros
{ ST : ( |- store), L : ( |- location), L' : ( |- location)
| x : [ |- store-bounds ST L], lt : [ |- loc-lt L L']
; split x as
  case store-bounds/cons:
  { ST1 : ( |- store),
    X : ( |- location),
    EN : ( |- entry),
    L : ( |- location),
    L' : ( |- location),
    Dlt : ( |- loc-lt X L)
  | x : [ |- store-bounds (store/cons ST1 X EN) L], lt : [ |- loc-lt L L']
  ; by loc-lt-trans [ |- Dlt] lt as Dlt1 unboxed;
    solve [ |- store-bounds/cons Dlt1]
  }
  case store-bounds/nil:
  { L : ( |- location), L' : ( |- location)
  | x : [ |- store-bounds store/nil L], lt : [ |- loc-lt L L']
  ; solve [ |- store-bounds/nil ]
  }
}
;

proof store-bounds-update :
  [ |- store-bounds ST L] ->
  [ |- store-update ST X EN ST'] ->
    [ |- store-bounds ST' L] =
/ total /
intros
{ ST : ( |- store),
  L : ( |- location),
  X : ( |- location),
  EN : ( |- entry),
  ST' : ( |- store)
| bounds : [ |- store-bounds ST L], x : [ |- store-update ST X EN ST']
; split bounds as
  case store-bounds/cons:
  { ST1 : ( |- store),
    X1 : ( |- location),
    EN1 : ( |- entry),
    L : ( |- location),
    X : ( |- location),
    EN : ( |- entry),
    ST' : ( |- store),
    Dlt : ( |- loc-lt X1 L)
  | bounds : [ |- store-bounds (store/cons ST1 X1 EN1) L],
    x : [ |- store-update (store/cons ST1 X1 EN1) X EN ST']
  ; split x as
    case store-update/miss:
    { ST1 : ( |- store),
      X1 : ( |- location),
      EN1 : ( |- entry),
      L : ( |- location),
      X : ( |- location),
      EN : ( |- entry),
      ST3 : ( |- store),
      Dlt : ( |- loc-lt X1 L),
      Dupdate : ( |- store-update ST1 X EN ST3)
    | bounds : [ |- store-bounds (store/cons ST1 X1 EN1) L],
      x :
        [ |-
           store-update (store/cons ST1 X1 EN1) X EN (store/cons ST3 X1 EN1)]
    ; solve [ |- store-bounds/cons Dlt]
    }
    case store-update/hit:
    { ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      L : ( |- location),
      EN : ( |- entry),
      Dlt : ( |- loc-lt X L)
    | bounds : [ |- store-bounds (store/cons ST1 X EN1) L],
      x :
        [ |- store-update (store/cons ST1 X EN1) X EN (store/cons ST1 X EN)]
    ; solve [ |- store-bounds/cons Dlt]
    }
  }
  case store-bounds/nil:
  { L : ( |- location),
    X : ( |- location),
    EN : ( |- entry),
    ST' : ( |- store)
  | bounds : [ |- store-bounds store/nil L],
    x : [ |- store-update store/nil X EN ST']
  ; impossible x
  }
}
;

proof store-bounds-update :
  [ |- store-bounds ST L] ->
  [ |- store-update ST X EN ST'] ->
    [ |- store-bounds ST' L] =
/ total /
intros
{ ST : ( |- store),
  L : ( |- location),
  X : ( |- location),
  EN : ( |- entry),
  ST' : ( |- store)
| bounds : [ |- store-bounds ST L], x : [ |- store-update ST X EN ST']
; split bounds as
  case store-bounds/cons:
  { ST1 : ( |- store),
    X1 : ( |- location),
    EN1 : ( |- entry),
    L : ( |- location),
    X : ( |- location),
    EN : ( |- entry),
    ST' : ( |- store),
    Dlt : ( |- loc-lt X1 L)
  | bounds : [ |- store-bounds (store/cons ST1 X1 EN1) L],
    x : [ |- store-update (store/cons ST1 X1 EN1) X EN ST']
  ; split x as
    case store-update/miss:
    { ST1 : ( |- store),
      X1 : ( |- location),
      EN1 : ( |- entry),
      L : ( |- location),
      X : ( |- location),
      EN : ( |- entry),
      ST3 : ( |- store),
      Dlt : ( |- loc-lt X1 L),
      Dupdate : ( |- store-update ST1 X EN ST3)
    | bounds : [ |- store-bounds (store/cons ST1 X1 EN1) L],
      x :
        [ |-
           store-update (store/cons ST1 X1 EN1) X EN (store/cons ST3 X1 EN1)]
    ; solve [ |- store-bounds/cons Dlt]
    }
    case store-update/hit:
    { ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      L : ( |- location),
      EN : ( |- entry),
      Dlt : ( |- loc-lt X L)
    | bounds : [ |- store-bounds (store/cons ST1 X EN1) L],
      x :
        [ |- store-update (store/cons ST1 X EN1) X EN (store/cons ST1 X EN)]
    ; solve [ |- store-bounds/cons Dlt]
    }
  }
  case store-bounds/nil:
  { L : ( |- location),
    X : ( |- location),
    EN : ( |- entry),
    ST' : ( |- store)
  | bounds : [ |- store-bounds store/nil L],
    x : [ |- store-update store/nil X EN ST']
  ; impossible x
  }
}
;

proof store-lookup-bound :
  [ |- store-of F ST F1] ->
  [ |- store-lookup ST L EN] ->
  [ |- store-bounds ST L] ->
    [ |- false] =
/ total 1 /
intros
{ F : ( |- sttp),
  ST : ( |- store),
  F1 : ( |- sttp),
  L : ( |- location),
  EN : ( |- entry)
| x : [ |- store-of F ST F1],
  x1 : [ |- store-lookup ST L EN],
  bounds : [ |- store-bounds ST L]
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    X : ( |- location),
    EN1 : ( |- entry),
    F3 : ( |- sttp),
    ET : ( |- entp),
    L : ( |- location),
    EN : ( |- entry),
    Dbounds : ( |- store-bounds ST1 X),
    X1 : ( |- entry-of F EN1 ET),
    Dof : ( |- store-of F ST1 F3)
  | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET)],
    x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
    bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
  ; split x1 as
    case store-lookup/miss:
    { F : ( |- sttp),
      ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      F3 : ( |- sttp),
      ET : ( |- entp),
      L : ( |- location),
      EN : ( |- entry),
      Dbounds : ( |- store-bounds ST1 X),
      X1 : ( |- entry-of F EN1 ET),
      Dof : ( |- store-of F ST1 F3),
      Dlookup : ( |- store-lookup ST1 L EN)
    | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET)],
      x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
      bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        X : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        L : ( |- location),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 X),
        X1 : ( |- entry-of F EN1 ET),
        Dof : ( |- store-of F ST1 F3),
        Dlookup : ( |- store-lookup ST1 L EN),
        Dlt : ( |- loc-lt X L)
      | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET)],
        x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
        bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
      ; solve
          store-lookup-bound [ |- Dof] [ |- Dlookup]
            (store-bounds-increase [ |- Dbounds] [ |- Dlt])
      }
    }
    case store-lookup/hit:
    { F : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN : ( |- entry),
      F3 : ( |- sttp),
      ET : ( |- entp),
      Dbounds : ( |- store-bounds ST1 L),
      X1 : ( |- entry-of F EN ET),
      Dof : ( |- store-of F ST1 F3)
    | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F3 L ET)],
      x1 : [ |- store-lookup (store/cons ST1 L EN) L EN],
      bounds : [ |- store-bounds (store/cons ST1 L EN) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN ET),
        Dof : ( |- store-of F ST1 F3),
        Dlt : ( |- loc-lt L L)
      | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F3 L ET)],
        x1 : [ |- store-lookup (store/cons ST1 L EN) L EN],
        bounds : [ |- store-bounds (store/cons ST1 L EN) L]
      ; solve loc-lt-antisymm [ |- Dlt]
      }
    }
  }
  case store-of/nil:
  { F : ( |- sttp), L : ( |- location), EN : ( |- entry)
  | x : [ |- store-of F store/nil st/nil],
    x1 : [ |- store-lookup store/nil L EN],
    bounds : [ |- store-bounds store/nil L]
  ; impossible x1
  }
}
;

proof store-update-bound :
  [ |- store-of F ST F'] ->
  [ |- store-update ST L EN ST'] ->
  [ |- store-bounds ST L] ->
    [ |- false] =
/ total 1 /
intros
{ F : ( |- sttp),
  ST : ( |- store),
  F' : ( |- sttp),
  L : ( |- location),
  EN : ( |- entry),
  ST' : ( |- store)
| x : [ |- store-of F ST F'],
  x1 : [ |- store-update ST L EN ST'],
  bounds : [ |- store-bounds ST L]
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    X : ( |- location),
    EN1 : ( |- entry),
    F2 : ( |- sttp),
    ET : ( |- entp),
    L : ( |- location),
    EN : ( |- entry),
    ST' : ( |- store),
    Dbounds : ( |- store-bounds ST1 X),
    X1 : ( |- entry-of F EN1 ET),
    Dof : ( |- store-of F ST1 F2)
  | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
    x1 : [ |- store-update (store/cons ST1 X EN1) L EN ST'],
    bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
  ; split x1 as
    case store-update/miss:
    { F : ( |- sttp),
      ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      L : ( |- location),
      EN : ( |- entry),
      ST3 : ( |- store),
      Dbounds : ( |- store-bounds ST1 X),
      X1 : ( |- entry-of F EN1 ET),
      Dof : ( |- store-of F ST1 F2),
      Dupdate : ( |- store-update ST1 L EN ST3)
    | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
      x1 :
        [ |- store-update (store/cons ST1 X EN1) L EN (store/cons ST3 X EN1)],
      bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        X : ( |- location),
        EN1 : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        L : ( |- location),
        EN : ( |- entry),
        ST3 : ( |- store),
        Dbounds : ( |- store-bounds ST1 X),
        X1 : ( |- entry-of F EN1 ET),
        Dof : ( |- store-of F ST1 F2),
        Dupdate : ( |- store-update ST1 L EN ST3),
        Dlt : ( |- loc-lt X L)
      | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
        x1 :
          [ |-
             store-update (store/cons ST1 X EN1) L EN (store/cons ST3 X EN1)],
        bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
      ; solve
          store-update-bound [ |- Dof] [ |- Dupdate]
            (store-bounds-increase [ |- Dbounds] [ |- Dlt])
      }
    }
    case store-update/hit:
    { F : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN1 : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      EN : ( |- entry),
      Dbounds : ( |- store-bounds ST1 L),
      X1 : ( |- entry-of F EN1 ET),
      Dof : ( |- store-of F ST1 F2)
    | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F2 L ET)],
      x1 :
        [ |- store-update (store/cons ST1 L EN1) L EN (store/cons ST1 L EN)],
      bounds : [ |- store-bounds (store/cons ST1 L EN1) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN1 : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN1 ET),
        Dof : ( |- store-of F ST1 F2),
        Dlt : ( |- loc-lt L L)
      | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F2 L ET)],
        x1 :
          [ |- store-update (store/cons ST1 L EN1) L EN (store/cons ST1 L EN)],
        bounds : [ |- store-bounds (store/cons ST1 L EN1) L]
      ; solve loc-lt-antisymm [ |- Dlt]
      }
    }
  }
  case store-of/nil:
  { F : ( |- sttp), L : ( |- location), EN : ( |- entry), ST' : ( |- store)
  | x : [ |- store-of F store/nil st/nil],
    x1 : [ |- store-update store/nil L EN ST'],
    bounds : [ |- store-bounds store/nil L]
  ; impossible x1
  }
}
;

proof sttp-lookup-bound :
  [ |- store-of F' ST F] ->
  [ |- st-lookup F L ET] ->
  [ |- store-bounds ST L] ->
    [ |- false] =
/ total 1 /
intros
{ F' : ( |- sttp),
  ST : ( |- store),
  F : ( |- sttp),
  L : ( |- location),
  ET : ( |- entp)
| x : [ |- store-of F' ST F],
  lookup : [ |- st-lookup F L ET],
  bounds : [ |- store-bounds ST L]
; split x as
  case store-of/cons:
  { F' : ( |- sttp),
    ST1 : ( |- store),
    X : ( |- location),
    EN : ( |- entry),
    F2 : ( |- sttp),
    ET1 : ( |- entp),
    L : ( |- location),
    ET : ( |- entp),
    Dbounds : ( |- store-bounds ST1 X),
    X1 : ( |- entry-of F' EN ET1),
    Dof : ( |- store-of F' ST1 F2)
  | x : [ |- store-of F' (store/cons ST1 X EN) (st/cons F2 X ET1)],
    lookup : [ |- st-lookup (st/cons F2 X ET1) L ET],
    bounds : [ |- store-bounds (store/cons ST1 X EN) L]
  ; split lookup as
    case st-lookup/miss:
    { F' : ( |- sttp),
      ST1 : ( |- store),
      X : ( |- location),
      EN : ( |- entry),
      F2 : ( |- sttp),
      ET1 : ( |- entp),
      L : ( |- location),
      ET : ( |- entp),
      Dbounds : ( |- store-bounds ST1 X),
      X1 : ( |- entry-of F' EN ET1),
      Dof : ( |- store-of F' ST1 F2),
      Dlookup : ( |- st-lookup F2 L ET)
    | x : [ |- store-of F' (store/cons ST1 X EN) (st/cons F2 X ET1)],
      lookup : [ |- st-lookup (st/cons F2 X ET1) L ET],
      bounds : [ |- store-bounds (store/cons ST1 X EN) L]
    ; split bounds as
      case store-bounds/cons:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        X : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET1 : ( |- entp),
        L : ( |- location),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 X),
        X1 : ( |- entry-of F' EN ET1),
        Dof : ( |- store-of F' ST1 F2),
        Dlookup : ( |- st-lookup F2 L ET),
        Dlt : ( |- loc-lt X L)
      | x : [ |- store-of F' (store/cons ST1 X EN) (st/cons F2 X ET1)],
        lookup : [ |- st-lookup (st/cons F2 X ET1) L ET],
        bounds : [ |- store-bounds (store/cons ST1 X EN) L]
      ; solve
          sttp-lookup-bound [ |- Dof] [ |- Dlookup]
            (store-bounds-increase [ |- Dbounds] [ |- Dlt])
      }
    }
    case st-lookup/hit:
    { F' : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      Dbounds : ( |- store-bounds ST1 L),
      X1 : ( |- entry-of F' EN ET),
      Dof : ( |- store-of F' ST1 F2)
    | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET)],
      lookup : [ |- st-lookup (st/cons F2 L ET) L ET],
      bounds : [ |- store-bounds (store/cons ST1 L EN) L]
    ; split bounds as
      case store-bounds/cons:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F' EN ET),
        Dof : ( |- store-of F' ST1 F2),
        Dlt : ( |- loc-lt L L)
      | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET)],
        lookup : [ |- st-lookup (st/cons F2 L ET) L ET],
        bounds : [ |- store-bounds (store/cons ST1 L EN) L]
      ; solve loc-lt-antisymm [ |- Dlt]
      }
    }
  }
  case store-of/nil:
  { F' : ( |- sttp), L : ( |- location), ET : ( |- entp)
  | x : [ |- store-of F' store/nil st/nil],
    lookup : [ |- st-lookup st/nil L ET],
    bounds : [ |- store-bounds store/nil L]
  ; impossible lookup
  }
}
;

proof store-lookup-bound :
  [ |- store-of F ST F'] ->
  [ |- store-lookup ST L EN] ->
  [ |- store-bounds ST L] ->
    [ |- false] =
/ total 1 /
intros
{ F : ( |- sttp),
  ST : ( |- store),
  F' : ( |- sttp),
  L : ( |- location),
  EN : ( |- entry)
| x : [ |- store-of F ST F'],
  x1 : [ |- store-lookup ST L EN],
  bounds : [ |- store-bounds ST L]
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    X : ( |- location),
    EN1 : ( |- entry),
    F2 : ( |- sttp),
    ET : ( |- entp),
    L : ( |- location),
    EN : ( |- entry),
    Dbounds : ( |- store-bounds ST1 X),
    X1 : ( |- entry-of F EN1 ET),
    Dof : ( |- store-of F ST1 F2)
  | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
    x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
    bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
  ; split x1 as
    case store-lookup/miss:
    { F : ( |- sttp),
      ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      L : ( |- location),
      EN : ( |- entry),
      Dbounds : ( |- store-bounds ST1 X),
      X1 : ( |- entry-of F EN1 ET),
      Dof : ( |- store-of F ST1 F2),
      Dlookup : ( |- store-lookup ST1 L EN)
    | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
      x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
      bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        X : ( |- location),
        EN1 : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        L : ( |- location),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 X),
        X1 : ( |- entry-of F EN1 ET),
        Dof : ( |- store-of F ST1 F2),
        Dlookup : ( |- store-lookup ST1 L EN),
        Dlt : ( |- loc-lt X L)
      | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
        x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
        bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
      ; solve
          store-lookup-bound [ |- Dof] [ |- Dlookup]
            (store-bounds-increase [ |- Dbounds] [ |- Dlt])
      }
    }
    case store-lookup/hit:
    { F : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      Dbounds : ( |- store-bounds ST1 L),
      X1 : ( |- entry-of F EN ET),
      Dof : ( |- store-of F ST1 F2)
    | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F2 L ET)],
      x1 : [ |- store-lookup (store/cons ST1 L EN) L EN],
      bounds : [ |- store-bounds (store/cons ST1 L EN) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN ET),
        Dof : ( |- store-of F ST1 F2),
        Dlt : ( |- loc-lt L L)
      | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F2 L ET)],
        x1 : [ |- store-lookup (store/cons ST1 L EN) L EN],
        bounds : [ |- store-bounds (store/cons ST1 L EN) L]
      ; solve loc-lt-antisymm [ |- Dlt]
      }
    }
  }
  case store-of/nil:
  { F : ( |- sttp), L : ( |- location), EN : ( |- entry)
  | x : [ |- store-of F store/nil st/nil],
    x1 : [ |- store-lookup store/nil L EN],
    bounds : [ |- store-bounds store/nil L]
  ; impossible x1
  }
}
;

proof preservation-lookup :
  [ |- store-of F1 ST F2] ->
  [ |- st-lookup F2 L ET] ->
  [ |- store-lookup ST L EN] ->
    [ |- entry-of F1 EN ET] =
/ total 1 /
intros
{ F : ( |- sttp),
  ST : ( |- store),
  F1 : ( |- sttp),
  L : ( |- location),
  ET : ( |- entp),
  EN : ( |- entry)
| x : [ |- store-of F ST F1],
  lookup : [ |- st-lookup F1 L ET],
  lookup1 : [ |- store-lookup ST L EN]
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    X : ( |- location),
    EN1 : ( |- entry),
    F3 : ( |- sttp),
    ET1 : ( |- entp),
    L : ( |- location),
    ET : ( |- entp),
    EN : ( |- entry),
    Dbounds : ( |- store-bounds ST1 X),
    X1 : ( |- entry-of F EN1 ET1),
    Dof : ( |- store-of F ST1 F3)
  | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET1)],
    lookup : [ |- st-lookup (st/cons F3 X ET1) L ET],
    lookup1 : [ |- store-lookup (store/cons ST1 X EN1) L EN]
  ; split lookup as
    case st-lookup/miss:
    { F : ( |- sttp),
      ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      F3 : ( |- sttp),
      ET1 : ( |- entp),
      L : ( |- location),
      ET : ( |- entp),
      EN : ( |- entry),
      Dbounds : ( |- store-bounds ST1 X),
      X1 : ( |- entry-of F EN1 ET1),
      Dof : ( |- store-of F ST1 F3),
      Dlookup : ( |- st-lookup F3 L ET)
    | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET1)],
      lookup : [ |- st-lookup (st/cons F3 X ET1) L ET],
      lookup1 : [ |- store-lookup (store/cons ST1 X EN1) L EN]
    ; split lookup1 as
      case store-lookup/miss:
      { F : ( |- sttp),
        ST1 : ( |- store),
        X : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET1 : ( |- entp),
        L : ( |- location),
        ET : ( |- entp),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 X),
        X1 : ( |- entry-of F EN1 ET1),
        Dof : ( |- store-of F ST1 F3),
        Dlookup : ( |- st-lookup F3 L ET),
        Dlookup1 : ( |- store-lookup ST1 L EN)
      | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET1)],
        lookup : [ |- st-lookup (st/cons F3 X ET1) L ET],
        lookup1 : [ |- store-lookup (store/cons ST1 X EN1) L EN]
      ; solve preservation-lookup [ |- Dof] [ |- Dlookup] [ |- Dlookup1]
      }
      case store-lookup/hit:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F3 : ( |- sttp),
        ET1 : ( |- entp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN ET1),
        Dof : ( |- store-of F ST1 F3),
        Dlookup : ( |- st-lookup F3 L ET)
      | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F3 L ET1)],
        lookup : [ |- st-lookup (st/cons F3 L ET1) L ET],
        lookup1 : [ |- store-lookup (store/cons ST1 L EN) L EN]
      ; impossible sttp-lookup-bound [ |- Dof] [ |- Dlookup] [ |- Dbounds]
      }
    }
    case st-lookup/hit:
    { F : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN1 : ( |- entry),
      F3 : ( |- sttp),
      ET : ( |- entp),
      EN : ( |- entry),
      Dbounds : ( |- store-bounds ST1 L),
      X1 : ( |- entry-of F EN1 ET),
      Dof : ( |- store-of F ST1 F3)
    | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET)],
      lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
      lookup1 : [ |- store-lookup (store/cons ST1 L EN1) L EN]
    ; split lookup1 as
      case store-lookup/miss:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN1 ET),
        Dof : ( |- store-of F ST1 F3),
        Dlookup : ( |- store-lookup ST1 L EN)
      | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET)],
        lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
        lookup1 : [ |- store-lookup (store/cons ST1 L EN1) L EN]
      ; impossible store-lookup-bound [ |- Dof] [ |- Dlookup] [ |- Dbounds]
      }
      case store-lookup/hit:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN ET),
        Dof : ( |- store-of F ST1 F3)
      | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F3 L ET)],
        lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
        lookup1 : [ |- store-lookup (store/cons ST1 L EN) L EN]
      ; solve [ |- X1]
      }
    }
  }
  case store-of/nil:
  { F : ( |- sttp), L : ( |- location), ET : ( |- entp), EN : ( |- entry)
  | x : [ |- store-of F store/nil st/nil],
    lookup : [ |- st-lookup st/nil L ET],
    lookup1 : [ |- store-lookup store/nil L EN]
  ; impossible lookup
  }
}
;

proof preservation-update :
  [ |- store-of F1 ST F2] ->
  [ |- st-lookup F2 L ET] ->
  [ |- store-update ST L EN ST'] ->
  [ |- entry-of F1 EN ET] ->
    [ |- store-of F1 ST' F2] =
/ total 1 /
intros
{ F : ( |- sttp),
  ST : ( |- store),
  F1 : ( |- sttp),
  L : ( |- location),
  ET : ( |- entp),
  EN : ( |- entry),
  ST' : ( |- store)
| x : [ |- store-of F ST F1],
  lookup : [ |- st-lookup F1 L ET],
  update : [ |- store-update ST L EN ST'],
  eof : [ |- entry-of F EN ET]
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    Dloc : ( |- location),
    EN1 : ( |- entry),
    F3 : ( |- sttp),
    ET1 : ( |- entp),
    L : ( |- location),
    ET : ( |- entp),
    EN : ( |- entry),
    ST' : ( |- store),
    Dbounds : ( |- store-bounds ST1 Dloc),
    Dof : ( |- entry-of F EN1 ET1),
    Dof1 : ( |- store-of F ST1 F3)
  | x : [ |- store-of F (store/cons ST1 Dloc EN1) (st/cons F3 Dloc ET1)],
    lookup : [ |- st-lookup (st/cons F3 Dloc ET1) L ET],
    update : [ |- store-update (store/cons ST1 Dloc EN1) L EN ST'],
    eof : [ |- entry-of F EN ET]
  ; split lookup as
    case st-lookup/miss:
    { F : ( |- sttp),
      ST1 : ( |- store),
      Dloc : ( |- location),
      EN1 : ( |- entry),
      F3 : ( |- sttp),
      ET1 : ( |- entp),
      L : ( |- location),
      ET : ( |- entp),
      EN : ( |- entry),
      ST' : ( |- store),
      Dbounds : ( |- store-bounds ST1 Dloc),
      Dof : ( |- entry-of F EN1 ET1),
      Dof1 : ( |- store-of F ST1 F3),
      Dlookup : ( |- st-lookup F3 L ET)
    | x : [ |- store-of F (store/cons ST1 Dloc EN1) (st/cons F3 Dloc ET1)],
      lookup : [ |- st-lookup (st/cons F3 Dloc ET1) L ET],
      update : [ |- store-update (store/cons ST1 Dloc EN1) L EN ST'],
      eof : [ |- entry-of F EN ET]
    ; split update as
      case store-update/miss:
      { F : ( |- sttp),
        ST1 : ( |- store),
        Dloc : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET1 : ( |- entp),
        L : ( |- location),
        ET : ( |- entp),
        EN : ( |- entry),
        ST3 : ( |- store),
        Dbounds : ( |- store-bounds ST1 Dloc),
        Dof : ( |- entry-of F EN1 ET1),
        Dof1 : ( |- store-of F ST1 F3),
        Dlookup : ( |- st-lookup F3 L ET),
        Dupdate : ( |- store-update ST1 L EN ST3)
      | x : [ |- store-of F (store/cons ST1 Dloc EN1) (st/cons F3 Dloc ET1)],
        lookup : [ |- st-lookup (st/cons F3 Dloc ET1) L ET],
        update :
          [ |-
             store-update
               (store/cons ST1 Dloc EN1) L EN (store/cons ST3 Dloc EN1)],
        eof : [ |- entry-of F EN ET]
      ; by preservation-update [ |- Dof1] [ |- Dlookup] [ |- Dupdate] eof
        as Dsof unboxed;
        by store-bounds-update [ |- Dbounds] [ |- Dupdate]
        as Dbounds1 unboxed;
        solve [ |- store-of/cons Dbounds1 Dof Dsof]
      }
      case store-update/hit:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET1 : ( |- entp),
        ET : ( |- entp),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F EN1 ET1),
        Dof1 : ( |- store-of F ST1 F3),
        Dlookup : ( |- st-lookup F3 L ET)
      | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET1)],
        lookup : [ |- st-lookup (st/cons F3 L ET1) L ET],
        update :
          [ |- store-update (store/cons ST1 L EN1) L EN (store/cons ST1 L EN)],
        eof : [ |- entry-of F EN ET]
      ; impossible sttp-lookup-bound [ |- Dof1] [ |- Dlookup] [ |- Dbounds]
      }
    }
    case st-lookup/hit:
    { F : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN1 : ( |- entry),
      F3 : ( |- sttp),
      ET : ( |- entp),
      EN : ( |- entry),
      ST' : ( |- store),
      Dbounds : ( |- store-bounds ST1 L),
      Dof : ( |- entry-of F EN1 ET),
      Dof1 : ( |- store-of F ST1 F3)
    | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET)],
      lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
      update : [ |- store-update (store/cons ST1 L EN1) L EN ST'],
      eof : [ |- entry-of F EN ET]
    ; split update as
      case store-update/miss:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        EN : ( |- entry),
        ST3 : ( |- store),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F EN1 ET),
        Dof1 : ( |- store-of F ST1 F3),
        Dupdate : ( |- store-update ST1 L EN ST3)
      | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET)],
        lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
        update :
          [ |-
             store-update (store/cons ST1 L EN1) L EN (store/cons ST3 L EN1)],
        eof : [ |- entry-of F EN ET]
      ; impossible store-update-bound [ |- Dof1] [ |- Dupdate] [ |- Dbounds]
      }
      case store-update/hit:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F EN1 ET),
        Dof1 : ( |- store-of F ST1 F3)
      | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET)],
        lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
        update :
          [ |- store-update (store/cons ST1 L EN1) L EN (store/cons ST1 L EN)],
        eof : [ |- entry-of F EN ET]
      ; by eof as Dof2 unboxed;
        solve [ |- store-of/cons Dbounds Dof2 Dof1]
      }
    }
  }
  case store-of/nil:
  { F : ( |- sttp),
    L : ( |- location),
    ET : ( |- entp),
    EN : ( |- entry),
    ST' : ( |- store)
  | x : [ |- store-of F store/nil st/nil],
    lookup : [ |- st-lookup st/nil L ET],
    update : [ |- store-update store/nil L EN ST'],
    eof : [ |- entry-of F EN ET]
  ; impossible lookup
  }
}
;

proof st-lookup-fun :
  [ |- store-of F' ST F] ->
  [ |- st-lookup F L ET] ->
  [ |- st-lookup F L ET'] ->
    [ |- entp-eq ET ET'] =
/ total 1 /
intros
{ F' : ( |- sttp),
  ST : ( |- store),
  F : ( |- sttp),
  L : ( |- location),
  ET : ( |- entp),
  ET' : ( |- entp)
| x : [ |- store-of F' ST F],
  lookup : [ |- st-lookup F L ET],
  lookup1 : [ |- st-lookup F L ET']
; split x as
  case store-of/cons:
  { F' : ( |- sttp),
    ST1 : ( |- store),
    Dloc : ( |- location),
    EN : ( |- entry),
    F2 : ( |- sttp),
    ET1 : ( |- entp),
    L : ( |- location),
    ET : ( |- entp),
    ET' : ( |- entp),
    Dbounds : ( |- store-bounds ST1 Dloc),
    Dof : ( |- entry-of F' EN ET1),
    Dof1 : ( |- store-of F' ST1 F2)
  | x : [ |- store-of F' (store/cons ST1 Dloc EN) (st/cons F2 Dloc ET1)],
    lookup : [ |- st-lookup (st/cons F2 Dloc ET1) L ET],
    lookup1 : [ |- st-lookup (st/cons F2 Dloc ET1) L ET']
  ; split lookup as
    case st-lookup/miss:
    { F' : ( |- sttp),
      ST1 : ( |- store),
      Dloc : ( |- location),
      EN : ( |- entry),
      F2 : ( |- sttp),
      ET1 : ( |- entp),
      L : ( |- location),
      ET : ( |- entp),
      ET' : ( |- entp),
      Dbounds : ( |- store-bounds ST1 Dloc),
      Dof : ( |- entry-of F' EN ET1),
      Dof1 : ( |- store-of F' ST1 F2),
      Dlookup : ( |- st-lookup F2 L ET)
    | x : [ |- store-of F' (store/cons ST1 Dloc EN) (st/cons F2 Dloc ET1)],
      lookup : [ |- st-lookup (st/cons F2 Dloc ET1) L ET],
      lookup1 : [ |- st-lookup (st/cons F2 Dloc ET1) L ET']
    ; split lookup1 as
      case st-lookup/miss:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        Dloc : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET1 : ( |- entp),
        L : ( |- location),
        ET : ( |- entp),
        ET' : ( |- entp),
        Dbounds : ( |- store-bounds ST1 Dloc),
        Dof : ( |- entry-of F' EN ET1),
        Dof1 : ( |- store-of F' ST1 F2),
        Dlookup : ( |- st-lookup F2 L ET),
        Dlookup1 : ( |- st-lookup F2 L ET')
      | x : [ |- store-of F' (store/cons ST1 Dloc EN) (st/cons F2 Dloc ET1)],
        lookup : [ |- st-lookup (st/cons F2 Dloc ET1) L ET],
        lookup1 : [ |- st-lookup (st/cons F2 Dloc ET1) L ET']
      ; solve st-lookup-fun [ |- Dof1] [ |- Dlookup] [ |- Dlookup1]
      }
      case st-lookup/hit:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET' : ( |- entp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F' EN ET'),
        Dof1 : ( |- store-of F' ST1 F2),
        Dlookup : ( |- st-lookup F2 L ET)
      | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET')],
        lookup : [ |- st-lookup (st/cons F2 L ET') L ET],
        lookup1 : [ |- st-lookup (st/cons F2 L ET') L ET']
      ; impossible sttp-lookup-bound [ |- Dof1] [ |- Dlookup] [ |- Dbounds]
      }
    }
    case st-lookup/hit:
    { F' : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      ET' : ( |- entp),
      Dbounds : ( |- store-bounds ST1 L),
      Dof : ( |- entry-of F' EN ET),
      Dof1 : ( |- store-of F' ST1 F2)
    | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET)],
      lookup : [ |- st-lookup (st/cons F2 L ET) L ET],
      lookup1 : [ |- st-lookup (st/cons F2 L ET) L ET']
    ; split lookup1 as
      case st-lookup/miss:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        ET' : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F' EN ET),
        Dof1 : ( |- store-of F' ST1 F2),
        Dlookup : ( |- st-lookup F2 L ET')
      | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET)],
        lookup : [ |- st-lookup (st/cons F2 L ET) L ET],
        lookup1 : [ |- st-lookup (st/cons F2 L ET) L ET']
      ; impossible sttp-lookup-bound [ |- Dof1] [ |- Dlookup] [ |- Dbounds]
      }
      case st-lookup/hit:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET' : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F' EN ET'),
        Dof1 : ( |- store-of F' ST1 F2)
      | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET')],
        lookup : [ |- st-lookup (st/cons F2 L ET') L ET'],
        lookup1 : [ |- st-lookup (st/cons F2 L ET') L ET']
      ; solve [ |- entp-eq/i ]
      }
    }
  }
  case store-of/nil:
  { F' : ( |- sttp), L : ( |- location), ET : ( |- entp), ET' : ( |- entp)
  | x : [ |- store-of F' store/nil st/nil],
    lookup : [ |- st-lookup st/nil L ET],
    lookup1 : [ |- st-lookup st/nil L ET']
  ; impossible lookup
  }
}
;

proof nextloc-bounds : [ |- nextloc ST L] -> [ |- store-bounds ST L] =
/ total /
intros
{ ST : ( |- store), L : ( |- location)
| nextloc : [ |- nextloc ST L]
; split nextloc as
  case nextloc/cons:
  { ST1 : ( |- store),
    Dloc : ( |- location),
    EN : ( |- entry),
    L : ( |- location),
    Dsucc : ( |- loc-succ Dloc L)
  | nextloc : [ |- nextloc (store/cons ST1 Dloc EN) L]
  ; by loc-succ-lt [ |- Dsucc] as Dlt unboxed;
    solve [ |- store-bounds/cons Dlt]
  }
  case nextloc/nil:
  {
  | nextloc : [ |- nextloc store/nil (location/i zero)]
  ; solve [ |- store-bounds/nil ]
  }
}
;

% Preservation

LF preservation-tm/e : sttp -> term -> con -> store -> type =
| preservation-tm/i :
  { F' : sttp}
  tm-of F' E' T ->
  store-of F' ST' F' ->
  extends F F' ->
    preservation-tm/e F E' T ST'
;

proof preservation-tm/i :
  { F' : [ |- sttp] }
  [ |- tm-of F' E' T] ->
  [ |- store-of F' ST' F'] ->
  [ |- extends F F'] ->
    [ |- preservation-tm/e F E' T ST'] =
/ total /
intros
{ E' : ( |- term),
  T : ( |- con),
  ST' : ( |- store),
  F : ( |- sttp),
  F' : ( |- sttp)
| tof : [ |- tm-of F' E' T],
  sof : [ |- store-of F' ST' F'],
  extends : [ |- extends F F']
; by tof as DofT unboxed;
  by sof as DofS unboxed;
  by extends as Dextends unboxed;
  solve [ |- preservation-tm/i F' DofT DofS Dextends]
}
;

proof preservation-tm :
  [ |- tm-of F E T] ->
  [ |- store-of F ST F] ->
  [ |- step ST E ST' E'] ->
    [ |- preservation-tm/e F E' T ST'] =
/ total 3 /
intros
{ F : ( |- sttp),
  E : ( |- term),
  T : ( |- con),
  ST : ( |- store),
  ST' : ( |- store),
  E' : ( |- term)
| tof : [ |- tm-of F E T],
  sof : [ |- store-of F ST F],
  x : [ |- step ST E ST' E']
; by tof as Dof unboxed;
  by sof as Dstof unboxed;
  split x as
  case step/snd-beta:
  { F : ( |- sttp),
    E' : ( |- term),
    C : ( |- con),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/snd (md/datom E' C)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E')
  | tof : [ |- tm-of F (tm/snd (md/datom E' C)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/snd (md/datom E' C)) ST' E']
  ; ?
  }
  case step/snd:
  { F : ( |- sttp),
    M : ( |- module'),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    M1 : ( |- module'),
    Dof : ( |- tm-of F (tm/snd M) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step-md ST M ST' M1)
  | tof : [ |- tm-of F (tm/snd M) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/snd M) ST' (tm/snd M1)]
  ; ?
  }
  case step/lett2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : (x24 : term |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/lett E1 (\y131. E2)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1)
  | tof : [ |- tm-of F (tm/lett E1 (\y131. E2)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/lett E1 (\y131. E2)) ST' (E2[E1])]
  ; ?
  }
  case step/lett1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : (x23 : term |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/lett E1 (\y131. E3)) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/lett E1 (\y131. E3)) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/lett E1 (\y131. E3)) ST' (tm/lett E2 (\y131. E3))]
  ; ?
  }
  case step/try-handle:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : (x22 : term |- term),
    T : ( |- con),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/try E1 (\y130. E3)) T),
    Dstof : ( |- store-of F ST' F),
    Draises : ( |- raises E1 E2)
  | tof : [ |- tm-of F (tm/try E1 (\y130. E3)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/try E1 (\y130. E3)) ST' (E3[E2])]
  ; ?
  }
  case step/try-done:
  { F : ( |- sttp),
    E' : ( |- term),
    E2 : (x21 : term |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/try E' (\y130. E2)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E')
  | tof : [ |- tm-of F (tm/try E' (\y130. E2)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/try E' (\y130. E2)) ST' E']
  ; ?
  }
  case step/try:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : (x20 : term |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/try E1 (\y130. E3)) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/try E1 (\y130. E3)) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/try E1 (\y130. E3)) ST' (tm/try E2 (\y130. E3))]
  ; ?
  }
  case step/raise:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/raise E1 C) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/raise E1 C) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/raise E1 C) ST' (tm/raise E2 C)]
  ; ?
  }
  case step/out-beta:
  { F : ( |- sttp),
    X : ( |- label),
    E' : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/out (tm/in X E')) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E')
  | tof : [ |- tm-of F (tm/out (tm/in X E')) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/out (tm/in X E')) ST' E']
  ; ?
  }
  case step/out:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/out E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/out E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/out E1) ST' (tm/out E2)]
  ; ?
  }
  case step/in:
  { F : ( |- sttp),
    X : ( |- label),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/in X E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/in X E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/in X E1) ST' (tm/in X E2)]
  ; ?
  }
  case step/unroll-beta:
  { F : ( |- sttp),
    E' : ( |- term),
    K : ( |- kind),
    C : (a78 : con, a77 : con |- con),
    C1 : ( |- con),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E')
  | tof : [ |- tm-of F (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) ST' E']
  ; ?
  }
  case step/unroll:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/unroll E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/unroll E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/unroll E1) ST' (tm/unroll E2)]
  ; ?
  }
  case step/roll:
  { F : ( |- sttp),
    E1 : ( |- term),
    K : ( |- kind),
    C : (a76 : con, a75 : con |- con),
    C1 : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/roll E1 K (\z126. \y127. C) C1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/roll E1 K (\z126. \y127. C) C1) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/roll E1 K (\z126. \y127. C) C1)
           ST' (tm/roll E2 K (\z126. \y127. C) C1)]
  ; ?
  }
  case step/iftag-beta2:
  { F : ( |- sttp),
    Dloc : ( |- location),
    E1 : ( |- term),
    Dloc1 : ( |- location),
    E2 : (x19 : term |- term),
    E' : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof :
      ( |-
         tm-of
           F
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc1) (\y125. E2) E') T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1),
    X : ( |- loc-neq Dloc Dloc1)
  | tof :
      [ |-
         tm-of
           F
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc1) (\y125. E2) E') T],
    sof : [ |- store-of F ST' F],
    x :
      [ |-
         step
           ST'
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc1) (\y125. E2) E') ST' E']
  ; split inversion-tm/iftag [ |- Dof] as
    case inversion-tm/iftag/i:
    { F : ( |- sttp),
      Dloc : ( |- location),
      E1 : ( |- term),
      Dloc1 : ( |- location),
      E2 : (x19 : term |- term),
      E' : ( |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof :
        ( |-
           tm-of
             F
             (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
             (tm/tagloc Dloc1) (\y125. E2) E') T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E1),
      X : ( |- loc-neq Dloc Dloc1),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F (tm/tag (tm/tagloc Dloc) E1) tagged),
      Dof2 : ( |- tm-of F (tm/tagloc Dloc1) (tag C1)),
      Dof3 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E2[x]) T[]),
      Dof4 : ( |- tm-of F E' T)
    | tof :
        [ |-
           tm-of
             F
             (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
             (tm/tagloc Dloc1) (\y125. E2) E') T],
      sof : [ |- store-of F ST' F],
      x :
        [ |-
           step
             ST'
             (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
             (tm/tagloc Dloc1) (\y125. E2) E') ST' E']
    ; solve [ |- preservation-tm/i F Dof4 Dstof (extends/nil )]
    }
  }
  case step/iftag-beta1:
  { F : ( |- sttp),
    Dloc : ( |- location),
    E1 : ( |- term),
    E2 : (x18 : term |- term),
    E3 : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof :
      ( |-
         tm-of
           F
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc) (\y125. E2) E3) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1)
  | tof :
      [ |-
         tm-of
           F
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc) (\y125. E2) E3) T],
    sof : [ |- store-of F ST' F],
    x :
      [ |-
         step
           ST'
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc) (\y125. E2) E3) ST' (E2[E1])]
  ; ?
  }
  case step/iftag2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    E4 : (x17 : term |- term),
    E5 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E3 : ( |- term),
    Dof : ( |- tm-of F (tm/iftag E1 E2 (\y125. E4) E5) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dstep : ( |- step ST E2 ST' E3)
  | tof : [ |- tm-of F (tm/iftag E1 E2 (\y125. E4) E5) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/iftag E1 E2 (\y125. E4) E5)
           ST' (tm/iftag E1 E3 (\y125. E4) E5)]
  ; ?
  }
  case step/iftag1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    E4 : (x16 : term |- term),
    E5 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/iftag E1 E3 (\y125. E4) E5) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/iftag E1 E3 (\y125. E4) E5) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/iftag E1 E3 (\y125. E4) E5)
           ST' (tm/iftag E2 E3 (\y125. E4) E5)]
  ; ?
  }
  case step/tag2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E3 : ( |- term),
    Dof : ( |- tm-of F (tm/tag E1 E2) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dstep : ( |- step ST E2 ST' E3)
  | tof : [ |- tm-of F (tm/tag E1 E2) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/tag E1 E2) ST' (tm/tag E1 E3)]
  ; ?
  }
  case step/tag1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/tag E1 E3) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/tag E1 E3) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/tag E1 E3) ST' (tm/tag E2 E3)]
  ; ?
  }
  case step/newtag-beta:
  { F : ( |- sttp),
    C : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    Dloc : ( |- location),
    Dof : ( |- tm-of F (tm/newtag C) T),
    Dstof : ( |- store-of F ST F),
    Dnextloc : ( |- nextloc ST Dloc)
  | tof : [ |- tm-of F (tm/newtag C) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/newtag C) (store/cons ST Dloc (entry/tag C)) (tm/tagloc Dloc)]
  ; ?
  }
  case step/assign-beta:
  { F : ( |- sttp),
    Dloc : ( |- location),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/assign (tm/refloc Dloc) E1) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dupdate : ( |- store-update ST Dloc (entry/ref E1) ST')
  | tof : [ |- tm-of F (tm/assign (tm/refloc Dloc) E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/assign (tm/refloc Dloc) E1) ST' tm/unit]
  ; ?
  }
  case step/assign2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E3 : ( |- term),
    Dof : ( |- tm-of F (tm/assign E1 E2) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dstep : ( |- step ST E2 ST' E3)
  | tof : [ |- tm-of F (tm/assign E1 E2) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/assign E1 E2) ST' (tm/assign E1 E3)]
  ; ?
  }
  case step/assign1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/assign E1 E3) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/assign E1 E3) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/assign E1 E3) ST' (tm/assign E2 E3)]
  ; ?
  }
  case step/deref-beta:
  { F : ( |- sttp),
    Dloc : ( |- location),
    T : ( |- con),
    ST' : ( |- store),
    E' : ( |- term),
    Dof : ( |- tm-of F (tm/deref (tm/refloc Dloc)) T),
    Dstof : ( |- store-of F ST' F),
    Dlookup : ( |- store-lookup ST' Dloc (entry/ref E'))
  | tof : [ |- tm-of F (tm/deref (tm/refloc Dloc)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/deref (tm/refloc Dloc)) ST' E']
  ; ?
  }
  case step/deref:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/deref E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/deref E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/deref E1) ST' (tm/deref E2)]
  ; by inversion-tm/deref [ |- Dof] as Dof' unboxed;
    split preservation-tm [ |- Dof'] [ |- Dstof] [ |- Dstep] as
    case preservation-tm/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/deref E1) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      Dof' : ( |- tm-of F E1 (ref T)),
      F2 : ( |- sttp),
      Dof1 : ( |- tm-of F2 E2 (ref T)),
      Dof2 : ( |- store-of F2 ST' F2),
      Dextends : ( |- extends F F2)
    | tof : [ |- tm-of F (tm/deref E1) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/deref E1) ST' (tm/deref E2)]
    ; solve [ |- preservation-tm/i F2 (tm-of/deref Dof1) Dof2 Dextends]
    }
  }
  case step/ref-beta:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    Dloc : ( |- location),
    Dof : ( |- tm-of F (tm/ref E1) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dnextloc : ( |- nextloc ST Dloc)
  | tof : [ |- tm-of F (tm/ref E1) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/ref E1) (store/cons ST Dloc (entry/ref E1)) (tm/refloc Dloc)]
  ; ?
  }
  case step/ref:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/ref E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/ref E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/ref E1) ST' (tm/ref E2)]
  ; split inversion-tm/ref [ |- Dof] as
    case inversion-tm/ref/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/ref E1) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv (ref C1) T t),
      Dof1 : ( |- tm-of F E1 C1)
    | tof : [ |- tm-of F (tm/ref E1) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/ref E1) ST' (tm/ref E2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/ref E1) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C1 : ( |- con),
        Dequiv : ( |- cn-equiv (ref C1) T t),
        Dof1 : ( |- tm-of F E1 C1),
        F2 : ( |- sttp),
        Dof2 : ( |- tm-of F2 E2 C1),
        Dof3 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/ref E1) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/ref E1) ST' (tm/ref E2)]
      ; solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/ref Dof2) Dequiv) Dof3 Dextends]
      }
    }
  }
  case step/case-beta2:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    E2 : (x14 : term |- term),
    E3 : (x15 : term |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/case (tm/in2 E1 C) (\x120. E2) (\y120. E3)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1)
  | tof : [ |- tm-of F (tm/case (tm/in2 E1 C) (\x120. E2) (\y120. E3)) T],
    sof : [ |- store-of F ST' F],
    x :
      [ |-
         step
           ST' (tm/case (tm/in2 E1 C) (\x120. E2) (\y120. E3)) ST' (E3[E1])]
  ; ?
  }
  case step/case-beta1:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    E2 : (x12 : term |- term),
    E3 : (x13 : term |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/case (tm/in1 E1 C) (\x120. E2) (\y120. E3)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1)
  | tof : [ |- tm-of F (tm/case (tm/in1 E1 C) (\x120. E2) (\y120. E3)) T],
    sof : [ |- store-of F ST' F],
    x :
      [ |-
         step
           ST' (tm/case (tm/in1 E1 C) (\x120. E2) (\y120. E3)) ST' (E2[E1])]
  ; ?
  }
  case step/case:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : (x10 : term |- term),
    E4 : (x11 : term |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/case E1 (\x120. E3) (\y120. E4)) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/case E1 (\x120. E3) (\y120. E4)) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/case E1 (\x120. E3) (\y120. E4))
           ST' (tm/case E2 (\x120. E3) (\y120. E4))]
  ; ?
  }
  case step/in2:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/in2 E1 C) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/in2 E1 C) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/in2 E1 C) ST' (tm/in2 E2 C)]
  ; split inversion-tm/in2 [ |- Dof] as
    case inversion-tm/in2/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/in2 E1 C) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C3 : ( |- con),
      Dequiv : ( |- cn-equiv (plus C C3) T t),
      Dof1 : ( |- tm-of F E1 C3),
      Dof2 : ( |- cn-of C t)
    | tof : [ |- tm-of F (tm/in2 E1 C) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/in2 E1 C) ST' (tm/in2 E2 C)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        C : ( |- con),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/in2 E1 C) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C3 : ( |- con),
        Dequiv : ( |- cn-equiv (plus C C3) T t),
        Dof1 : ( |- tm-of F E1 C3),
        Dof2 : ( |- cn-of C t),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E2 C3),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/in2 E1 C) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/in2 E1 C) ST' (tm/in2 E2 C)]
      ; solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/in2 Dof3 Dof2) Dequiv) Dof4 Dextends]
      }
    }
  }
  case step/in1:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/in1 E1 C) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/in1 E1 C) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/in1 E1 C) ST' (tm/in1 E2 C)]
  ; split inversion-tm/in1 [ |- Dof] as
    case inversion-tm/in1/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/in1 E1 C) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C3 : ( |- con),
      Dequiv : ( |- cn-equiv (plus C3 C) T t),
      Dof1 : ( |- tm-of F E1 C3),
      Dof2 : ( |- cn-of C t)
    | tof : [ |- tm-of F (tm/in1 E1 C) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/in1 E1 C) ST' (tm/in1 E2 C)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        C : ( |- con),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/in1 E1 C) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C3 : ( |- con),
        Dequiv : ( |- cn-equiv (plus C3 C) T t),
        Dof1 : ( |- tm-of F E1 C3),
        Dof2 : ( |- cn-of C t),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E2 C3),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/in1 E1 C) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/in1 E1 C) ST' (tm/in1 E2 C)]
      ; solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/in1 Dof3 Dof2) Dequiv) Dof4 Dextends]
      }
    }
  }
  case step/app-beta:
  { F : ( |- sttp),
    C : ( |- con),
    E2 : (x9 : term |- term),
    E1 : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/app (tm/lam C (\x. E2)) E1) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1)
  | tof : [ |- tm-of F (tm/app (tm/lam C (\x. E2)) E1) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/app (tm/lam C (\x. E2)) E1) ST' (E2[E1])]
  ; ?
  }
  case step/app2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E3 : ( |- term),
    Dof : ( |- tm-of F (tm/app E1 E2) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dstep : ( |- step ST E2 ST' E3)
  | tof : [ |- tm-of F (tm/app E1 E2) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/app E1 E2) ST' (tm/app E1 E3)]
  ; ?
  }
  case step/app1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/app E1 E3) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/app E1 E3) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/app E1 E3) ST' (tm/app E2 E3)]
  ; ?
  }
  case step/pi2-beta:
  { F : ( |- sttp),
    E1 : ( |- term),
    E' : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/pi2 (tm/pair E1 E')) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1),
    Dvalue1 : ( |- value E')
  | tof : [ |- tm-of F (tm/pi2 (tm/pair E1 E')) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/pi2 (tm/pair E1 E')) ST' E']
  ; ?
  }
  case step/pi2:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/pi2 E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/pi2 E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/pi2 E1) ST' (tm/pi2 E2)]
  ; split inversion-tm/pi2 [ |- Dof] as
    case inversion-tm/pi2/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/pi2 E1) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F E1 (prod C1 T))
    | tof : [ |- tm-of F (tm/pi2 E1) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/pi2 E1) ST' (tm/pi2 E2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/pi2 E1) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C1 : ( |- con),
        Dof1 : ( |- tm-of F E1 (prod C1 T)),
        F2 : ( |- sttp),
        Dof2 : ( |- tm-of F2 E2 (prod C1 T)),
        Dof3 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/pi2 E1) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/pi2 E1) ST' (tm/pi2 E2)]
      ; solve [ |- preservation-tm/i F2 (tm-of/pi2 Dof2) Dof3 Dextends]
      }
    }
  }
  case step/pi1-beta:
  { F : ( |- sttp),
    E' : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/pi1 (tm/pair E' E2)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E'),
    Dvalue1 : ( |- value E2)
  | tof : [ |- tm-of F (tm/pi1 (tm/pair E' E2)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/pi1 (tm/pair E' E2)) ST' E']
  ; ?
  }
  case step/pi1:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/pi1 E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/pi1 E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/pi1 E1) ST' (tm/pi1 E2)]
  ; split inversion-tm/pi1 [ |- Dof] as
    case inversion-tm/pi1/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/pi1 E1) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F E1 (prod T C1))
    | tof : [ |- tm-of F (tm/pi1 E1) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/pi1 E1) ST' (tm/pi1 E2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/pi1 E1) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C1 : ( |- con),
        Dof1 : ( |- tm-of F E1 (prod T C1)),
        F2 : ( |- sttp),
        Dof2 : ( |- tm-of F2 E2 (prod T C1)),
        Dof3 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/pi1 E1) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/pi1 E1) ST' (tm/pi1 E2)]
      ; solve [ |- preservation-tm/i F2 (tm-of/pi1 Dof2) Dof3 Dextends]
      }
    }
  }
  case step/pair2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E3 : ( |- term),
    Dof : ( |- tm-of F (tm/pair E1 E2) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dstep : ( |- step ST E2 ST' E3)
  | tof : [ |- tm-of F (tm/pair E1 E2) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/pair E1 E2) ST' (tm/pair E1 E3)]
  ; ?
  }
  case step/pair1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/pair E1 E3) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/pair E1 E3) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/pair E1 E3) ST' (tm/pair E2 E3)]
  ; ?
  }
  case step/abort:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/abort E1 C) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/abort E1 C) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/abort E1 C) ST' (tm/abort E2 C)]
  ; split inversion-tm/abort [ |- Dof] as
    case inversion-tm/abort/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/abort E1 C) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      Dof1 : ( |- tm-of F E1 void),
      Dequiv : ( |- cn-equiv C T t)
    | tof : [ |- tm-of F (tm/abort E1 C) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/abort E1 C) ST' (tm/abort E2 C)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        C : ( |- con),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/abort E1 C) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        Dof1 : ( |- tm-of F E1 void),
        Dequiv : ( |- cn-equiv C T t),
        F2 : ( |- sttp),
        Dof2 : ( |- tm-of F2 E2 void),
        Dof3 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/abort E1 C) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/abort E1 C) ST' (tm/abort E2 C)]
      ; by cn-equiv-reg/cn-of1 [ |- Dequiv] as DofT unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/abort DofT Dof2) Dequiv) Dof3 Dextends]
      }
    }
  }
}
;
