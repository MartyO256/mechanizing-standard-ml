% Monotonicity

LF extends : sttp -> sttp -> type =
| extends/nil : extends F F
| extends/cons :
  extends F1 F2 ->
    ({ L : location } { ET : entp } extends F1 (st/cons F2 L ET))
;
--name extends Dextends extends.

proof monotonicity-lookup :
  (g : conblock)
  [g |- st-lookup F L[] ET] ->
  [g |- extends F F'] ->
    [g |- st-lookup F' L[] ET] =
/ total 2 /
intros
{ g : conblock,
  F : (g |- sttp),
  L : ( |- location),
  ET : (g |- entp),
  F' : (g |- sttp)
| lookup : [g |- st-lookup F L[] ET], x : [g |- extends F F']
; split x as
  case extends/cons:
  { g : conblock,
    F : (g |- sttp),
    L : ( |- location),
    ET : (g |- entp),
    F2 : (g |- sttp),
    Dloc : ( |- location),
    ET1 : (g |- entp),
    Dextends : (g |- extends F F2)
  | lookup : [g |- st-lookup F L[] ET],
    x : [g |- extends F (st/cons F2 Dloc[] ET1)]
  ; by monotonicity-lookup lookup [_ |- Dextends] as Dlookup' unboxed;
    solve [_ |- st-lookup/miss Dlookup']
  }
  case extends/nil:
  { g : conblock, F' : (g |- sttp), L : ( |- location), ET : (g |- entp)
  | lookup : [g |- st-lookup F' L[] ET], x : [g |- extends F' F']
  ; solve lookup
  }
}
;

schema monotonicity-ctx =
  % termbind
  some [T : con]
  block (
    x : term, u : { F' : sttp } tm-of F' x T
  ) +
  % modbind
  some [K : kind, S : sg]
  block (
    a : con, da : cn-of a K,
    m : module', dm : { P' : purity } { F' : sttp } md-of P' F' m S,
    dfst : md-fst m a
  );

proof monotonicity-tm :
  (g : monotonicity-ctx)
  [g |- tm-of F E T] ->
  [g |- extends F F'] ->
    [g |- tm-of F' E T] =
/ total 1 /
intros
{ g : monotonicity-ctx,
  F : (g |- sttp),
  E : (g |- term),
  T : (g |- con),
  F' : (g |- sttp)
| x : [g |- tm-of F E T], extends : [g |- extends F F']
; split x as
  case tm-of/equiv:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E : (g |- term),
    T : (g |- con),
    F' : (g |- sttp),
    C : (g |- con),
    Dof : (g |- tm-of F E C),
    Dequiv : (g |- cn-equiv C T t)
  | x : [g |- tm-of F E T], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/equiv Dof' Dequiv]
  }
  case tm-of/snd:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    T : (g |- con),
    F' : (g |- sttp),
    P : ( |- purity),
    Dof : (g |- md-of P[] F M (sg/datom T))
  | x : [g |- tm-of F (tm/snd M) T], extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/snd Dof']
  }
  case tm-of/lett:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g, x6 : term |- term),
    T : (g |- con),
    F' : (g |- sttp),
    C : (g |- con),
    Dof : (g |- tm-of F E1 C),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         tm-of (F[..]) (E2[.., x]) (T[..]))
  | x : [g |- tm-of F (tm/lett E1 (\x. E2)) T], extends : [g |- extends F F']
  ; by extends as Dextends unboxed;
    by monotonicity-tm [g |- Dof] [g |- Dextends] as Dof1' unboxed;
    by monotonicity-tm
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
            Dof1[.., b.1, b.2]]
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
            Dextends[..]]
    as Dof2' unboxed;
    solve [g |- tm-of/lett Dof1' (\x. \u. Dof2'[.., <x; u>])]
  }
  case tm-of/try:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g, x5 : term |- term),
    T : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E1 T),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x tagged |-
         tm-of (F[..]) (E2[.., x]) (T[..]))
  | x : [g |- tm-of F (tm/try E1 (\x. E2)) T], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof1' unboxed;
    by extends as Dextends unboxed;
    by monotonicity-tm
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x tagged) |-
            Dof1[.., b.1, b.2]]
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x tagged) |-
            Dextends[..]]
    as Dof2' unboxed;
    solve [g |- tm-of/try Dof1' (\x. \u. Dof2'[.., <x; u>])]
  }
  case tm-of/raise:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E1 tagged),
    Dof1 : (g |- cn-of T t)
  | x : [g |- tm-of F (tm/raise E1 T) T], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/raise Dof' Dof1]
  }
  case tm-of/out:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    F' : (g |- sttp),
    X : ( |- label),
    Dof : (g |- tm-of F E1 (labeled X[] T))
  | x : [g |- tm-of F (tm/out E1) T], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/out Dof']
  }
  case tm-of/in:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    X : ( |- label),
    E1 : (g |- term),
    C : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E1 C)
  | x : [g |- tm-of F (tm/in X[] E1) (labeled X[] C)],
    extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/in Dof']
  }
  case tm-of/unroll:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    C : (g, a46 : con, a45 : con |- con),
    C1 : (g |- con),
    K : (g |- kind),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E1 (rec' K (\x255. \z255. C) C1))
  | x :
      [g |-
         tm-of
           F
           (tm/unroll E1)
           (C[.., lam K
              (\a. rec' (K[..]) (\x255. \z255. C[.., x255, z255]) a), C1])],
    extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/unroll Dof']
  }
  case tm-of/roll:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    K : (g |- kind),
    C : (g, a44 : con, a43 : con |- con),
    C1 : (g |- con),
    F' : (g |- sttp),
    Dof :
      (g |-
         tm-of
           F
           E1
           (C[.., lam K
              (\a. rec' (K[..]) (\x255. \z255. C[.., x255, z255]) a), C1])),
    Dwf : (g |- kd-wf K),
    Dof1 :
      (g, a : con, x367 : cn-of a (pi (K[..]) (\l. t)), b : con,
       z367 : cn-of b (K[..]) |- cn-of (C[.., a, b]) t),
    Dof2 : (g |- cn-of C1 K)
  | x :
      [g |-
         tm-of
           F
           (tm/roll E1 K (\z276. \y277. C) C1) (rec' K (\x255. \z255. C) C1)],
    extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/roll Dof' Dwf (\a. \da. \b. \db. Dof1) Dof2]
  }
  case tm-of/iftag:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g |- term),
    E3 : (g, x4 : term |- term),
    E4 : (g |- term),
    T : (g |- con),
    F' : (g |- sttp),
    C : (g |- con),
    Dof : (g |- tm-of F E1 tagged),
    Dof1 : (g |- tm-of F E2 (tag C)),
    Dof2 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         tm-of (F[..]) (E3[.., x]) (T[..])),
    Dof3 : (g |- tm-of F E4 T)
  | x : [g |- tm-of F (tm/iftag E1 E2 (\y275. E3) E4) T],
    extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof1' unboxed;
    by monotonicity-tm [g |- Dof1] extends as Dof2' unboxed;
    by extends as Dextends unboxed;
    by monotonicity-tm
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
            Dof2[.., b.1, b.2]]
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
            Dextends[..]]
    as Dof3' unboxed;
    by monotonicity-tm [g |- Dof3] extends as Dof4' unboxed;
    solve [g |- tm-of/iftag Dof1' Dof2' (\x. \u. Dof3'[.., <x; u>]) Dof4']
  }
  case tm-of/tag:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g |- term),
    F' : (g |- sttp),
    C : (g |- con),
    Dof : (g |- tm-of F E1 (tag C)),
    Dof1 : (g |- tm-of F E2 C)
  | x : [g |- tm-of F (tm/tag E1 E2) tagged], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof1' unboxed;
    by monotonicity-tm [g |- Dof1] extends as Dof2' unboxed;
    solve [g |- tm-of/tag Dof1' Dof2']
  }
  case tm-of/newtag:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    C : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- cn-of C t)
  | x : [g |- tm-of F (tm/newtag C) (tag C)], extends : [g |- extends F F']
  ; solve [g |- tm-of/newtag Dof]
  }
  case tm-of/tagloc:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    Dloc : ( |- location),
    C : (g |- con),
    F' : (g |- sttp),
    Dlookup : (g |- st-lookup F Dloc[] (et/tag C)),
    Dof : (g |- cn-of C t)
  | x : [g |- tm-of F (tm/tagloc Dloc[]) (tag C)],
    extends : [g |- extends F F']
  ; by monotonicity-lookup [g |- Dlookup] extends as Dlookup' unboxed;
    solve [g |- tm-of/tagloc Dlookup' Dof]
  }
  case tm-of/assign:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g |- term),
    F' : (g |- sttp),
    C : (g |- con),
    Dof : (g |- tm-of F E1 (ref C)),
    Dof1 : (g |- tm-of F E2 C)
  | x : [g |- tm-of F (tm/assign E1 E2) unit], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof1' unboxed;
    by monotonicity-tm [g |- Dof1] extends as Dof2' unboxed;
    solve [g |- tm-of/assign Dof1' Dof2']
  }
  case tm-of/deref:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E1 (ref T))
  | x : [g |- tm-of F (tm/deref E1) T], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/deref Dof']
  }
  case tm-of/ref:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    C : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E1 C)
  | x : [g |- tm-of F (tm/ref E1) (ref C)], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/ref Dof']
  }
  case tm-of/refloc:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    Dloc : ( |- location),
    C : (g |- con),
    F' : (g |- sttp),
    Dlookup : (g |- st-lookup F Dloc[] (et/ref C)),
    Dof : (g |- cn-of C t)
  | x : [g |- tm-of F (tm/refloc Dloc[]) (ref C)],
    extends : [g |- extends F F']
  ; by monotonicity-lookup [g |- Dlookup] extends as Dlookup' unboxed;
    solve [g |- tm-of/refloc Dlookup' Dof]
  }
  case tm-of/case:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g, x2 : term |- term),
    E3 : (g, x3 : term |- term),
    T : (g |- con),
    F' : (g |- sttp),
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- tm-of F E1 (plus C C1)),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         tm-of (F[..]) (E2[.., x]) (T[..])),
    Dof2 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C1[..]) |-
         tm-of (F[..]) (E3[.., x]) (T[..]))
  | x : [g |- tm-of F (tm/case E1 (\x270. E2) (\y270. E3)) T],
    extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    by extends as Dextends unboxed;
    by monotonicity-tm
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
            Dof1[.., b.1, b.2]]
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
            Dextends[..]]
    as Dof1' unboxed;
    by monotonicity-tm
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C1[..])) |-
            Dof2[.., b.1, b.2]]
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C1[..])) |-
            Dextends[..]]
    as Dof2' unboxed;
    solve
      [g |-
         tm-of/case Dof'
         (\x. \u. Dof1'[.., <x; u>]) (\x. \u. Dof2'[.., <x; u>])]
  }
  case tm-of/in2:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    C1 : (g |- con),
    C : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E1 C),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- tm-of F (tm/in2 E1 C1) (plus C1 C)],
    extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/in2 Dof' Dof1]
  }
  case tm-of/in1:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    C1 : (g |- con),
    C : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E1 C),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- tm-of F (tm/in1 E1 C1) (plus C C1)],
    extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/in1 Dof' Dof1]
  }
  case tm-of/app:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g |- term),
    T : (g |- con),
    F' : (g |- sttp),
    C : (g |- con),
    Dof : (g |- tm-of F E1 (arrow C T)),
    Dof1 : (g |- tm-of F E2 C)
  | x : [g |- tm-of F (tm/app E1 E2) T], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof1' unboxed;
    by monotonicity-tm [g |- Dof1] extends as Dof2' unboxed;
    solve [g |- tm-of/app Dof1' Dof2']
  }
  case tm-of/lam:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    C : (g |- con),
    E1 : (g, x1 : term |- term),
    C1 : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- cn-of C t),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         tm-of (F[..]) (E1[.., x]) (C1[..]))
  | x : [g |- tm-of F (tm/lam C (\x. E1)) (arrow C C1)],
    extends : [g |- extends F F']
  ; by extends as Dextends unboxed;
    by monotonicity-tm
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
            Dof1[.., b.1, b.2]]
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
            Dextends[..]]
    as Dof' unboxed;
    solve [g |- tm-of/lam Dof (\x. \u. Dof'[.., <x; u>])]
  }
  case tm-of/pi2:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    F' : (g |- sttp),
    C : (g |- con),
    Dof : (g |- tm-of F E1 (prod C T))
  | x : [g |- tm-of F (tm/pi2 E1) T], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/pi2 Dof']
  }
  case tm-of/pi1:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    F' : (g |- sttp),
    C1 : (g |- con),
    Dof : (g |- tm-of F E1 (prod T C1))
  | x : [g |- tm-of F (tm/pi1 E1) T], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- tm-of/pi1 Dof']
  }
  case tm-of/pair:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g |- term),
    C : (g |- con),
    C1 : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E1 C),
    Dof1 : (g |- tm-of F E2 C1)
  | x : [g |- tm-of F (tm/pair E1 E2) (prod C C1)],
    extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof1' unboxed;
    by monotonicity-tm [g |- Dof1] extends as Dof2' unboxed;
    solve [g |- tm-of/pair Dof1' Dof2']
  }
  case tm-of/abort:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- tm-of F E1 void)
  | x : [g |- tm-of F (tm/abort E1 T) T], extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof1] extends as Dof' unboxed;
    solve [g |- tm-of/abort Dof Dof']
  }
  case tm-of/unit:
  { g : monotonicity-ctx, F : (g |- sttp), F' : (g |- sttp)
  | x : [g |- tm-of F tm/unit unit], extends : [g |- extends F F']
  ; solve [g |- tm-of/unit ]
  }
  %{ FIXME: Ill-typed expression.
  case #.2:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    T : (g |- con),
    #tof : #(g |- block (x : term, u : {F' : sttp}  tm-of F' x (T[..]))),
    F' : (g |- sttp)
  | x : [g |- tm-of F #tof.1 T], extends : [g |- extends F F']
  ; ?
  }
  }%
}

and proof monotonicity-md :
  (g : monotonicity-ctx)
  [g |- md-of P[] F M S] ->
  [g |- extends F F'] ->
    [g |- md-of P[] F' M S] =
/ total 1 /
intros
{ g : monotonicity-ctx,
  P : ( |- purity),
  F : (g |- sttp),
  M : (g |- module'),
  S : (g |- sg),
  F' : (g |- sttp)
| x : [g |- md-of P[] F M S], extends : [g |- extends F F']
; split x as
  case md-of/subsume:
  { g : monotonicity-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M : (g |- module'),
    S : (g |- sg),
    F' : (g |- sttp),
    S1 : (g |- sg),
    Dof : (g |- md-of P[] F M S1),
    Dsub : (g |- sg-sub S1 S)
  | x : [g |- md-of P[] F M S], extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof' unboxed;
    solve [g |- md-of/subsume Dof' Dsub]
  }
  case md-of/forget:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    S : (g |- sg),
    F' : (g |- sttp),
    Dof : (g |- md-of pure F M S)
  | x : [g |- md-of impure F M S], extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof' unboxed;
    solve [g |- md-of/forget Dof']
  }
  case md-of/extnamed:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    L : ( |- name),
    S2 : (g |- sg),
    F' : (g |- sttp),
    S1 : (g |- sg),
    Dof : (g |- md-of pure F M (sg/named L[] S1)),
    Dof1 : (g |- md-of pure F (md/out M) S2)
  | x : [g |- md-of pure F M (sg/named L[] S2)],
    extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof1' unboxed;
    by monotonicity-md [g |- Dof1] extends as Dof2' unboxed;
    solve [g |- md-of/extnamed Dof1' Dof2']
  }
  case md-of/extsigma:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    S1 : (g |- sg),
    S2 : (g |- sg),
    F' : (g |- sttp),
    Dof : (g |- md-of pure F (md/pi1 M) S1),
    Dof1 : (g |- md-of pure F (md/pi2 M) S2)
  | x : [g |- md-of pure F M (sg/sigma S1 (\x. S2[..]))],
    extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof1' unboxed;
    by monotonicity-md [g |- Dof1] extends as Dof2' unboxed;
    solve [g |- md-of/extsigma Dof1' Dof2']
  }
  case md-of/self:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    K1 : (g |- kind),
    F' : (g |- sttp),
    K : (g |- kind),
    C : (g |- con),
    Dof : (g |- md-of pure F M (sg/satom K)),
    Dfst : (g |- md-fst M C),
    Dof1 : (g |- cn-of C K1)
  | x : [g |- md-of pure F M (sg/satom K1)], extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof' unboxed;
    solve [g |- md-of/self Dof' Dfst Dof1]
  }
  case md-of/seal:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    F' : (g |- sttp),
    P1 : ( |- purity),
    Dof : (g |- md-of P1[] F M1 S)
  | x : [g |- md-of impure F (md/seal M1 S) S], extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof' unboxed;
    solve [g |- md-of/seal Dof']
  }
  case md-of/lete:
  { g : monotonicity-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    E : (g |- term),
    C : (g |- con),
    M1 : (g, x7 : term |- module'),
    S : (g |- sg),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E C),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         md-of P[] (F[..]) (M1[.., x]) (S[..]))
  | x : [g |- md-of P[] F (md/lete E C (\x. M1)) S],
    extends : [g |- extends F F']
  ; by extends as Dextends unboxed;
    by monotonicity-tm [g |- Dof] [g |- Dextends] as Dof1' unboxed;
    by monotonicity-md
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
            Dof1[.., b.1, b.2]]
         [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
            Dextends[..]]
    as Dof2' unboxed;
    solve [g |- md-of/lete Dof1' (\x. \u. Dof2'[.., <x; u>])]
  }
  case md-of/letp:
  { g : monotonicity-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a68 : con, m4 : module' |- module'),
    S2 : (g, a69 : con |- sg),
    C : (g |- con),
    F' : (g |- sttp),
    S1 : (g |- sg),
    K : (g |- kind),
    Dof : (g |- md-of pure F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dfst1 : (g |- md-fst M1 C),
    Dof1 :
      (g, a : con, z400 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       y401 : md-fst m a |- md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a]))
  | x : [g |- md-of P[] F (md/letp M1 (\y291. \x291. M2)) (S2[.., C])],
    extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof1' unboxed;
    by extends as Dextends unboxed;
    by monotonicity-md
         [g,
          b :
            block (
              a : con,
              da : cn-of a (K[..]),
              m : module',
              u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
              dfst : md-fst m a) |- Dof1[.., b.1, b.2, b.3, b.4, b.5]]
         [g,
          b :
            block (
              a : con,
              da : cn-of a (K[..]),
              m : module',
              u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
              dfst : md-fst m a) |- Dextends[..]]
    as Dof2' unboxed;
    solve
      [g |-
         md-of/letp Dof1'
         Dfst
         Dfst1
         (\a.
            \da.
              \m. \u. \dfst. Dof2'[.., <a; da; m; (\P'. \F'. u P' F'); dfst>])]
  }
  case md-of/let:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a67 : con, m3 : module' |- module'),
    S : (g |- sg),
    F' : (g |- sttp),
    P1 : ( |- purity),
    S1 : (g |- sg),
    K : (g |- kind),
    P2 : ( |- purity),
    Dof : (g |- md-of P1[] F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dof1 :
      (g, a : con, z398 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       y399 : md-fst m a |- md-of P2[] (F[..]) (M2[.., a, m]) (S[..]))
  | x : [g |- md-of impure F (md/let M1 (\z289. \y290. M2) S) S],
    extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof1' unboxed;
    by extends as Dextends unboxed;
    by monotonicity-md
         [g,
          b :
            block (
              a : con,
              da : cn-of a (K[..]),
              m : module',
              u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
              dfst : md-fst m a) |- Dof1[.., b.1, b.2, b.3, b.4, b.5]]
         [g,
          b :
            block (
              a : con,
              da : cn-of a (K[..]),
              m : module',
              u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
              dfst : md-fst m a) |- Dextends[..]]
    as Dof2' unboxed;
    solve
      [g |-
         md-of/let Dof1'
         Dfst
         (\a.
            \da.
              \m. \u. \dfst. Dof2'[.., <a; da; m; (\P'. \F'. u P' F'); dfst>])]
  }
  case md-of/out:
  { g : monotonicity-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    F' : (g |- sttp),
    L : ( |- name),
    Dof : (g |- md-of P[] F M1 (sg/named L[] S))
  | x : [g |- md-of P[] F (md/out M1) S], extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof' unboxed;
    solve [g |- md-of/out Dof']
  }
  case md-of/in:
  { g : monotonicity-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    L : ( |- name),
    M1 : (g |- module'),
    S1 : (g |- sg),
    F' : (g |- sttp),
    Dof : (g |- md-of P[] F M1 S1)
  | x : [g |- md-of P[] F (md/in L[] M1) (sg/named L[] S1)],
    extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof' unboxed;
    solve [g |- md-of/in Dof']
  }
  case md-of/app:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g |- module'),
    S2 : (g, a66 : con |- sg),
    C : (g |- con),
    F' : (g |- sttp),
    P1 : ( |- purity),
    S1 : (g |- sg),
    Dof : (g |- md-of P1[] F M1 (sg/pi S1 (\y262. S2))),
    Dof1 : (g |- md-of pure F M2 S1),
    Dfst : (g |- md-fst M2 C)
  | x : [g |- md-of impure F (md/app M1 M2) (S2[.., C])],
    extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof1' unboxed;
    by monotonicity-md [g |- Dof1] extends as Dof2' unboxed;
    solve [g |- md-of/app Dof1' Dof2' Dfst]
  }
  case md-of/lam:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    S1 : (g |- sg),
    M1 : (g, a64 : con, m2 : module' |- module'),
    S2 : (g, a65 : con |- sg),
    F' : (g |- sttp),
    K : (g |- kind),
    P1 : ( |- purity),
    Dwf : (g |- sg-wf S1),
    Dfst : (g |- sg-fst S1 K),
    Dof :
      (g, a : con, x395 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       z395 : md-fst m a |- md-of P1[] (F[..]) (M1[.., a, m]) (S2[.., a]))
  | x :
      [g |-
         md-of pure F (md/lam S1 (\x286. \z286. M1)) (sg/pi S1 (\y262. S2))],
    extends : [g |- extends F F']
  ; by extends as Dextends unboxed;
    by monotonicity-md
         [g,
          b :
            block (
              a : con,
              da : cn-of a (K[..]),
              m : module',
              u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
              dfst : md-fst m a) |- Dof[.., b.1, b.2, b.3, b.4, b.5]]
         [g,
          b :
            block (
              a : con,
              da : cn-of a (K[..]),
              m : module',
              u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
              dfst : md-fst m a) |- Dextends[..]]
    as Dof' unboxed;
    solve
      [g |-
         md-of/lam Dwf
         Dfst
         (\a.
            \da.
              \m. \u. \dfst. Dof'[.., <a; da; m; (\P'. \F'. u P' F'); dfst>])]
  }
  case md-of/pi2:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S2 : (g, a63 : con |- sg),
    C : (g |- con),
    F' : (g |- sttp),
    S1 : (g |- sg),
    Dof : (g |- md-of pure F M1 (sg/sigma S1 (\y263. S2))),
    Dfst : (g |- md-fst M1 C)
  | x : [g |- md-of pure F (md/pi2 M1) (S2[.., pi1 C])],
    extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof' unboxed;
    solve [g |- md-of/pi2 Dof' Dfst]
  }
  case md-of/pi1:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    F' : (g |- sttp),
    S2 : (g, a62 : con |- sg),
    Dof : (g |- md-of pure F M1 (sg/sigma S (\y263. S2)))
  | x : [g |- md-of pure F (md/pi1 M1) S], extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof' unboxed;
    solve [g |- md-of/pi1 Dof']
  }
  case md-of/dpair:
  { g : monotonicity-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a60 : con, m1 : module' |- module'),
    S1 : (g |- sg),
    S2 : (g, a61 : con |- sg),
    F' : (g |- sttp),
    K : (g |- kind),
    Dof : (g |- md-of P[] F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dof1 :
      (g, a : con, z392 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       y393 : md-fst m a |- md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a]))
  | x :
      [g |- md-of P[] F (md/dpair M1 (\a. \m. M2)) (sg/sigma S1 (\y263. S2))],
    extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof1' unboxed;
    by extends as Dextends unboxed;
    by monotonicity-md
         [g,
          b :
            block (
              a : con,
              da : cn-of a (K[..]),
              m : module',
              u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
              dfst : md-fst m a) |- Dof1[.., b.1, b.2, b.3, b.4, b.5]]
         [g,
          b :
            block (
              a : con,
              da : cn-of a (K[..]),
              m : module',
              u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
              dfst : md-fst m a) |- Dextends[..]]
    as Dof2' unboxed;
    solve
      [g |-
         md-of/dpair Dof1'
         Dfst
         (\a.
            \da.
              \m. \u. \dfst. Dof2'[.., <a; da; m; (\P'. \F'. u P' F'); dfst>])]
  }
  case md-of/pair:
  { g : monotonicity-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g |- module'),
    S1 : (g |- sg),
    S2 : (g |- sg),
    F' : (g |- sttp),
    Dof : (g |- md-of P[] F M1 S1),
    Dof1 : (g |- md-of P[] F M2 S2)
  | x : [g |- md-of P[] F (md/pair M1 M2) (sg/sigma S1 (\x. S2[..]))],
    extends : [g |- extends F F']
  ; by monotonicity-md [g |- Dof] extends as Dof1' unboxed;
    by monotonicity-md [g |- Dof1] extends as Dof2' unboxed;
    solve [g |- md-of/pair Dof1' Dof2']
  }
  case md-of/datom:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    E : (g |- term),
    C : (g |- con),
    F' : (g |- sttp),
    Dof : (g |- tm-of F E C)
  | x : [g |- md-of pure F (md/datom E C) (sg/datom C)],
    extends : [g |- extends F F']
  ; by monotonicity-tm [g |- Dof] extends as Dof' unboxed;
    solve [g |- md-of/datom Dof']
  }
  case md-of/sgatom:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    S1 : (g |- sg),
    F' : (g |- sttp),
    Dwf : (g |- sg-wf S1)
  | x : [g |- md-of pure F (md/sgatom S1) (sg/sgatom S1)],
    extends : [g |- extends F F']
  ; solve [g |- md-of/sgatom Dwf]
  }
  case md-of/satom:
  { g : monotonicity-ctx,
    F : (g |- sttp),
    C : (g |- con),
    K : (g |- kind),
    F' : (g |- sttp),
    Dof : (g |- cn-of C K)
  | x : [g |- md-of pure F (md/satom C) (sg/satom K)],
    extends : [g |- extends F F']
  ; solve [g |- md-of/satom Dof]
  }
  case md-of/unit:
  { g : monotonicity-ctx, F : (g |- sttp), F' : (g |- sttp)
  | x : [g |- md-of pure F md/unit sg/one], extends : [g |- extends F F']
  ; solve [g |- md-of/unit ]
  }
  %{ FIXME: Uncaught exception
  case #.4:
  { g : monotonicity-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    K474 : (g |- kind),
    S : (g |- sg),
    #fst :
      #(g |-
          block (
            a : con,
            da : cn-of a (K474[..]),
            m : module',
            dm : {P' : purity}  {F' : sttp}  md-of P' F' m (S[..]),
            dfst : md-fst m a)),
    F' : (g |- sttp)
  | x : [g |- md-of P[] F #fst.3 S], extends : [g |- extends F F']
  ; ?
  }
  }%
}
;

proof monotonicity-entry :
  [ |- entry-of F EN ET] ->
  [ |- extends F F'] ->
    [ |- entry-of F' EN ET] =
/ total /
intros
{ F : ( |- sttp), EN : ( |- entry), ET : ( |- entp), F' : ( |- sttp)
| eof : [ |- entry-of F EN ET], extends : [ |- extends F F']
; split eof as
  case entry-of/tag:
  { F : ( |- sttp), C : ( |- con), F' : ( |- sttp), Dof : ( |- cn-of C t)
  | eof : [ |- entry-of F (entry/tag C) (et/tag C)],
    extends : [ |- extends F F']
  ; solve [ |- entry-of/tag Dof]
  }
  case entry-of/ref:
  { F : ( |- sttp),
    E : ( |- term),
    C : ( |- con),
    F' : ( |- sttp),
    Dvalue : ( |- value E),
    Dof : ( |- tm-of F E C)
  | eof : [ |- entry-of F (entry/ref E) (et/ref C)],
    extends : [ |- extends F F']
  ; by monotonicity-tm [ |- Dof] extends as Dof' unboxed;
    solve [ |- entry-of/ref Dvalue Dof']
  }
}
;

proof monotonicity-store :
  [ |- store-of F1 ST F2] ->
  [ |- extends F1 F1'] ->
    [ |- store-of F1' ST F2] =
/ total 1 /
intros
{ F : ( |- sttp), ST : ( |- store), F1 : ( |- sttp), F1' : ( |- sttp)
| x : [ |- store-of F ST F1], extends : [ |- extends F F1']
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    Dloc : ( |- location),
    EN : ( |- entry),
    F3 : ( |- sttp),
    ET : ( |- entp),
    F1' : ( |- sttp),
    Dbounds : ( |- store-bounds ST1 Dloc),
    Dof : ( |- entry-of F EN ET),
    Dof1 : ( |- store-of F ST1 F3)
  | x : [ |- store-of F (store/cons ST1 Dloc EN) (st/cons F3 Dloc ET)],
    extends : [ |- extends F F1']
  ; by monotonicity-store [ |- Dof1] extends as Dstof' unboxed;
    by monotonicity-entry [ |- Dof] extends as Dof' unboxed;
    solve [ |- store-of/cons Dbounds Dof' Dstof']
  }
  case store-of/nil:
  { F : ( |- sttp), F1' : ( |- sttp)
  | x : [ |- store-of F store/nil st/nil], extends : [ |- extends F F1']
  ; solve [ |- store-of/nil ]
  }
}
;

% Locations

proof loc-lt-antisymm : [ |- loc-lt L L] -> [ |- false] =
/ total /
intros
{ L : ( |- location)
| lt : [ |- loc-lt L L]
; split lt as
  case loc-lt/i:
  { N : ( |- nat), Dlt : ( |- lt N N)
  | lt : [ |- loc-lt (location/i N) (location/i N)]
  ; suffices by lt-antisymm toshow
    [ |- lt N N] {
      solve [ |- Dlt]
    }
  }
}
;

proof loc-lt-trans :
  [ |- loc-lt L1 L2] ->
  [ |- loc-lt L2 L3] ->
    [ |- loc-lt L1 L3] =
/ total /
intros
{ L : ( |- location), L1 : ( |- location), L2 : ( |- location)
| lt : [ |- loc-lt L L1], lt1 : [ |- loc-lt L1 L2]
; split lt as
  case loc-lt/i:
  { N : ( |- nat), N1 : ( |- nat), L2 : ( |- location), Dlt : ( |- lt N N1)
  | lt : [ |- loc-lt (location/i N) (location/i N1)],
    lt1 : [ |- loc-lt (location/i N1) L2]
  ; split lt1 as
    case loc-lt/i:
    { N : ( |- nat),
      N1 : ( |- nat),
      N3 : ( |- nat),
      Dlt : ( |- lt N N1),
      Dlt1 : ( |- lt N1 N3)
    | lt : [ |- loc-lt (location/i N) (location/i N1)],
      lt1 : [ |- loc-lt (location/i N1) (location/i N3)]
    ; by lt-trans [ |- Dlt] [ |- Dlt1] as Dlt2 unboxed;
      solve [ |- loc-lt/i Dlt2]
    }
  }
}
;

proof loc-succ-lt : [ |- loc-succ L L'] -> [ |- loc-lt L L'] =
/ total /
intros
{ L : ( |- location), L' : ( |- location)
| succ : [ |- loc-succ L L']
; split succ as
  case loc-succ/i:
  { N : ( |- nat)
  | succ : [ |- loc-succ (location/i N) (location/i (succ N))]
  ; suffices by loc-lt/i toshow
    [ |- lt N (succ N)] {
      suffices by lt-succ [ |- N] toshow
    }
  }
}
;

% Stores

proof store-bounds-increase :
  [ |- store-bounds ST L] ->
  [ |- loc-lt L L'] ->
    [ |- store-bounds ST L'] =
/ total 1 /
intros
{ ST : ( |- store), L : ( |- location), L' : ( |- location)
| x : [ |- store-bounds ST L], lt : [ |- loc-lt L L']
; split x as
  case store-bounds/cons:
  { ST1 : ( |- store),
    X : ( |- location),
    EN : ( |- entry),
    L : ( |- location),
    L' : ( |- location),
    Dlt : ( |- loc-lt X L)
  | x : [ |- store-bounds (store/cons ST1 X EN) L], lt : [ |- loc-lt L L']
  ; by loc-lt-trans [ |- Dlt] lt as Dlt1 unboxed;
    solve [ |- store-bounds/cons Dlt1]
  }
  case store-bounds/nil:
  { L : ( |- location), L' : ( |- location)
  | x : [ |- store-bounds store/nil L], lt : [ |- loc-lt L L']
  ; solve [ |- store-bounds/nil ]
  }
}
;

proof store-bounds-update :
  [ |- store-bounds ST L] ->
  [ |- store-update ST X EN ST'] ->
    [ |- store-bounds ST' L] =
/ total /
intros
{ ST : ( |- store),
  L : ( |- location),
  X : ( |- location),
  EN : ( |- entry),
  ST' : ( |- store)
| bounds : [ |- store-bounds ST L], x : [ |- store-update ST X EN ST']
; split bounds as
  case store-bounds/cons:
  { ST1 : ( |- store),
    X1 : ( |- location),
    EN1 : ( |- entry),
    L : ( |- location),
    X : ( |- location),
    EN : ( |- entry),
    ST' : ( |- store),
    Dlt : ( |- loc-lt X1 L)
  | bounds : [ |- store-bounds (store/cons ST1 X1 EN1) L],
    x : [ |- store-update (store/cons ST1 X1 EN1) X EN ST']
  ; split x as
    case store-update/miss:
    { ST1 : ( |- store),
      X1 : ( |- location),
      EN1 : ( |- entry),
      L : ( |- location),
      X : ( |- location),
      EN : ( |- entry),
      ST3 : ( |- store),
      Dlt : ( |- loc-lt X1 L),
      Dupdate : ( |- store-update ST1 X EN ST3)
    | bounds : [ |- store-bounds (store/cons ST1 X1 EN1) L],
      x :
        [ |-
           store-update (store/cons ST1 X1 EN1) X EN (store/cons ST3 X1 EN1)]
    ; solve [ |- store-bounds/cons Dlt]
    }
    case store-update/hit:
    { ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      L : ( |- location),
      EN : ( |- entry),
      Dlt : ( |- loc-lt X L)
    | bounds : [ |- store-bounds (store/cons ST1 X EN1) L],
      x :
        [ |- store-update (store/cons ST1 X EN1) X EN (store/cons ST1 X EN)]
    ; solve [ |- store-bounds/cons Dlt]
    }
  }
  case store-bounds/nil:
  { L : ( |- location),
    X : ( |- location),
    EN : ( |- entry),
    ST' : ( |- store)
  | bounds : [ |- store-bounds store/nil L],
    x : [ |- store-update store/nil X EN ST']
  ; impossible x
  }
}
;

proof store-bounds-update :
  [ |- store-bounds ST L] ->
  [ |- store-update ST X EN ST'] ->
    [ |- store-bounds ST' L] =
/ total /
intros
{ ST : ( |- store),
  L : ( |- location),
  X : ( |- location),
  EN : ( |- entry),
  ST' : ( |- store)
| bounds : [ |- store-bounds ST L], x : [ |- store-update ST X EN ST']
; split bounds as
  case store-bounds/cons:
  { ST1 : ( |- store),
    X1 : ( |- location),
    EN1 : ( |- entry),
    L : ( |- location),
    X : ( |- location),
    EN : ( |- entry),
    ST' : ( |- store),
    Dlt : ( |- loc-lt X1 L)
  | bounds : [ |- store-bounds (store/cons ST1 X1 EN1) L],
    x : [ |- store-update (store/cons ST1 X1 EN1) X EN ST']
  ; split x as
    case store-update/miss:
    { ST1 : ( |- store),
      X1 : ( |- location),
      EN1 : ( |- entry),
      L : ( |- location),
      X : ( |- location),
      EN : ( |- entry),
      ST3 : ( |- store),
      Dlt : ( |- loc-lt X1 L),
      Dupdate : ( |- store-update ST1 X EN ST3)
    | bounds : [ |- store-bounds (store/cons ST1 X1 EN1) L],
      x :
        [ |-
           store-update (store/cons ST1 X1 EN1) X EN (store/cons ST3 X1 EN1)]
    ; solve [ |- store-bounds/cons Dlt]
    }
    case store-update/hit:
    { ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      L : ( |- location),
      EN : ( |- entry),
      Dlt : ( |- loc-lt X L)
    | bounds : [ |- store-bounds (store/cons ST1 X EN1) L],
      x :
        [ |- store-update (store/cons ST1 X EN1) X EN (store/cons ST1 X EN)]
    ; solve [ |- store-bounds/cons Dlt]
    }
  }
  case store-bounds/nil:
  { L : ( |- location),
    X : ( |- location),
    EN : ( |- entry),
    ST' : ( |- store)
  | bounds : [ |- store-bounds store/nil L],
    x : [ |- store-update store/nil X EN ST']
  ; impossible x
  }
}
;

proof store-lookup-bound :
  [ |- store-of F ST F1] ->
  [ |- store-lookup ST L EN] ->
  [ |- store-bounds ST L] ->
    [ |- false] =
/ total 1 /
intros
{ F : ( |- sttp),
  ST : ( |- store),
  F1 : ( |- sttp),
  L : ( |- location),
  EN : ( |- entry)
| x : [ |- store-of F ST F1],
  x1 : [ |- store-lookup ST L EN],
  bounds : [ |- store-bounds ST L]
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    X : ( |- location),
    EN1 : ( |- entry),
    F3 : ( |- sttp),
    ET : ( |- entp),
    L : ( |- location),
    EN : ( |- entry),
    Dbounds : ( |- store-bounds ST1 X),
    X1 : ( |- entry-of F EN1 ET),
    Dof : ( |- store-of F ST1 F3)
  | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET)],
    x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
    bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
  ; split x1 as
    case store-lookup/miss:
    { F : ( |- sttp),
      ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      F3 : ( |- sttp),
      ET : ( |- entp),
      L : ( |- location),
      EN : ( |- entry),
      Dbounds : ( |- store-bounds ST1 X),
      X1 : ( |- entry-of F EN1 ET),
      Dof : ( |- store-of F ST1 F3),
      Dlookup : ( |- store-lookup ST1 L EN)
    | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET)],
      x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
      bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        X : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        L : ( |- location),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 X),
        X1 : ( |- entry-of F EN1 ET),
        Dof : ( |- store-of F ST1 F3),
        Dlookup : ( |- store-lookup ST1 L EN),
        Dlt : ( |- loc-lt X L)
      | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET)],
        x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
        bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
      ; solve
          store-lookup-bound [ |- Dof] [ |- Dlookup]
            (store-bounds-increase [ |- Dbounds] [ |- Dlt])
      }
    }
    case store-lookup/hit:
    { F : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN : ( |- entry),
      F3 : ( |- sttp),
      ET : ( |- entp),
      Dbounds : ( |- store-bounds ST1 L),
      X1 : ( |- entry-of F EN ET),
      Dof : ( |- store-of F ST1 F3)
    | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F3 L ET)],
      x1 : [ |- store-lookup (store/cons ST1 L EN) L EN],
      bounds : [ |- store-bounds (store/cons ST1 L EN) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN ET),
        Dof : ( |- store-of F ST1 F3),
        Dlt : ( |- loc-lt L L)
      | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F3 L ET)],
        x1 : [ |- store-lookup (store/cons ST1 L EN) L EN],
        bounds : [ |- store-bounds (store/cons ST1 L EN) L]
      ; solve loc-lt-antisymm [ |- Dlt]
      }
    }
  }
  case store-of/nil:
  { F : ( |- sttp), L : ( |- location), EN : ( |- entry)
  | x : [ |- store-of F store/nil st/nil],
    x1 : [ |- store-lookup store/nil L EN],
    bounds : [ |- store-bounds store/nil L]
  ; impossible x1
  }
}
;

proof store-update-bound :
  [ |- store-of F ST F'] ->
  [ |- store-update ST L EN ST'] ->
  [ |- store-bounds ST L] ->
    [ |- false] =
/ total 1 /
intros
{ F : ( |- sttp),
  ST : ( |- store),
  F' : ( |- sttp),
  L : ( |- location),
  EN : ( |- entry),
  ST' : ( |- store)
| x : [ |- store-of F ST F'],
  x1 : [ |- store-update ST L EN ST'],
  bounds : [ |- store-bounds ST L]
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    X : ( |- location),
    EN1 : ( |- entry),
    F2 : ( |- sttp),
    ET : ( |- entp),
    L : ( |- location),
    EN : ( |- entry),
    ST' : ( |- store),
    Dbounds : ( |- store-bounds ST1 X),
    X1 : ( |- entry-of F EN1 ET),
    Dof : ( |- store-of F ST1 F2)
  | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
    x1 : [ |- store-update (store/cons ST1 X EN1) L EN ST'],
    bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
  ; split x1 as
    case store-update/miss:
    { F : ( |- sttp),
      ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      L : ( |- location),
      EN : ( |- entry),
      ST3 : ( |- store),
      Dbounds : ( |- store-bounds ST1 X),
      X1 : ( |- entry-of F EN1 ET),
      Dof : ( |- store-of F ST1 F2),
      Dupdate : ( |- store-update ST1 L EN ST3)
    | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
      x1 :
        [ |- store-update (store/cons ST1 X EN1) L EN (store/cons ST3 X EN1)],
      bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        X : ( |- location),
        EN1 : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        L : ( |- location),
        EN : ( |- entry),
        ST3 : ( |- store),
        Dbounds : ( |- store-bounds ST1 X),
        X1 : ( |- entry-of F EN1 ET),
        Dof : ( |- store-of F ST1 F2),
        Dupdate : ( |- store-update ST1 L EN ST3),
        Dlt : ( |- loc-lt X L)
      | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
        x1 :
          [ |-
             store-update (store/cons ST1 X EN1) L EN (store/cons ST3 X EN1)],
        bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
      ; solve
          store-update-bound [ |- Dof] [ |- Dupdate]
            (store-bounds-increase [ |- Dbounds] [ |- Dlt])
      }
    }
    case store-update/hit:
    { F : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN1 : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      EN : ( |- entry),
      Dbounds : ( |- store-bounds ST1 L),
      X1 : ( |- entry-of F EN1 ET),
      Dof : ( |- store-of F ST1 F2)
    | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F2 L ET)],
      x1 :
        [ |- store-update (store/cons ST1 L EN1) L EN (store/cons ST1 L EN)],
      bounds : [ |- store-bounds (store/cons ST1 L EN1) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN1 : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN1 ET),
        Dof : ( |- store-of F ST1 F2),
        Dlt : ( |- loc-lt L L)
      | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F2 L ET)],
        x1 :
          [ |- store-update (store/cons ST1 L EN1) L EN (store/cons ST1 L EN)],
        bounds : [ |- store-bounds (store/cons ST1 L EN1) L]
      ; solve loc-lt-antisymm [ |- Dlt]
      }
    }
  }
  case store-of/nil:
  { F : ( |- sttp), L : ( |- location), EN : ( |- entry), ST' : ( |- store)
  | x : [ |- store-of F store/nil st/nil],
    x1 : [ |- store-update store/nil L EN ST'],
    bounds : [ |- store-bounds store/nil L]
  ; impossible x1
  }
}
;

proof sttp-lookup-bound :
  [ |- store-of F' ST F] ->
  [ |- st-lookup F L ET] ->
  [ |- store-bounds ST L] ->
    [ |- false] =
/ total 1 /
intros
{ F' : ( |- sttp),
  ST : ( |- store),
  F : ( |- sttp),
  L : ( |- location),
  ET : ( |- entp)
| x : [ |- store-of F' ST F],
  lookup : [ |- st-lookup F L ET],
  bounds : [ |- store-bounds ST L]
; split x as
  case store-of/cons:
  { F' : ( |- sttp),
    ST1 : ( |- store),
    X : ( |- location),
    EN : ( |- entry),
    F2 : ( |- sttp),
    ET1 : ( |- entp),
    L : ( |- location),
    ET : ( |- entp),
    Dbounds : ( |- store-bounds ST1 X),
    X1 : ( |- entry-of F' EN ET1),
    Dof : ( |- store-of F' ST1 F2)
  | x : [ |- store-of F' (store/cons ST1 X EN) (st/cons F2 X ET1)],
    lookup : [ |- st-lookup (st/cons F2 X ET1) L ET],
    bounds : [ |- store-bounds (store/cons ST1 X EN) L]
  ; split lookup as
    case st-lookup/miss:
    { F' : ( |- sttp),
      ST1 : ( |- store),
      X : ( |- location),
      EN : ( |- entry),
      F2 : ( |- sttp),
      ET1 : ( |- entp),
      L : ( |- location),
      ET : ( |- entp),
      Dbounds : ( |- store-bounds ST1 X),
      X1 : ( |- entry-of F' EN ET1),
      Dof : ( |- store-of F' ST1 F2),
      Dlookup : ( |- st-lookup F2 L ET)
    | x : [ |- store-of F' (store/cons ST1 X EN) (st/cons F2 X ET1)],
      lookup : [ |- st-lookup (st/cons F2 X ET1) L ET],
      bounds : [ |- store-bounds (store/cons ST1 X EN) L]
    ; split bounds as
      case store-bounds/cons:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        X : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET1 : ( |- entp),
        L : ( |- location),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 X),
        X1 : ( |- entry-of F' EN ET1),
        Dof : ( |- store-of F' ST1 F2),
        Dlookup : ( |- st-lookup F2 L ET),
        Dlt : ( |- loc-lt X L)
      | x : [ |- store-of F' (store/cons ST1 X EN) (st/cons F2 X ET1)],
        lookup : [ |- st-lookup (st/cons F2 X ET1) L ET],
        bounds : [ |- store-bounds (store/cons ST1 X EN) L]
      ; solve
          sttp-lookup-bound [ |- Dof] [ |- Dlookup]
            (store-bounds-increase [ |- Dbounds] [ |- Dlt])
      }
    }
    case st-lookup/hit:
    { F' : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      Dbounds : ( |- store-bounds ST1 L),
      X1 : ( |- entry-of F' EN ET),
      Dof : ( |- store-of F' ST1 F2)
    | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET)],
      lookup : [ |- st-lookup (st/cons F2 L ET) L ET],
      bounds : [ |- store-bounds (store/cons ST1 L EN) L]
    ; split bounds as
      case store-bounds/cons:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F' EN ET),
        Dof : ( |- store-of F' ST1 F2),
        Dlt : ( |- loc-lt L L)
      | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET)],
        lookup : [ |- st-lookup (st/cons F2 L ET) L ET],
        bounds : [ |- store-bounds (store/cons ST1 L EN) L]
      ; solve loc-lt-antisymm [ |- Dlt]
      }
    }
  }
  case store-of/nil:
  { F' : ( |- sttp), L : ( |- location), ET : ( |- entp)
  | x : [ |- store-of F' store/nil st/nil],
    lookup : [ |- st-lookup st/nil L ET],
    bounds : [ |- store-bounds store/nil L]
  ; impossible lookup
  }
}
;

proof store-lookup-bound :
  [ |- store-of F ST F'] ->
  [ |- store-lookup ST L EN] ->
  [ |- store-bounds ST L] ->
    [ |- false] =
/ total 1 /
intros
{ F : ( |- sttp),
  ST : ( |- store),
  F' : ( |- sttp),
  L : ( |- location),
  EN : ( |- entry)
| x : [ |- store-of F ST F'],
  x1 : [ |- store-lookup ST L EN],
  bounds : [ |- store-bounds ST L]
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    X : ( |- location),
    EN1 : ( |- entry),
    F2 : ( |- sttp),
    ET : ( |- entp),
    L : ( |- location),
    EN : ( |- entry),
    Dbounds : ( |- store-bounds ST1 X),
    X1 : ( |- entry-of F EN1 ET),
    Dof : ( |- store-of F ST1 F2)
  | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
    x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
    bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
  ; split x1 as
    case store-lookup/miss:
    { F : ( |- sttp),
      ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      L : ( |- location),
      EN : ( |- entry),
      Dbounds : ( |- store-bounds ST1 X),
      X1 : ( |- entry-of F EN1 ET),
      Dof : ( |- store-of F ST1 F2),
      Dlookup : ( |- store-lookup ST1 L EN)
    | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
      x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
      bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        X : ( |- location),
        EN1 : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        L : ( |- location),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 X),
        X1 : ( |- entry-of F EN1 ET),
        Dof : ( |- store-of F ST1 F2),
        Dlookup : ( |- store-lookup ST1 L EN),
        Dlt : ( |- loc-lt X L)
      | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F2 X ET)],
        x1 : [ |- store-lookup (store/cons ST1 X EN1) L EN],
        bounds : [ |- store-bounds (store/cons ST1 X EN1) L]
      ; solve
          store-lookup-bound [ |- Dof] [ |- Dlookup]
            (store-bounds-increase [ |- Dbounds] [ |- Dlt])
      }
    }
    case store-lookup/hit:
    { F : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      Dbounds : ( |- store-bounds ST1 L),
      X1 : ( |- entry-of F EN ET),
      Dof : ( |- store-of F ST1 F2)
    | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F2 L ET)],
      x1 : [ |- store-lookup (store/cons ST1 L EN) L EN],
      bounds : [ |- store-bounds (store/cons ST1 L EN) L]
    ; split bounds as
      case store-bounds/cons:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN ET),
        Dof : ( |- store-of F ST1 F2),
        Dlt : ( |- loc-lt L L)
      | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F2 L ET)],
        x1 : [ |- store-lookup (store/cons ST1 L EN) L EN],
        bounds : [ |- store-bounds (store/cons ST1 L EN) L]
      ; solve loc-lt-antisymm [ |- Dlt]
      }
    }
  }
  case store-of/nil:
  { F : ( |- sttp), L : ( |- location), EN : ( |- entry)
  | x : [ |- store-of F store/nil st/nil],
    x1 : [ |- store-lookup store/nil L EN],
    bounds : [ |- store-bounds store/nil L]
  ; impossible x1
  }
}
;

proof preservation-lookup :
  [ |- store-of F1 ST F2] ->
  [ |- st-lookup F2 L ET] ->
  [ |- store-lookup ST L EN] ->
    [ |- entry-of F1 EN ET] =
/ total 1 /
intros
{ F : ( |- sttp),
  ST : ( |- store),
  F1 : ( |- sttp),
  L : ( |- location),
  ET : ( |- entp),
  EN : ( |- entry)
| x : [ |- store-of F ST F1],
  lookup : [ |- st-lookup F1 L ET],
  lookup1 : [ |- store-lookup ST L EN]
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    X : ( |- location),
    EN1 : ( |- entry),
    F3 : ( |- sttp),
    ET1 : ( |- entp),
    L : ( |- location),
    ET : ( |- entp),
    EN : ( |- entry),
    Dbounds : ( |- store-bounds ST1 X),
    X1 : ( |- entry-of F EN1 ET1),
    Dof : ( |- store-of F ST1 F3)
  | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET1)],
    lookup : [ |- st-lookup (st/cons F3 X ET1) L ET],
    lookup1 : [ |- store-lookup (store/cons ST1 X EN1) L EN]
  ; split lookup as
    case st-lookup/miss:
    { F : ( |- sttp),
      ST1 : ( |- store),
      X : ( |- location),
      EN1 : ( |- entry),
      F3 : ( |- sttp),
      ET1 : ( |- entp),
      L : ( |- location),
      ET : ( |- entp),
      EN : ( |- entry),
      Dbounds : ( |- store-bounds ST1 X),
      X1 : ( |- entry-of F EN1 ET1),
      Dof : ( |- store-of F ST1 F3),
      Dlookup : ( |- st-lookup F3 L ET)
    | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET1)],
      lookup : [ |- st-lookup (st/cons F3 X ET1) L ET],
      lookup1 : [ |- store-lookup (store/cons ST1 X EN1) L EN]
    ; split lookup1 as
      case store-lookup/miss:
      { F : ( |- sttp),
        ST1 : ( |- store),
        X : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET1 : ( |- entp),
        L : ( |- location),
        ET : ( |- entp),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 X),
        X1 : ( |- entry-of F EN1 ET1),
        Dof : ( |- store-of F ST1 F3),
        Dlookup : ( |- st-lookup F3 L ET),
        Dlookup1 : ( |- store-lookup ST1 L EN)
      | x : [ |- store-of F (store/cons ST1 X EN1) (st/cons F3 X ET1)],
        lookup : [ |- st-lookup (st/cons F3 X ET1) L ET],
        lookup1 : [ |- store-lookup (store/cons ST1 X EN1) L EN]
      ; solve preservation-lookup [ |- Dof] [ |- Dlookup] [ |- Dlookup1]
      }
      case store-lookup/hit:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F3 : ( |- sttp),
        ET1 : ( |- entp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN ET1),
        Dof : ( |- store-of F ST1 F3),
        Dlookup : ( |- st-lookup F3 L ET)
      | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F3 L ET1)],
        lookup : [ |- st-lookup (st/cons F3 L ET1) L ET],
        lookup1 : [ |- store-lookup (store/cons ST1 L EN) L EN]
      ; impossible sttp-lookup-bound [ |- Dof] [ |- Dlookup] [ |- Dbounds]
      }
    }
    case st-lookup/hit:
    { F : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN1 : ( |- entry),
      F3 : ( |- sttp),
      ET : ( |- entp),
      EN : ( |- entry),
      Dbounds : ( |- store-bounds ST1 L),
      X1 : ( |- entry-of F EN1 ET),
      Dof : ( |- store-of F ST1 F3)
    | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET)],
      lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
      lookup1 : [ |- store-lookup (store/cons ST1 L EN1) L EN]
    ; split lookup1 as
      case store-lookup/miss:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN1 ET),
        Dof : ( |- store-of F ST1 F3),
        Dlookup : ( |- store-lookup ST1 L EN)
      | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET)],
        lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
        lookup1 : [ |- store-lookup (store/cons ST1 L EN1) L EN]
      ; impossible store-lookup-bound [ |- Dof] [ |- Dlookup] [ |- Dbounds]
      }
      case store-lookup/hit:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        X1 : ( |- entry-of F EN ET),
        Dof : ( |- store-of F ST1 F3)
      | x : [ |- store-of F (store/cons ST1 L EN) (st/cons F3 L ET)],
        lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
        lookup1 : [ |- store-lookup (store/cons ST1 L EN) L EN]
      ; solve [ |- X1]
      }
    }
  }
  case store-of/nil:
  { F : ( |- sttp), L : ( |- location), ET : ( |- entp), EN : ( |- entry)
  | x : [ |- store-of F store/nil st/nil],
    lookup : [ |- st-lookup st/nil L ET],
    lookup1 : [ |- store-lookup store/nil L EN]
  ; impossible lookup
  }
}
;

proof preservation-update :
  [ |- store-of F1 ST F2] ->
  [ |- st-lookup F2 L ET] ->
  [ |- store-update ST L EN ST'] ->
  [ |- entry-of F1 EN ET] ->
    [ |- store-of F1 ST' F2] =
/ total 1 /
intros
{ F : ( |- sttp),
  ST : ( |- store),
  F1 : ( |- sttp),
  L : ( |- location),
  ET : ( |- entp),
  EN : ( |- entry),
  ST' : ( |- store)
| x : [ |- store-of F ST F1],
  lookup : [ |- st-lookup F1 L ET],
  update : [ |- store-update ST L EN ST'],
  eof : [ |- entry-of F EN ET]
; split x as
  case store-of/cons:
  { F : ( |- sttp),
    ST1 : ( |- store),
    Dloc : ( |- location),
    EN1 : ( |- entry),
    F3 : ( |- sttp),
    ET1 : ( |- entp),
    L : ( |- location),
    ET : ( |- entp),
    EN : ( |- entry),
    ST' : ( |- store),
    Dbounds : ( |- store-bounds ST1 Dloc),
    Dof : ( |- entry-of F EN1 ET1),
    Dof1 : ( |- store-of F ST1 F3)
  | x : [ |- store-of F (store/cons ST1 Dloc EN1) (st/cons F3 Dloc ET1)],
    lookup : [ |- st-lookup (st/cons F3 Dloc ET1) L ET],
    update : [ |- store-update (store/cons ST1 Dloc EN1) L EN ST'],
    eof : [ |- entry-of F EN ET]
  ; split lookup as
    case st-lookup/miss:
    { F : ( |- sttp),
      ST1 : ( |- store),
      Dloc : ( |- location),
      EN1 : ( |- entry),
      F3 : ( |- sttp),
      ET1 : ( |- entp),
      L : ( |- location),
      ET : ( |- entp),
      EN : ( |- entry),
      ST' : ( |- store),
      Dbounds : ( |- store-bounds ST1 Dloc),
      Dof : ( |- entry-of F EN1 ET1),
      Dof1 : ( |- store-of F ST1 F3),
      Dlookup : ( |- st-lookup F3 L ET)
    | x : [ |- store-of F (store/cons ST1 Dloc EN1) (st/cons F3 Dloc ET1)],
      lookup : [ |- st-lookup (st/cons F3 Dloc ET1) L ET],
      update : [ |- store-update (store/cons ST1 Dloc EN1) L EN ST'],
      eof : [ |- entry-of F EN ET]
    ; split update as
      case store-update/miss:
      { F : ( |- sttp),
        ST1 : ( |- store),
        Dloc : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET1 : ( |- entp),
        L : ( |- location),
        ET : ( |- entp),
        EN : ( |- entry),
        ST3 : ( |- store),
        Dbounds : ( |- store-bounds ST1 Dloc),
        Dof : ( |- entry-of F EN1 ET1),
        Dof1 : ( |- store-of F ST1 F3),
        Dlookup : ( |- st-lookup F3 L ET),
        Dupdate : ( |- store-update ST1 L EN ST3)
      | x : [ |- store-of F (store/cons ST1 Dloc EN1) (st/cons F3 Dloc ET1)],
        lookup : [ |- st-lookup (st/cons F3 Dloc ET1) L ET],
        update :
          [ |-
             store-update
               (store/cons ST1 Dloc EN1) L EN (store/cons ST3 Dloc EN1)],
        eof : [ |- entry-of F EN ET]
      ; by preservation-update [ |- Dof1] [ |- Dlookup] [ |- Dupdate] eof
        as Dsof unboxed;
        by store-bounds-update [ |- Dbounds] [ |- Dupdate]
        as Dbounds1 unboxed;
        solve [ |- store-of/cons Dbounds1 Dof Dsof]
      }
      case store-update/hit:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET1 : ( |- entp),
        ET : ( |- entp),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F EN1 ET1),
        Dof1 : ( |- store-of F ST1 F3),
        Dlookup : ( |- st-lookup F3 L ET)
      | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET1)],
        lookup : [ |- st-lookup (st/cons F3 L ET1) L ET],
        update :
          [ |- store-update (store/cons ST1 L EN1) L EN (store/cons ST1 L EN)],
        eof : [ |- entry-of F EN ET]
      ; impossible sttp-lookup-bound [ |- Dof1] [ |- Dlookup] [ |- Dbounds]
      }
    }
    case st-lookup/hit:
    { F : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN1 : ( |- entry),
      F3 : ( |- sttp),
      ET : ( |- entp),
      EN : ( |- entry),
      ST' : ( |- store),
      Dbounds : ( |- store-bounds ST1 L),
      Dof : ( |- entry-of F EN1 ET),
      Dof1 : ( |- store-of F ST1 F3)
    | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET)],
      lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
      update : [ |- store-update (store/cons ST1 L EN1) L EN ST'],
      eof : [ |- entry-of F EN ET]
    ; split update as
      case store-update/miss:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        EN : ( |- entry),
        ST3 : ( |- store),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F EN1 ET),
        Dof1 : ( |- store-of F ST1 F3),
        Dupdate : ( |- store-update ST1 L EN ST3)
      | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET)],
        lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
        update :
          [ |-
             store-update (store/cons ST1 L EN1) L EN (store/cons ST3 L EN1)],
        eof : [ |- entry-of F EN ET]
      ; impossible store-update-bound [ |- Dof1] [ |- Dupdate] [ |- Dbounds]
      }
      case store-update/hit:
      { F : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN1 : ( |- entry),
        F3 : ( |- sttp),
        ET : ( |- entp),
        EN : ( |- entry),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F EN1 ET),
        Dof1 : ( |- store-of F ST1 F3)
      | x : [ |- store-of F (store/cons ST1 L EN1) (st/cons F3 L ET)],
        lookup : [ |- st-lookup (st/cons F3 L ET) L ET],
        update :
          [ |- store-update (store/cons ST1 L EN1) L EN (store/cons ST1 L EN)],
        eof : [ |- entry-of F EN ET]
      ; by eof as Dof2 unboxed;
        solve [ |- store-of/cons Dbounds Dof2 Dof1]
      }
    }
  }
  case store-of/nil:
  { F : ( |- sttp),
    L : ( |- location),
    ET : ( |- entp),
    EN : ( |- entry),
    ST' : ( |- store)
  | x : [ |- store-of F store/nil st/nil],
    lookup : [ |- st-lookup st/nil L ET],
    update : [ |- store-update store/nil L EN ST'],
    eof : [ |- entry-of F EN ET]
  ; impossible lookup
  }
}
;

proof st-lookup-fun :
  [ |- store-of F' ST F] ->
  [ |- st-lookup F L ET] ->
  [ |- st-lookup F L ET'] ->
    [ |- entp-eq ET ET'] =
/ total 1 /
intros
{ F' : ( |- sttp),
  ST : ( |- store),
  F : ( |- sttp),
  L : ( |- location),
  ET : ( |- entp),
  ET' : ( |- entp)
| x : [ |- store-of F' ST F],
  lookup : [ |- st-lookup F L ET],
  lookup1 : [ |- st-lookup F L ET']
; split x as
  case store-of/cons:
  { F' : ( |- sttp),
    ST1 : ( |- store),
    Dloc : ( |- location),
    EN : ( |- entry),
    F2 : ( |- sttp),
    ET1 : ( |- entp),
    L : ( |- location),
    ET : ( |- entp),
    ET' : ( |- entp),
    Dbounds : ( |- store-bounds ST1 Dloc),
    Dof : ( |- entry-of F' EN ET1),
    Dof1 : ( |- store-of F' ST1 F2)
  | x : [ |- store-of F' (store/cons ST1 Dloc EN) (st/cons F2 Dloc ET1)],
    lookup : [ |- st-lookup (st/cons F2 Dloc ET1) L ET],
    lookup1 : [ |- st-lookup (st/cons F2 Dloc ET1) L ET']
  ; split lookup as
    case st-lookup/miss:
    { F' : ( |- sttp),
      ST1 : ( |- store),
      Dloc : ( |- location),
      EN : ( |- entry),
      F2 : ( |- sttp),
      ET1 : ( |- entp),
      L : ( |- location),
      ET : ( |- entp),
      ET' : ( |- entp),
      Dbounds : ( |- store-bounds ST1 Dloc),
      Dof : ( |- entry-of F' EN ET1),
      Dof1 : ( |- store-of F' ST1 F2),
      Dlookup : ( |- st-lookup F2 L ET)
    | x : [ |- store-of F' (store/cons ST1 Dloc EN) (st/cons F2 Dloc ET1)],
      lookup : [ |- st-lookup (st/cons F2 Dloc ET1) L ET],
      lookup1 : [ |- st-lookup (st/cons F2 Dloc ET1) L ET']
    ; split lookup1 as
      case st-lookup/miss:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        Dloc : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET1 : ( |- entp),
        L : ( |- location),
        ET : ( |- entp),
        ET' : ( |- entp),
        Dbounds : ( |- store-bounds ST1 Dloc),
        Dof : ( |- entry-of F' EN ET1),
        Dof1 : ( |- store-of F' ST1 F2),
        Dlookup : ( |- st-lookup F2 L ET),
        Dlookup1 : ( |- st-lookup F2 L ET')
      | x : [ |- store-of F' (store/cons ST1 Dloc EN) (st/cons F2 Dloc ET1)],
        lookup : [ |- st-lookup (st/cons F2 Dloc ET1) L ET],
        lookup1 : [ |- st-lookup (st/cons F2 Dloc ET1) L ET']
      ; solve st-lookup-fun [ |- Dof1] [ |- Dlookup] [ |- Dlookup1]
      }
      case st-lookup/hit:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET' : ( |- entp),
        ET : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F' EN ET'),
        Dof1 : ( |- store-of F' ST1 F2),
        Dlookup : ( |- st-lookup F2 L ET)
      | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET')],
        lookup : [ |- st-lookup (st/cons F2 L ET') L ET],
        lookup1 : [ |- st-lookup (st/cons F2 L ET') L ET']
      ; impossible sttp-lookup-bound [ |- Dof1] [ |- Dlookup] [ |- Dbounds]
      }
    }
    case st-lookup/hit:
    { F' : ( |- sttp),
      ST1 : ( |- store),
      L : ( |- location),
      EN : ( |- entry),
      F2 : ( |- sttp),
      ET : ( |- entp),
      ET' : ( |- entp),
      Dbounds : ( |- store-bounds ST1 L),
      Dof : ( |- entry-of F' EN ET),
      Dof1 : ( |- store-of F' ST1 F2)
    | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET)],
      lookup : [ |- st-lookup (st/cons F2 L ET) L ET],
      lookup1 : [ |- st-lookup (st/cons F2 L ET) L ET']
    ; split lookup1 as
      case st-lookup/miss:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET : ( |- entp),
        ET' : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F' EN ET),
        Dof1 : ( |- store-of F' ST1 F2),
        Dlookup : ( |- st-lookup F2 L ET')
      | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET)],
        lookup : [ |- st-lookup (st/cons F2 L ET) L ET],
        lookup1 : [ |- st-lookup (st/cons F2 L ET) L ET']
      ; impossible sttp-lookup-bound [ |- Dof1] [ |- Dlookup] [ |- Dbounds]
      }
      case st-lookup/hit:
      { F' : ( |- sttp),
        ST1 : ( |- store),
        L : ( |- location),
        EN : ( |- entry),
        F2 : ( |- sttp),
        ET' : ( |- entp),
        Dbounds : ( |- store-bounds ST1 L),
        Dof : ( |- entry-of F' EN ET'),
        Dof1 : ( |- store-of F' ST1 F2)
      | x : [ |- store-of F' (store/cons ST1 L EN) (st/cons F2 L ET')],
        lookup : [ |- st-lookup (st/cons F2 L ET') L ET'],
        lookup1 : [ |- st-lookup (st/cons F2 L ET') L ET']
      ; solve [ |- entp-eq/i ]
      }
    }
  }
  case store-of/nil:
  { F' : ( |- sttp), L : ( |- location), ET : ( |- entp), ET' : ( |- entp)
  | x : [ |- store-of F' store/nil st/nil],
    lookup : [ |- st-lookup st/nil L ET],
    lookup1 : [ |- st-lookup st/nil L ET']
  ; impossible lookup
  }
}
;

proof nextloc-bounds : [ |- nextloc ST L] -> [ |- store-bounds ST L] =
/ total /
intros
{ ST : ( |- store), L : ( |- location)
| nextloc : [ |- nextloc ST L]
; split nextloc as
  case nextloc/cons:
  { ST1 : ( |- store),
    Dloc : ( |- location),
    EN : ( |- entry),
    L : ( |- location),
    Dsucc : ( |- loc-succ Dloc L)
  | nextloc : [ |- nextloc (store/cons ST1 Dloc EN) L]
  ; by loc-succ-lt [ |- Dsucc] as Dlt unboxed;
    solve [ |- store-bounds/cons Dlt]
  }
  case nextloc/nil:
  {
  | nextloc : [ |- nextloc store/nil (location/i zero)]
  ; solve [ |- store-bounds/nil ]
  }
}
;

% Preservation

proof preservation-raises-tm :
  [ |- tm-of F E T] ->
  [ |- raises E V] ->
    [ |- tm-of F V tagged] =
/ total 2 /
intros
{ F : ( |- sttp), E : ( |- term), T : ( |- con), V : ( |- term)
| tof : [ |- tm-of F E T], x : [ |- raises E V]
; split x as
  case raises/snd:
  { F : ( |- sttp),
    M : ( |- module'),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises-md M V)
  | tof : [ |- tm-of F (tm/snd M) T], x : [ |- raises (tm/snd M) V]
  ; by inversion-tm/snd tof as Dof unboxed;
    solve preservation-raises-md [ |- Dof] [ |- Draises]
  }
  case raises/lett:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : (x31 : term |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/lett E1 (\z503. E3)) T],
    x : [ |- raises (tm/lett E1 (\z503. E3)) V]
  ; split inversion-tm/lett tof as
    case inversion-tm/lett/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E3 : (x31 : term |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      Dof : ( |- tm-of F E1 C1),
      Dof1 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E3[x]) T[])
    | tof : [ |- tm-of F (tm/lett E1 (\z503. E3)) T],
      x : [ |- raises (tm/lett E1 (\z503. E3)) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/raise2:
  { F : ( |- sttp),
    V : ( |- term),
    C : ( |- con),
    T : ( |- con),
    Dvalue : ( |- value V)
  | tof : [ |- tm-of F (tm/raise V C) T], x : [ |- raises (tm/raise V C) V]
  ; split inversion-tm/raise tof as
    case inversion-tm/raise/i:
    { F : ( |- sttp),
      V : ( |- term),
      C : ( |- con),
      T : ( |- con),
      Dvalue : ( |- value V),
      Dequiv : ( |- cn-equiv C T t),
      Dof : ( |- tm-of F V tagged)
    | tof : [ |- tm-of F (tm/raise V C) T], x : [ |- raises (tm/raise V C) V]
    ; solve [ |- Dof]
    }
  }
  case raises/raise1:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/raise E1 C) T], x : [ |- raises (tm/raise E1 C) V]
  ; split inversion-tm/raise tof as
    case inversion-tm/raise/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      Dequiv : ( |- cn-equiv C T t),
      Dof : ( |- tm-of F E1 tagged)
    | tof : [ |- tm-of F (tm/raise E1 C) T],
      x : [ |- raises (tm/raise E1 C) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/out:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/out E1) T], x : [ |- raises (tm/out E1) V]
  ; split inversion-tm/out tof as
    case inversion-tm/out/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      X : ( |- label),
      Dof : ( |- tm-of F E1 (labeled X T))
    | tof : [ |- tm-of F (tm/out E1) T], x : [ |- raises (tm/out E1) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/in:
  { F : ( |- sttp),
    X : ( |- label),
    E1 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/in X E1) T], x : [ |- raises (tm/in X E1) V]
  ; split inversion-tm/in tof as
    case inversion-tm/in/i:
    { F : ( |- sttp),
      X : ( |- label),
      E1 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv (labeled X C1) T t),
      Dof : ( |- tm-of F E1 C1)
    | tof : [ |- tm-of F (tm/in X E1) T], x : [ |- raises (tm/in X E1) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/unroll:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/unroll E1) T], x : [ |- raises (tm/unroll E1) V]
  ; split inversion-tm/unroll tof as
    case inversion-tm/unroll/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      K : ( |- kind),
      C1 : (z1316 : con, y1317 : con |- con),
      C2 : ( |- con),
      Dequiv :
        ( |-
           cn-equiv
             (C1[lam K (\a. rec' K[] (\y478. \x478. C1[y478, x478]) a), C2])
             T t),
      Dof : ( |- tm-of F E1 (rec' K (\y478. \x478. C1) C2))
    | tof : [ |- tm-of F (tm/unroll E1) T], x : [ |- raises (tm/unroll E1) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/roll:
  { F : ( |- sttp),
    E1 : ( |- term),
    K : ( |- kind),
    C : (a87 : con, a86 : con |- con),
    C1 : ( |- con),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/roll E1 K (\x499. \z499. C) C1) T],
    x : [ |- raises (tm/roll E1 K (\x499. \z499. C) C1) V]
  ; split inversion-tm/roll tof as
    case inversion-tm/roll/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      K : ( |- kind),
      C : (a87 : con, a86 : con |- con),
      C1 : ( |- con),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      Dequiv : ( |- cn-equiv (rec' K (\y478. \x478. C) C1) T t),
      Dof :
        ( |-
           tm-of
             F
             E1 (C[lam K (\a. rec' K[] (\y478. \x478. C[y478, x478]) a), C1])),
      Dwf : ( |- kd-wf K),
      Dof1 :
        (a : con, z1313 : cn-of a (pi K[] (\l. t)), b : con,
         y1314 : cn-of b K[] |- cn-of (C[a, b]) t),
      Dof2 : ( |- cn-of C1 K)
    | tof : [ |- tm-of F (tm/roll E1 K (\x499. \z499. C) C1) T],
      x : [ |- raises (tm/roll E1 K (\x499. \z499. C) C1) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/iftag2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    E4 : (x30 : term |- term),
    E5 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Dvalue : ( |- value E1),
    Draises : ( |- raises E2 V)
  | tof : [ |- tm-of F (tm/iftag E1 E2 (\z497. E4) E5) T],
    x : [ |- raises (tm/iftag E1 E2 (\z497. E4) E5) V]
  ; split inversion-tm/iftag tof as
    case inversion-tm/iftag/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      E4 : (x30 : term |- term),
      E5 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Dvalue : ( |- value E1),
      Draises : ( |- raises E2 V),
      C1 : ( |- con),
      Dof : ( |- tm-of F E1 tagged),
      Dof1 : ( |- tm-of F E2 (tag C1)),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E4[x]) T[]),
      Dof3 : ( |- tm-of F E5 T)
    | tof : [ |- tm-of F (tm/iftag E1 E2 (\z497. E4) E5) T],
      x : [ |- raises (tm/iftag E1 E2 (\z497. E4) E5) V]
    ; solve preservation-raises-tm [ |- Dof1] [ |- Draises]
    }
  }
  case raises/iftag1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    E4 : (x29 : term |- term),
    E5 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/iftag E1 E3 (\z497. E4) E5) T],
    x : [ |- raises (tm/iftag E1 E3 (\z497. E4) E5) V]
  ; split inversion-tm/iftag tof as
    case inversion-tm/iftag/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E3 : ( |- term),
      E4 : (x29 : term |- term),
      E5 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      Dof : ( |- tm-of F E1 tagged),
      Dof1 : ( |- tm-of F E3 (tag C1)),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E4[x]) T[]),
      Dof3 : ( |- tm-of F E5 T)
    | tof : [ |- tm-of F (tm/iftag E1 E3 (\z497. E4) E5) T],
      x : [ |- raises (tm/iftag E1 E3 (\z497. E4) E5) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/tag2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Dvalue : ( |- value E1),
    Draises : ( |- raises E2 V)
  | tof : [ |- tm-of F (tm/tag E1 E2) T], x : [ |- raises (tm/tag E1 E2) V]
  ; split inversion-tm/tag tof as
    case inversion-tm/tag/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Dvalue : ( |- value E1),
      Draises : ( |- raises E2 V),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv tagged T t),
      Dof : ( |- tm-of F E1 (tag C1)),
      Dof1 : ( |- tm-of F E2 C1)
    | tof : [ |- tm-of F (tm/tag E1 E2) T], x : [ |- raises (tm/tag E1 E2) V]
    ; solve preservation-raises-tm [ |- Dof1] [ |- Draises]
    }
  }
  case raises/tag1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/tag E1 E3) T], x : [ |- raises (tm/tag E1 E3) V]
  ; split inversion-tm/tag tof as
    case inversion-tm/tag/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E3 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv tagged T t),
      Dof : ( |- tm-of F E1 (tag C1)),
      Dof1 : ( |- tm-of F E3 C1)
    | tof : [ |- tm-of F (tm/tag E1 E3) T], x : [ |- raises (tm/tag E1 E3) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/assign2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Dvalue : ( |- value E1),
    Draises : ( |- raises E2 V)
  | tof : [ |- tm-of F (tm/assign E1 E2) T],
    x : [ |- raises (tm/assign E1 E2) V]
  ; split inversion-tm/assign tof as
    case inversion-tm/assign/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Dvalue : ( |- value E1),
      Draises : ( |- raises E2 V),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv unit T t),
      Dof : ( |- tm-of F E1 (ref C1)),
      Dof1 : ( |- tm-of F E2 C1)
    | tof : [ |- tm-of F (tm/assign E1 E2) T],
      x : [ |- raises (tm/assign E1 E2) V]
    ; solve preservation-raises-tm [ |- Dof1] [ |- Draises]
    }
  }
  case raises/assign1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/assign E1 E3) T],
    x : [ |- raises (tm/assign E1 E3) V]
  ; split inversion-tm/assign tof as
    case inversion-tm/assign/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E3 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv unit T t),
      Dof : ( |- tm-of F E1 (ref C1)),
      Dof1 : ( |- tm-of F E3 C1)
    | tof : [ |- tm-of F (tm/assign E1 E3) T],
      x : [ |- raises (tm/assign E1 E3) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/deref:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/deref E1) T], x : [ |- raises (tm/deref E1) V]
  ; by inversion-tm/deref tof as Dof unboxed;
    solve preservation-raises-tm [ |- Dof] [ |- Draises]
  }
  case raises/ref:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/ref E1) T], x : [ |- raises (tm/ref E1) V]
  ; split inversion-tm/ref tof as
    case inversion-tm/ref/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv (ref C1) T t),
      Dof : ( |- tm-of F E1 C1)
    | tof : [ |- tm-of F (tm/ref E1) T], x : [ |- raises (tm/ref E1) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/case:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : (x27 : term |- term),
    E4 : (x28 : term |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/case E1 (\y493. E3) (\z492. E4)) T],
    x : [ |- raises (tm/case E1 (\y493. E3) (\z492. E4)) V]
  ; split inversion-tm/case tof as
    case inversion-tm/case/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E3 : (x27 : term |- term),
      E4 : (x28 : term |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      C2 : ( |- con),
      Dof : ( |- tm-of F E1 (plus C1 C2)),
      Dof1 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E3[x]) T[]),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x C2[] |- tm-of F[] (E4[x]) T[])
    | tof : [ |- tm-of F (tm/case E1 (\y493. E3) (\z492. E4)) T],
      x : [ |- raises (tm/case E1 (\y493. E3) (\z492. E4)) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/in2:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/in2 E1 C) T], x : [ |- raises (tm/in2 E1 C) V]
  ; split inversion-tm/in2 tof as
    case inversion-tm/in2/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C3 : ( |- con),
      Dequiv : ( |- cn-equiv (plus C C3) T t),
      Dof : ( |- tm-of F E1 C3),
      Dof1 : ( |- cn-of C t)
    | tof : [ |- tm-of F (tm/in2 E1 C) T], x : [ |- raises (tm/in2 E1 C) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/in1:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/in1 E1 C) T], x : [ |- raises (tm/in1 E1 C) V]
  ; split inversion-tm/in1 tof as
    case inversion-tm/in1/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C3 : ( |- con),
      Dequiv : ( |- cn-equiv (plus C3 C) T t),
      Dof : ( |- tm-of F E1 C3),
      Dof1 : ( |- cn-of C t)
    | tof : [ |- tm-of F (tm/in1 E1 C) T], x : [ |- raises (tm/in1 E1 C) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/app2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Dvalue : ( |- value E1),
    Draises : ( |- raises E2 V)
  | tof : [ |- tm-of F (tm/app E1 E2) T], x : [ |- raises (tm/app E1 E2) V]
  ; split inversion-tm/app tof as
    case inversion-tm/app/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Dvalue : ( |- value E1),
      Draises : ( |- raises E2 V),
      C1 : ( |- con),
      Dof : ( |- tm-of F E1 (arrow C1 T)),
      Dof1 : ( |- tm-of F E2 C1)
    | tof : [ |- tm-of F (tm/app E1 E2) T], x : [ |- raises (tm/app E1 E2) V]
    ; solve preservation-raises-tm [ |- Dof1] [ |- Draises]
    }
  }
  case raises/app1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/app E1 E3) T], x : [ |- raises (tm/app E1 E3) V]
  ; split inversion-tm/app tof as
    case inversion-tm/app/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E3 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      Dof : ( |- tm-of F E1 (arrow C1 T)),
      Dof1 : ( |- tm-of F E3 C1)
    | tof : [ |- tm-of F (tm/app E1 E3) T], x : [ |- raises (tm/app E1 E3) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/pi2:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/pi2 E1) T], x : [ |- raises (tm/pi2 E1) V]
  ; split inversion-tm/pi2 tof as
    case inversion-tm/pi2/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      Dof : ( |- tm-of F E1 (prod C1 T))
    | tof : [ |- tm-of F (tm/pi2 E1) T], x : [ |- raises (tm/pi2 E1) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/pi1:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/pi1 E1) T], x : [ |- raises (tm/pi1 E1) V]
  ; split inversion-tm/pi1 tof as
    case inversion-tm/pi1/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      Dof : ( |- tm-of F E1 (prod T C1))
    | tof : [ |- tm-of F (tm/pi1 E1) T], x : [ |- raises (tm/pi1 E1) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/pair2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Dvalue : ( |- value E1),
    Draises : ( |- raises E2 V)
  | tof : [ |- tm-of F (tm/pair E1 E2) T], x : [ |- raises (tm/pair E1 E2) V]
  ; split inversion-tm/pair tof as
    case inversion-tm/pair/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Dvalue : ( |- value E1),
      Draises : ( |- raises E2 V),
      C1 : ( |- con),
      C2 : ( |- con),
      Dequiv : ( |- cn-equiv (prod C1 C2) T t),
      Dof : ( |- tm-of F E1 C1),
      Dof1 : ( |- tm-of F E2 C2)
    | tof : [ |- tm-of F (tm/pair E1 E2) T],
      x : [ |- raises (tm/pair E1 E2) V]
    ; solve preservation-raises-tm [ |- Dof1] [ |- Draises]
    }
  }
  case raises/pair1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/pair E1 E3) T], x : [ |- raises (tm/pair E1 E3) V]
  ; split inversion-tm/pair tof as
    case inversion-tm/pair/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E3 : ( |- term),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      C1 : ( |- con),
      C2 : ( |- con),
      Dequiv : ( |- cn-equiv (prod C1 C2) T t),
      Dof : ( |- tm-of F E1 C1),
      Dof1 : ( |- tm-of F E3 C2)
    | tof : [ |- tm-of F (tm/pair E1 E3) T],
      x : [ |- raises (tm/pair E1 E3) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises/abort:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    V : ( |- term),
    Draises : ( |- raises E1 V)
  | tof : [ |- tm-of F (tm/abort E1 C) T], x : [ |- raises (tm/abort E1 C) V]
  ; split inversion-tm/abort tof as
    case inversion-tm/abort/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      T : ( |- con),
      V : ( |- term),
      Draises : ( |- raises E1 V),
      Dof : ( |- tm-of F E1 void),
      Dequiv : ( |- cn-equiv C T t)
    | tof : [ |- tm-of F (tm/abort E1 C) T],
      x : [ |- raises (tm/abort E1 C) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
}

and proof preservation-raises-md :
  [ |- md-of P F M S] ->
  [ |- raises-md M V] ->
    [ |- tm-of F V tagged] =
/ total 2 /
intros
{ P : ( |- purity),
  F : ( |- sttp),
  M : ( |- module'),
  S : ( |- sg),
  V : ( |- term)
| mof : [ |- md-of P F M S], x : [ |- raises-md M V]
; split x as
  case raises-md/lete:
  { P : ( |- purity),
    F : ( |- sttp),
    E : ( |- term),
    C : ( |- con),
    M1 : (x32 : term |- module'),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises E V)
  | mof : [ |- md-of P F (md/lete E C (\x. M1)) S],
    x : [ |- raises-md (md/lete E C (\x. M1)) V]
  ; split inversion-md/lete mof as
    case inversion-md/lete/i:
    { P : ( |- purity),
      F : ( |- sttp),
      E : ( |- term),
      C : ( |- con),
      M1 : (x32 : term |- module'),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises E V),
      Dof : ( |- tm-of F E C),
      Dof1 :
        (x : term, F' : sttp, y1398 : tm-of F' x C[] |-
           md-of P[] F[] (M1[x]) S[])
    | mof : [ |- md-of P F (md/lete E C (\x. M1)) S],
      x : [ |- raises-md (md/lete E C (\x. M1)) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
  case raises-md/letp:
  { P : ( |- purity),
    F : ( |- sttp),
    M1 : ( |- module'),
    M2 : (a90 : con, m17 : module' |- module'),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises-md M1 V)
  | mof : [ |- md-of P F (md/letp M1 (\a. \m. M2)) S],
    x : [ |- raises-md (md/letp M1 (\a. \m. M2)) V]
  ; split inversion-md/letp mof as
    case inversion-md/letp/i:
    { P : ( |- purity),
      F : ( |- sttp),
      M1 : ( |- module'),
      M2 : (a90 : con, m17 : module' |- module'),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises-md M1 V),
      S2 : ( |- sg),
      S3 : (y1394 : con |- sg),
      K : ( |- kind),
      C : ( |- con),
      Dof : ( |- md-of pure F M1 S2),
      Dfst : ( |- sg-fst S2 K),
      Dfst1 : ( |- md-fst M1 C),
      Dof1 :
        (a : con, y1393 : cn-of a K[], m : module', P' : purity, F' : sttp,
         x1393 : md-of P' F' m S2[],
         z1393 : md-fst m a |- md-of P[] F[] (M2[a, m]) (S3[a])),
      Dsub : ( |- sg-sub (S3[C]) S)
    | mof : [ |- md-of P F (md/letp M1 (\a. \m. M2)) S],
      x : [ |- raises-md (md/letp M1 (\a. \m. M2)) V]
    ; solve preservation-raises-md [ |- Dof] [ |- Draises]
    }
  }
  case raises-md/let:
  { P : ( |- purity),
    F : ( |- sttp),
    M1 : ( |- module'),
    M2 : (a89 : con, m16 : module' |- module'),
    S1 : ( |- sg),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises-md M1 V)
  | mof : [ |- md-of P F (md/let M1 (\a. \m. M2) S1) S],
    x : [ |- raises-md (md/let M1 (\a. \m. M2) S1) V]
  ; split inversion-md/let mof as
    case inversion-md/let/i:
    { P : ( |- purity),
      F : ( |- sttp),
      M1 : ( |- module'),
      M2 : (a89 : con, m16 : module' |- module'),
      S1 : ( |- sg),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises-md M1 V),
      S4 : ( |- sg),
      K : ( |- kind),
      Dof : ( |- md-of impure F M1 S4),
      Dfst : ( |- sg-fst S4 K),
      Dof1 :
        (a : con, z1380 : cn-of a K[], m : module', P' : purity, F' : sttp,
         y1381 : md-of P' F' m S4[],
         x1381 : md-fst m a |- md-of impure F[] (M2[a, m]) S1[]),
      Dsub : ( |- sg-sub S1 S),
      X : ( |- purity-sub impure P)
    | mof : [ |- md-of P F (md/let M1 (\a. \m. M2) S1) S],
      x : [ |- raises-md (md/let M1 (\a. \m. M2) S1) V]
    ; solve preservation-raises-md [ |- Dof] [ |- Draises]
    }
  }
  case raises-md/out:
  { P : ( |- purity),
    F : ( |- sttp),
    M1 : ( |- module'),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises-md M1 V)
  | mof : [ |- md-of P F (md/out M1) S], x : [ |- raises-md (md/out M1) V]
  ; split inversion-md/out mof as
    case inversion-md/out/i:
    { P : ( |- purity),
      F : ( |- sttp),
      M1 : ( |- module'),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises-md M1 V),
      L : ( |- name),
      Dof : ( |- md-of P F M1 (sg/named L S))
    | mof : [ |- md-of P F (md/out M1) S], x : [ |- raises-md (md/out M1) V]
    ; solve preservation-raises-md [ |- Dof] [ |- Draises]
    }
  }
  case raises-md/in:
  { P : ( |- purity),
    F : ( |- sttp),
    L : ( |- name),
    M1 : ( |- module'),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises-md M1 V)
  | mof : [ |- md-of P F (md/in L M1) S], x : [ |- raises-md (md/in L M1) V]
  ; split inversion-md/in mof as
    case inversion-md/in/i:
    { P : ( |- purity),
      F : ( |- sttp),
      L : ( |- name),
      M1 : ( |- module'),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises-md M1 V),
      S2 : ( |- sg),
      Dof : ( |- md-of P F M1 S2),
      Dsub : ( |- sg-sub (sg/named L S2) S)
    | mof : [ |- md-of P F (md/in L M1) S],
      x : [ |- raises-md (md/in L M1) V]
    ; solve preservation-raises-md [ |- Dof] [ |- Draises]
    }
  }
  case raises-md/app2:
  { P : ( |- purity),
    F : ( |- sttp),
    M1 : ( |- module'),
    M2 : ( |- module'),
    S : ( |- sg),
    V : ( |- term),
    Dvalue : ( |- value-md M1),
    Draises : ( |- raises-md M2 V)
  | mof : [ |- md-of P F (md/app M1 M2) S],
    x : [ |- raises-md (md/app M1 M2) V]
  ; split inversion-md/app mof as
    case inversion-md/app/i:
    { P : ( |- purity),
      F : ( |- sttp),
      M1 : ( |- module'),
      M2 : ( |- module'),
      S : ( |- sg),
      V : ( |- term),
      Dvalue : ( |- value-md M1),
      Draises : ( |- raises-md M2 V),
      S2 : ( |- sg),
      S3 : (y1367 : con |- sg),
      C : ( |- con),
      Dof : ( |- md-of impure F M1 (sg/pi S2 (\z484. S3))),
      Dof1 : ( |- md-of pure F M2 S2),
      Dfst : ( |- md-fst M2 C),
      Dsub : ( |- sg-sub (S3[C]) S),
      X : ( |- purity-sub impure P)
    | mof : [ |- md-of P F (md/app M1 M2) S],
      x : [ |- raises-md (md/app M1 M2) V]
    ; solve preservation-raises-md [ |- Dof1] [ |- Draises]
    }
  }
  case raises-md/app1:
  { P : ( |- purity),
    F : ( |- sttp),
    M1 : ( |- module'),
    M2 : ( |- module'),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises-md M1 V)
  | mof : [ |- md-of P F (md/app M1 M2) S],
    x : [ |- raises-md (md/app M1 M2) V]
  ; split inversion-md/app mof as
    case inversion-md/app/i:
    { P : ( |- purity),
      F : ( |- sttp),
      M1 : ( |- module'),
      M2 : ( |- module'),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises-md M1 V),
      S2 : ( |- sg),
      S3 : (y1367 : con |- sg),
      C : ( |- con),
      Dof : ( |- md-of impure F M1 (sg/pi S2 (\z484. S3))),
      Dof1 : ( |- md-of pure F M2 S2),
      Dfst : ( |- md-fst M2 C),
      Dsub : ( |- sg-sub (S3[C]) S),
      X : ( |- purity-sub impure P)
    | mof : [ |- md-of P F (md/app M1 M2) S],
      x : [ |- raises-md (md/app M1 M2) V]
    ; solve preservation-raises-md [ |- Dof] [ |- Draises]
    }
  }
  case raises-md/pi2:
  { P : ( |- purity),
    F : ( |- sttp),
    M1 : ( |- module'),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises-md M1 V)
  | mof : [ |- md-of P F (md/pi2 M1) S], x : [ |- raises-md (md/pi2 M1) V]
  ; split inversion-md/pi2 mof as
    case inversion-md/pi1/i:
    { P : ( |- purity),
      F : ( |- sttp),
      M1 : ( |- module'),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises-md M1 V),
      S2 : ( |- sg),
      Dof : ( |- md-of pure F M1 (sg/sigma S (\l. S2[])))
    | mof : [ |- md-of P F (md/pi2 M1) S], x : [ |- raises-md (md/pi2 M1) V]
    ; solve preservation-raises-md [ |- Dof] [ |- Draises]
    }
  }
  case raises-md/pi1:
  { P : ( |- purity),
    F : ( |- sttp),
    M1 : ( |- module'),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises-md M1 V)
  | mof : [ |- md-of P F (md/pi1 M1) S], x : [ |- raises-md (md/pi1 M1) V]
  ; split inversion-md/pi1 mof as
    case inversion-md/pi1/i:
    { P : ( |- purity),
      F : ( |- sttp),
      M1 : ( |- module'),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises-md M1 V),
      S2 : ( |- sg),
      Dof : ( |- md-of pure F M1 (sg/sigma S (\l. S2[])))
    | mof : [ |- md-of P F (md/pi1 M1) S], x : [ |- raises-md (md/pi1 M1) V]
    ; solve preservation-raises-md [ |- Dof] [ |- Draises]
    }
  }
  case raises-md/dpair:
  { P : ( |- purity),
    F : ( |- sttp),
    M1 : ( |- module'),
    M2 : (a88 : con, m15 : module' |- module'),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises-md M1 V)
  | mof : [ |- md-of P F (md/dpair M1 (\a. \m. M2)) S],
    x : [ |- raises-md (md/dpair M1 (\a. \m. M2)) V]
  ; split inversion-md/dpair mof as
    case inversion-md/dpair/i:
    { P : ( |- purity),
      F : ( |- sttp),
      M1 : ( |- module'),
      M2 : (a88 : con, m15 : module' |- module'),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises-md M1 V),
      S2 : ( |- sg),
      S3 : (y1346 : con |- sg),
      K : ( |- kind),
      Dof : ( |- md-of P F M1 S2),
      Dfst : ( |- sg-fst S2 K),
      Dof1 :
        (a : con, y1345 : cn-of a K[], m : module', P' : purity, F' : sttp,
         x1345 : md-of P' F' m S2[],
         z1345 : md-fst m a |- md-of P[] F[] (M2[a, m]) (S3[a])),
      Dsub : ( |- sg-sub (sg/sigma S2 (\z485. S3)) S)
    | mof : [ |- md-of P F (md/dpair M1 (\a. \m. M2)) S],
      x : [ |- raises-md (md/dpair M1 (\a. \m. M2)) V]
    ; solve preservation-raises-md [ |- Dof] [ |- Draises]
    }
  }
  case raises-md/pair2:
  { P : ( |- purity),
    F : ( |- sttp),
    M1 : ( |- module'),
    M2 : ( |- module'),
    S : ( |- sg),
    V : ( |- term),
    Dvalue : ( |- value-md M1),
    Draises : ( |- raises-md M2 V)
  | mof : [ |- md-of P F (md/pair M1 M2) S],
    x : [ |- raises-md (md/pair M1 M2) V]
  ; split inversion-md/pair mof as
    case inversion-md/pair/i:
    { P : ( |- purity),
      F : ( |- sttp),
      M1 : ( |- module'),
      M2 : ( |- module'),
      S : ( |- sg),
      V : ( |- term),
      Dvalue : ( |- value-md M1),
      Draises : ( |- raises-md M2 V),
      S2 : ( |- sg),
      S3 : ( |- sg),
      Dof : ( |- md-of P F M1 S2),
      Dof1 : ( |- md-of P F M2 S3),
      Dsub : ( |- sg-sub (sg/sigma S2 (\l. S3[])) S)
    | mof : [ |- md-of P F (md/pair M1 M2) S],
      x : [ |- raises-md (md/pair M1 M2) V]
    ; solve preservation-raises-md [ |- Dof1] [ |- Draises]
    }
  }
  case raises-md/pair1:
  { P : ( |- purity),
    F : ( |- sttp),
    M1 : ( |- module'),
    M2 : ( |- module'),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises-md M1 V)
  | mof : [ |- md-of P F (md/pair M1 M2) S],
    x : [ |- raises-md (md/pair M1 M2) V]
  ; split inversion-md/pair mof as
    case inversion-md/pair/i:
    { P : ( |- purity),
      F : ( |- sttp),
      M1 : ( |- module'),
      M2 : ( |- module'),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises-md M1 V),
      S2 : ( |- sg),
      S3 : ( |- sg),
      Dof : ( |- md-of P F M1 S2),
      Dof1 : ( |- md-of P F M2 S3),
      Dsub : ( |- sg-sub (sg/sigma S2 (\l. S3[])) S)
    | mof : [ |- md-of P F (md/pair M1 M2) S],
      x : [ |- raises-md (md/pair M1 M2) V]
    ; solve preservation-raises-md [ |- Dof] [ |- Draises]
    }
  }
  case raises-md/datom:
  { P : ( |- purity),
    F : ( |- sttp),
    E : ( |- term),
    C : ( |- con),
    S : ( |- sg),
    V : ( |- term),
    Draises : ( |- raises E V)
  | mof : [ |- md-of P F (md/datom E C) S],
    x : [ |- raises-md (md/datom E C) V]
  ; split inversion-md/datom mof as
    case inversion-md/datom/i:
    { P : ( |- purity),
      F : ( |- sttp),
      E : ( |- term),
      C : ( |- con),
      S : ( |- sg),
      V : ( |- term),
      Draises : ( |- raises E V),
      Dof : ( |- tm-of F E C),
      Dsub : ( |- sg-sub (sg/datom C) S)
    | mof : [ |- md-of P F (md/datom E C) S],
      x : [ |- raises-md (md/datom E C) V]
    ; solve preservation-raises-tm [ |- Dof] [ |- Draises]
    }
  }
}
;

LF preservation-tm/e : sttp -> term -> con -> store -> type =
| preservation-tm/i :
  { F' : sttp}
  tm-of F' E' T ->
  store-of F' ST' F' ->
  extends F F' ->
    preservation-tm/e F E' T ST'
;

LF preservation-md/e : purity -> sttp -> module' -> sg -> store -> type =
| preservation-md/i :
  { F' : sttp }
  md-of P F' M' S ->
  store-of F' ST' F' ->
  extends F F' ->
    preservation-md/e P F M' S ST'
;

proof preservation-tm :
  [ |- tm-of F E T] ->
  [ |- store-of F ST F] ->
  [ |- step ST E ST' E'] ->
    [ |- preservation-tm/e F E' T ST'] =
/ total 3 /
intros
{ F : ( |- sttp),
  E : ( |- term),
  T : ( |- con),
  ST : ( |- store),
  ST' : ( |- store),
  E' : ( |- term)
| tof : [ |- tm-of F E T],
  sof : [ |- store-of F ST F],
  x : [ |- step ST E ST' E']
; by tof as Dof unboxed;
  by sof as Dstof unboxed;
  split x as
  case step/snd-beta:
  { F : ( |- sttp),
    E' : ( |- term),
    C : ( |- con),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/snd (md/datom E' C)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E')
  | tof : [ |- tm-of F (tm/snd (md/datom E' C)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/snd (md/datom E' C)) ST' E']
  ; by inversion-tm/snd [ |- Dof] as Dof' unboxed;
    split inversion-md/datom [ |- Dof'] as
    case inversion-md/datom/i:
    { F : ( |- sttp),
      E' : ( |- term),
      C : ( |- con),
      T : ( |- con),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/snd (md/datom E' C)) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E'),
      Dof' : ( |- md-of impure F (md/datom E' C) (sg/datom T)),
      Dof1 : ( |- tm-of F E' C),
      Dsub : ( |- sg-sub (sg/datom C) (sg/datom T))
    | tof : [ |- tm-of F (tm/snd (md/datom E' C)) T],
      sof : [ |- store-of F ST' F],
      x : [ |- step ST' (tm/snd (md/datom E' C)) ST' E']
    ; by sg-sub-datom-invert [ |- Dsub] as Dequiv unboxed;
      solve
        [ |-
           preservation-tm/i _ (tm-of/equiv Dof1 Dequiv) Dstof (extends/nil )]
    }
  }
  case step/snd:
  { F : ( |- sttp),
    M : ( |- module'),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    M1 : ( |- module'),
    Dof : ( |- tm-of F (tm/snd M) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step-md ST M ST' M1)
  | tof : [ |- tm-of F (tm/snd M) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/snd M) ST' (tm/snd M1)]
  ; by inversion-tm/snd [ |- Dof] as Dof' unboxed;
    split preservation-md [ |- Dof'] [ |- Dstof] [ |- Dstep] as
    case preservation-md/i:
    { F : ( |- sttp),
      M : ( |- module'),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      M1 : ( |- module'),
      Dof : ( |- tm-of F (tm/snd M) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step-md ST M ST' M1),
      Dof' : ( |- md-of impure F M (sg/datom T)),
      F2 : ( |- sttp),
      Dof1 : ( |- md-of impure F2 M1 (sg/datom T)),
      Dof2 : ( |- store-of F2 ST' F2),
      Dextends : ( |- extends F F2)
    | tof : [ |- tm-of F (tm/snd M) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/snd M) ST' (tm/snd M1)]
    ; solve [ |- preservation-tm/i _ (tm-of/snd Dof1) Dof2 Dextends]
    }
  }
  case step/lett2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : (x24 : term |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/lett E1 (\y131. E2)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1)
  | tof : [ |- tm-of F (tm/lett E1 (\y131. E2)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/lett E1 (\y131. E2)) ST' (E2[E1])]
  ; split inversion-tm/lett [ |- Dof] as
    case inversion-tm/lett/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : (x24 : term |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/lett E1 (\y131. E2)) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E1),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F E1 C1),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E2[x]) T[])
    | tof : [ |- tm-of F (tm/lett E1 (\x361. E2)) T],
      sof : [ |- store-of F ST' F],
      x : [ |- step ST' (tm/lett E1 (\x361. E2)) ST' (E2[E1])]
    ; by [ |- Dof2[E1, (\f. _)]] as Dof'' unboxed;
      solve [ |- preservation-tm/i F Dof'' Dstof (extends/nil )]
    }
  }
  case step/lett1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : (x23 : term |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/lett E1 (\y131. E3)) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/lett E1 (\y131. E3)) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/lett E1 (\y131. E3)) ST' (tm/lett E2 (\y131. E3))]
  ; split inversion-tm/lett [ |- Dof] as
    case inversion-tm/lett/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E3 : (x23 : term |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/lett E1 (\y131. E3)) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F E1 C1),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E3[x]) T[])
    | tof : [ |- tm-of F (tm/lett E1 (\y281. E3)) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/lett E1 (\y281. E3)) ST' (tm/lett E2 (\y281. E3))]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E3 : (x23 : term |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/lett E1 (\y131. E3)) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C1 : ( |- con),
        Dof1 : ( |- tm-of F E1 C1),
        Dof2 :
          (x : term, u : {F' : sttp}  tm-of F' x C1[] |-
             tm-of F[] (E3[x]) T[]),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E2 C1),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/lett E1 (\y281. E3)) T],
        sof : [ |- store-of F ST F],
        x :
          [ |- step ST (tm/lett E1 (\y281. E3)) ST' (tm/lett E2 (\y281. E3))]
      ; by monotonicity-tm
             [b : block (x : term, u : {F' : sttp}  tm-of F' x C1[]) |-
                Dof2[b.1, b.2]]
             [b : block (x : term, u : {F' : sttp}  tm-of F' x C1[]) |-
                Dextends[]]
        as Dof2' unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/lett Dof3 (\x. \u. Dof2'[<x; u>])) Dof4 Dextends]
      }
    }
  }
  case step/try-handle:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : (x22 : term |- term),
    T : ( |- con),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/try E1 (\y130. E3)) T),
    Dstof : ( |- store-of F ST' F),
    Draises : ( |- raises E1 E2)
  | tof : [ |- tm-of F (tm/try E1 (\y130. E3)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/try E1 (\y130. E3)) ST' (E3[E2])]
  ; split inversion-tm/try tof as
    case inversion-tm/try/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E3 : (x22 : term |- term),
      T : ( |- con),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/try E1 (\y130. E3)) T),
      Dstof : ( |- store-of F ST' F),
      Draises : ( |- raises E1 E2),
      Dof1 : ( |- tm-of F E1 T),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x tagged |-
           tm-of F[] (E3[x]) T[])
    | tof : [ |- tm-of F (tm/try E1 (\z502. E3)) T],
      sof : [ |- store-of F ST' F],
      x : [ |- step ST' (tm/try E1 (\z502. E3)) ST' (E3[E2])]
    ; by preservation-raises-tm [ |- Dof1] [ |- Draises] as Dof' unboxed;
      by [ |- Dof2[E2, (\f. _)]] as Dof'' unboxed;
      solve [ |- preservation-tm/i F Dof'' Dstof (extends/nil )]
    }
  }
  case step/try-done:
  { F : ( |- sttp),
    E' : ( |- term),
    E2 : (x21 : term |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/try E' (\y130. E2)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E')
  | tof : [ |- tm-of F (tm/try E' (\y130. E2)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/try E' (\y130. E2)) ST' E']
  ; split inversion-tm/try [ |- Dof] as
    case inversion-tm/try/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : (x21 : term |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/try E1 (\y130. E2)) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E1),
      Dof1 : ( |- tm-of F E1 T),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x tagged |-
           tm-of F[] (E2[x]) T[])
    | tof : [ |- tm-of F (tm/try E1 (\y130. E2)) T],
      sof : [ |- store-of F ST' F],
      x : [ |- step ST' (tm/try E1 (\y130. E2)) ST' E1]
    ; solve [ |- preservation-tm/i F Dof1 Dstof (extends/nil )]
    }
  }
  case step/try:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : (x20 : term |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/try E1 (\y130. E3)) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/try E1 (\y130. E3)) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/try E1 (\y130. E3)) ST' (tm/try E2 (\y130. E3))]
  ; split inversion-tm/try [ |- Dof] as
    case inversion-tm/try/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E3 : (x20 : term |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/try E1 (\y130. E3)) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      Dof1 : ( |- tm-of F E1 T),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x tagged |-
           tm-of F[] (E3[x]) T[])
    | tof : [ |- tm-of F (tm/try E1 (\y280. E3)) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/try E1 (\y280. E3)) ST' (tm/try E2 (\y280. E3))]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E3 : (x20 : term |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/try E1 (\y130. E3)) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        Dof1 : ( |- tm-of F E1 T),
        Dof2 :
          (x : term, u : {F' : sttp}  tm-of F' x tagged |-
             tm-of F[] (E3[x]) T[]),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E2 T),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/try E1 (\y280. E3)) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/try E1 (\y280. E3)) ST' (tm/try E2 (\y280. E3))]
      ; by monotonicity-tm
             [b : block (x : term, u : {F' : sttp}  tm-of F' x tagged) |-
                Dof2[b.1, b.2]]
             [b : block (x : term, u : {F' : sttp}  tm-of F' x tagged) |-
                Dextends[]]
        as Dof2' unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/try Dof3 (\x. \u. Dof2'[<x; u>])) Dof4 Dextends]
      }
    }
  }
  case step/raise:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/raise E1 C) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/raise E1 C) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/raise E1 C) ST' (tm/raise E2 C)]
  ; split inversion-tm/raise [ |- Dof] as
    case inversion-tm/raise/i:
    { F : ( |- sttp),
      E : ( |- term),
      C : ( |- con),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E' : ( |- term),
      Dof : ( |- tm-of F (tm/raise E C) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E ST' E'),
      Dequiv : ( |- cn-equiv C T t),
      Dof1 : ( |- tm-of F E tagged)
    | tof : [ |- tm-of F (tm/raise E C) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/raise E C) ST' (tm/raise E' C)]
    ; split cn-equiv-reg [ |- Dequiv] as
      case cn-equiv-reg/i:
      { F : ( |- sttp),
        E : ( |- term),
        C : ( |- con),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E' : ( |- term),
        Dof : ( |- tm-of F (tm/raise E C) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E ST' E'),
        Dequiv : ( |- cn-equiv C T t),
        Dof1 : ( |- tm-of F E tagged),
        Dof2 : ( |- cn-of C t),
        Dof3 : ( |- cn-of T t),
        Dwf : ( |- kd-wf t)
      | tof : [ |- tm-of F (tm/raise E C) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/raise E C) ST' (tm/raise E' C)]
      ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
        case preservation-tm/i:
        { F : ( |- sttp),
          E : ( |- term),
          C : ( |- con),
          T : ( |- con),
          ST : ( |- store),
          ST' : ( |- store),
          E' : ( |- term),
          Dof : ( |- tm-of F (tm/raise E C) T),
          Dstof : ( |- store-of F ST F),
          Dstep : ( |- step ST E ST' E'),
          Dequiv : ( |- cn-equiv C T t),
          Dof1 : ( |- tm-of F E tagged),
          Dof2 : ( |- cn-of C t),
          Dof3 : ( |- cn-of T t),
          Dwf : ( |- kd-wf t),
          F2 : ( |- sttp),
          Dof4 : ( |- tm-of F2 E' tagged),
          Dof5 : ( |- store-of F2 ST' F2),
          Dextends : ( |- extends F F2)
        | tof : [ |- tm-of F (tm/raise E C) T],
          sof : [ |- store-of F ST F],
          x : [ |- step ST (tm/raise E C) ST' (tm/raise E' C)]
        ; solve
            [ |-
               preservation-tm/i F2
               (tm-of/equiv (tm-of/raise Dof4 Dof2) Dequiv) Dof5 Dextends]
        }
      }
    }
  }
  case step/out-beta:
  { F : ( |- sttp),
    X : ( |- label),
    E' : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/out (tm/in X E')) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E')
  | tof : [ |- tm-of F (tm/out (tm/in X E')) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/out (tm/in X E')) ST' E']
  ; split inversion-tm/out [ |- Dof] as
    case inversion-tm/out/i:
    { F : ( |- sttp),
      X : ( |- label),
      E' : ( |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/out (tm/in X E')) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E'),
      X1 : ( |- label),
      Dof1 : ( |- tm-of F (tm/in X E') (labeled X1 T))
    | tof : [ |- tm-of F (tm/out (tm/in X E')) T],
      sof : [ |- store-of F ST' F],
      x : [ |- step ST' (tm/out (tm/in X E')) ST' E']
    ; split inversion-tm/in [ |- Dof1] as
      case inversion-tm/in/i:
      { F : ( |- sttp),
        X : ( |- label),
        E' : ( |- term),
        T : ( |- con),
        ST' : ( |- store),
        Dof : ( |- tm-of F (tm/out (tm/in X E')) T),
        Dstof : ( |- store-of F ST' F),
        Dvalue : ( |- value E'),
        X1 : ( |- label),
        Dof1 : ( |- tm-of F (tm/in X E') (labeled X1 T)),
        C1 : ( |- con),
        Dequiv : ( |- cn-equiv (labeled X C1) (labeled X1 T) t),
        Dof2 : ( |- tm-of F E' C1)
      | tof : [ |- tm-of F (tm/out (tm/in X E')) T],
        sof : [ |- store-of F ST' F],
        x : [ |- step ST' (tm/out (tm/in X E')) ST' E']
      ; split injective-labeled [ |- Dequiv] as
        case injective-labeled/i:
        { F : ( |- sttp),
          X : ( |- label),
          E' : ( |- term),
          T : ( |- con),
          ST' : ( |- store),
          Dof : ( |- tm-of F (tm/out (tm/in X E')) T),
          Dstof : ( |- store-of F ST' F),
          Dvalue : ( |- value E'),
          X1 : ( |- label),
          Dof1 : ( |- tm-of F (tm/in X E') (labeled X1 T)),
          C1 : ( |- con),
          Dequiv : ( |- cn-equiv (labeled X C1) (labeled X1 T) t),
          Dof2 : ( |- tm-of F E' C1),
          X4 : ( |- label-eq X X1),
          Dequiv1 : ( |- cn-equiv C1 T t)
        | tof : [ |- tm-of F (tm/out (tm/in X E')) T],
          sof : [ |- store-of F ST' F],
          x : [ |- step ST' (tm/out (tm/in X E')) ST' E']
        ; solve
            [ |-
               preservation-tm/i F
               (tm-of/equiv Dof2 Dequiv1) Dstof (extends/nil )]
        }
      }
    }
  }
  case step/out:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/out E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/out E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/out E1) ST' (tm/out E2)]
  ; split inversion-tm/out [ |- Dof] as
    case inversion-tm/out/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E' : ( |- term),
      Dof : ( |- tm-of F (tm/out E) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E ST' E'),
      X : ( |- label),
      Dof1 : ( |- tm-of F E (labeled X T))
    | tof : [ |- tm-of F (tm/out E) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/out E) ST' (tm/out E')]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E' : ( |- term),
        Dof : ( |- tm-of F (tm/out E) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E ST' E'),
        L : ( |- label),
        Dof' : ( |- tm-of F E (labeled L T)),
        F2 : ( |- sttp),
        Dof1 : ( |- tm-of F2 E' (labeled L T)),
        Dof2 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/out E) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/out E) ST' (tm/out E')]
      ; solve [ |- preservation-tm/i F2 (tm-of/out Dof1) Dof2 Dextends]
      }
    }
  }
  case step/in:
  { F : ( |- sttp),
    X : ( |- label),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/in X E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/in X E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/in X E1) ST' (tm/in X E2)]
  ; split inversion-tm/in [ |- Dof] as
    case inversion-tm/in/i:
    { F : ( |- sttp),
      X : ( |- label),
      E : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E' : ( |- term),
      Dof : ( |- tm-of F (tm/in X E) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E ST' E'),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv (labeled X C1) T t),
      Dof1 : ( |- tm-of F E C1)
    | tof : [ |- tm-of F (tm/in X E) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/in X E) ST' (tm/in X E')]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        X : ( |- label),
        E : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E' : ( |- term),
        Dof : ( |- tm-of F (tm/in X E) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E ST' E'),
        T' : ( |- con),
        Dequiv : ( |- cn-equiv (labeled X T') T t),
        Dof' : ( |- tm-of F E T'),
        F2 : ( |- sttp),
        Dof1 : ( |- tm-of F2 E' T'),
        Dof2 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/in X E) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/in X E) ST' (tm/in X E')]
      ; solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/in Dof1) Dequiv) Dof2 Dextends]
      }
    }
  }
  case step/unroll-beta:
  { F : ( |- sttp),
    E' : ( |- term),
    K : ( |- kind),
    C : (a78 : con, a77 : con |- con),
    C1 : ( |- con),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E')
  | tof : [ |- tm-of F (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) ST' E']
  ; split inversion-tm/unroll [ |- Dof] as
    case inversion-tm/unroll/i:
    { F : ( |- sttp),
      E' : ( |- term),
      K : ( |- kind),
      C : (a78 : con, a77 : con |- con),
      C1 : ( |- con),
      T : ( |- con),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E'),
      K1 : ( |- kind),
      C3 : (x1047 : con, z1047 : con |- con),
      C4 : ( |- con),
      Dequiv :
        ( |-
           cn-equiv
             (C3[lam K1 (\a. rec' K1[] (\z335. \y336. C3[z335, y336]) a), C4])
             T t),
      Dof1 :
        ( |-
           tm-of
             F
             (tm/roll E' K (\z126. \y127. C) C1)
             (rec' K1 (\z335. \y336. C3) C4))
    | tof : [ |- tm-of F (tm/unroll (tm/roll E' K (\y357. \x357. C) C1)) T],
      sof : [ |- store-of F ST' F],
      x :
        [ |- step ST' (tm/unroll (tm/roll E' K (\y357. \x357. C) C1)) ST' E']
    ; split inversion-tm/roll [ |- Dof1] as
      case inversion-tm/roll/i:
      { F : ( |- sttp),
        E' : ( |- term),
        K : ( |- kind),
        C : (a78 : con, a77 : con |- con),
        C1 : ( |- con),
        T : ( |- con),
        ST' : ( |- store),
        Dof : ( |- tm-of F (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) T),
        Dstof : ( |- store-of F ST' F),
        Dvalue : ( |- value E'),
        K1 : ( |- kind),
        C3 : (x1047 : con, z1047 : con |- con),
        C4 : ( |- con),
        Dequiv :
          ( |-
             cn-equiv
               (C3[lam K1 (\a. rec' K1[] (\z335. \y336. C3[z335, y336]) a),
                   C4]) T t),
        Dof1 :
          ( |-
             tm-of
               F
               (tm/roll E' K (\z126. \y127. C) C1)
               (rec' K1 (\z335. \y336. C3) C4)),
        Dequiv1 :
          ( |-
             cn-equiv
               (rec' K (\z335. \y336. C) C1)
               (rec' K1 (\z335. \y336. C3) C4) t),
        Dof2 :
          ( |-
             tm-of
               F
               E'
               (C[lam K (\a. rec' K[] (\z335. \y336. C[z335, y336]) a), C1])),
        Dwf : ( |- kd-wf K),
        Dof3 :
          (a : con, x1044 : cn-of a (pi K[] (\l. t)), b : con,
           z1044 : cn-of b K[] |- cn-of (C[a, b]) t),
        Dof4 : ( |- cn-of C1 K)
      | tof : [ |- tm-of F (tm/unroll (tm/roll E' K (\y357. \x357. C) C1)) T],
        sof : [ |- store-of F ST' F],
        x :
          [ |-
             step ST' (tm/unroll (tm/roll E' K (\y357. \x357. C) C1)) ST' E']
      ; split injective-rec [ |- Dequiv1] as
        case injective-rec/i:
        { F : ( |- sttp),
          E' : ( |- term),
          K : ( |- kind),
          C : (a78 : con, a77 : con |- con),
          C1 : ( |- con),
          T : ( |- con),
          ST' : ( |- store),
          Dof :
            ( |- tm-of F (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) T),
          Dstof : ( |- store-of F ST' F),
          Dvalue : ( |- value E'),
          K1 : ( |- kind),
          C3 : (x1047 : con, z1047 : con |- con),
          C4 : ( |- con),
          Dequiv :
            ( |-
               cn-equiv
                 (C3[lam K1 (\a. rec' K1[] (\z335. \y336. C3[z335, y336]) a),
                     C4]) T t),
          Dof1 :
            ( |-
               tm-of
                 F
                 (tm/roll E' K (\z126. \y127. C) C1)
                 (rec' K1 (\z335. \y336. C3) C4)),
          Dequiv1 :
            ( |-
               cn-equiv
                 (rec' K (\z335. \y336. C) C1)
                 (rec' K1 (\z335. \y336. C3) C4) t),
          Dof2 :
            ( |-
               tm-of
                 F
                 E'
                 (C[lam K (\a. rec' K[] (\z335. \y336. C[z335, y336]) a), C1])),
          Dwf : ( |- kd-wf K),
          Dof3 :
            (a : con, x1044 : cn-of a (pi K[] (\l. t)), b : con,
             z1044 : cn-of b K[] |- cn-of (C[a, b]) t),
          Dof4 : ( |- cn-of C1 K),
          Dequiv2 : ( |- kd-equiv K K1),
          Dequiv3 :
            (a : con, x989 : cn-of a (pi K[] (\l. t)), b : con,
             z989 : cn-of b K[] |- cn-equiv (C[a, b]) (C3[a, b]) t),
          Dequiv4 : ( |- cn-equiv C1 C4 K)
        | tof :
            [ |- tm-of F (tm/unroll (tm/roll E' K (\y357. \x357. C) C1)) T],
          sof : [ |- store-of F ST' F],
          x :
            [ |-
               step
                 ST' (tm/unroll (tm/roll E' K (\y357. \x357. C) C1)) ST' E']
        ; split cn-equiv-reg [ |- Dequiv1] as
          case cn-equiv-reg/i:
          { F : ( |- sttp),
            E' : ( |- term),
            K : ( |- kind),
            C : (a78 : con, a77 : con |- con),
            C1 : ( |- con),
            T : ( |- con),
            ST' : ( |- store),
            Dof :
              ( |- tm-of F (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) T),
            Dstof : ( |- store-of F ST' F),
            Dvalue : ( |- value E'),
            K1 : ( |- kind),
            C3 : (x1047 : con, z1047 : con |- con),
            C4 : ( |- con),
            Dequiv :
              ( |-
                 cn-equiv
                   (C3[lam K1
                       (\a. rec' K1[] (\z335. \y336. C3[z335, y336]) a), C4])
                   T t),
            Dof1 :
              ( |-
                 tm-of
                   F
                   (tm/roll E' K (\z126. \y127. C) C1)
                   (rec' K1 (\z335. \y336. C3) C4)),
            Dequiv1 :
              ( |-
                 cn-equiv
                   (rec' K (\z335. \y336. C) C1)
                   (rec' K1 (\z335. \y336. C3) C4) t),
            Dof2 :
              ( |-
                 tm-of
                   F
                   E'
                   (C[lam K (\a. rec' K[] (\z335. \y336. C[z335, y336]) a),
                      C1])),
            Dwf : ( |- kd-wf K),
            Dof3 :
              (a : con, x1044 : cn-of a (pi K[] (\l. t)), b : con,
               z1044 : cn-of b K[] |- cn-of (C[a, b]) t),
            Dof4 : ( |- cn-of C1 K),
            Dequiv2 : ( |- kd-equiv K K1),
            Dequiv3 :
              (a : con, x989 : cn-of a (pi K[] (\l. t)), b : con,
               z989 : cn-of b K[] |- cn-equiv (C[a, b]) (C3[a, b]) t),
            Dequiv4 : ( |- cn-equiv C1 C4 K),
            Dof5 : ( |- cn-of (rec' K (\z335. \y336. C) C1) t),
            Dof6 : ( |- cn-of (rec' K1 (\z335. \y336. C3) C4) t),
            Dwf1 : ( |- kd-wf t)
          | tof :
              [ |- tm-of F (tm/unroll (tm/roll E' K (\y357. \x357. C) C1)) T],
            sof : [ |- store-of F ST' F],
            x :
              [ |-
                 step
                   ST' (tm/unroll (tm/roll E' K (\y357. \x357. C) C1)) ST' E']
          ; split inversion-rec [ |- Dof6] as
            case inversion-rec/i:
            { F : ( |- sttp),
              E' : ( |- term),
              K : ( |- kind),
              C : (a78 : con, a77 : con |- con),
              C1 : ( |- con),
              T : ( |- con),
              ST' : ( |- store),
              Dof :
                ( |-
                   tm-of F (tm/unroll (tm/roll E' K (\z126. \y127. C) C1)) T),
              Dstof : ( |- store-of F ST' F),
              Dvalue : ( |- value E'),
              K1 : ( |- kind),
              C3 : (x1047 : con, z1047 : con |- con),
              C4 : ( |- con),
              Dequiv :
                ( |-
                   cn-equiv
                     (C3[lam K1
                         (\a. rec' K1[] (\z335. \y336. C3[z335, y336]) a), C4])
                     T t),
              Dof1 :
                ( |-
                   tm-of
                     F
                     (tm/roll E' K (\z126. \y127. C) C1)
                     (rec' K1 (\z335. \y336. C3) C4)),
              Dequiv1 :
                ( |-
                   cn-equiv
                     (rec' K (\z335. \y336. C) C1)
                     (rec' K1 (\z335. \y336. C3) C4) t),
              Dof2 :
                ( |-
                   tm-of
                     F
                     E'
                     (C[lam K (\a. rec' K[] (\z335. \y336. C[z335, y336]) a),
                        C1])),
              Dwf : ( |- kd-wf K),
              Dof3 :
                (a : con, x1044 : cn-of a (pi K[] (\l. t)), b : con,
                 z1044 : cn-of b K[] |- cn-of (C[a, b]) t),
              Dof4 : ( |- cn-of C1 K),
              Dequiv2 : ( |- kd-equiv K K1),
              Dequiv3 :
                (a : con, x989 : cn-of a (pi K[] (\l. t)), b : con,
                 z989 : cn-of b K[] |- cn-equiv (C[a, b]) (C3[a, b]) t),
              Dequiv4 : ( |- cn-equiv C1 C4 K),
              Dof5 : ( |- cn-of (rec' K (\z335. \y336. C) C1) t),
              Dof6 : ( |- cn-of (rec' K1 (\z335. \y336. C3) C4) t),
              Dwf1 : ( |- kd-wf t),
              Dwf2 : ( |- kd-wf K1),
              Dof7 :
                (a : con, z708 : cn-of a (pi K1[] (\l. t)), b : con,
                 y709 : cn-of b K1[] |- cn-of (C3[a, b]) t),
              Dof8 : ( |- cn-of C4 K1)
            | tof :
                [ |-
                   tm-of F (tm/unroll (tm/roll E' K (\y357. \x357. C) C1)) T],
              sof : [ |- store-of F ST' F],
              x :
                [ |-
                   step
                     ST'
                     (tm/unroll (tm/roll E' K (\y357. \x357. C) C1)) ST' E']
            ; by [a : con, da : cn-of a K[] |-
      cn-equiv/rec Dequiv2[]
      (\a1. \da1. \b. \db. Dequiv3[a1, da1, b, db]) (cn-equiv/refl da)]
as DequivRec1 unboxed;
              by [ |- cn-equiv/lam Dequiv2 (\a. \da. DequivRec1)]
              as DequivLam1 unboxed;
              by functionality-cn
                   [c : con, dc : cn-of c (pi K[] (\l. t)) |-
                      Dof3[c, dc, C1[], Dof4[]]]
                   [ |- DequivLam1]
              as DequivC1' unboxed;
              by [ |-
                    cn-of/subsume (cn-of/lam Dwf2
                                  (\a.
                                     \da.
                                       cn-of/rec Dwf2[]
                                       (\a1.
                                          \da1. \b. \db. Dof7[a1, da1, b, db])
                                       da))
                    (kd-sub/refl (kd-equiv/pi (kd-equiv/symm Dequiv2)
                                 (\l1. \l2. kd-equiv/refl kd-wf/t)))]
              as DofLam unboxed;
              by [b : con, db : cn-of b _ |-
                    Dof3[lam K1[] (\a. rec' K1[] (\b1. \c. C3[b1, c]) a),
                         DofLam[], b, db]]
              as DofC1'' unboxed;
              by functionality-cn [c : con, dc : cn-of c K[] |- DofC1'']
                   [ |- Dequiv4]
              as DequivC1'' unboxed;
              by [ |-
                    cn-of/subsume Dof8 (kd-sub/refl (kd-equiv/symm Dequiv2))]
              as DofC2'' unboxed;
              by [ |-
                    cn-equiv/trans (cn-equiv/trans DequivC1'
                                   (cn-equiv/trans DequivC1''
                                   (Dequiv3[_, DofLam, _, DofC2''])))
                    Dequiv]
              as Dequiv' unboxed;
              by [ |- tm-of/equiv Dof2 Dequiv'] as Dof' unboxed;
              solve [ |- preservation-tm/i F Dof' Dstof (extends/nil )]
            }
          }
        }
      }
    }
  }
  case step/unroll:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/unroll E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/unroll E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/unroll E1) ST' (tm/unroll E2)]
  ; split inversion-tm/unroll [ |- Dof] as
    case inversion-tm/unroll/i:
    { F : ( |- sttp),
      E : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E' : ( |- term),
      Dof : ( |- tm-of F (tm/unroll E) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E ST' E'),
      K : ( |- kind),
      C1 : (y675 : con, x675 : con |- con),
      C2 : ( |- con),
      Dequiv :
        ( |-
           cn-equiv
             (C1[lam K (\a. rec' K[] (\x105. \z105. C1[x105, z105]) a), C2])
             T t),
      Dof1 : ( |- tm-of F E (rec' K (\x105. \z105. C1) C2))
    | tof : [ |- tm-of F (tm/unroll E) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/unroll E) ST' (tm/unroll E')]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E' : ( |- term),
        Dof : ( |- tm-of F (tm/unroll E) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E ST' E'),
        K : ( |- kind),
        C1 : (y675 : con, x675 : con |- con),
        C2 : ( |- con),
        Dequiv :
          ( |-
             cn-equiv
               (C1[lam K (\a. rec' K[] (\x105. \z105. C1[x105, z105]) a), C2])
               T t),
        Dof' : ( |- tm-of F E (rec' K (\x105. \z105. C1) C2)),
        F2 : ( |- sttp),
        Dof1 : ( |- tm-of F2 E' (rec' K (\x105. \z105. C1) C2)),
        Dof2 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/unroll E) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/unroll E) ST' (tm/unroll E')]
      ; solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/unroll Dof1) Dequiv) Dof2 Dextends]
      }
    }
  }
  case step/roll:
  { F : ( |- sttp),
    E1 : ( |- term),
    K : ( |- kind),
    C : (a76 : con, a75 : con |- con),
    C1 : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/roll E1 K (\z126. \y127. C) C1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/roll E1 K (\z126. \y127. C) C1) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/roll E1 K (\z126. \y127. C) C1)
           ST' (tm/roll E2 K (\z126. \y127. C) C1)]
  ; split inversion-tm/roll [ |- Dof] as
    case inversion-tm/roll/i:
    { F : ( |- sttp),
      E : ( |- term),
      K : ( |- kind),
      C1 : (a76 : con, a75 : con |- con),
      C2 : ( |- con),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E' : ( |- term),
      Dof : ( |- tm-of F (tm/roll E K (\z126. \y127. C1) C2) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E ST' E'),
      Dequiv : ( |- cn-equiv (rec' K (\x105. \z105. C1) C2) T t),
      Dof1 :
        ( |-
           tm-of
             F
             E
             (C1[lam K (\a. rec' K[] (\x105. \z105. C1[x105, z105]) a), C2])),
      Dwf : ( |- kd-wf K),
      Dof2 :
        (a : con, y672 : cn-of a (pi K[] (\l. t)), b : con,
         x672 : cn-of b K[] |- cn-of (C1[a, b]) t),
      Dof3 : ( |- cn-of C2 K)
    | tof : [ |- tm-of F (tm/roll E K (\z126. \y127. C1) C2) T],
      sof : [ |- store-of F ST F],
      x :
        [ |-
           step
             ST
             (tm/roll E K (\z126. \y127. C1) C2)
             ST' (tm/roll E' K (\z126. \y127. C1) C2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E : ( |- term),
        K : ( |- kind),
        C1 : (a76 : con, a75 : con |- con),
        C2 : ( |- con),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E' : ( |- term),
        Dof : ( |- tm-of F (tm/roll E K (\z126. \y127. C1) C2) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E ST' E'),
        Dequiv : ( |- cn-equiv (rec' K (\x105. \z105. C1) C2) T t),
        Dof' :
          ( |-
             tm-of
               F
               E
               (C1[lam K (\a. rec' K[] (\x105. \z105. C1[x105, z105]) a), C2])),
        DwfK : ( |- kd-wf K),
        DofC1 :
          (a : con, y672 : cn-of a (pi K[] (\l. t)), b : con,
           x672 : cn-of b K[] |- cn-of (C1[a, b]) t),
        DofC2 : ( |- cn-of C2 K),
        F2 : ( |- sttp),
        Dof1 :
          ( |-
             tm-of
               F2
               E'
               (C1[lam K (\a. rec' K[] (\x105. \z105. C1[x105, z105]) a), C2])),
        Dof2 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/roll E K (\z126. \y127. C1) C2) T],
        sof : [ |- store-of F ST F],
        x :
          [ |-
             step
               ST
               (tm/roll E K (\z126. \y127. C1) C2)
               ST' (tm/roll E' K (\z126. \y127. C1) C2)]
      ; solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/roll Dof1
                          DwfK (\a. \da. \b. \db. DofC1) DofC2)
             Dequiv) Dof2 Dextends]
      }
    }
  }
  case step/iftag-beta2:
  { F : ( |- sttp),
    Dloc : ( |- location),
    E1 : ( |- term),
    Dloc1 : ( |- location),
    E2 : (x19 : term |- term),
    E' : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof :
      ( |-
         tm-of
           F
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc1) (\y125. E2) E') T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1),
    X : ( |- loc-neq Dloc Dloc1)
  | tof :
      [ |-
         tm-of
           F
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc1) (\y125. E2) E') T],
    sof : [ |- store-of F ST' F],
    x :
      [ |-
         step
           ST'
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc1) (\y125. E2) E') ST' E']
  ; split inversion-tm/iftag [ |- Dof] as
    case inversion-tm/iftag/i:
    { F : ( |- sttp),
      Dloc : ( |- location),
      E1 : ( |- term),
      Dloc1 : ( |- location),
      E2 : (x19 : term |- term),
      E' : ( |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof :
        ( |-
           tm-of
             F
             (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
             (tm/tagloc Dloc1) (\y125. E2) E') T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E1),
      X : ( |- loc-neq Dloc Dloc1),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F (tm/tag (tm/tagloc Dloc) E1) tagged),
      Dof2 : ( |- tm-of F (tm/tagloc Dloc1) (tag C1)),
      Dof3 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E2[x]) T[]),
      Dof4 : ( |- tm-of F E' T)
    | tof :
        [ |-
           tm-of
             F
             (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
             (tm/tagloc Dloc1) (\y125. E2) E') T],
      sof : [ |- store-of F ST' F],
      x :
        [ |-
           step
             ST'
             (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
             (tm/tagloc Dloc1) (\y125. E2) E') ST' E']
    ; solve [ |- preservation-tm/i F Dof4 Dstof (extends/nil )]
    }
  }
  case step/iftag-beta1:
  { F : ( |- sttp),
    Dloc : ( |- location),
    E1 : ( |- term),
    E2 : (x18 : term |- term),
    E3 : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof :
      ( |-
         tm-of
           F
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc) (\y125. E2) E3) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1)
  | tof :
      [ |-
         tm-of
           F
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc) (\y125. E2) E3) T],
    sof : [ |- store-of F ST' F],
    x :
      [ |-
         step
           ST'
           (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
           (tm/tagloc Dloc) (\y125. E2) E3) ST' (E2[E1])]
  ; split inversion-tm/iftag [ |- Dof] as
    case inversion-tm/iftag/i:
    { F : ( |- sttp),
      Dloc : ( |- location),
      E1 : ( |- term),
      E2 : (x18 : term |- term),
      E3 : ( |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof :
        ( |-
           tm-of
             F
             (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
             (tm/tagloc Dloc) (\y125. E2) E3) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E1),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F (tm/tag (tm/tagloc Dloc) E1) tagged),
      Dof2 : ( |- tm-of F (tm/tagloc Dloc) (tag C1)),
      Dof3 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E2[x]) T[]),
      Dof4 : ( |- tm-of F E3 T)
    | tof :
        [ |-
           tm-of
             F
             (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
             (tm/tagloc Dloc) (\x355. E2) E3) T],
      sof : [ |- store-of F ST' F],
      x :
        [ |-
           step
             ST'
             (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
             (tm/tagloc Dloc) (\x355. E2) E3) ST' (E2[E1])]
    ; split inversion-tm/tag [ |- Dof1] as
      case inversion-tm/tag/i:
      { F : ( |- sttp),
        Dloc : ( |- location),
        E1 : ( |- term),
        E2 : (x18 : term |- term),
        E3 : ( |- term),
        T : ( |- con),
        ST' : ( |- store),
        Dof :
          ( |-
             tm-of
               F
               (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
               (tm/tagloc Dloc) (\y125. E2) E3) T),
        Dstof : ( |- store-of F ST' F),
        Dvalue : ( |- value E1),
        C1 : ( |- con),
        Dof1 : ( |- tm-of F (tm/tag (tm/tagloc Dloc) E1) tagged),
        Dof2 : ( |- tm-of F (tm/tagloc Dloc) (tag C1)),
        Dof3 :
          (x : term, u : {F' : sttp}  tm-of F' x C1[] |-
             tm-of F[] (E2[x]) T[]),
        Dof4 : ( |- tm-of F E3 T),
        C3 : ( |- con),
        Dequiv : ( |- cn-equiv tagged tagged t),
        Dof5 : ( |- tm-of F (tm/tagloc Dloc) (tag C3)),
        Dof6 : ( |- tm-of F E1 C3)
      | tof :
          [ |-
             tm-of
               F
               (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
               (tm/tagloc Dloc) (\x355. E2) E3) T],
        sof : [ |- store-of F ST' F],
        x :
          [ |-
             step
               ST'
               (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
               (tm/tagloc Dloc) (\x355. E2) E3) ST' (E2[E1])]
      ; split inversion-tm/tagloc [ |- Dof2] as
        case inversion-tm/tagloc/i:
        { F : ( |- sttp),
          Dloc : ( |- location),
          E1 : ( |- term),
          E2 : (x18 : term |- term),
          E3 : ( |- term),
          T : ( |- con),
          ST' : ( |- store),
          Dof :
            ( |-
               tm-of
                 F
                 (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
                 (tm/tagloc Dloc) (\y125. E2) E3) T),
          Dstof : ( |- store-of F ST' F),
          Dvalue : ( |- value E1),
          C1 : ( |- con),
          Dof1 : ( |- tm-of F (tm/tag (tm/tagloc Dloc) E1) tagged),
          Dof2 : ( |- tm-of F (tm/tagloc Dloc) (tag C1)),
          Dof3 :
            (x : term, u : {F' : sttp}  tm-of F' x C1[] |-
               tm-of F[] (E2[x]) T[]),
          Dof4 : ( |- tm-of F E3 T),
          C3 : ( |- con),
          Dequiv : ( |- cn-equiv tagged tagged t),
          Dof5 : ( |- tm-of F (tm/tagloc Dloc) (tag C3)),
          Dof6 : ( |- tm-of F E1 C3),
          C5 : ( |- con),
          Dequiv1 : ( |- cn-equiv (tag C5) (tag C1) t),
          Dlookup : ( |- st-lookup F Dloc (et/tag C5)),
          Dof7 : ( |- cn-of C5 t)
        | tof :
            [ |-
               tm-of
                 F
                 (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
                 (tm/tagloc Dloc) (\x355. E2) E3) T],
          sof : [ |- store-of F ST' F],
          x :
            [ |-
               step
                 ST'
                 (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
                 (tm/tagloc Dloc) (\x355. E2) E3) ST' (E2[E1])]
        ; split inversion-tm/tagloc [ |- Dof5] as
          case inversion-tm/tagloc/i:
          { F : ( |- sttp),
            Dloc : ( |- location),
            E1 : ( |- term),
            E2 : (x18 : term |- term),
            E3 : ( |- term),
            T : ( |- con),
            ST' : ( |- store),
            Dof :
              ( |-
                 tm-of
                   F
                   (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
                   (tm/tagloc Dloc) (\y125. E2) E3) T),
            Dstof : ( |- store-of F ST' F),
            Dvalue : ( |- value E1),
            C1 : ( |- con),
            Dof1 : ( |- tm-of F (tm/tag (tm/tagloc Dloc) E1) tagged),
            Dof2 : ( |- tm-of F (tm/tagloc Dloc) (tag C1)),
            Dof3 :
              (x : term, u : {F' : sttp}  tm-of F' x C1[] |-
                 tm-of F[] (E2[x]) T[]),
            Dof4 : ( |- tm-of F E3 T),
            C3 : ( |- con),
            Dequiv : ( |- cn-equiv tagged tagged t),
            Dof5 : ( |- tm-of F (tm/tagloc Dloc) (tag C3)),
            Dof6 : ( |- tm-of F E1 C3),
            C5 : ( |- con),
            Dequiv1 : ( |- cn-equiv (tag C5) (tag C1) t),
            Dlookup : ( |- st-lookup F Dloc (et/tag C5)),
            Dof7 : ( |- cn-of C5 t),
            C7 : ( |- con),
            Dequiv2 : ( |- cn-equiv (tag C7) (tag C3) t),
            Dlookup1 : ( |- st-lookup F Dloc (et/tag C7)),
            Dof8 : ( |- cn-of C7 t)
          | tof :
              [ |-
                 tm-of
                   F
                   (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
                   (tm/tagloc Dloc) (\x355. E2) E3) T],
            sof : [ |- store-of F ST' F],
            x :
              [ |-
                 step
                   ST'
                   (tm/iftag (tm/tag (tm/tagloc Dloc) E1)
                   (tm/tagloc Dloc) (\x355. E2) E3) ST' (E2[E1])]
          ; by injective-tag [ |- Dequiv1] as Dequiv1' unboxed;
            by injective-tag [ |- Dequiv2] as Dequiv2' unboxed;
            by st-lookup-fun [ |- Dstof] [ |- Dlookup] [ |- Dlookup1]
            as Deq unboxed;
            by entp-eq-invert-tag [ |- Deq] as Deq' unboxed;
            by cn-equiv-resp [ |- Deq'] [ |- con-eq/i ] [ |- kind-eq/i ]
                 [ |- Dequiv1']
            as Dequiv1'' unboxed;
            by [ |-
                  tm-of/equiv Dof6
                  (cn-equiv/trans (cn-equiv/symm Dequiv2') Dequiv1'')]
            as Dof' unboxed;
            by [ |- Dof3[E1, (\f. _)]] as Dof'' unboxed;
            solve [ |- preservation-tm/i F Dof'' Dstof (extends/nil )]
          }
        }
      }
    }
  }
  case step/iftag2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    E4 : (x17 : term |- term),
    E5 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E3 : ( |- term),
    Dof : ( |- tm-of F (tm/iftag E1 E2 (\y125. E4) E5) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dstep : ( |- step ST E2 ST' E3)
  | tof : [ |- tm-of F (tm/iftag E1 E2 (\y125. E4) E5) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/iftag E1 E2 (\y125. E4) E5)
           ST' (tm/iftag E1 E3 (\y125. E4) E5)]
  ; split inversion-tm/iftag [ |- Dof] as
    case inversion-tm/iftag/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      E3 : (x17 : term |- term),
      E4 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2' : ( |- term),
      Dof : ( |- tm-of F (tm/iftag E1 E2 (\y125. E3) E4) T),
      Dstof : ( |- store-of F ST F),
      Dvalue : ( |- value E1),
      Dstep : ( |- step ST E2 ST' E2'),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F E1 tagged),
      Dof2 : ( |- tm-of F E2 (tag C1)),
      Dof3 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E3[x]) T[]),
      Dof4 : ( |- tm-of F E4 T)
    | tof : [ |- tm-of F (tm/iftag E1 E2 (\y275. E3) E4) T],
      sof : [ |- store-of F ST F],
      x :
        [ |-
           step
             ST
             (tm/iftag E1 E2 (\y275. E3) E4)
             ST' (tm/iftag E1 E2' (\y275. E3) E4)]
    ; split preservation-tm [ |- Dof2] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E2 : ( |- term),
        E3 : (x17 : term |- term),
        E4 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2' : ( |- term),
        Dof : ( |- tm-of F (tm/iftag E1 E2 (\y125. E3) E4) T),
        Dstof : ( |- store-of F ST F),
        Dvalue : ( |- value E1),
        Dstep : ( |- step ST E2 ST' E2'),
        T' : ( |- con),
        Dof1 : ( |- tm-of F E1 tagged),
        Dof2 : ( |- tm-of F E2 (tag T')),
        Dof3 :
          (x : term, u : {F' : sttp}  tm-of F' x T'[] |-
             tm-of F[] (E3[x]) T[]),
        Dof4 : ( |- tm-of F E4 T),
        F2 : ( |- sttp),
        Dof5 : ( |- tm-of F2 E2' (tag T')),
        Dof6 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/iftag E1 E2 (\y275. E3) E4) T],
        sof : [ |- store-of F ST F],
        x :
          [ |-
             step
               ST
               (tm/iftag E1 E2 (\y275. E3) E4)
               ST' (tm/iftag E1 E2' (\y275. E3) E4)]
      ; by monotonicity-tm [ |- Dof1] [ |- Dextends] as Dof1' unboxed;
        by monotonicity-tm
             [b : block (x : term, u : {F' : sttp}  tm-of F' x T'[]) |-
                Dof3[b.1, b.2]]
             [b : block (x : term, u : {F' : sttp}  tm-of F' x T'[]) |-
                Dextends[]]
        as Dof3' unboxed;
        by monotonicity-tm [ |- Dof4] [ |- Dextends] as Dof4' unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/iftag Dof1' Dof5 (\x. \u. Dof3'[<x; u>]) Dof4')
             Dof6 Dextends]
      }
    }
  }
  case step/iftag1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    E4 : (x16 : term |- term),
    E5 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/iftag E1 E3 (\y125. E4) E5) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/iftag E1 E3 (\y125. E4) E5) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/iftag E1 E3 (\y125. E4) E5)
           ST' (tm/iftag E2 E3 (\y125. E4) E5)]
  ; split inversion-tm/iftag [ |- Dof] as
    case inversion-tm/iftag/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      E3 : (x16 : term |- term),
      E4 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E1' : ( |- term),
      Dof : ( |- tm-of F (tm/iftag E1 E2 (\y125. E3) E4) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E1'),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F E1 tagged),
      Dof2 : ( |- tm-of F E2 (tag C1)),
      Dof3 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E3[x]) T[]),
      Dof4 : ( |- tm-of F E4 T)
    | tof : [ |- tm-of F (tm/iftag E1 E2 (\y275. E3) E4) T],
      sof : [ |- store-of F ST F],
      x :
        [ |-
           step
             ST
             (tm/iftag E1 E2 (\y275. E3) E4)
             ST' (tm/iftag E1' E2 (\y275. E3) E4)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E2 : ( |- term),
        E3 : (x16 : term |- term),
        E4 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E1' : ( |- term),
        Dof : ( |- tm-of F (tm/iftag E1 E2 (\y125. E3) E4) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E1'),
        T' : ( |- con),
        Dof1 : ( |- tm-of F E1 tagged),
        Dof2 : ( |- tm-of F E2 (tag T')),
        Dof3 :
          (x : term, u : {F' : sttp}  tm-of F' x T'[] |-
             tm-of F[] (E3[x]) T[]),
        Dof4 : ( |- tm-of F E4 T),
        F2 : ( |- sttp),
        Dof5 : ( |- tm-of F2 E1' tagged),
        Dof6 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/iftag E1 E2 (\y275. E3) E4) T],
        sof : [ |- store-of F ST F],
        x :
          [ |-
             step
               ST
               (tm/iftag E1 E2 (\y275. E3) E4)
               ST' (tm/iftag E1' E2 (\y275. E3) E4)]
      ; by monotonicity-tm [ |- Dof2] [ |- Dextends] as Dof2' unboxed;
        by monotonicity-tm
             [b : block (x : term, u : {F' : sttp}  tm-of F' x T'[]) |-
                Dof3[b.1, b.2]]
             [b : block (x : term, u : {F' : sttp}  tm-of F' x T'[]) |-
                Dextends[]]
        as Dof3' unboxed;
        by monotonicity-tm [ |- Dof4] [ |- Dextends] as Dof4' unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/iftag Dof5 Dof2' (\x. \u. Dof3'[<x; u>]) Dof4')
             Dof6 Dextends]
      }
    }
  }
  case step/tag2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E3 : ( |- term),
    Dof : ( |- tm-of F (tm/tag E1 E2) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dstep : ( |- step ST E2 ST' E3)
  | tof : [ |- tm-of F (tm/tag E1 E2) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/tag E1 E2) ST' (tm/tag E1 E3)]
  ; split inversion-tm/tag [ |- Dof] as
    case inversion-tm/tag/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2' : ( |- term),
      Dof : ( |- tm-of F (tm/tag E1 E2) T),
      Dstof : ( |- store-of F ST F),
      Dvalue : ( |- value E1),
      Dstep : ( |- step ST E2 ST' E2'),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv tagged T t),
      Dof1 : ( |- tm-of F E1 (tag C1)),
      Dof2 : ( |- tm-of F E2 C1)
    | tof : [ |- tm-of F (tm/tag E1 E2) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/tag E1 E2) ST' (tm/tag E1 E2')]
    ; split preservation-tm [ |- Dof2] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E2 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2' : ( |- term),
        Dof : ( |- tm-of F (tm/tag E1 E2) T),
        Dstof : ( |- store-of F ST F),
        Dvalue : ( |- value E1),
        Dstep : ( |- step ST E2 ST' E2'),
        T' : ( |- con),
        Dequiv : ( |- cn-equiv tagged T t),
        Dof1 : ( |- tm-of F E1 (tag T')),
        Dof2 : ( |- tm-of F E2 T'),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E2' T'),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/tag E1 E2) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/tag E1 E2) ST' (tm/tag E1 E2')]
      ; by monotonicity-tm [ |- Dof1] [ |- Dextends] as Dof1' unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/tag Dof1' Dof3) Dequiv) Dof4 Dextends]
      }
    }
  }
  case step/tag1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/tag E1 E3) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/tag E1 E3) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/tag E1 E3) ST' (tm/tag E2 E3)]
  ; split inversion-tm/tag [ |- Dof] as
    case inversion-tm/tag/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E1' : ( |- term),
      Dof : ( |- tm-of F (tm/tag E1 E2) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E1'),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv tagged T t),
      Dof1 : ( |- tm-of F E1 (tag C1)),
      Dof2 : ( |- tm-of F E2 C1)
    | tof : [ |- tm-of F (tm/tag E1 E2) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/tag E1 E2) ST' (tm/tag E1' E2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E2 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E1' : ( |- term),
        Dof : ( |- tm-of F (tm/tag E1 E2) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E1'),
        T' : ( |- con),
        Dequiv : ( |- cn-equiv tagged T t),
        Dof1 : ( |- tm-of F E1 (tag T')),
        Dof2 : ( |- tm-of F E2 T'),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E1' (tag T')),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/tag E1 E2) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/tag E1 E2) ST' (tm/tag E1' E2)]
      ; by monotonicity-tm [ |- Dof2] [ |- Dextends] as Dof2' unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/tag Dof3 Dof2') Dequiv) Dof4 Dextends]
      }
    }
  }
  case step/newtag-beta:
  { F : ( |- sttp),
    C : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    Dloc : ( |- location),
    Dof : ( |- tm-of F (tm/newtag C) T),
    Dstof : ( |- store-of F ST F),
    Dnextloc : ( |- nextloc ST Dloc)
  | tof : [ |- tm-of F (tm/newtag C) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/newtag C) (store/cons ST Dloc (entry/tag C)) (tm/tagloc Dloc)]
  ; by nextloc-bounds [ |- Dnextloc] as Dbound unboxed;
    by inversion-tm/newtag [ |- Dof] as Dequiv unboxed;
    split cn-equiv-reg [ |- Dequiv] as
    case cn-equiv-reg/i:
    { F : ( |- sttp),
      C : ( |- con),
      T : ( |- con),
      ST : ( |- store),
      Dloc : ( |- location),
      Dof : ( |- tm-of F (tm/newtag C) T),
      Dstof : ( |- store-of F ST F),
      Dnextloc : ( |- nextloc ST Dloc),
      Dbound : ( |- store-bounds ST Dloc),
      Dequiv : ( |- cn-equiv (tag C) T t),
      Dof1 : ( |- cn-of (tag C) t),
      Dof2 : ( |- cn-of T t),
      Dwf : ( |- kd-wf t)
    | tof : [ |- tm-of F (tm/newtag C) T],
      sof : [ |- store-of F ST F],
      x :
        [ |-
           step
             ST
             (tm/newtag C)
             (store/cons ST Dloc (entry/tag C)) (tm/tagloc Dloc)]
    ; by inversion-tag [ |- Dof1] as Dwf' unboxed;
      by monotonicity-store [ |- Dstof]
     [ |- extends/cons (extends/nil ) Dloc (et/tag C)]
as Dstof' unboxed;
      by [ |- tm-of/equiv (tm-of/tagloc (st-lookup/hit ) Dwf') Dequiv]
      as Dof' unboxed;
      by [ |- store-of/cons Dbound (entry-of/tag Dwf') Dstof']
      as Dstof'' unboxed;
      solve
        [ |-
           preservation-tm/i _ Dof' Dstof'' (extends/cons (extends/nil ) _ _)]
    }
  }
  case step/assign-beta:
  { F : ( |- sttp),
    Dloc : ( |- location),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/assign (tm/refloc Dloc) E1) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dupdate : ( |- store-update ST Dloc (entry/ref E1) ST')
  | tof : [ |- tm-of F (tm/assign (tm/refloc Dloc) E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/assign (tm/refloc Dloc) E1) ST' tm/unit]
  ; split inversion-tm/assign [ |- Dof] as
    case inversion-tm/assign/i:
    { F : ( |- sttp),
      Dloc : ( |- location),
      E1 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/assign (tm/refloc Dloc) E1) T),
      Dstof : ( |- store-of F ST F),
      Dvalue : ( |- value E1),
      Dupdate : ( |- store-update ST Dloc (entry/ref E1) ST'),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv unit T t),
      Dof1 : ( |- tm-of F (tm/refloc Dloc) (ref C1)),
      Dof2 : ( |- tm-of F E1 C1)
    | tof : [ |- tm-of F (tm/assign (tm/refloc Dloc) E1) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/assign (tm/refloc Dloc) E1) ST' tm/unit]
    ; split inversion-tm/refloc [ |- Dof1] as
      case inversion-tm/refloc/i:
      { F : ( |- sttp),
        Dloc : ( |- location),
        E1 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        Dof : ( |- tm-of F (tm/assign (tm/refloc Dloc) E1) T),
        Dstof : ( |- store-of F ST F),
        Dvalue : ( |- value E1),
        Dupdate : ( |- store-update ST Dloc (entry/ref E1) ST'),
        C1 : ( |- con),
        Dequiv : ( |- cn-equiv unit T t),
        Dof1 : ( |- tm-of F (tm/refloc Dloc) (ref C1)),
        Dof2 : ( |- tm-of F E1 C1),
        C3 : ( |- con),
        Dequiv1 : ( |- cn-equiv (ref C3) (ref C1) t),
        Dlookup : ( |- st-lookup F Dloc (et/ref C3)),
        Dof3 : ( |- cn-of C3 t)
      | tof : [ |- tm-of F (tm/assign (tm/refloc Dloc) E1) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/assign (tm/refloc Dloc) E1) ST' tm/unit]
      ; by injective-ref [ |- Dequiv1] as Dequiv' unboxed;
        by preservation-update [ |- Dstof] [ |- Dlookup] [ |- Dupdate]
             [ |-
                entry-of/ref Dvalue
                (tm-of/equiv Dof2 (cn-equiv/symm Dequiv'))]
        as Dstof' unboxed;
        solve
          [ |-
             preservation-tm/i F
             (tm-of/equiv (tm-of/unit ) Dequiv) Dstof' (extends/nil )]
      }
    }
  }
  case step/assign2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E3 : ( |- term),
    Dof : ( |- tm-of F (tm/assign E1 E2) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dstep : ( |- step ST E2 ST' E3)
  | tof : [ |- tm-of F (tm/assign E1 E2) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/assign E1 E2) ST' (tm/assign E1 E3)]
  ; split inversion-tm/assign [ |- Dof] as
    case inversion-tm/assign/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2' : ( |- term),
      Dof : ( |- tm-of F (tm/assign E1 E2) T),
      Dstof : ( |- store-of F ST F),
      Dvalue : ( |- value E1),
      Dstep : ( |- step ST E2 ST' E2'),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv unit T t),
      Dof1 : ( |- tm-of F E1 (ref C1)),
      Dof2 : ( |- tm-of F E2 C1)
    | tof : [ |- tm-of F (tm/assign E1 E2) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/assign E1 E2) ST' (tm/assign E1 E2')]
    ; split preservation-tm [ |- Dof2] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E2 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2' : ( |- term),
        Dof : ( |- tm-of F (tm/assign E1 E2) T),
        Dstof : ( |- store-of F ST F),
        Dvalue : ( |- value E1),
        Dstep : ( |- step ST E2 ST' E2'),
        T' : ( |- con),
        Dequiv : ( |- cn-equiv unit T t),
        Dof1 : ( |- tm-of F E1 (ref T')),
        Dof2 : ( |- tm-of F E2 T'),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E2' T'),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/assign E1 E2) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/assign E1 E2) ST' (tm/assign E1 E2')]
      ; by monotonicity-tm [ |- Dof1] [ |- Dextends] as Dof1' unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/assign Dof1' Dof3) Dequiv) Dof4 Dextends]
      }
    }
  }
  case step/assign1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/assign E1 E3) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/assign E1 E3) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/assign E1 E3) ST' (tm/assign E2 E3)]
  ; split inversion-tm/assign [ |- Dof] as
    case inversion-tm/assign/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E1' : ( |- term),
      Dof : ( |- tm-of F (tm/assign E1 E2) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E1'),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv unit T t),
      Dof1 : ( |- tm-of F E1 (ref C1)),
      Dof2 : ( |- tm-of F E2 C1)
    | tof : [ |- tm-of F (tm/assign E1 E2) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/assign E1 E2) ST' (tm/assign E1' E2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E2 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E1' : ( |- term),
        Dof : ( |- tm-of F (tm/assign E1 E2) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E1'),
        T' : ( |- con),
        Dequiv : ( |- cn-equiv unit T t),
        Dof1 : ( |- tm-of F E1 (ref T')),
        Dof2 : ( |- tm-of F E2 T'),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E1' (ref T')),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/assign E1 E2) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/assign E1 E2) ST' (tm/assign E1' E2)]
      ; by monotonicity-tm [ |- Dof2] [ |- Dextends] as Dof2' unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/assign Dof3 Dof2') Dequiv) Dof4 Dextends]
      }
    }
  }
  case step/deref-beta:
  { F : ( |- sttp),
    Dloc : ( |- location),
    T : ( |- con),
    ST' : ( |- store),
    E' : ( |- term),
    Dof : ( |- tm-of F (tm/deref (tm/refloc Dloc)) T),
    Dstof : ( |- store-of F ST' F),
    Dlookup : ( |- store-lookup ST' Dloc (entry/ref E'))
  | tof : [ |- tm-of F (tm/deref (tm/refloc Dloc)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/deref (tm/refloc Dloc)) ST' E']
  ; by inversion-tm/deref [ |- Dof] as Dof' unboxed;
    split inversion-tm/refloc [ |- Dof'] as
    case inversion-tm/refloc/i:
    { F : ( |- sttp),
      Dloc : ( |- location),
      T : ( |- con),
      ST' : ( |- store),
      E' : ( |- term),
      Dof : ( |- tm-of F (tm/deref (tm/refloc Dloc)) T),
      Dstof : ( |- store-of F ST' F),
      Dlookup : ( |- store-lookup ST' Dloc (entry/ref E')),
      Dof' : ( |- tm-of F (tm/refloc Dloc) (ref T)),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv (ref C1) (ref T) t),
      Dlookup1 : ( |- st-lookup F Dloc (et/ref C1)),
      Dof1 : ( |- cn-of C1 t)
    | tof : [ |- tm-of F (tm/deref (tm/refloc Dloc)) T],
      sof : [ |- store-of F ST' F],
      x : [ |- step ST' (tm/deref (tm/refloc Dloc)) ST' E']
    ; split preservation-lookup [ |- Dstof] [ |- Dlookup1] [ |- Dlookup] as
      case entry-of/ref:
      { F : ( |- sttp),
        Dloc : ( |- location),
        T : ( |- con),
        ST' : ( |- store),
        E' : ( |- term),
        Dof : ( |- tm-of F (tm/deref (tm/refloc Dloc)) T),
        Dstof : ( |- store-of F ST' F),
        Dlookup : ( |- store-lookup ST' Dloc (entry/ref E')),
        Dof' : ( |- tm-of F (tm/refloc Dloc) (ref T)),
        C1 : ( |- con),
        Dequiv : ( |- cn-equiv (ref C1) (ref T) t),
        Dlookup1 : ( |- st-lookup F Dloc (et/ref C1)),
        Dof1 : ( |- cn-of C1 t),
        Dvalue : ( |- value E'),
        Dof2 : ( |- tm-of F E' C1)
      | tof : [ |- tm-of F (tm/deref (tm/refloc Dloc)) T],
        sof : [ |- store-of F ST' F],
        x : [ |- step ST' (tm/deref (tm/refloc Dloc)) ST' E']
      ; by injective-ref [ |- Dequiv] as Dequiv' unboxed;
        solve
          [ |-
             preservation-tm/i F
             (tm-of/equiv Dof2 Dequiv') Dstof (extends/nil )]
      }
    }
  }
  case step/deref:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/deref E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/deref E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/deref E1) ST' (tm/deref E2)]
  ; by inversion-tm/deref [ |- Dof] as Dof' unboxed;
    split preservation-tm [ |- Dof'] [ |- Dstof] [ |- Dstep] as
    case preservation-tm/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/deref E1) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      Dof' : ( |- tm-of F E1 (ref T)),
      F2 : ( |- sttp),
      Dof1 : ( |- tm-of F2 E2 (ref T)),
      Dof2 : ( |- store-of F2 ST' F2),
      Dextends : ( |- extends F F2)
    | tof : [ |- tm-of F (tm/deref E1) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/deref E1) ST' (tm/deref E2)]
    ; solve [ |- preservation-tm/i F2 (tm-of/deref Dof1) Dof2 Dextends]
    }
  }
  case step/ref-beta:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    Dloc : ( |- location),
    Dof : ( |- tm-of F (tm/ref E1) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dnextloc : ( |- nextloc ST Dloc)
  | tof : [ |- tm-of F (tm/ref E1) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/ref E1) (store/cons ST Dloc (entry/ref E1)) (tm/refloc Dloc)]
  ; by nextloc-bounds [ |- Dnextloc] as Dbound unboxed;
    split inversion-tm/ref [ |- Dof] as
    case inversion-tm/ref/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      Dloc : ( |- location),
      Dof : ( |- tm-of F (tm/ref E1) T),
      Dstof : ( |- store-of F ST F),
      Dvalue : ( |- value E1),
      Dnextloc : ( |- nextloc ST Dloc),
      Dbound : ( |- store-bounds ST Dloc),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv (ref C1) T t),
      Dof1 : ( |- tm-of F E1 C1)
    | tof : [ |- tm-of F (tm/ref E1) T],
      sof : [ |- store-of F ST F],
      x :
        [ |-
           step
             ST
             (tm/ref E1) (store/cons ST Dloc (entry/ref E1)) (tm/refloc Dloc)]
    ; by tm-of-reg [ |- Dof1] as Dwf unboxed;
      by monotonicity-tm [ |- Dof1]
           [ |- extends/cons (extends/nil ) Dloc (et/ref C1)]
      as Dof'' unboxed;
      by monotonicity-store [ |- Dstof]
           [ |- extends/cons (extends/nil ) Dloc (et/ref C1)]
      as Dstof' unboxed;
      by [ |- tm-of/equiv (tm-of/refloc (st-lookup/hit ) Dwf) Dequiv]
      as Dof''' unboxed;
      by [ |- store-of/cons Dbound (entry-of/ref Dvalue Dof'') Dstof']
      as Dstof'' unboxed;
      solve
        [ |-
           preservation-tm/i _
           Dof''' Dstof'' (extends/cons (extends/nil ) _ _)]
    }
  }
  case step/ref:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/ref E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/ref E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/ref E1) ST' (tm/ref E2)]
  ; split inversion-tm/ref [ |- Dof] as
    case inversion-tm/ref/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/ref E1) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C1 : ( |- con),
      Dequiv : ( |- cn-equiv (ref C1) T t),
      Dof1 : ( |- tm-of F E1 C1)
    | tof : [ |- tm-of F (tm/ref E1) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/ref E1) ST' (tm/ref E2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/ref E1) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C1 : ( |- con),
        Dequiv : ( |- cn-equiv (ref C1) T t),
        Dof1 : ( |- tm-of F E1 C1),
        F2 : ( |- sttp),
        Dof2 : ( |- tm-of F2 E2 C1),
        Dof3 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/ref E1) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/ref E1) ST' (tm/ref E2)]
      ; solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/ref Dof2) Dequiv) Dof3 Dextends]
      }
    }
  }
  case step/case-beta2:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    E2 : (x14 : term |- term),
    E3 : (x15 : term |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/case (tm/in2 E1 C) (\x120. E2) (\y120. E3)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1)
  | tof : [ |- tm-of F (tm/case (tm/in2 E1 C) (\x120. E2) (\y120. E3)) T],
    sof : [ |- store-of F ST' F],
    x :
      [ |-
         step
           ST' (tm/case (tm/in2 E1 C) (\x120. E2) (\y120. E3)) ST' (E3[E1])]
  ; split inversion-tm/case [ |- Dof] as
    case inversion-tm/case/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      E2 : (x14 : term |- term),
      E3 : (x15 : term |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/case (tm/in2 E1 C) (\x120. E2) (\y120. E3)) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E1),
      C2 : ( |- con),
      C3 : ( |- con),
      Dof1 : ( |- tm-of F (tm/in2 E1 C) (plus C2 C3)),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x C2[] |- tm-of F[] (E2[x]) T[]),
      Dof3 :
        (x : term, u : {F' : sttp}  tm-of F' x C3[] |- tm-of F[] (E3[x]) T[])
    | tof : [ |- tm-of F (tm/case (tm/in2 E1 C) (\z350. E2) (\x350. E3)) T],
      sof : [ |- store-of F ST' F],
      x :
        [ |-
           step
             ST' (tm/case (tm/in2 E1 C) (\z350. E2) (\x350. E3)) ST' (E3[E1])]
    ; split inversion-tm/in2 [ |- Dof1] as
      case inversion-tm/in2/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        C : ( |- con),
        E2 : (x14 : term |- term),
        E3 : (x15 : term |- term),
        T : ( |- con),
        ST' : ( |- store),
        Dof : ( |- tm-of F (tm/case (tm/in2 E1 C) (\x120. E2) (\y120. E3)) T),
        Dstof : ( |- store-of F ST' F),
        Dvalue : ( |- value E1),
        C2 : ( |- con),
        C3 : ( |- con),
        Dof1 : ( |- tm-of F (tm/in2 E1 C) (plus C2 C3)),
        Dof2 :
          (x : term, u : {F' : sttp}  tm-of F' x C2[] |-
             tm-of F[] (E2[x]) T[]),
        Dof3 :
          (x : term, u : {F' : sttp}  tm-of F' x C3[] |-
             tm-of F[] (E3[x]) T[]),
        C6 : ( |- con),
        Dequiv : ( |- cn-equiv (plus C C6) (plus C2 C3) t),
        Dof4 : ( |- tm-of F E1 C6),
        Dof5 : ( |- cn-of C t)
      | tof : [ |- tm-of F (tm/case (tm/in2 E1 C) (\z350. E2) (\x350. E3)) T],
        sof : [ |- store-of F ST' F],
        x :
          [ |-
             step
               ST'
               (tm/case (tm/in2 E1 C) (\z350. E2) (\x350. E3)) ST' (E3[E1])]
      ; split injective-plus [ |- Dequiv] as
        case injective-plus/i:
        { F : ( |- sttp),
          E1 : ( |- term),
          C : ( |- con),
          E2 : (x14 : term |- term),
          E3 : (x15 : term |- term),
          T : ( |- con),
          ST' : ( |- store),
          Dof :
            ( |- tm-of F (tm/case (tm/in2 E1 C) (\x120. E2) (\y120. E3)) T),
          Dstof : ( |- store-of F ST' F),
          Dvalue : ( |- value E1),
          C2 : ( |- con),
          C3 : ( |- con),
          Dof1 : ( |- tm-of F (tm/in2 E1 C) (plus C2 C3)),
          Dof2 :
            (x : term, u : {F' : sttp}  tm-of F' x C2[] |-
               tm-of F[] (E2[x]) T[]),
          Dof3 :
            (x : term, u : {F' : sttp}  tm-of F' x C3[] |-
               tm-of F[] (E3[x]) T[]),
          C6 : ( |- con),
          Dequiv : ( |- cn-equiv (plus C C6) (plus C2 C3) t),
          Dof4 : ( |- tm-of F E1 C6),
          Dof5 : ( |- cn-of C t),
          Dequiv1 : ( |- cn-equiv C C2 t),
          Dequiv2 : ( |- cn-equiv C6 C3 t)
        | tof :
            [ |- tm-of F (tm/case (tm/in2 E1 C) (\z350. E2) (\x350. E3)) T],
          sof : [ |- store-of F ST' F],
          x :
            [ |-
               step
                 ST'
                 (tm/case (tm/in2 E1 C) (\z350. E2) (\x350. E3)) ST' (E3[E1])]
        ; by [ |- tm-of/equiv Dof4 Dequiv2] as Dof' unboxed;
          by [ |- Dof3[E1, (\f. _)]] as Dof'' unboxed;
          solve [ |- preservation-tm/i F Dof'' Dstof (extends/nil )]
        }
      }
    }
  }
  case step/case-beta1:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    E2 : (x12 : term |- term),
    E3 : (x13 : term |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/case (tm/in1 E1 C) (\x120. E2) (\y120. E3)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1)
  | tof : [ |- tm-of F (tm/case (tm/in1 E1 C) (\x120. E2) (\y120. E3)) T],
    sof : [ |- store-of F ST' F],
    x :
      [ |-
         step
           ST' (tm/case (tm/in1 E1 C) (\x120. E2) (\y120. E3)) ST' (E2[E1])]
  ; split inversion-tm/case [ |- Dof] as
    case inversion-tm/case/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      E2 : (x12 : term |- term),
      E3 : (x13 : term |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/case (tm/in1 E1 C) (\x120. E2) (\y120. E3)) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E1),
      C2 : ( |- con),
      C3 : ( |- con),
      Dof1 : ( |- tm-of F (tm/in1 E1 C) (plus C2 C3)),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x C2[] |- tm-of F[] (E2[x]) T[]),
      Dof3 :
        (x : term, u : {F' : sttp}  tm-of F' x C3[] |- tm-of F[] (E3[x]) T[])
    | tof : [ |- tm-of F (tm/case (tm/in1 E1 C) (\z350. E2) (\x350. E3)) T],
      sof : [ |- store-of F ST' F],
      x :
        [ |-
           step
             ST' (tm/case (tm/in1 E1 C) (\z350. E2) (\x350. E3)) ST' (E2[E1])]
    ; split inversion-tm/in1 [ |- Dof1] as
      case inversion-tm/in1/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        C : ( |- con),
        E2 : (x12 : term |- term),
        E3 : (x13 : term |- term),
        T : ( |- con),
        ST' : ( |- store),
        Dof : ( |- tm-of F (tm/case (tm/in1 E1 C) (\x120. E2) (\y120. E3)) T),
        Dstof : ( |- store-of F ST' F),
        Dvalue : ( |- value E1),
        C2 : ( |- con),
        C3 : ( |- con),
        Dof1 : ( |- tm-of F (tm/in1 E1 C) (plus C2 C3)),
        Dof2 :
          (x : term, u : {F' : sttp}  tm-of F' x C2[] |-
             tm-of F[] (E2[x]) T[]),
        Dof3 :
          (x : term, u : {F' : sttp}  tm-of F' x C3[] |-
             tm-of F[] (E3[x]) T[]),
        C6 : ( |- con),
        Dequiv : ( |- cn-equiv (plus C6 C) (plus C2 C3) t),
        Dof4 : ( |- tm-of F E1 C6),
        Dof5 : ( |- cn-of C t)
      | tof : [ |- tm-of F (tm/case (tm/in1 E1 C) (\z350. E2) (\x350. E3)) T],
        sof : [ |- store-of F ST' F],
        x :
          [ |-
             step
               ST'
               (tm/case (tm/in1 E1 C) (\z350. E2) (\x350. E3)) ST' (E2[E1])]
      ; split injective-plus [ |- Dequiv] as
        case injective-plus/i:
        { F : ( |- sttp),
          E1 : ( |- term),
          C : ( |- con),
          E2 : (x12 : term |- term),
          E3 : (x13 : term |- term),
          T : ( |- con),
          ST' : ( |- store),
          Dof :
            ( |- tm-of F (tm/case (tm/in1 E1 C) (\x120. E2) (\y120. E3)) T),
          Dstof : ( |- store-of F ST' F),
          Dvalue : ( |- value E1),
          C2 : ( |- con),
          C3 : ( |- con),
          Dof1 : ( |- tm-of F (tm/in1 E1 C) (plus C2 C3)),
          Dof2 :
            (x : term, u : {F' : sttp}  tm-of F' x C2[] |-
               tm-of F[] (E2[x]) T[]),
          Dof3 :
            (x : term, u : {F' : sttp}  tm-of F' x C3[] |-
               tm-of F[] (E3[x]) T[]),
          C6 : ( |- con),
          Dequiv : ( |- cn-equiv (plus C6 C) (plus C2 C3) t),
          Dof4 : ( |- tm-of F E1 C6),
          Dof5 : ( |- cn-of C t),
          Dequiv1 : ( |- cn-equiv C6 C2 t),
          Dequiv2 : ( |- cn-equiv C C3 t)
        | tof :
            [ |- tm-of F (tm/case (tm/in1 E1 C) (\z350. E2) (\x350. E3)) T],
          sof : [ |- store-of F ST' F],
          x :
            [ |-
               step
                 ST'
                 (tm/case (tm/in1 E1 C) (\z350. E2) (\x350. E3)) ST' (E2[E1])]
        ; by [ |- tm-of/equiv Dof4 Dequiv1] as Dof' unboxed;
          by [ |- Dof2[E1, (\f. _)]] as Dof'' unboxed;
          solve [ |- preservation-tm/i F Dof'' Dstof (extends/nil )]
        }
      }
    }
  }
  case step/case:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : (x10 : term |- term),
    E4 : (x11 : term |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/case E1 (\x120. E3) (\y120. E4)) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/case E1 (\x120. E3) (\y120. E4)) T],
    sof : [ |- store-of F ST F],
    x :
      [ |-
         step
           ST
           (tm/case E1 (\x120. E3) (\y120. E4))
           ST' (tm/case E2 (\x120. E3) (\y120. E4))]
  ; split inversion-tm/case [ |- Dof] as
    case inversion-tm/case/i:
    { F : ( |- sttp),
      E : ( |- term),
      E1 : (x10 : term |- term),
      E2 : (x11 : term |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E' : ( |- term),
      Dof : ( |- tm-of F (tm/case E (\x120. E1) (\y120. E2)) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E ST' E'),
      C1 : ( |- con),
      C2 : ( |- con),
      Dof1 : ( |- tm-of F E (plus C1 C2)),
      Dof2 :
        (x : term, u : {F' : sttp}  tm-of F' x C1[] |- tm-of F[] (E1[x]) T[]),
      Dof3 :
        (x : term, u : {F' : sttp}  tm-of F' x C2[] |- tm-of F[] (E2[x]) T[])
    | tof : [ |- tm-of F (tm/case E (\x270. E1) (\y270. E2)) T],
      sof : [ |- store-of F ST F],
      x :
        [ |-
           step
             ST
             (tm/case E (\x270. E1) (\y270. E2))
             ST' (tm/case E' (\x270. E1) (\y270. E2))]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E : ( |- term),
        E1 : (x10 : term |- term),
        E2 : (x11 : term |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E' : ( |- term),
        Dof : ( |- tm-of F (tm/case E (\x120. E1) (\y120. E2)) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E ST' E'),
        C1 : ( |- con),
        C2 : ( |- con),
        Dof' : ( |- tm-of F E (plus C1 C2)),
        Dof1 :
          (x : term, u : {F' : sttp}  tm-of F' x C1[] |-
             tm-of F[] (E1[x]) T[]),
        Dof2 :
          (x : term, u : {F' : sttp}  tm-of F' x C2[] |-
             tm-of F[] (E2[x]) T[]),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E' (plus C1 C2)),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/case E (\x270. E1) (\y270. E2)) T],
        sof : [ |- store-of F ST F],
        x :
          [ |-
             step
               ST
               (tm/case E (\x270. E1) (\y270. E2))
               ST' (tm/case E' (\x270. E1) (\y270. E2))]
      ; by monotonicity-tm
             [b : block (x : term, u : {F' : sttp}  tm-of F' x C1[]) |-
                Dof1[b.1, b.2]]
             [b : block (x : term, u : {F' : sttp}  tm-of F' x C1[]) |-
                Dextends[]]
        as Dof1' unboxed;
        by monotonicity-tm
             [b : block (x : term, u : {F' : sttp}  tm-of F' x C2[]) |-
                Dof2[b.1, b.2]]
             [b : block (x : term, u : {F' : sttp}  tm-of F' x C2[]) |-
                Dextends[]]
        as Dof2' unboxed;
        solve
  [ |-
     preservation-tm/i F2
     (tm-of/case Dof3 (\x. \u. Dof1'[<x; u>]) (\x. \u. Dof2'[<x; u>]))
     Dof4 Dextends]
      }
    }
  }
  case step/in2:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/in2 E1 C) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/in2 E1 C) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/in2 E1 C) ST' (tm/in2 E2 C)]
  ; split inversion-tm/in2 [ |- Dof] as
    case inversion-tm/in2/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/in2 E1 C) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C3 : ( |- con),
      Dequiv : ( |- cn-equiv (plus C C3) T t),
      Dof1 : ( |- tm-of F E1 C3),
      Dof2 : ( |- cn-of C t)
    | tof : [ |- tm-of F (tm/in2 E1 C) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/in2 E1 C) ST' (tm/in2 E2 C)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        C : ( |- con),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/in2 E1 C) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C3 : ( |- con),
        Dequiv : ( |- cn-equiv (plus C C3) T t),
        Dof1 : ( |- tm-of F E1 C3),
        Dof2 : ( |- cn-of C t),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E2 C3),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/in2 E1 C) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/in2 E1 C) ST' (tm/in2 E2 C)]
      ; solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/in2 Dof3 Dof2) Dequiv) Dof4 Dextends]
      }
    }
  }
  case step/in1:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/in1 E1 C) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/in1 E1 C) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/in1 E1 C) ST' (tm/in1 E2 C)]
  ; split inversion-tm/in1 [ |- Dof] as
    case inversion-tm/in1/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/in1 E1 C) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C3 : ( |- con),
      Dequiv : ( |- cn-equiv (plus C3 C) T t),
      Dof1 : ( |- tm-of F E1 C3),
      Dof2 : ( |- cn-of C t)
    | tof : [ |- tm-of F (tm/in1 E1 C) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/in1 E1 C) ST' (tm/in1 E2 C)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        C : ( |- con),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/in1 E1 C) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C3 : ( |- con),
        Dequiv : ( |- cn-equiv (plus C3 C) T t),
        Dof1 : ( |- tm-of F E1 C3),
        Dof2 : ( |- cn-of C t),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E2 C3),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/in1 E1 C) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/in1 E1 C) ST' (tm/in1 E2 C)]
      ; solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/in1 Dof3 Dof2) Dequiv) Dof4 Dextends]
      }
    }
  }
  case step/app-beta:
  { F : ( |- sttp),
    C : ( |- con),
    E2 : (x9 : term |- term),
    E1 : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/app (tm/lam C (\x. E2)) E1) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1)
  | tof : [ |- tm-of F (tm/app (tm/lam C (\x. E2)) E1) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/app (tm/lam C (\x. E2)) E1) ST' (E2[E1])]
  ; split inversion-tm/app [ |- Dof] as
    case inversion-tm/app/i:
    { F : ( |- sttp),
      C : ( |- con),
      E2 : (x9 : term |- term),
      E1 : ( |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/app (tm/lam C (\x. E2)) E1) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E1),
      C2 : ( |- con),
      Dof1 : ( |- tm-of F (tm/lam C (\x. E2)) (arrow C2 T)),
      Dof2 : ( |- tm-of F E1 C2)
    | tof : [ |- tm-of F (tm/app (tm/lam C (\x. E2)) E1) T],
      sof : [ |- store-of F ST' F],
      x : [ |- step ST' (tm/app (tm/lam C (\x. E2)) E1) ST' (E2[E1])]
    ; split inversion-tm/lam [ |- Dof1] as
      case inversion-tm/lam/i:
      { F : ( |- sttp),
        C : ( |- con),
        E2 : (x9 : term |- term),
        E1 : ( |- term),
        T : ( |- con),
        ST' : ( |- store),
        Dof : ( |- tm-of F (tm/app (tm/lam C (\x. E2)) E1) T),
        Dstof : ( |- store-of F ST' F),
        Dvalue : ( |- value E1),
        C2 : ( |- con),
        Dof1 : ( |- tm-of F (tm/lam C (\x. E2)) (arrow C2 T)),
        Dof2 : ( |- tm-of F E1 C2),
        C5 : ( |- con),
        Dequiv : ( |- cn-equiv (arrow C C5) (arrow C2 T) t),
        Dof3 :
          (x : term, u : {F' : sttp}  tm-of F' x C[] |-
             tm-of F[] (E2[x]) C5[])
      | tof : [ |- tm-of F (tm/app (tm/lam C (\x. E2)) E1) T],
        sof : [ |- store-of F ST' F],
        x : [ |- step ST' (tm/app (tm/lam C (\x. E2)) E1) ST' (E2[E1])]
      ; split injective-arrow [ |- Dequiv] as
        case injective-arrow/i:
        { F : ( |- sttp),
          C : ( |- con),
          E2 : (x9 : term |- term),
          E1 : ( |- term),
          T : ( |- con),
          ST' : ( |- store),
          Dof : ( |- tm-of F (tm/app (tm/lam C (\x. E2)) E1) T),
          Dstof : ( |- store-of F ST' F),
          Dvalue : ( |- value E1),
          C2 : ( |- con),
          Dof1 : ( |- tm-of F (tm/lam C (\x. E2)) (arrow C2 T)),
          Dof2 : ( |- tm-of F E1 C2),
          C5 : ( |- con),
          Dequiv : ( |- cn-equiv (arrow C C5) (arrow C2 T) t),
          Dof3 :
            (x : term, u : {F' : sttp}  tm-of F' x C[] |-
               tm-of F[] (E2[x]) C5[]),
          Dequiv1 : ( |- cn-equiv C C2 t),
          Dequiv2 : ( |- cn-equiv C5 T t)
        | tof : [ |- tm-of F (tm/app (tm/lam C (\x. E2)) E1) T],
          sof : [ |- store-of F ST' F],
          x : [ |- step ST' (tm/app (tm/lam C (\x. E2)) E1) ST' (E2[E1])]
        ; by [ |- Dof3[E1, (\f. _)]] as Dof' unboxed;
          by [ |- tm-of/equiv Dof' Dequiv2] as Dof'' unboxed;
          solve [ |- preservation-tm/i F Dof'' Dstof (extends/nil )]
        }
      }
    }
  }
  case step/app2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E3 : ( |- term),
    Dof : ( |- tm-of F (tm/app E1 E2) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dstep : ( |- step ST E2 ST' E3)
  | tof : [ |- tm-of F (tm/app E1 E2) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/app E1 E2) ST' (tm/app E1 E3)]
  ; split inversion-tm/app [ |- Dof] as
    case inversion-tm/app/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2' : ( |- term),
      Dof : ( |- tm-of F (tm/app E1 E2) T),
      Dstof : ( |- store-of F ST F),
      Dvalue : ( |- value E1),
      Dstep : ( |- step ST E2 ST' E2'),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F E1 (arrow C1 T)),
      Dof2 : ( |- tm-of F E2 C1)
    | tof : [ |- tm-of F (tm/app E1 E2) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/app E1 E2) ST' (tm/app E1 E2')]
    ; split preservation-tm [ |- Dof2] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E2 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2' : ( |- term),
        Dof : ( |- tm-of F (tm/app E1 E2) T),
        Dstof : ( |- store-of F ST F),
        Dvalue : ( |- value E1),
        Dstep : ( |- step ST E2 ST' E2'),
        T' : ( |- con),
        Dof1 : ( |- tm-of F E1 (arrow T' T)),
        Dof2 : ( |- tm-of F E2 T'),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E2' T'),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/app E1 E2) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/app E1 E2) ST' (tm/app E1 E2')]
      ; by monotonicity-tm [ |- Dof1] [ |- Dextends] as Dof1' unboxed;
        solve [ |- preservation-tm/i F2 (tm-of/app Dof1' Dof3) Dof4 Dextends]
      }
    }
  }
  case step/app1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/app E1 E3) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/app E1 E3) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/app E1 E3) ST' (tm/app E2 E3)]
  ; split inversion-tm/app [ |- Dof] as
    case inversion-tm/app/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E1' : ( |- term),
      Dof : ( |- tm-of F (tm/app E1 E2) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E1'),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F E1 (arrow C1 T)),
      Dof2 : ( |- tm-of F E2 C1)
    | tof : [ |- tm-of F (tm/app E1 E2) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/app E1 E2) ST' (tm/app E1' E2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E2 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E1' : ( |- term),
        Dof : ( |- tm-of F (tm/app E1 E2) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E1'),
        T' : ( |- con),
        Dof1 : ( |- tm-of F E1 (arrow T' T)),
        Dof2 : ( |- tm-of F E2 T'),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E1' (arrow T' T)),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/app E1 E2) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/app E1 E2) ST' (tm/app E1' E2)]
      ; by monotonicity-tm [ |- Dof2] [ |- Dextends] as Dof2' unboxed;
        solve [ |- preservation-tm/i F2 (tm-of/app Dof3 Dof2') Dof4 Dextends]
      }
    }
  }
  case step/pi2-beta:
  { F : ( |- sttp),
    E1 : ( |- term),
    E' : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/pi2 (tm/pair E1 E')) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E1),
    Dvalue1 : ( |- value E')
  | tof : [ |- tm-of F (tm/pi2 (tm/pair E1 E')) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/pi2 (tm/pair E1 E')) ST' E']
  ; split inversion-tm/pi2 [ |- Dof] as
    case inversion-tm/pi2/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E' : ( |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/pi2 (tm/pair E1 E')) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E1),
      Dvalue1 : ( |- value E'),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F (tm/pair E1 E') (prod C1 T))
    | tof : [ |- tm-of F (tm/pi2 (tm/pair E1 E')) T],
      sof : [ |- store-of F ST' F],
      x : [ |- step ST' (tm/pi2 (tm/pair E1 E')) ST' E']
    ; split inversion-tm/pair [ |- Dof1] as
      case inversion-tm/pair/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E' : ( |- term),
        T : ( |- con),
        ST' : ( |- store),
        Dof : ( |- tm-of F (tm/pi2 (tm/pair E1 E')) T),
        Dstof : ( |- store-of F ST' F),
        Dvalue : ( |- value E1),
        Dvalue1 : ( |- value E'),
        C1 : ( |- con),
        Dof1 : ( |- tm-of F (tm/pair E1 E') (prod C1 T)),
        C3 : ( |- con),
        C4 : ( |- con),
        Dequiv : ( |- cn-equiv (prod C3 C4) (prod C1 T) t),
        Dof2 : ( |- tm-of F E1 C3),
        Dof3 : ( |- tm-of F E' C4)
      | tof : [ |- tm-of F (tm/pi2 (tm/pair E1 E')) T],
        sof : [ |- store-of F ST' F],
        x : [ |- step ST' (tm/pi2 (tm/pair E1 E')) ST' E']
      ; split injective-prod [ |- Dequiv] as
        case injective-prod/i:
        { F : ( |- sttp),
          E1 : ( |- term),
          E' : ( |- term),
          T : ( |- con),
          ST' : ( |- store),
          Dof : ( |- tm-of F (tm/pi2 (tm/pair E1 E')) T),
          Dstof : ( |- store-of F ST' F),
          Dvalue : ( |- value E1),
          Dvalue1 : ( |- value E'),
          C1 : ( |- con),
          Dof1 : ( |- tm-of F (tm/pair E1 E') (prod C1 T)),
          C3 : ( |- con),
          C4 : ( |- con),
          Dequiv : ( |- cn-equiv (prod C3 C4) (prod C1 T) t),
          Dof2 : ( |- tm-of F E1 C3),
          Dof3 : ( |- tm-of F E' C4),
          Dequiv1 : ( |- cn-equiv C3 C1 t),
          Dequiv2 : ( |- cn-equiv C4 T t)
        | tof : [ |- tm-of F (tm/pi2 (tm/pair E1 E')) T],
          sof : [ |- store-of F ST' F],
          x : [ |- step ST' (tm/pi2 (tm/pair E1 E')) ST' E']
        ; solve
            [ |-
               preservation-tm/i F
               (tm-of/equiv Dof3 Dequiv2) Dstof (extends/nil )]
        }
      }
    }
  }
  case step/pi2:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/pi2 E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/pi2 E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/pi2 E1) ST' (tm/pi2 E2)]
  ; split inversion-tm/pi2 [ |- Dof] as
    case inversion-tm/pi2/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/pi2 E1) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F E1 (prod C1 T))
    | tof : [ |- tm-of F (tm/pi2 E1) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/pi2 E1) ST' (tm/pi2 E2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/pi2 E1) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C1 : ( |- con),
        Dof1 : ( |- tm-of F E1 (prod C1 T)),
        F2 : ( |- sttp),
        Dof2 : ( |- tm-of F2 E2 (prod C1 T)),
        Dof3 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/pi2 E1) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/pi2 E1) ST' (tm/pi2 E2)]
      ; solve [ |- preservation-tm/i F2 (tm-of/pi2 Dof2) Dof3 Dextends]
      }
    }
  }
  case step/pi1-beta:
  { F : ( |- sttp),
    E' : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    ST' : ( |- store),
    Dof : ( |- tm-of F (tm/pi1 (tm/pair E' E2)) T),
    Dstof : ( |- store-of F ST' F),
    Dvalue : ( |- value E'),
    Dvalue1 : ( |- value E2)
  | tof : [ |- tm-of F (tm/pi1 (tm/pair E' E2)) T],
    sof : [ |- store-of F ST' F],
    x : [ |- step ST' (tm/pi1 (tm/pair E' E2)) ST' E']
  ; split inversion-tm/pi1 [ |- Dof] as
    case inversion-tm/pi1/i:
    { F : ( |- sttp),
      E' : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      ST' : ( |- store),
      Dof : ( |- tm-of F (tm/pi1 (tm/pair E' E2)) T),
      Dstof : ( |- store-of F ST' F),
      Dvalue : ( |- value E'),
      Dvalue1 : ( |- value E2),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F (tm/pair E' E2) (prod T C1))
    | tof : [ |- tm-of F (tm/pi1 (tm/pair E' E2)) T],
      sof : [ |- store-of F ST' F],
      x : [ |- step ST' (tm/pi1 (tm/pair E' E2)) ST' E']
    ; split inversion-tm/pair [ |- Dof1] as
      case inversion-tm/pair/i:
      { F : ( |- sttp),
        E' : ( |- term),
        E2 : ( |- term),
        T : ( |- con),
        ST' : ( |- store),
        Dof : ( |- tm-of F (tm/pi1 (tm/pair E' E2)) T),
        Dstof : ( |- store-of F ST' F),
        Dvalue : ( |- value E'),
        Dvalue1 : ( |- value E2),
        C1 : ( |- con),
        Dof1 : ( |- tm-of F (tm/pair E' E2) (prod T C1)),
        C3 : ( |- con),
        C4 : ( |- con),
        Dequiv : ( |- cn-equiv (prod C3 C4) (prod T C1) t),
        Dof2 : ( |- tm-of F E' C3),
        Dof3 : ( |- tm-of F E2 C4)
      | tof : [ |- tm-of F (tm/pi1 (tm/pair E' E2)) T],
        sof : [ |- store-of F ST' F],
        x : [ |- step ST' (tm/pi1 (tm/pair E' E2)) ST' E']
      ; split injective-prod [ |- Dequiv] as
        case injective-prod/i:
        { F : ( |- sttp),
          E' : ( |- term),
          E2 : ( |- term),
          T : ( |- con),
          ST' : ( |- store),
          Dof : ( |- tm-of F (tm/pi1 (tm/pair E' E2)) T),
          Dstof : ( |- store-of F ST' F),
          Dvalue : ( |- value E'),
          Dvalue1 : ( |- value E2),
          C1 : ( |- con),
          Dof1 : ( |- tm-of F (tm/pair E' E2) (prod T C1)),
          C3 : ( |- con),
          C4 : ( |- con),
          Dequiv : ( |- cn-equiv (prod C3 C4) (prod T C1) t),
          Dof2 : ( |- tm-of F E' C3),
          Dof3 : ( |- tm-of F E2 C4),
          Dequiv1 : ( |- cn-equiv C3 T t),
          Dequiv2 : ( |- cn-equiv C4 C1 t)
        | tof : [ |- tm-of F (tm/pi1 (tm/pair E' E2)) T],
          sof : [ |- store-of F ST' F],
          x : [ |- step ST' (tm/pi1 (tm/pair E' E2)) ST' E']
        ; solve
            [ |-
               preservation-tm/i F
               (tm-of/equiv Dof2 Dequiv1) Dstof (extends/nil )]
        }
      }
    }
  }
  case step/pi1:
  { F : ( |- sttp),
    E1 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/pi1 E1) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/pi1 E1) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/pi1 E1) ST' (tm/pi1 E2)]
  ; split inversion-tm/pi1 [ |- Dof] as
    case inversion-tm/pi1/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/pi1 E1) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      C1 : ( |- con),
      Dof1 : ( |- tm-of F E1 (prod T C1))
    | tof : [ |- tm-of F (tm/pi1 E1) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/pi1 E1) ST' (tm/pi1 E2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/pi1 E1) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        C1 : ( |- con),
        Dof1 : ( |- tm-of F E1 (prod T C1)),
        F2 : ( |- sttp),
        Dof2 : ( |- tm-of F2 E2 (prod T C1)),
        Dof3 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/pi1 E1) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/pi1 E1) ST' (tm/pi1 E2)]
      ; solve [ |- preservation-tm/i F2 (tm-of/pi1 Dof2) Dof3 Dextends]
      }
    }
  }
  case step/pair2:
  { F : ( |- sttp),
    E1 : ( |- term),
    E2 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E3 : ( |- term),
    Dof : ( |- tm-of F (tm/pair E1 E2) T),
    Dstof : ( |- store-of F ST F),
    Dvalue : ( |- value E1),
    Dstep : ( |- step ST E2 ST' E3)
  | tof : [ |- tm-of F (tm/pair E1 E2) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/pair E1 E2) ST' (tm/pair E1 E3)]
  ; split inversion-tm/pair [ |- Dof] as
    case inversion-tm/pair/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2' : ( |- term),
      Dof : ( |- tm-of F (tm/pair E1 E2) T),
      Dstof : ( |- store-of F ST F),
      Dvalue : ( |- value E1),
      Dstep : ( |- step ST E2 ST' E2'),
      C1 : ( |- con),
      C2 : ( |- con),
      Dequiv : ( |- cn-equiv (prod C1 C2) T t),
      Dof1 : ( |- tm-of F E1 C1),
      Dof2 : ( |- tm-of F E2 C2)
    | tof : [ |- tm-of F (tm/pair E1 E2) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/pair E1 E2) ST' (tm/pair E1 E2')]
    ; split preservation-tm [ |- Dof2] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E2 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2' : ( |- term),
        Dof : ( |- tm-of F (tm/pair E1 E2) T),
        Dstof : ( |- store-of F ST F),
        Dvalue : ( |- value E1),
        Dstep : ( |- step ST E2 ST' E2'),
        C1 : ( |- con),
        C2 : ( |- con),
        Dequiv : ( |- cn-equiv (prod C1 C2) T t),
        Dof1 : ( |- tm-of F E1 C1),
        Dof2 : ( |- tm-of F E2 C2),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E2' C2),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/pair E1 E2) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/pair E1 E2) ST' (tm/pair E1 E2')]
      ; by monotonicity-tm [ |- Dof1] [ |- Dextends] as Dof1' unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/pair Dof1' Dof3) Dequiv) Dof4 Dextends]
      }
    }
  }
  case step/pair1:
  { F : ( |- sttp),
    E1 : ( |- term),
    E3 : ( |- term),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/pair E1 E3) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/pair E1 E3) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/pair E1 E3) ST' (tm/pair E2 E3)]
  ; split inversion-tm/pair [ |- Dof] as
    case inversion-tm/pair/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      E2 : ( |- term),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E1' : ( |- term),
      Dof : ( |- tm-of F (tm/pair E1 E2) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E1'),
      C1 : ( |- con),
      C2 : ( |- con),
      Dequiv : ( |- cn-equiv (prod C1 C2) T t),
      Dof1 : ( |- tm-of F E1 C1),
      Dof2 : ( |- tm-of F E2 C2)
    | tof : [ |- tm-of F (tm/pair E1 E2) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/pair E1 E2) ST' (tm/pair E1' E2)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        E2 : ( |- term),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E1' : ( |- term),
        Dof : ( |- tm-of F (tm/pair E1 E2) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E1'),
        T1 : ( |- con),
        T2 : ( |- con),
        Dequiv : ( |- cn-equiv (prod T1 T2) T t),
        Dof1 : ( |- tm-of F E1 T1),
        Dof2 : ( |- tm-of F E2 T2),
        F2 : ( |- sttp),
        Dof3 : ( |- tm-of F2 E1' T1),
        Dof4 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/pair E1 E2) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/pair E1 E2) ST' (tm/pair E1' E2)]
      ; by monotonicity-tm [ |- Dof2] [ |- Dextends] as Dof2' unboxed;
        solve
          [ |-
             preservation-tm/i F2
             (tm-of/equiv (tm-of/pair Dof3 Dof2') Dequiv) Dof4 Dextends]
      }
    }
  }
  case step/abort:
  { F : ( |- sttp),
    E1 : ( |- term),
    C : ( |- con),
    T : ( |- con),
    ST : ( |- store),
    ST' : ( |- store),
    E2 : ( |- term),
    Dof : ( |- tm-of F (tm/abort E1 C) T),
    Dstof : ( |- store-of F ST F),
    Dstep : ( |- step ST E1 ST' E2)
  | tof : [ |- tm-of F (tm/abort E1 C) T],
    sof : [ |- store-of F ST F],
    x : [ |- step ST (tm/abort E1 C) ST' (tm/abort E2 C)]
  ; split inversion-tm/abort [ |- Dof] as
    case inversion-tm/abort/i:
    { F : ( |- sttp),
      E1 : ( |- term),
      C : ( |- con),
      T : ( |- con),
      ST : ( |- store),
      ST' : ( |- store),
      E2 : ( |- term),
      Dof : ( |- tm-of F (tm/abort E1 C) T),
      Dstof : ( |- store-of F ST F),
      Dstep : ( |- step ST E1 ST' E2),
      Dof1 : ( |- tm-of F E1 void),
      Dequiv : ( |- cn-equiv C T t)
    | tof : [ |- tm-of F (tm/abort E1 C) T],
      sof : [ |- store-of F ST F],
      x : [ |- step ST (tm/abort E1 C) ST' (tm/abort E2 C)]
    ; split preservation-tm [ |- Dof1] [ |- Dstof] [ |- Dstep] as
      case preservation-tm/i:
      { F : ( |- sttp),
        E1 : ( |- term),
        C : ( |- con),
        T : ( |- con),
        ST : ( |- store),
        ST' : ( |- store),
        E2 : ( |- term),
        Dof : ( |- tm-of F (tm/abort E1 C) T),
        Dstof : ( |- store-of F ST F),
        Dstep : ( |- step ST E1 ST' E2),
        Dof1 : ( |- tm-of F E1 void),
        Dequiv : ( |- cn-equiv C T t),
        F2 : ( |- sttp),
        Dof2 : ( |- tm-of F2 E2 void),
        Dof3 : ( |- store-of F2 ST' F2),
        Dextends : ( |- extends F F2)
      | tof : [ |- tm-of F (tm/abort E1 C) T],
        sof : [ |- store-of F ST F],
        x : [ |- step ST (tm/abort E1 C) ST' (tm/abort E2 C)]
      ; split cn-equiv-reg [ |- Dequiv] as
        case cn-equiv-reg/i:
        { F : ( |- sttp),
          E1 : ( |- term),
          C : ( |- con),
          T : ( |- con),
          ST : ( |- store),
          ST' : ( |- store),
          E2 : ( |- term),
          Dof : ( |- tm-of F (tm/abort E1 C) T),
          Dstof : ( |- store-of F ST F),
          Dstep : ( |- step ST E1 ST' E2),
          Dof1 : ( |- tm-of F E1 void),
          Dequiv : ( |- cn-equiv C T t),
          F2 : ( |- sttp),
          Dof2 : ( |- tm-of F2 E2 void),
          Dof3 : ( |- store-of F2 ST' F2),
          Dextends : ( |- extends F F2),
          Dof4 : ( |- cn-of C t),
          Dof5 : ( |- cn-of T t),
          Dwf : ( |- kd-wf t)
        | tof : [ |- tm-of F (tm/abort E1 C) T],
          sof : [ |- store-of F ST F],
          x : [ |- step ST (tm/abort E1 C) ST' (tm/abort E2 C)]
        ; solve
            [ |-
               preservation-tm/i F2
               (tm-of/equiv (tm-of/abort Dof4 Dof2) Dequiv) Dof3 Dextends]
        }
      }
    }
  }
}

and proof preservation-md :
  [ |- md-of P F M S] ->
  [ |- store-of F ST F] ->
  [ |- step-md ST M ST' M'] ->
    [ |- preservation-md/e P F M' S ST'] =
/ total 3 /
?
;
