% Kind Inversion

LF kd-wf-kprod-invert/e : kind -> kind -> type =
| kd-wf-kprod-invert/i :
  kd-wf K1 -> kd-wf K2 -> kd-wf-kprod-invert/e K1 K2
;

proof kd-wf-kprod-invert :
  (g : conbind)
  [g |- kd-wf (sigma K1 (\l. K2[..]))] ->
    [g |- kd-wf-kprod-invert/e K1 K2] =
/ total /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| wf : [g |- kd-wf (sigma K (\l. K1[..]))]
; split wf as
  case kd-wf/sigma:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dwf : (g |- kd-wf K),
    Dwf1 : (g, a : con, y387 : cn-of a (K[..]) |- kd-wf (K1[..]))
  | wf : [g |- kd-wf (sigma K (\l. K1[..]))]
  ; split inhabitation [_ |- Dwf] as
    case inhabitation/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g |- kind),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g, a : con, y387 : cn-of a (K[..]) |- kd-wf (K1[..])),
      C : (g |- con),
      Dof : (g |- cn-of C K)
    | wf : [g |- kd-wf (sigma K (\l. K1[..]))]
    ; solve [_ |- kd-wf-kprod-invert/i Dwf (Dwf1[.., C, Dof])]
    }
  }
}
;

LF kd-equiv-pi-form/e : kind -> type =
| kd-equiv-pi-form/i :
  { K1' : kind } { K2' : con -> kind }
  kind-eq K (pi K1' K2') -> kd-equiv-pi-form/e K
;

proof kd-equiv-pi-form :
  (g : conbind+conbind-reg)
  [g |- kd-equiv (pi K1 (\a. K2)) K] ->
    [g |- kd-equiv-pi-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g, z327 : con |- kind),
  K2 : (g |- kind)
| equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
; split equiv as
  case kd-equiv/pi:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K4 : (g |- kind),
    K6 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K K4),
    Dequiv1 :
      (g, a : con, z391 : cn-of a (K[..]) |- kd-equiv (K1[.., a]) (K6[.., a]))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K4 (\z327. K6))]
  ; solve [_ |- kd-equiv-pi-form/i K4 (\a. K6) (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K2 : (g |- kind),
    K4 : (g |- kind),
    Dequiv : (g |- kd-equiv (pi K (\a. K1)) K4),
    Dequiv1 : (g |- kd-equiv K4 K2)
  | equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
  ; split kd-equiv-pi-form [g |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K2 : (g |- kind),
      K4 : (g |- kind),
      Dequiv : (g |- kd-equiv (pi K (\a. K1)) K4),
      Dequiv1 : (g |- kd-equiv K4 K2),
      K6 : (g |- kind),
      K7 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K4 (pi K6 (\z327. K7)))
    | equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
    ; by kd-equiv-resp [g |- Deq] [g |- kind-eq/i ] [g |- Dequiv1]
      as Dequiv'' unboxed;
      split kd-equiv-pi-form [g |- Dequiv''] as
      case kd-equiv-pi-form/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g, z327 : con |- kind),
        K2 : (g |- kind),
        K4 : (g |- kind),
        Dequiv : (g |- kd-equiv (pi K (\a. K1)) K4),
        Dequiv1 : (g |- kd-equiv K4 K2),
        K6 : (g |- kind),
        K7 : (g, x774 : con |- kind),
        Deq : (g |- kind-eq K4 (pi K6 (\z327. K7))),
        Dequiv'' : (g |- kd-equiv (pi K6 (\z327. K7)) K2),
        K9 : (g |- kind),
        K10 : (g, x774 : con |- kind),
        Deq1 : (g |- kind-eq K2 (pi K9 (\z327. K10)))
      | equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
      ; solve [g |- kd-equiv-pi-form/i K9 (\a. K10) Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv K2 (pi K (\a. K1)))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
  ; split kd-equiv-pi-form' [g |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv K2 (pi K (\a. K1))),
      K4 : (g |- kind),
      K5 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K2 (pi K4 (\z327. K5)))
    | equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
    ; solve [g |- kd-equiv-pi-form/i K4 (\a. K5) Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    Dwf : (g |- kd-wf (pi K (\a. K1)))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K (\a. K1))]
  ; solve [g |- kd-equiv-pi-form/i K (\a. K1) (kind-eq/i )]
  }
}

and proof kd-equiv-pi-form' :
  (g : conbind+conbind-reg)
  [g |- kd-equiv K (pi K1 (\a. K2))] ->
    [g |- kd-equiv-pi-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g |- kind),
  K2 : (g, z327 : con |- kind)
| equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
; split equiv as
  case kd-equiv/pi:
  { g : conbind+conbind-reg,
    K3 : (g |- kind),
    K5 : (g, a5 : con |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv K3 K1),
    Dequiv1 :
      (g, a : con, z391 : cn-of a (K3[..]) |-
         kd-equiv (K5[.., a]) (K2[.., a]))
  | equiv : [g |- kd-equiv (pi K3 (\z327. K5)) (pi K1 (\a. K2))]
  ; solve [g |- kd-equiv-pi-form/i K3 (\a. K5) (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    K4 : (g |- kind),
    Dequiv : (g |- kd-equiv K K4),
    Dequiv1 : (g |- kd-equiv K4 (pi K1 (\a. K2)))
  | equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
  ; split kd-equiv-pi-form' [g |- Dequiv1] as
    case kd-equiv-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z327 : con |- kind),
      K4 : (g |- kind),
      Dequiv : (g |- kd-equiv K K4),
      Dequiv1 : (g |- kd-equiv K4 (pi K1 (\a. K2))),
      K6 : (g |- kind),
      K7 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K4 (pi K6 (\z327. K7)))
    | equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
    ; by kd-equiv-resp [g |- kind-eq/i ] [g |- Deq] [g |- Dequiv]
      as Dequiv'' unboxed;
      split kd-equiv-pi-form' [g |- Dequiv''] as
      case kd-equiv-pi-form/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g |- kind),
        K2 : (g, z327 : con |- kind),
        K4 : (g |- kind),
        Dequiv : (g |- kd-equiv K K4),
        Dequiv1 : (g |- kd-equiv K4 (pi K1 (\a. K2))),
        K6 : (g |- kind),
        K7 : (g, x774 : con |- kind),
        Deq : (g |- kind-eq K4 (pi K6 (\z327. K7))),
        Dequiv'' : (g |- kd-equiv K (pi K6 (\z327. K7))),
        K9 : (g |- kind),
        K10 : (g, x774 : con |- kind),
        Deq1 : (g |- kind-eq K (pi K9 (\z327. K10)))
      | equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
      ; solve [g |- kd-equiv-pi-form/i K9 (\a. K10) Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv (pi K1 (\a. K2)) K)
  | equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
  ; split kd-equiv-pi-form [g |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z327 : con |- kind),
      Dequiv : (g |- kd-equiv (pi K1 (\a. K2)) K),
      K4 : (g |- kind),
      K5 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K (pi K4 (\z327. K5)))
    | equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
    ; solve [g |- kd-equiv-pi-form/i K4 (\a. K5) Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind+conbind-reg,
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    Dwf : (g |- kd-wf (pi K1 (\a. K2)))
  | equiv : [g |- kd-equiv (pi K1 (\a. K2)) (pi K1 (\a. K2))]
  ; solve [g |- kd-equiv-pi-form/i K1 (\a. K2) (kind-eq/i )]
  }
}
;

LF kd-equiv-sigma-form/e : kind -> type =
| kd-equiv-sigma-form/i :
  { K1' : kind } { K2' : con -> kind }
  kind-eq K (sigma K1' K2') -> kd-equiv-sigma-form/e K
;

proof kd-equiv-sigma-form :
  (g : conbind)
  [g |- kd-equiv (sigma K1 (\a. K2)) K] ->
    [g |- kd-equiv-sigma-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind,
  K : (g |- kind),
  K1 : (g, z328 : con |- kind),
  K2 : (g |- kind)
| equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
; split equiv as
  case kd-equiv/sigma:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K4 : (g |- kind),
    K6 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K K4),
    Dequiv1 :
      (g, a : con, z392 : cn-of a (K[..]) |- kd-equiv (K1[.., a]) (K6[.., a]))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K4 (\z328. K6))]
  ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K2 : (g |- kind),
    K4 : (g |- kind),
    Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K4),
    Dequiv1 : (g |- kd-equiv K4 K2)
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
  ; split kd-equiv-sigma-form [g |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K2 : (g |- kind),
      K4 : (g |- kind),
      Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K4),
      Dequiv1 : (g |- kd-equiv K4 K2),
      K6 : (g |- kind),
      K7 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7)))
    | equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
    ; by kd-equiv-resp [g |- Deq] [g |- kind-eq/i ] [g |- Dequiv1]
      as Dequiv'' unboxed;
      split kd-equiv-sigma-form [g |- Dequiv''] as
      case kd-equiv-sigma-form/i:
      { g : conbind,
        K : (g |- kind),
        K1 : (g, z328 : con |- kind),
        K2 : (g |- kind),
        K4 : (g |- kind),
        Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K4),
        Dequiv1 : (g |- kd-equiv K4 K2),
        K6 : (g |- kind),
        K7 : (g, z776 : con |- kind),
        Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7))),
        Dequiv'' : (g |- kd-equiv (sigma K6 (\z328. K7)) K2),
        K9 : (g |- kind),
        K10 : (g, z776 : con |- kind),
        Deq1 : (g |- kind-eq K2 (sigma K9 (\z328. K10)))
      | equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
      ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv K2 (sigma K (\a. K1)))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
  ; split kd-equiv-sigma-form' [g |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv K2 (sigma K (\a. K1))),
      K4 : (g |- kind),
      K5 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K2 (sigma K4 (\z328. K5)))
    | equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
    ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    Dwf : (g |- kd-wf (sigma K (\a. K1)))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K (\a. K1))]
  ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
}

and proof kd-equiv-sigma-form' :
  (g : conbind)
  [g |- kd-equiv K (sigma K1 (\a. K2))] ->
    [g |- kd-equiv-sigma-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind,
  K : (g |- kind),
  K1 : (g |- kind),
  K2 : (g, z328 : con |- kind)
| equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
; split equiv as
  case kd-equiv/sigma:
  { g : conbind,
    K3 : (g |- kind),
    K5 : (g, a7 : con |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv K3 K1),
    Dequiv1 :
      (g, a : con, z392 : cn-of a (K3[..]) |-
         kd-equiv (K5[.., a]) (K2[.., a]))
  | equiv : [g |- kd-equiv (sigma K3 (\z328. K5)) (sigma K1 (\a. K2))]
  ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    K4 : (g |- kind),
    Dequiv : (g |- kd-equiv K K4),
    Dequiv1 : (g |- kd-equiv K4 (sigma K1 (\a. K2)))
  | equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
  ; split kd-equiv-sigma-form' [g |- Dequiv1] as
    case kd-equiv-sigma-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z328 : con |- kind),
      K4 : (g |- kind),
      Dequiv : (g |- kd-equiv K K4),
      Dequiv1 : (g |- kd-equiv K4 (sigma K1 (\a. K2))),
      K6 : (g |- kind),
      K7 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7)))
    | equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
    ; by kd-equiv-resp [g |- kind-eq/i ] [g |- Deq] [g |- Dequiv]
      as Dequiv'' unboxed;
      split kd-equiv-sigma-form' [g |- Dequiv''] as
      case kd-equiv-sigma-form/i:
      { g : conbind,
        K : (g |- kind),
        K1 : (g |- kind),
        K2 : (g, z328 : con |- kind),
        K4 : (g |- kind),
        Dequiv : (g |- kd-equiv K K4),
        Dequiv1 : (g |- kd-equiv K4 (sigma K1 (\a. K2))),
        K6 : (g |- kind),
        K7 : (g, z776 : con |- kind),
        Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7))),
        Dequiv'' : (g |- kd-equiv K (sigma K6 (\z328. K7))),
        K9 : (g |- kind),
        K10 : (g, z776 : con |- kind),
        Deq1 : (g |- kind-eq K (sigma K9 (\z328. K10)))
      | equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
      ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv (sigma K1 (\a. K2)) K)
  | equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
  ; split kd-equiv-sigma-form [g |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z328 : con |- kind),
      Dequiv : (g |- kd-equiv (sigma K1 (\a. K2)) K),
      K4 : (g |- kind),
      K5 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K (sigma K4 (\z328. K5)))
    | equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
    ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind,
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    Dwf : (g |- kd-wf (sigma K1 (\a. K2)))
  | equiv : [g |- kd-equiv (sigma K1 (\a. K2)) (sigma K1 (\a. K2))]
  ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
}
;

LF kd-equiv-sing-form/e : kind -> type =
| kd-equiv-sing-form/i :
  { C' : con }
  kind-eq K (sing C') -> kd-equiv-sing-form/e K
;

proof kd-equiv-sing-form :
  (g : conbind)
  [g |- kd-equiv (sing C) K] ->
    [g |- kd-equiv-sing-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, C : (g |- con), K : (g |- kind)
| equiv : [g |- kd-equiv (sing C) K]
; split equiv as
  case kd-equiv/sing:
  { g : conbind,
    C : (g |- con),
    C2 : (g |- con),
    Dequiv : (g |- cn-equiv C C2 t)
  | equiv : [g |- kd-equiv (sing C) (sing C2)]
  ; solve [g |- kd-equiv-sing-form/i _ (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind,
    C : (g |- con),
    K : (g |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv (sing C) K2),
    Dequiv1 : (g |- kd-equiv K2 K)
  | equiv : [g |- kd-equiv (sing C) K]
  ; split kd-equiv-sing-form [g |- Dequiv] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      C : (g |- con),
      K : (g |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv (sing C) K2),
      Dequiv1 : (g |- kd-equiv K2 K),
      C1 : (g |- con),
      Deq : (g |- kind-eq K2 (sing C1))
    | equiv : [g |- kd-equiv (sing C) K]
    ; by kd-equiv-resp [g |- Deq] [g |- kind-eq/i ] [g |- Dequiv1]
      as Dequiv'' unboxed;
      split kd-equiv-sing-form [g |- Dequiv''] as
      case kd-equiv-sing-form/i:
      { g : conbind,
        C : (g |- con),
        K : (g |- kind),
        K2 : (g |- kind),
        Dequiv : (g |- kd-equiv (sing C) K2),
        Dequiv1 : (g |- kd-equiv K2 K),
        C1 : (g |- con),
        Deq : (g |- kind-eq K2 (sing C1)),
        Dequiv'' : (g |- kd-equiv (sing C1) K),
        C2 : (g |- con),
        Deq1 : (g |- kind-eq K (sing C2))
      | equiv : [g |- kd-equiv (sing C) K]
      ; solve [g |- kd-equiv-sing-form/i _ Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind,
    C : (g |- con),
    K : (g |- kind),
    Dequiv : (g |- kd-equiv K (sing C))
  | equiv : [g |- kd-equiv (sing C) K]
  ; split kd-equiv-sing-form' [g |- Dequiv] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      C : (g |- con),
      K : (g |- kind),
      Dequiv : (g |- kd-equiv K (sing C)),
      C1 : (g |- con),
      Deq : (g |- kind-eq K (sing C1))
    | equiv : [g |- kd-equiv (sing C) K]
    ; solve [g |- kd-equiv-sing-form/i _ Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind, C : (g |- con), Dwf : (g |- kd-wf (sing C))
  | equiv : [g |- kd-equiv (sing C) (sing C)]
  ; solve [g |- kd-equiv-sing-form/i _ (kind-eq/i )]
  }
}

and proof kd-equiv-sing-form' :
  (g : conbind)
  [g |- kd-equiv K (sing C)] ->
    [g |- kd-equiv-sing-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, K : (g |- kind), C : (g |- con)
| equiv : [g |- kd-equiv K (sing C)]
; split equiv as
  case kd-equiv/sing:
  { g : conbind,
    C1 : (g |- con),
    C : (g |- con),
    Dequiv : (g |- cn-equiv C1 C t)
  | equiv : [g |- kd-equiv (sing C1) (sing C)]
  ; solve [g |- kd-equiv-sing-form/i _ (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    C : (g |- con),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv K K2),
    Dequiv1 : (g |- kd-equiv K2 (sing C))
  | equiv : [g |- kd-equiv K (sing C)]
  ; split kd-equiv-sing-form' [g |- Dequiv1] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      K : (g |- kind),
      C : (g |- con),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv K K2),
      Dequiv1 : (g |- kd-equiv K2 (sing C)),
      C1 : (g |- con),
      Deq : (g |- kind-eq K2 (sing C1))
    | equiv : [g |- kd-equiv K (sing C)]
    ; by kd-equiv-resp [g |- kind-eq/i ] [g |- Deq] [g |- Dequiv]
      as Dequiv'' unboxed;
      split kd-equiv-sing-form' [g |- Dequiv''] as
      case kd-equiv-sing-form/i:
      { g : conbind,
        K : (g |- kind),
        C : (g |- con),
        K2 : (g |- kind),
        Dequiv : (g |- kd-equiv K K2),
        Dequiv1 : (g |- kd-equiv K2 (sing C)),
        C1 : (g |- con),
        Deq : (g |- kind-eq K2 (sing C1)),
        Dequiv'' : (g |- kd-equiv K (sing C1)),
        C2 : (g |- con),
        Deq1 : (g |- kind-eq K (sing C2))
      | equiv : [g |- kd-equiv K (sing C)]
      ; solve [g |- kd-equiv-sing-form/i _ Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    C : (g |- con),
    Dequiv : (g |- kd-equiv (sing C) K)
  | equiv : [g |- kd-equiv K (sing C)]
  ; split kd-equiv-sing-form [g |- Dequiv] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      K : (g |- kind),
      C : (g |- con),
      Dequiv : (g |- kd-equiv (sing C) K),
      C1 : (g |- con),
      Deq : (g |- kind-eq K (sing C1))
    | equiv : [g |- kd-equiv K (sing C)]
    ; solve [g |- kd-equiv-sing-form/i _ Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind, C : (g |- con), Dwf : (g |- kd-wf (sing C))
  | equiv : [g |- kd-equiv (sing C) (sing C)]
  ; solve [g |- kd-equiv-sing-form/i _ (kind-eq/i )]
  }
}
;

LF kd-sub-pi-form/e : kind -> type =
| kd-sub-pi-form/i :
  { K1' : kind } { K2' : con -> kind }
  kind-eq K (pi K1' K2') -> kd-sub-pi-form/e K
;

proof kd-sub-pi-form :
  (g : conbind)
  [g |- kd-sub (pi K1 (\a. K2)) K] ->
    [g |- kd-sub-pi-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind,
  K : (g |- kind),
  K1 : (g, z327 : con |- kind),
  K2 : (g |- kind)
| sub : [g |- kd-sub (pi K (\a. K1)) K2]
; split sub as
  case kd-sub/pi:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K3 : (g |- kind),
    K6 : (g, a10 : con |- kind),
    Dsub : (g |- kd-sub K3 K),
    Dsub1 :
      (g, a : con, z395 : cn-of a (K3[..]) |- kd-sub (K1[.., a]) (K6[.., a])),
    Dwf : (g, a : con, x395 : cn-of a (K[..]) |- kd-wf (K1[.., a]))
  | sub : [g |- kd-sub (pi K (\a. K1)) (pi K3 (\z327. K6))]
  ; solve [_ |- kd-sub-pi-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-sub/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K2 : (g |- kind),
    K4 : (g |- kind),
    Dsub : (g |- kd-sub (pi K (\a. K1)) K4),
    Dsub1 : (g |- kd-sub K4 K2)
  | sub : [g |- kd-sub (pi K (\a. K1)) K2]
  ; split kd-sub-pi-form [_ |- Dsub] as
    case kd-sub-pi-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K2 : (g |- kind),
      K4 : (g |- kind),
      Dsub : (g |- kd-sub (pi K (\a. K1)) K4),
      Dsub1 : (g |- kd-sub K4 K2),
      K6 : (g |- kind),
      K7 : (g, y781 : con |- kind),
      Deq : (g |- kind-eq K4 (pi K6 (\z327. K7)))
    | sub : [g |- kd-sub (pi K (\a. K1)) K2]
    ; by kd-sub-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dsub1]
      as Dsub' unboxed;
      split kd-sub-pi-form [_ |- Dsub'] as
      case kd-sub-pi-form/i:
      { g : conbind,
        K : (g |- kind),
        K1 : (g, z327 : con |- kind),
        K2 : (g |- kind),
        K4 : (g |- kind),
        Dsub : (g |- kd-sub (pi K (\a. K1)) K4),
        Dsub1 : (g |- kd-sub K4 K2),
        K6 : (g |- kind),
        K7 : (g, y781 : con |- kind),
        Deq : (g |- kind-eq K4 (pi K6 (\z327. K7))),
        Dsub' : (g |- kd-sub (pi K6 (\z327. K7)) K2),
        K9 : (g |- kind),
        K10 : (g, y781 : con |- kind),
        Deq1 : (g |- kind-eq K2 (pi K9 (\z327. K10)))
      | sub : [g |- kd-sub (pi K (\a. K1)) K2]
      ; solve [_ |- kd-sub-pi-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv (pi K (\a. K1)) K2)
  | sub : [g |- kd-sub (pi K (\a. K1)) K2]
  ; split kd-equiv-pi-form [_ |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv (pi K (\a. K1)) K2),
      K4 : (g |- kind),
      K5 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K2 (pi K4 (\z327. K5)))
    | sub : [g |- kd-sub (pi K (\a. K1)) K2]
    ; solve [_ |- kd-sub-pi-form/i _ (\a. _) Deq]
    }
  }
}
;

proof kd-sub-pi-form' :
  (g : conbind)
  [g |- kd-sub K (pi K1 (\a. K2))] ->
    [g |- kd-sub-pi-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind,
  K : (g |- kind),
  K1 : (g |- kind),
  K2 : (g, z327 : con |- kind)
| sub : [g |- kd-sub K (pi K1 (\a. K2))]
; split sub as
  case kd-sub/pi:
  { g : conbind,
    K4 : (g |- kind),
    K5 : (g, a9 : con |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    Dsub : (g |- kd-sub K1 K4),
    Dsub1 :
      (g, a : con, z395 : cn-of a (K1[..]) |- kd-sub (K5[.., a]) (K2[.., a])),
    Dwf : (g, a : con, x395 : cn-of a (K4[..]) |- kd-wf (K5[.., a]))
  | sub : [g |- kd-sub (pi K4 (\z327. K5)) (pi K1 (\a. K2))]
  ; solve [_ |- kd-sub-pi-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-sub/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    K4 : (g |- kind),
    Dsub : (g |- kd-sub K K4),
    Dsub1 : (g |- kd-sub K4 (pi K1 (\a. K2)))
  | sub : [g |- kd-sub K (pi K1 (\a. K2))]
  ; split kd-sub-pi-form' [_ |- Dsub1] as
    case kd-sub-pi-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z327 : con |- kind),
      K4 : (g |- kind),
      Dsub : (g |- kd-sub K K4),
      Dsub1 : (g |- kd-sub K4 (pi K1 (\a. K2))),
      K6 : (g |- kind),
      K7 : (g, y781 : con |- kind),
      Deq : (g |- kind-eq K4 (pi K6 (\z327. K7)))
    | sub : [g |- kd-sub K (pi K1 (\a. K2))]
    ; by kd-sub-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dsub]
      as Dsub' unboxed;
      split kd-sub-pi-form' [_ |- Dsub'] as
      case kd-sub-pi-form/i:
      { g : conbind,
        K : (g |- kind),
        K1 : (g |- kind),
        K2 : (g, z327 : con |- kind),
        K4 : (g |- kind),
        Dsub : (g |- kd-sub K K4),
        Dsub1 : (g |- kd-sub K4 (pi K1 (\a. K2))),
        K6 : (g |- kind),
        K7 : (g, y781 : con |- kind),
        Deq : (g |- kind-eq K4 (pi K6 (\z327. K7))),
        Dsub' : (g |- kd-sub K (pi K6 (\z327. K7))),
        K9 : (g |- kind),
        K10 : (g, y781 : con |- kind),
        Deq1 : (g |- kind-eq K (pi K9 (\z327. K10)))
      | sub : [g |- kd-sub K (pi K1 (\a. K2))]
      ; solve [_ |- kd-sub-pi-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv K (pi K1 (\a. K2)))
  | sub : [g |- kd-sub K (pi K1 (\a. K2))]
  ; split kd-equiv-pi-form' [_ |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z327 : con |- kind),
      Dequiv : (g |- kd-equiv K (pi K1 (\a. K2))),
      K4 : (g |- kind),
      K5 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K (pi K4 (\z327. K5)))
    | sub : [g |- kd-sub K (pi K1 (\a. K2))]
    ; solve [_ |- kd-sub-pi-form/i _ (\a. _) Deq]
    }
  }
}
;

LF kd-sub-sigma-form/e : kind -> type =
| kd-sub-sigma-form/i :
  { K1' : kind } { K2' : con -> kind }
  kind-eq K (sigma K1' K2') -> kd-sub-sigma-form/e K
;

proof kd-sub-sigma-form :
  (g : conbind+conbind-reg)
  [g |- kd-sub (sigma K1 (\a. K2)) K] ->
    [g |- kd-sub-sigma-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g, z328 : con |- kind),
  K2 : (g |- kind)
| sub : [g |- kd-sub (sigma K (\a. K1)) K2]
; split sub as
  case kd-sub/sigma:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K4 : (g |- kind),
    K6 : (g, a12 : con |- kind),
    Dsub : (g |- kd-sub K K4),
    Dsub1 :
      (g, a : con, x397 : cn-of a (K[..]) |- kd-sub (K1[.., a]) (K6[.., a])),
    Dwf : (g, a : con, y397 : cn-of a (K4[..]) |- kd-wf (K6[.., a]))
  | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K4 (\z328. K6))]
  ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-sub/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K2 : (g |- kind),
    K4 : (g |- kind),
    Dsub : (g |- kd-sub (sigma K (\a. K1)) K4),
    Dsub1 : (g |- kd-sub K4 K2)
  | sub : [g |- kd-sub (sigma K (\a. K1)) K2]
  ; split kd-sub-sigma-form [_ |- Dsub] as
    case kd-sub-sigma-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K2 : (g |- kind),
      K4 : (g |- kind),
      Dsub : (g |- kd-sub (sigma K (\a. K1)) K4),
      Dsub1 : (g |- kd-sub K4 K2),
      K6 : (g |- kind),
      K7 : (g, x786 : con |- kind),
      Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7)))
    | sub : [g |- kd-sub (sigma K (\a. K1)) K2]
    ; by kd-sub-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dsub1]
      as Dsub' unboxed;
      split kd-sub-sigma-form [_ |- Dsub'] as
      case kd-sub-sigma-form/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g, z328 : con |- kind),
        K2 : (g |- kind),
        K4 : (g |- kind),
        Dsub : (g |- kd-sub (sigma K (\a. K1)) K4),
        Dsub1 : (g |- kd-sub K4 K2),
        K6 : (g |- kind),
        K7 : (g, x786 : con |- kind),
        Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7))),
        Dsub' : (g |- kd-sub (sigma K6 (\z328. K7)) K2),
        K9 : (g |- kind),
        K10 : (g, x786 : con |- kind),
        Deq1 : (g |- kind-eq K2 (sigma K9 (\z328. K10)))
      | sub : [g |- kd-sub (sigma K (\a. K1)) K2]
      ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K2)
  | sub : [g |- kd-sub (sigma K (\a. K1)) K2]
  ; split kd-equiv-sigma-form [_ |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K2),
      K4 : (g |- kind),
      K5 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K2 (sigma K4 (\z328. K5)))
    | sub : [g |- kd-sub (sigma K (\a. K1)) K2]
    ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) Deq]
    }
  }
}
;

proof kd-sub-sigma-form' :
  (g : conbind+conbind-reg)
  [g |- kd-sub K (sigma K1 (\a. K2))] ->
    [g |- kd-sub-sigma-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g |- kind),
  K2 : (g, z328 : con |- kind)
| sub : [g |- kd-sub K (sigma K1 (\a. K2))]
; split sub as
  case kd-sub/sigma:
  { g : conbind+conbind-reg,
    K3 : (g |- kind),
    K5 : (g, a11 : con |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    Dsub : (g |- kd-sub K3 K1),
    Dsub1 :
      (g, a : con, x397 : cn-of a (K3[..]) |- kd-sub (K5[.., a]) (K2[.., a])),
    Dwf : (g, a : con, y397 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | sub : [g |- kd-sub (sigma K3 (\z328. K5)) (sigma K1 (\a. K2))]
  ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-sub/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    K4 : (g |- kind),
    Dsub : (g |- kd-sub K K4),
    Dsub1 : (g |- kd-sub K4 (sigma K1 (\a. K2)))
  | sub : [g |- kd-sub K (sigma K1 (\a. K2))]
  ; split kd-sub-sigma-form' [_ |- Dsub1] as
    case kd-sub-sigma-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z328 : con |- kind),
      K4 : (g |- kind),
      Dsub : (g |- kd-sub K K4),
      Dsub1 : (g |- kd-sub K4 (sigma K1 (\a. K2))),
      K6 : (g |- kind),
      K7 : (g, x786 : con |- kind),
      Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7)))
    | sub : [g |- kd-sub K (sigma K1 (\a. K2))]
    ; by kd-sub-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dsub]
      as Dsub' unboxed;
      split kd-sub-sigma-form' [_ |- Dsub'] as
      case kd-sub-sigma-form/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g |- kind),
        K2 : (g, z328 : con |- kind),
        K4 : (g |- kind),
        Dsub : (g |- kd-sub K K4),
        Dsub1 : (g |- kd-sub K4 (sigma K1 (\a. K2))),
        K6 : (g |- kind),
        K7 : (g, x786 : con |- kind),
        Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7))),
        Dsub' : (g |- kd-sub K (sigma K6 (\z328. K7))),
        K9 : (g |- kind),
        K10 : (g, x786 : con |- kind),
        Deq1 : (g |- kind-eq K (sigma K9 (\z328. K10)))
      | sub : [g |- kd-sub K (sigma K1 (\a. K2))]
      ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv K (sigma K1 (\a. K2)))
  | sub : [g |- kd-sub K (sigma K1 (\a. K2))]
  ; split kd-equiv-sigma-form' [_ |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z328 : con |- kind),
      Dequiv : (g |- kd-equiv K (sigma K1 (\a. K2))),
      K4 : (g |- kind),
      K5 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K (sigma K4 (\z328. K5)))
    | sub : [g |- kd-sub K (sigma K1 (\a. K2))]
    ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) Deq]
    }
  }
}
;

LF kd-sub-sing-form'/e : kind -> type =
| kd-sub-sing-form'/i :
  { C' : con }
  kind-eq K (sing C') -> kd-sub-sing-form'/e K
;

proof kd-sub-sing-form' :
  (g : conbind)
  [g |- kd-sub K (sing C)] ->
    [g |- kd-sub-sing-form'/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, K : (g |- kind), C : (g |- con)
| sub : [g |- kd-sub K (sing C)]
; split sub as
  case kd-sub/trans:
  { g : conbind,
    K : (g |- kind),
    C : (g |- con),
    K2 : (g |- kind),
    Dsub : (g |- kd-sub K K2),
    Dsub1 : (g |- kd-sub K2 (sing C))
  | sub : [g |- kd-sub K (sing C)]
  ; split kd-sub-sing-form' [_ |- Dsub1] as
    case kd-sub-sing-form'/i:
    { g : conbind,
      K : (g |- kind),
      C : (g |- con),
      K2 : (g |- kind),
      Dsub : (g |- kd-sub K K2),
      Dsub1 : (g |- kd-sub K2 (sing C)),
      C1 : (g |- con),
      Deq : (g |- kind-eq K2 (sing C1))
    | sub : [g |- kd-sub K (sing C)]
    ; by kd-sub-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dsub]
      as Dsub' unboxed;
      split kd-sub-sing-form' [_ |- Dsub'] as
      case kd-sub-sing-form'/i:
      { g : conbind,
        K : (g |- kind),
        C : (g |- con),
        K2 : (g |- kind),
        Dsub : (g |- kd-sub K K2),
        Dsub1 : (g |- kd-sub K2 (sing C)),
        C1 : (g |- con),
        Deq : (g |- kind-eq K2 (sing C1)),
        Dsub' : (g |- kd-sub K (sing C1)),
        C2 : (g |- con),
        Deq1 : (g |- kind-eq K (sing C2))
      | sub : [g |- kd-sub K (sing C)]
      ; solve [_ |- kd-sub-sing-form'/i _ Deq1]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind,
    K : (g |- kind),
    C : (g |- con),
    Dequiv : (g |- kd-equiv K (sing C))
  | sub : [g |- kd-sub K (sing C)]
  ; split kd-equiv-sing-form' [_ |- Dequiv] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      K : (g |- kind),
      C : (g |- con),
      Dequiv : (g |- kd-equiv K (sing C)),
      C1 : (g |- con),
      Deq : (g |- kind-eq K (sing C1))
    | sub : [g |- kd-sub K (sing C)]
    ; solve [_ |- kd-sub-sing-form'/i _ Deq]
    }
  }
}
;

proof injective-sing :
  (g : conbind)
  [g |- kd-equiv (sing C) (sing C')] ->
    [g |- cn-equiv C C' t] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, C : (g |- con), C' : (g |- con)
| equiv : [g |- kd-equiv (sing C) (sing C')]
; split equiv as
  case kd-equiv/sing:
  { g : conbind,
    C : (g |- con),
    C' : (g |- con),
    Dequiv : (g |- cn-equiv C C' t)
  | equiv : [g |- kd-equiv (sing C) (sing C')]
  ; solve [g |- Dequiv]
  }
  case kd-equiv/trans:
  { g : conbind,
    C : (g |- con),
    C' : (g |- con),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv (sing C) K1),
    Dequiv1 : (g |- kd-equiv K1 (sing C'))
  | equiv : [g |- kd-equiv (sing C) (sing C')]
  ; split kd-equiv-sing-form [_ |- Dequiv] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      C : (g |- con),
      C' : (g |- con),
      K1 : (g |- kind),
      Dequiv : (g |- kd-equiv (sing C) K1),
      Dequiv1 : (g |- kd-equiv K1 (sing C')),
      C1 : (g |- con),
      Deq : (g |- kind-eq K1 (sing C1))
    | equiv : [g |- kd-equiv (sing C) (sing C')]
    ; by kd-equiv-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dequiv]
      as D12' unboxed;
      by kd-equiv-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dequiv1]
      as D23' unboxed;
      by injective-sing [_ |- D12'] as D12'' unboxed;
      by injective-sing [_ |- D23'] as D23'' unboxed;
      solve [_ |- cn-equiv/trans D12'' D23'']
    }
  }
  case kd-equiv/symm:
  { g : conbind,
    C : (g |- con),
    C' : (g |- con),
    Dequiv : (g |- kd-equiv (sing C') (sing C))
  | equiv : [g |- kd-equiv (sing C) (sing C')]
  ; by injective-sing [_ |- Dequiv] as D' unboxed;
    solve [_ |- cn-equiv/symm D']
  }
  case kd-equiv/refl:
  { g : conbind, C' : (g |- con), Dwf : (g |- kd-wf (sing C'))
  | equiv : [g |- kd-equiv (sing C') (sing C')]
  ; split [_ |- Dwf] as
    case kd-wf/sing:
    { g : conbind, C' : (g |- con), Dof : (g |- cn-of C' t)
    | equiv : [g |- kd-equiv (sing C') (sing C')]
    ; solve [_ |- cn-equiv/refl Dof]
    }
  }
}
;

LF injective-pi/e : kind -> (con -> kind) -> kind -> (con -> kind) -> type =
| injective-pi/i :
  kd-equiv K1 K1' ->
  ({ a : con } cn-of a K1 -> kd-equiv (K2 a) (K2' a)) ->
    injective-pi/e K1 K2 K1' K2'
;

proof injective-pi :
  (g : conbind-reg)
  [g |- kd-equiv (pi K1 (\a. K2)) (pi K1' (\a. K2'))] ->
    [g |- injective-pi/e K1 (\a. K2) K1' (\a. K2')] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind-reg,
  K : (g |- kind),
  K1 : (g, z327 : con |- kind),
  K1' : (g |- kind),
  K2' : (g, z327 : con |- kind)
| equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
; split equiv as
  case kd-equiv/pi:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv K K1'),
    Dequiv1 :
      (g, a : con, z391 : cn-of a (K[..]) |-
         kd-equiv (K1[.., a]) (K2'[.., a]))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
  ; solve [_ |- injective-pi/i Dequiv (\a. \da. Dequiv1)]
  }
  case kd-equiv/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv (pi K (\a. K1)) K3),
    Dequiv1 : (g |- kd-equiv K3 (pi K1' (\a. K2')))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
  ; split kd-equiv-pi-form [_ |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z327 : con |- kind),
      K3 : (g |- kind),
      Dequiv : (g |- kd-equiv (pi K (\a. K1)) K3),
      Dequiv1 : (g |- kd-equiv K3 (pi K1' (\a. K2'))),
      K5 : (g |- kind),
      K6 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K3 (pi K5 (\z327. K6)))
    | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
    ; by kd-equiv-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dequiv]
      as DequivAB' unboxed;
      by kd-equiv-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dequiv1]
      as DequivBC' unboxed;
      split injective-pi [_ |- DequivAB'] as
      case injective-pi/i:
      { g : conbind-reg,
        K : (g |- kind),
        K1 : (g, z327 : con |- kind),
        K1' : (g |- kind),
        K2' : (g, z327 : con |- kind),
        K3 : (g |- kind),
        Dequiv : (g |- kd-equiv (pi K (\a. K1)) K3),
        Dequiv1 : (g |- kd-equiv K3 (pi K1' (\a. K2'))),
        K5 : (g |- kind),
        K6 : (g, x774 : con |- kind),
        Deq : (g |- kind-eq K3 (pi K5 (\z327. K6))),
        DequivAB' : (g |- kd-equiv (pi K (\a. K1)) (pi K5 (\z327. K6))),
        DequivBC' : (g |- kd-equiv (pi K5 (\z327. K6)) (pi K1' (\a. K2'))),
        Dequiv2 : (g |- kd-equiv K K5),
        Dequiv3 :
          (g, a : con, z799 : cn-of a (K[..]) |-
             kd-equiv (K1[.., a]) (K6[.., a]))
      | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
      ; split injective-pi [_ |- DequivBC'] as
        case injective-pi/i:
        { g : conbind-reg,
          K : (g |- kind),
          K1 : (g, z327 : con |- kind),
          K1' : (g |- kind),
          K2' : (g, z327 : con |- kind),
          K3 : (g |- kind),
          Dequiv : (g |- kd-equiv (pi K (\a. K1)) K3),
          Dequiv1 : (g |- kd-equiv K3 (pi K1' (\a. K2'))),
          K5 : (g |- kind),
          K6 : (g, x774 : con |- kind),
          Deq : (g |- kind-eq K3 (pi K5 (\z327. K6))),
          DequivAB' : (g |- kd-equiv (pi K (\a. K1)) (pi K5 (\z327. K6))),
          DequivBC' : (g |- kd-equiv (pi K5 (\z327. K6)) (pi K1' (\a. K2'))),
          Dequiv2 : (g |- kd-equiv K K5),
          Dequiv3 :
            (g, a : con, z799 : cn-of a (K[..]) |-
               kd-equiv (K1[.., a]) (K6[.., a])),
          Dequiv4 : (g |- kd-equiv K5 K1'),
          Dequiv5 :
            (g, a : con, z799 : cn-of a (K5[..]) |-
               kd-equiv (K6[.., a]) (K2'[.., a]))
        | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
        ; by [_ |- kd-equiv/trans Dequiv2 Dequiv4] as Dequiv1' unboxed;
          by [_, a : con, z799 : cn-of a (K[..]) |-
                kd-equiv/trans Dequiv3 (Dequiv5[.., a, _])]
          as Dequiv2' unboxed;
          solve [_ |- injective-pi/i Dequiv1' (\a. \da. Dequiv2')]
        }
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv (pi K1' (\a. K2')) (pi K (\a. K1)))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
  ; split injective-pi [_ |- Dequiv] as
    case injective-pi/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z327 : con |- kind),
      Dequiv : (g |- kd-equiv (pi K1' (\a. K2')) (pi K (\a. K1))),
      Dequiv1 : (g |- kd-equiv K1' K),
      Dequiv2 :
        (g, a : con, z799 : cn-of a (K1'[..]) |-
           kd-equiv (K2'[.., a]) (K1[.., a]))
    | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
    ; by [_ |- kd-equiv/symm Dequiv1] as Dequiv1' unboxed;
      by [_, a : con, z799 : cn-of a (K1'[..]) |- kd-equiv/symm Dequiv2]
      as Dequiv2' unboxed;
      solve [_ |- injective-pi/i Dequiv1' (\a. \da. Dequiv2'[.., a, _])]
    }
  }
  case kd-equiv/refl:
  { g : conbind-reg,
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    Dwf : (g |- kd-wf (pi K1' (\a. K2')))
  | equiv : [g |- kd-equiv (pi K1' (\a. K2')) (pi K1' (\a. K2'))]
  ; split [_ |- Dwf] as
    case kd-wf/pi:
    { g : conbind-reg,
      K1' : (g |- kind),
      K2' : (g, z327 : con |- kind),
      Dwf1 : (g |- kd-wf K1'),
      Dwf2 : (g, a : con, y388 : cn-of a (K1'[..]) |- kd-wf (K2'[.., a]))
    | equiv : [g |- kd-equiv (pi K1' (\a. K2')) (pi K1' (\a. K2'))]
    ; by [_ |- kd-equiv/refl Dwf1] as Dequiv1' unboxed;
      by [_, a : con, y388 : cn-of a (K1'[..]) |- kd-equiv/refl Dwf2]
      as Dequiv2' unboxed;
      solve [_ |- injective-pi/i Dequiv1' (\a. \da. Dequiv2'[.., a, _])]
    }
  }
}
;

LF injective-sigma/e : kind -> (con -> kind) -> kind -> (con -> kind) -> type =
| injective-sigma/i :
  kd-equiv K1 K1' ->
  ({ a : con } cn-of a K1 -> kd-equiv (K2 a) (K2' a)) ->
    injective-sigma/e K1 K2 K1' K2'
;

proof injective-sigma :
  (g : conbind+conbind-reg)
  [g |- kd-equiv (sigma K1 (\a. K2)) (sigma K1' (\a. K2'))] ->
    [g |- injective-sigma/e K1 (\a. K2) K1' (\a. K2')] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g, z328 : con |- kind),
  K1' : (g |- kind),
  K2' : (g, z328 : con |- kind)
| equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
; split equiv as
  case kd-equiv/sigma:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv K K1'),
    Dequiv1 :
      (g, a : con, z392 : cn-of a (K[..]) |-
         kd-equiv (K1[.., a]) (K2'[.., a]))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
  ; solve [_ |- injective-sigma/i Dequiv (\a. \da. Dequiv1)]
  }
  case kd-equiv/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K3),
    Dequiv1 : (g |- kd-equiv K3 (sigma K1' (\a. K2')))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
  ; split kd-equiv-sigma-form [_ |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z328 : con |- kind),
      K3 : (g |- kind),
      Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K3),
      Dequiv1 : (g |- kd-equiv K3 (sigma K1' (\a. K2'))),
      K5 : (g |- kind),
      K6 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K3 (sigma K5 (\z328. K6)))
    | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
    ; by kd-equiv-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dequiv]
      as DequivAB' unboxed;
      by kd-equiv-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dequiv1]
      as DequivBC' unboxed;
      split injective-sigma [_ |- DequivAB'] as
      case injective-sigma/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g, z328 : con |- kind),
        K1' : (g |- kind),
        K2' : (g, z328 : con |- kind),
        K3 : (g |- kind),
        Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K3),
        Dequiv1 : (g |- kd-equiv K3 (sigma K1' (\a. K2'))),
        K5 : (g |- kind),
        K6 : (g, z776 : con |- kind),
        Deq : (g |- kind-eq K3 (sigma K5 (\z328. K6))),
        DequivAB' : (g |- kd-equiv (sigma K (\a. K1)) (sigma K5 (\z328. K6))),
        DequivBC' :
          (g |- kd-equiv (sigma K5 (\z328. K6)) (sigma K1' (\a. K2'))),
        Dequiv2 : (g |- kd-equiv K K5),
        Dequiv3 :
          (g, a : con, z805 : cn-of a (K[..]) |-
             kd-equiv (K1[.., a]) (K6[.., a]))
      | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
      ; split injective-sigma [_ |- DequivBC'] as
        case injective-sigma/i:
        { g : conbind+conbind-reg,
          K : (g |- kind),
          K1 : (g, z328 : con |- kind),
          K1' : (g |- kind),
          K2' : (g, z328 : con |- kind),
          K3 : (g |- kind),
          Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K3),
          Dequiv1 : (g |- kd-equiv K3 (sigma K1' (\a. K2'))),
          K5 : (g |- kind),
          K6 : (g, z776 : con |- kind),
          Deq : (g |- kind-eq K3 (sigma K5 (\z328. K6))),
          DequivAB' :
            (g |- kd-equiv (sigma K (\a. K1)) (sigma K5 (\z328. K6))),
          DequivBC' :
            (g |- kd-equiv (sigma K5 (\z328. K6)) (sigma K1' (\a. K2'))),
          Dequiv2 : (g |- kd-equiv K K5),
          Dequiv3 :
            (g, a : con, z805 : cn-of a (K[..]) |-
               kd-equiv (K1[.., a]) (K6[.., a])),
          Dequiv4 : (g |- kd-equiv K5 K1'),
          Dequiv5 :
            (g, a : con, z805 : cn-of a (K5[..]) |-
               kd-equiv (K6[.., a]) (K2'[.., a]))
        | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
        ; by [_ |- kd-equiv/trans Dequiv2 Dequiv4] as Dequiv1' unboxed;
          by [_, a : con, z805 : cn-of a (K[..]) |-
                kd-equiv/trans Dequiv3 (Dequiv5[.., a, _])]
          as Dequiv2' unboxed;
          solve [_ |- injective-sigma/i Dequiv1' (\a. \da. Dequiv2')]
        }
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv (sigma K1' (\a. K2')) (sigma K (\a. K1)))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
  ; split injective-sigma [_ |- Dequiv] as
    case injective-sigma/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z328 : con |- kind),
      Dequiv : (g |- kd-equiv (sigma K1' (\a. K2')) (sigma K (\a. K1))),
      Dequiv1 : (g |- kd-equiv K1' K),
      Dequiv2 :
        (g, a : con, z805 : cn-of a (K1'[..]) |-
           kd-equiv (K2'[.., a]) (K1[.., a]))
    | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
    ; by [_ |- kd-equiv/symm Dequiv1] as Dequiv1' unboxed;
      by [_, a : con, z805 : cn-of a (K1'[..]) |- kd-equiv/symm Dequiv2]
      as Dequiv2' unboxed;
      solve [_ |- injective-sigma/i Dequiv1' (\a. \da. Dequiv2'[.., a, _])]
    }
  }
  case kd-equiv/refl:
  { g : conbind+conbind-reg,
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    Dwf : (g |- kd-wf (sigma K1' (\a. K2')))
  | equiv : [g |- kd-equiv (sigma K1' (\a. K2')) (sigma K1' (\a. K2'))]
  ; split [_ |- Dwf] as
    case kd-wf/sigma:
    { g : conbind+conbind-reg,
      K1' : (g |- kind),
      K2' : (g, z328 : con |- kind),
      Dwf1 : (g |- kd-wf K1'),
      Dwf2 : (g, a : con, y389 : cn-of a (K1'[..]) |- kd-wf (K2'[.., a]))
    | equiv : [g |- kd-equiv (sigma K1' (\a. K2')) (sigma K1' (\a. K2'))]
    ; by [_ |- kd-equiv/refl Dwf1] as Dequiv1' unboxed;
      by [_, a : con, y389 : cn-of a (K1'[..]) |- kd-equiv/refl Dwf2]
      as Dequiv2' unboxed;
      solve [_ |- injective-sigma/i Dequiv1' (\a. \da. Dequiv2'[.., a, _])]
    }
  }
}
;
