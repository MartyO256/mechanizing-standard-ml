% Kind Inversion

LF kd-wf-kprod-invert/e : kind -> kind -> type =
| kd-wf-kprod-invert/i :
  kd-wf K1 -> kd-wf K2 -> kd-wf-kprod-invert/e K1 K2
;

proof kd-wf-kprod-invert :
  (g : conbind)
  [g |- kd-wf (sigma K1 (\l. K2[..]))] ->
    [g |- kd-wf-kprod-invert/e K1 K2] =
/ total /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| wf : [g |- kd-wf (sigma K (\l. K1[..]))]
; split wf as
  case kd-wf/sigma:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dwf : (g |- kd-wf K),
    Dwf1 : (g, a : con, y387 : cn-of a (K[..]) |- kd-wf (K1[..]))
  | wf : [g |- kd-wf (sigma K (\l. K1[..]))]
  ; split inhabitation [_ |- Dwf] as
    case inhabitation/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g |- kind),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g, a : con, y387 : cn-of a (K[..]) |- kd-wf (K1[..])),
      C : (g |- con),
      Dof : (g |- cn-of C K)
    | wf : [g |- kd-wf (sigma K (\l. K1[..]))]
    ; solve [_ |- kd-wf-kprod-invert/i Dwf (Dwf1[.., C, Dof])]
    }
  }
}
;

LF kd-equiv-pi-form/e : kind -> type =
| kd-equiv-pi-form/i :
  { K1' : kind } { K2' : con -> kind }
  kind-eq K (pi K1' K2') -> kd-equiv-pi-form/e K
;

proof kd-equiv-pi-form :
  (g : conbind+conbind-reg)
  [g |- kd-equiv (pi K1 (\a. K2)) K] ->
    [g |- kd-equiv-pi-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g, z327 : con |- kind),
  K2 : (g |- kind)
| equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
; split equiv as
  case kd-equiv/pi:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K4 : (g |- kind),
    K6 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K K4),
    Dequiv1 :
      (g, a : con, z391 : cn-of a (K[..]) |- kd-equiv (K1[.., a]) (K6[.., a]))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K4 (\z327. K6))]
  ; solve [_ |- kd-equiv-pi-form/i K4 (\a. K6) (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K2 : (g |- kind),
    K4 : (g |- kind),
    Dequiv : (g |- kd-equiv (pi K (\a. K1)) K4),
    Dequiv1 : (g |- kd-equiv K4 K2)
  | equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
  ; split kd-equiv-pi-form [g |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K2 : (g |- kind),
      K4 : (g |- kind),
      Dequiv : (g |- kd-equiv (pi K (\a. K1)) K4),
      Dequiv1 : (g |- kd-equiv K4 K2),
      K6 : (g |- kind),
      K7 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K4 (pi K6 (\z327. K7)))
    | equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
    ; by kd-equiv-resp [g |- Deq] [g |- kind-eq/i ] [g |- Dequiv1]
      as Dequiv'' unboxed;
      split kd-equiv-pi-form [g |- Dequiv''] as
      case kd-equiv-pi-form/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g, z327 : con |- kind),
        K2 : (g |- kind),
        K4 : (g |- kind),
        Dequiv : (g |- kd-equiv (pi K (\a. K1)) K4),
        Dequiv1 : (g |- kd-equiv K4 K2),
        K6 : (g |- kind),
        K7 : (g, x774 : con |- kind),
        Deq : (g |- kind-eq K4 (pi K6 (\z327. K7))),
        Dequiv'' : (g |- kd-equiv (pi K6 (\z327. K7)) K2),
        K9 : (g |- kind),
        K10 : (g, x774 : con |- kind),
        Deq1 : (g |- kind-eq K2 (pi K9 (\z327. K10)))
      | equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
      ; solve [g |- kd-equiv-pi-form/i K9 (\a. K10) Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv K2 (pi K (\a. K1)))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
  ; split kd-equiv-pi-form' [g |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv K2 (pi K (\a. K1))),
      K4 : (g |- kind),
      K5 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K2 (pi K4 (\z327. K5)))
    | equiv : [g |- kd-equiv (pi K (\a. K1)) K2]
    ; solve [g |- kd-equiv-pi-form/i K4 (\a. K5) Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    Dwf : (g |- kd-wf (pi K (\a. K1)))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K (\a. K1))]
  ; solve [g |- kd-equiv-pi-form/i K (\a. K1) (kind-eq/i )]
  }
}

and proof kd-equiv-pi-form' :
  (g : conbind+conbind-reg)
  [g |- kd-equiv K (pi K1 (\a. K2))] ->
    [g |- kd-equiv-pi-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g |- kind),
  K2 : (g, z327 : con |- kind)
| equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
; split equiv as
  case kd-equiv/pi:
  { g : conbind+conbind-reg,
    K3 : (g |- kind),
    K5 : (g, a5 : con |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv K3 K1),
    Dequiv1 :
      (g, a : con, z391 : cn-of a (K3[..]) |-
         kd-equiv (K5[.., a]) (K2[.., a]))
  | equiv : [g |- kd-equiv (pi K3 (\z327. K5)) (pi K1 (\a. K2))]
  ; solve [g |- kd-equiv-pi-form/i K3 (\a. K5) (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    K4 : (g |- kind),
    Dequiv : (g |- kd-equiv K K4),
    Dequiv1 : (g |- kd-equiv K4 (pi K1 (\a. K2)))
  | equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
  ; split kd-equiv-pi-form' [g |- Dequiv1] as
    case kd-equiv-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z327 : con |- kind),
      K4 : (g |- kind),
      Dequiv : (g |- kd-equiv K K4),
      Dequiv1 : (g |- kd-equiv K4 (pi K1 (\a. K2))),
      K6 : (g |- kind),
      K7 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K4 (pi K6 (\z327. K7)))
    | equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
    ; by kd-equiv-resp [g |- kind-eq/i ] [g |- Deq] [g |- Dequiv]
      as Dequiv'' unboxed;
      split kd-equiv-pi-form' [g |- Dequiv''] as
      case kd-equiv-pi-form/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g |- kind),
        K2 : (g, z327 : con |- kind),
        K4 : (g |- kind),
        Dequiv : (g |- kd-equiv K K4),
        Dequiv1 : (g |- kd-equiv K4 (pi K1 (\a. K2))),
        K6 : (g |- kind),
        K7 : (g, x774 : con |- kind),
        Deq : (g |- kind-eq K4 (pi K6 (\z327. K7))),
        Dequiv'' : (g |- kd-equiv K (pi K6 (\z327. K7))),
        K9 : (g |- kind),
        K10 : (g, x774 : con |- kind),
        Deq1 : (g |- kind-eq K (pi K9 (\z327. K10)))
      | equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
      ; solve [g |- kd-equiv-pi-form/i K9 (\a. K10) Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv (pi K1 (\a. K2)) K)
  | equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
  ; split kd-equiv-pi-form [g |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z327 : con |- kind),
      Dequiv : (g |- kd-equiv (pi K1 (\a. K2)) K),
      K4 : (g |- kind),
      K5 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K (pi K4 (\z327. K5)))
    | equiv : [g |- kd-equiv K (pi K1 (\a. K2))]
    ; solve [g |- kd-equiv-pi-form/i K4 (\a. K5) Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind+conbind-reg,
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    Dwf : (g |- kd-wf (pi K1 (\a. K2)))
  | equiv : [g |- kd-equiv (pi K1 (\a. K2)) (pi K1 (\a. K2))]
  ; solve [g |- kd-equiv-pi-form/i K1 (\a. K2) (kind-eq/i )]
  }
}
;

LF kd-equiv-sigma-form/e : kind -> type =
| kd-equiv-sigma-form/i :
  { K1' : kind } { K2' : con -> kind }
  kind-eq K (sigma K1' K2') -> kd-equiv-sigma-form/e K
;

proof kd-equiv-sigma-form :
  (g : conbind)
  [g |- kd-equiv (sigma K1 (\a. K2)) K] ->
    [g |- kd-equiv-sigma-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind,
  K : (g |- kind),
  K1 : (g, z328 : con |- kind),
  K2 : (g |- kind)
| equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
; split equiv as
  case kd-equiv/sigma:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K4 : (g |- kind),
    K6 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K K4),
    Dequiv1 :
      (g, a : con, z392 : cn-of a (K[..]) |- kd-equiv (K1[.., a]) (K6[.., a]))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K4 (\z328. K6))]
  ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K2 : (g |- kind),
    K4 : (g |- kind),
    Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K4),
    Dequiv1 : (g |- kd-equiv K4 K2)
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
  ; split kd-equiv-sigma-form [g |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K2 : (g |- kind),
      K4 : (g |- kind),
      Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K4),
      Dequiv1 : (g |- kd-equiv K4 K2),
      K6 : (g |- kind),
      K7 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7)))
    | equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
    ; by kd-equiv-resp [g |- Deq] [g |- kind-eq/i ] [g |- Dequiv1]
      as Dequiv'' unboxed;
      split kd-equiv-sigma-form [g |- Dequiv''] as
      case kd-equiv-sigma-form/i:
      { g : conbind,
        K : (g |- kind),
        K1 : (g, z328 : con |- kind),
        K2 : (g |- kind),
        K4 : (g |- kind),
        Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K4),
        Dequiv1 : (g |- kd-equiv K4 K2),
        K6 : (g |- kind),
        K7 : (g, z776 : con |- kind),
        Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7))),
        Dequiv'' : (g |- kd-equiv (sigma K6 (\z328. K7)) K2),
        K9 : (g |- kind),
        K10 : (g, z776 : con |- kind),
        Deq1 : (g |- kind-eq K2 (sigma K9 (\z328. K10)))
      | equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
      ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv K2 (sigma K (\a. K1)))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
  ; split kd-equiv-sigma-form' [g |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv K2 (sigma K (\a. K1))),
      K4 : (g |- kind),
      K5 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K2 (sigma K4 (\z328. K5)))
    | equiv : [g |- kd-equiv (sigma K (\a. K1)) K2]
    ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    Dwf : (g |- kd-wf (sigma K (\a. K1)))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K (\a. K1))]
  ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
}

and proof kd-equiv-sigma-form' :
  (g : conbind)
  [g |- kd-equiv K (sigma K1 (\a. K2))] ->
    [g |- kd-equiv-sigma-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind,
  K : (g |- kind),
  K1 : (g |- kind),
  K2 : (g, z328 : con |- kind)
| equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
; split equiv as
  case kd-equiv/sigma:
  { g : conbind,
    K3 : (g |- kind),
    K5 : (g, a7 : con |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv K3 K1),
    Dequiv1 :
      (g, a : con, z392 : cn-of a (K3[..]) |-
         kd-equiv (K5[.., a]) (K2[.., a]))
  | equiv : [g |- kd-equiv (sigma K3 (\z328. K5)) (sigma K1 (\a. K2))]
  ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    K4 : (g |- kind),
    Dequiv : (g |- kd-equiv K K4),
    Dequiv1 : (g |- kd-equiv K4 (sigma K1 (\a. K2)))
  | equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
  ; split kd-equiv-sigma-form' [g |- Dequiv1] as
    case kd-equiv-sigma-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z328 : con |- kind),
      K4 : (g |- kind),
      Dequiv : (g |- kd-equiv K K4),
      Dequiv1 : (g |- kd-equiv K4 (sigma K1 (\a. K2))),
      K6 : (g |- kind),
      K7 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7)))
    | equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
    ; by kd-equiv-resp [g |- kind-eq/i ] [g |- Deq] [g |- Dequiv]
      as Dequiv'' unboxed;
      split kd-equiv-sigma-form' [g |- Dequiv''] as
      case kd-equiv-sigma-form/i:
      { g : conbind,
        K : (g |- kind),
        K1 : (g |- kind),
        K2 : (g, z328 : con |- kind),
        K4 : (g |- kind),
        Dequiv : (g |- kd-equiv K K4),
        Dequiv1 : (g |- kd-equiv K4 (sigma K1 (\a. K2))),
        K6 : (g |- kind),
        K7 : (g, z776 : con |- kind),
        Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7))),
        Dequiv'' : (g |- kd-equiv K (sigma K6 (\z328. K7))),
        K9 : (g |- kind),
        K10 : (g, z776 : con |- kind),
        Deq1 : (g |- kind-eq K (sigma K9 (\z328. K10)))
      | equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
      ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv (sigma K1 (\a. K2)) K)
  | equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
  ; split kd-equiv-sigma-form [g |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z328 : con |- kind),
      Dequiv : (g |- kd-equiv (sigma K1 (\a. K2)) K),
      K4 : (g |- kind),
      K5 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K (sigma K4 (\z328. K5)))
    | equiv : [g |- kd-equiv K (sigma K1 (\a. K2))]
    ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind,
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    Dwf : (g |- kd-wf (sigma K1 (\a. K2)))
  | equiv : [g |- kd-equiv (sigma K1 (\a. K2)) (sigma K1 (\a. K2))]
  ; solve [g |- kd-equiv-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
}
;

LF kd-equiv-sing-form/e : kind -> type =
| kd-equiv-sing-form/i :
  { C' : con }
  kind-eq K (sing C') -> kd-equiv-sing-form/e K
;

proof kd-equiv-sing-form :
  (g : conbind)
  [g |- kd-equiv (sing C) K] ->
    [g |- kd-equiv-sing-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, C : (g |- con), K : (g |- kind)
| equiv : [g |- kd-equiv (sing C) K]
; split equiv as
  case kd-equiv/sing:
  { g : conbind,
    C : (g |- con),
    C2 : (g |- con),
    Dequiv : (g |- cn-equiv C C2 t)
  | equiv : [g |- kd-equiv (sing C) (sing C2)]
  ; solve [g |- kd-equiv-sing-form/i _ (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind,
    C : (g |- con),
    K : (g |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv (sing C) K2),
    Dequiv1 : (g |- kd-equiv K2 K)
  | equiv : [g |- kd-equiv (sing C) K]
  ; split kd-equiv-sing-form [g |- Dequiv] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      C : (g |- con),
      K : (g |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv (sing C) K2),
      Dequiv1 : (g |- kd-equiv K2 K),
      C1 : (g |- con),
      Deq : (g |- kind-eq K2 (sing C1))
    | equiv : [g |- kd-equiv (sing C) K]
    ; by kd-equiv-resp [g |- Deq] [g |- kind-eq/i ] [g |- Dequiv1]
      as Dequiv'' unboxed;
      split kd-equiv-sing-form [g |- Dequiv''] as
      case kd-equiv-sing-form/i:
      { g : conbind,
        C : (g |- con),
        K : (g |- kind),
        K2 : (g |- kind),
        Dequiv : (g |- kd-equiv (sing C) K2),
        Dequiv1 : (g |- kd-equiv K2 K),
        C1 : (g |- con),
        Deq : (g |- kind-eq K2 (sing C1)),
        Dequiv'' : (g |- kd-equiv (sing C1) K),
        C2 : (g |- con),
        Deq1 : (g |- kind-eq K (sing C2))
      | equiv : [g |- kd-equiv (sing C) K]
      ; solve [g |- kd-equiv-sing-form/i _ Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind,
    C : (g |- con),
    K : (g |- kind),
    Dequiv : (g |- kd-equiv K (sing C))
  | equiv : [g |- kd-equiv (sing C) K]
  ; split kd-equiv-sing-form' [g |- Dequiv] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      C : (g |- con),
      K : (g |- kind),
      Dequiv : (g |- kd-equiv K (sing C)),
      C1 : (g |- con),
      Deq : (g |- kind-eq K (sing C1))
    | equiv : [g |- kd-equiv (sing C) K]
    ; solve [g |- kd-equiv-sing-form/i _ Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind, C : (g |- con), Dwf : (g |- kd-wf (sing C))
  | equiv : [g |- kd-equiv (sing C) (sing C)]
  ; solve [g |- kd-equiv-sing-form/i _ (kind-eq/i )]
  }
}

and proof kd-equiv-sing-form' :
  (g : conbind)
  [g |- kd-equiv K (sing C)] ->
    [g |- kd-equiv-sing-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, K : (g |- kind), C : (g |- con)
| equiv : [g |- kd-equiv K (sing C)]
; split equiv as
  case kd-equiv/sing:
  { g : conbind,
    C1 : (g |- con),
    C : (g |- con),
    Dequiv : (g |- cn-equiv C1 C t)
  | equiv : [g |- kd-equiv (sing C1) (sing C)]
  ; solve [g |- kd-equiv-sing-form/i _ (kind-eq/i )]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    C : (g |- con),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv K K2),
    Dequiv1 : (g |- kd-equiv K2 (sing C))
  | equiv : [g |- kd-equiv K (sing C)]
  ; split kd-equiv-sing-form' [g |- Dequiv1] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      K : (g |- kind),
      C : (g |- con),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv K K2),
      Dequiv1 : (g |- kd-equiv K2 (sing C)),
      C1 : (g |- con),
      Deq : (g |- kind-eq K2 (sing C1))
    | equiv : [g |- kd-equiv K (sing C)]
    ; by kd-equiv-resp [g |- kind-eq/i ] [g |- Deq] [g |- Dequiv]
      as Dequiv'' unboxed;
      split kd-equiv-sing-form' [g |- Dequiv''] as
      case kd-equiv-sing-form/i:
      { g : conbind,
        K : (g |- kind),
        C : (g |- con),
        K2 : (g |- kind),
        Dequiv : (g |- kd-equiv K K2),
        Dequiv1 : (g |- kd-equiv K2 (sing C)),
        C1 : (g |- con),
        Deq : (g |- kind-eq K2 (sing C1)),
        Dequiv'' : (g |- kd-equiv K (sing C1)),
        C2 : (g |- con),
        Deq1 : (g |- kind-eq K (sing C2))
      | equiv : [g |- kd-equiv K (sing C)]
      ; solve [g |- kd-equiv-sing-form/i _ Deq1]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    C : (g |- con),
    Dequiv : (g |- kd-equiv (sing C) K)
  | equiv : [g |- kd-equiv K (sing C)]
  ; split kd-equiv-sing-form [g |- Dequiv] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      K : (g |- kind),
      C : (g |- con),
      Dequiv : (g |- kd-equiv (sing C) K),
      C1 : (g |- con),
      Deq : (g |- kind-eq K (sing C1))
    | equiv : [g |- kd-equiv K (sing C)]
    ; solve [g |- kd-equiv-sing-form/i _ Deq]
    }
  }
  case kd-equiv/refl:
  { g : conbind, C : (g |- con), Dwf : (g |- kd-wf (sing C))
  | equiv : [g |- kd-equiv (sing C) (sing C)]
  ; solve [g |- kd-equiv-sing-form/i _ (kind-eq/i )]
  }
}
;

LF kd-sub-pi-form/e : kind -> type =
| kd-sub-pi-form/i :
  { K1' : kind } { K2' : con -> kind }
  kind-eq K (pi K1' K2') -> kd-sub-pi-form/e K
;

proof kd-sub-pi-form :
  (g : conbind+conbind-reg)
  [g |- kd-sub (pi K1 (\a. K2)) K] ->
    [g |- kd-sub-pi-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g, z327 : con |- kind),
  K2 : (g |- kind)
| sub : [g |- kd-sub (pi K (\a. K1)) K2]
; split sub as
  case kd-sub/pi:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K3 : (g |- kind),
    K6 : (g, a10 : con |- kind),
    Dsub : (g |- kd-sub K3 K),
    Dsub1 :
      (g, a : con, z395 : cn-of a (K3[..]) |- kd-sub (K1[.., a]) (K6[.., a])),
    Dwf : (g, a : con, x395 : cn-of a (K[..]) |- kd-wf (K1[.., a]))
  | sub : [g |- kd-sub (pi K (\a. K1)) (pi K3 (\z327. K6))]
  ; solve [_ |- kd-sub-pi-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-sub/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K2 : (g |- kind),
    K4 : (g |- kind),
    Dsub : (g |- kd-sub (pi K (\a. K1)) K4),
    Dsub1 : (g |- kd-sub K4 K2)
  | sub : [g |- kd-sub (pi K (\a. K1)) K2]
  ; split kd-sub-pi-form [_ |- Dsub] as
    case kd-sub-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K2 : (g |- kind),
      K4 : (g |- kind),
      Dsub : (g |- kd-sub (pi K (\a. K1)) K4),
      Dsub1 : (g |- kd-sub K4 K2),
      K6 : (g |- kind),
      K7 : (g, y781 : con |- kind),
      Deq : (g |- kind-eq K4 (pi K6 (\z327. K7)))
    | sub : [g |- kd-sub (pi K (\a. K1)) K2]
    ; by kd-sub-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dsub1]
      as Dsub' unboxed;
      split kd-sub-pi-form [_ |- Dsub'] as
      case kd-sub-pi-form/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g, z327 : con |- kind),
        K2 : (g |- kind),
        K4 : (g |- kind),
        Dsub : (g |- kd-sub (pi K (\a. K1)) K4),
        Dsub1 : (g |- kd-sub K4 K2),
        K6 : (g |- kind),
        K7 : (g, y781 : con |- kind),
        Deq : (g |- kind-eq K4 (pi K6 (\z327. K7))),
        Dsub' : (g |- kd-sub (pi K6 (\z327. K7)) K2),
        K9 : (g |- kind),
        K10 : (g, y781 : con |- kind),
        Deq1 : (g |- kind-eq K2 (pi K9 (\z327. K10)))
      | sub : [g |- kd-sub (pi K (\a. K1)) K2]
      ; solve [_ |- kd-sub-pi-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv (pi K (\a. K1)) K2)
  | sub : [g |- kd-sub (pi K (\a. K1)) K2]
  ; split kd-equiv-pi-form [_ |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv (pi K (\a. K1)) K2),
      K4 : (g |- kind),
      K5 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K2 (pi K4 (\z327. K5)))
    | sub : [g |- kd-sub (pi K (\a. K1)) K2]
    ; solve [_ |- kd-sub-pi-form/i _ (\a. _) Deq]
    }
  }
}
;

proof kd-sub-pi-form' :
  (g : conbind+conbind-reg)
  [g |- kd-sub K (pi K1 (\a. K2))] ->
    [g |- kd-sub-pi-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g |- kind),
  K2 : (g, z327 : con |- kind)
| sub : [g |- kd-sub K (pi K1 (\a. K2))]
; split sub as
  case kd-sub/pi:
  { g : conbind+conbind-reg,
    K4 : (g |- kind),
    K5 : (g, a9 : con |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    Dsub : (g |- kd-sub K1 K4),
    Dsub1 :
      (g, a : con, z395 : cn-of a (K1[..]) |- kd-sub (K5[.., a]) (K2[.., a])),
    Dwf : (g, a : con, x395 : cn-of a (K4[..]) |- kd-wf (K5[.., a]))
  | sub : [g |- kd-sub (pi K4 (\z327. K5)) (pi K1 (\a. K2))]
  ; solve [_ |- kd-sub-pi-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-sub/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    K4 : (g |- kind),
    Dsub : (g |- kd-sub K K4),
    Dsub1 : (g |- kd-sub K4 (pi K1 (\a. K2)))
  | sub : [g |- kd-sub K (pi K1 (\a. K2))]
  ; split kd-sub-pi-form' [_ |- Dsub1] as
    case kd-sub-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z327 : con |- kind),
      K4 : (g |- kind),
      Dsub : (g |- kd-sub K K4),
      Dsub1 : (g |- kd-sub K4 (pi K1 (\a. K2))),
      K6 : (g |- kind),
      K7 : (g, y781 : con |- kind),
      Deq : (g |- kind-eq K4 (pi K6 (\z327. K7)))
    | sub : [g |- kd-sub K (pi K1 (\a. K2))]
    ; by kd-sub-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dsub]
      as Dsub' unboxed;
      split kd-sub-pi-form' [_ |- Dsub'] as
      case kd-sub-pi-form/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g |- kind),
        K2 : (g, z327 : con |- kind),
        K4 : (g |- kind),
        Dsub : (g |- kd-sub K K4),
        Dsub1 : (g |- kd-sub K4 (pi K1 (\a. K2))),
        K6 : (g |- kind),
        K7 : (g, y781 : con |- kind),
        Deq : (g |- kind-eq K4 (pi K6 (\z327. K7))),
        Dsub' : (g |- kd-sub K (pi K6 (\z327. K7))),
        K9 : (g |- kind),
        K10 : (g, y781 : con |- kind),
        Deq1 : (g |- kind-eq K (pi K9 (\z327. K10)))
      | sub : [g |- kd-sub K (pi K1 (\a. K2))]
      ; solve [_ |- kd-sub-pi-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv K (pi K1 (\a. K2)))
  | sub : [g |- kd-sub K (pi K1 (\a. K2))]
  ; split kd-equiv-pi-form' [_ |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z327 : con |- kind),
      Dequiv : (g |- kd-equiv K (pi K1 (\a. K2))),
      K4 : (g |- kind),
      K5 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K (pi K4 (\z327. K5)))
    | sub : [g |- kd-sub K (pi K1 (\a. K2))]
    ; solve [_ |- kd-sub-pi-form/i _ (\a. _) Deq]
    }
  }
}
;

LF kd-sub-sigma-form/e : kind -> type =
| kd-sub-sigma-form/i :
  { K1' : kind } { K2' : con -> kind }
  kind-eq K (sigma K1' K2') -> kd-sub-sigma-form/e K
;

proof kd-sub-sigma-form :
  (g : conbind+conbind-reg)
  [g |- kd-sub (sigma K1 (\a. K2)) K] ->
    [g |- kd-sub-sigma-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g, z328 : con |- kind),
  K2 : (g |- kind)
| sub : [g |- kd-sub (sigma K (\a. K1)) K2]
; split sub as
  case kd-sub/sigma:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K4 : (g |- kind),
    K6 : (g, a12 : con |- kind),
    Dsub : (g |- kd-sub K K4),
    Dsub1 :
      (g, a : con, x397 : cn-of a (K[..]) |- kd-sub (K1[.., a]) (K6[.., a])),
    Dwf : (g, a : con, y397 : cn-of a (K4[..]) |- kd-wf (K6[.., a]))
  | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K4 (\z328. K6))]
  ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-sub/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K2 : (g |- kind),
    K4 : (g |- kind),
    Dsub : (g |- kd-sub (sigma K (\a. K1)) K4),
    Dsub1 : (g |- kd-sub K4 K2)
  | sub : [g |- kd-sub (sigma K (\a. K1)) K2]
  ; split kd-sub-sigma-form [_ |- Dsub] as
    case kd-sub-sigma-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K2 : (g |- kind),
      K4 : (g |- kind),
      Dsub : (g |- kd-sub (sigma K (\a. K1)) K4),
      Dsub1 : (g |- kd-sub K4 K2),
      K6 : (g |- kind),
      K7 : (g, x786 : con |- kind),
      Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7)))
    | sub : [g |- kd-sub (sigma K (\a. K1)) K2]
    ; by kd-sub-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dsub1]
      as Dsub' unboxed;
      split kd-sub-sigma-form [_ |- Dsub'] as
      case kd-sub-sigma-form/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g, z328 : con |- kind),
        K2 : (g |- kind),
        K4 : (g |- kind),
        Dsub : (g |- kd-sub (sigma K (\a. K1)) K4),
        Dsub1 : (g |- kd-sub K4 K2),
        K6 : (g |- kind),
        K7 : (g, x786 : con |- kind),
        Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7))),
        Dsub' : (g |- kd-sub (sigma K6 (\z328. K7)) K2),
        K9 : (g |- kind),
        K10 : (g, x786 : con |- kind),
        Deq1 : (g |- kind-eq K2 (sigma K9 (\z328. K10)))
      | sub : [g |- kd-sub (sigma K (\a. K1)) K2]
      ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K2)
  | sub : [g |- kd-sub (sigma K (\a. K1)) K2]
  ; split kd-equiv-sigma-form [_ |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K2),
      K4 : (g |- kind),
      K5 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K2 (sigma K4 (\z328. K5)))
    | sub : [g |- kd-sub (sigma K (\a. K1)) K2]
    ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) Deq]
    }
  }
}
;

proof kd-sub-sigma-form' :
  (g : conbind+conbind-reg)
  [g |- kd-sub K (sigma K1 (\a. K2))] ->
    [g |- kd-sub-sigma-form/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g |- kind),
  K2 : (g, z328 : con |- kind)
| sub : [g |- kd-sub K (sigma K1 (\a. K2))]
; split sub as
  case kd-sub/sigma:
  { g : conbind+conbind-reg,
    K3 : (g |- kind),
    K5 : (g, a11 : con |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    Dsub : (g |- kd-sub K3 K1),
    Dsub1 :
      (g, a : con, x397 : cn-of a (K3[..]) |- kd-sub (K5[.., a]) (K2[.., a])),
    Dwf : (g, a : con, y397 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | sub : [g |- kd-sub (sigma K3 (\z328. K5)) (sigma K1 (\a. K2))]
  ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) (kind-eq/i )]
  }
  case kd-sub/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    K4 : (g |- kind),
    Dsub : (g |- kd-sub K K4),
    Dsub1 : (g |- kd-sub K4 (sigma K1 (\a. K2)))
  | sub : [g |- kd-sub K (sigma K1 (\a. K2))]
  ; split kd-sub-sigma-form' [_ |- Dsub1] as
    case kd-sub-sigma-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z328 : con |- kind),
      K4 : (g |- kind),
      Dsub : (g |- kd-sub K K4),
      Dsub1 : (g |- kd-sub K4 (sigma K1 (\a. K2))),
      K6 : (g |- kind),
      K7 : (g, x786 : con |- kind),
      Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7)))
    | sub : [g |- kd-sub K (sigma K1 (\a. K2))]
    ; by kd-sub-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dsub]
      as Dsub' unboxed;
      split kd-sub-sigma-form' [_ |- Dsub'] as
      case kd-sub-sigma-form/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g |- kind),
        K2 : (g, z328 : con |- kind),
        K4 : (g |- kind),
        Dsub : (g |- kd-sub K K4),
        Dsub1 : (g |- kd-sub K4 (sigma K1 (\a. K2))),
        K6 : (g |- kind),
        K7 : (g, x786 : con |- kind),
        Deq : (g |- kind-eq K4 (sigma K6 (\z328. K7))),
        Dsub' : (g |- kd-sub K (sigma K6 (\z328. K7))),
        K9 : (g |- kind),
        K10 : (g, x786 : con |- kind),
        Deq1 : (g |- kind-eq K (sigma K9 (\z328. K10)))
      | sub : [g |- kd-sub K (sigma K1 (\a. K2))]
      ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) Deq1]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv K (sigma K1 (\a. K2)))
  | sub : [g |- kd-sub K (sigma K1 (\a. K2))]
  ; split kd-equiv-sigma-form' [_ |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K2 : (g, z328 : con |- kind),
      Dequiv : (g |- kd-equiv K (sigma K1 (\a. K2))),
      K4 : (g |- kind),
      K5 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K (sigma K4 (\z328. K5)))
    | sub : [g |- kd-sub K (sigma K1 (\a. K2))]
    ; solve [_ |- kd-sub-sigma-form/i _ (\a. _) Deq]
    }
  }
}
;

LF kd-sub-sing-form'/e : kind -> type =
| kd-sub-sing-form'/i :
  { C' : con }
  kind-eq K (sing C') -> kd-sub-sing-form'/e K
;

proof kd-sub-sing-form' :
  (g : conblock+conbind)
  [g |- kd-sub K (sing C)] ->
    [g |- kd-sub-sing-form'/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : conblock+conbind, K : (g |- kind), C : (g |- con)
| sub : [g |- kd-sub K (sing C)]
; split sub as
  case kd-sub/trans:
  { g : conblock+conbind,
    K : (g |- kind),
    C : (g |- con),
    K2 : (g |- kind),
    Dsub : (g |- kd-sub K K2),
    Dsub1 : (g |- kd-sub K2 (sing C))
  | sub : [g |- kd-sub K (sing C)]
  ; split kd-sub-sing-form' [_ |- Dsub1] as
    case kd-sub-sing-form'/i:
    { g : conblock+conbind,
      K : (g |- kind),
      C : (g |- con),
      K2 : (g |- kind),
      Dsub : (g |- kd-sub K K2),
      Dsub1 : (g |- kd-sub K2 (sing C)),
      C1 : (g |- con),
      Deq : (g |- kind-eq K2 (sing C1))
    | sub : [g |- kd-sub K (sing C)]
    ; by kd-sub-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dsub]
      as Dsub' unboxed;
      split kd-sub-sing-form' [_ |- Dsub'] as
      case kd-sub-sing-form'/i:
      { g : conblock+conbind,
        K : (g |- kind),
        C : (g |- con),
        K2 : (g |- kind),
        Dsub : (g |- kd-sub K K2),
        Dsub1 : (g |- kd-sub K2 (sing C)),
        C1 : (g |- con),
        Deq : (g |- kind-eq K2 (sing C1)),
        Dsub' : (g |- kd-sub K (sing C1)),
        C2 : (g |- con),
        Deq1 : (g |- kind-eq K (sing C2))
      | sub : [g |- kd-sub K (sing C)]
      ; solve [_ |- kd-sub-sing-form'/i _ Deq1]
      }
    }
  }
  case kd-sub/refl:
  { g : conblock+conbind,
    K : (g |- kind),
    C : (g |- con),
    Dequiv : (g |- kd-equiv K (sing C))
  | sub : [g |- kd-sub K (sing C)]
  ; split kd-equiv-sing-form' [_ |- Dequiv] as
    case kd-equiv-sing-form/i:
    { g : conblock+conbind,
      K : (g |- kind),
      C : (g |- con),
      Dequiv : (g |- kd-equiv K (sing C)),
      C1 : (g |- con),
      Deq : (g |- kind-eq K (sing C1))
    | sub : [g |- kd-sub K (sing C)]
    ; solve [_ |- kd-sub-sing-form'/i _ Deq]
    }
  }
}
;

proof injective-sing :
  (g : conbind)
  [g |- kd-equiv (sing C) (sing C')] ->
    [g |- cn-equiv C C' t] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, C : (g |- con), C' : (g |- con)
| equiv : [g |- kd-equiv (sing C) (sing C')]
; split equiv as
  case kd-equiv/sing:
  { g : conbind,
    C : (g |- con),
    C' : (g |- con),
    Dequiv : (g |- cn-equiv C C' t)
  | equiv : [g |- kd-equiv (sing C) (sing C')]
  ; solve [g |- Dequiv]
  }
  case kd-equiv/trans:
  { g : conbind,
    C : (g |- con),
    C' : (g |- con),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv (sing C) K1),
    Dequiv1 : (g |- kd-equiv K1 (sing C'))
  | equiv : [g |- kd-equiv (sing C) (sing C')]
  ; split kd-equiv-sing-form [_ |- Dequiv] as
    case kd-equiv-sing-form/i:
    { g : conbind,
      C : (g |- con),
      C' : (g |- con),
      K1 : (g |- kind),
      Dequiv : (g |- kd-equiv (sing C) K1),
      Dequiv1 : (g |- kd-equiv K1 (sing C')),
      C1 : (g |- con),
      Deq : (g |- kind-eq K1 (sing C1))
    | equiv : [g |- kd-equiv (sing C) (sing C')]
    ; by kd-equiv-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dequiv]
      as D12' unboxed;
      by kd-equiv-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dequiv1]
      as D23' unboxed;
      by injective-sing [_ |- D12'] as D12'' unboxed;
      by injective-sing [_ |- D23'] as D23'' unboxed;
      solve [_ |- cn-equiv/trans D12'' D23'']
    }
  }
  case kd-equiv/symm:
  { g : conbind,
    C : (g |- con),
    C' : (g |- con),
    Dequiv : (g |- kd-equiv (sing C') (sing C))
  | equiv : [g |- kd-equiv (sing C) (sing C')]
  ; by injective-sing [_ |- Dequiv] as D' unboxed;
    solve [_ |- cn-equiv/symm D']
  }
  case kd-equiv/refl:
  { g : conbind, C' : (g |- con), Dwf : (g |- kd-wf (sing C'))
  | equiv : [g |- kd-equiv (sing C') (sing C')]
  ; split [_ |- Dwf] as
    case kd-wf/sing:
    { g : conbind, C' : (g |- con), Dof : (g |- cn-of C' t)
    | equiv : [g |- kd-equiv (sing C') (sing C')]
    ; solve [_ |- cn-equiv/refl Dof]
    }
  }
}
;

LF injective-pi/e : kind -> (con -> kind) -> kind -> (con -> kind) -> type =
| injective-pi/i :
  kd-equiv K1 K1' ->
  ({ a : con } cn-of a K1 -> kd-equiv (K2 a) (K2' a)) ->
    injective-pi/e K1 K2 K1' K2'
;

proof injective-pi :
  (g : conbind-reg)
  [g |- kd-equiv (pi K1 (\a. K2)) (pi K1' (\a. K2'))] ->
    [g |- injective-pi/e K1 (\a. K2) K1' (\a. K2')] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind-reg,
  K : (g |- kind),
  K1 : (g, z327 : con |- kind),
  K1' : (g |- kind),
  K2' : (g, z327 : con |- kind)
| equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
; split equiv as
  case kd-equiv/pi:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv K K1'),
    Dequiv1 :
      (g, a : con, z391 : cn-of a (K[..]) |-
         kd-equiv (K1[.., a]) (K2'[.., a]))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
  ; solve [_ |- injective-pi/i Dequiv (\a. \da. Dequiv1)]
  }
  case kd-equiv/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv (pi K (\a. K1)) K3),
    Dequiv1 : (g |- kd-equiv K3 (pi K1' (\a. K2')))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
  ; split kd-equiv-pi-form [_ |- Dequiv] as
    case kd-equiv-pi-form/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z327 : con |- kind),
      K3 : (g |- kind),
      Dequiv : (g |- kd-equiv (pi K (\a. K1)) K3),
      Dequiv1 : (g |- kd-equiv K3 (pi K1' (\a. K2'))),
      K5 : (g |- kind),
      K6 : (g, x774 : con |- kind),
      Deq : (g |- kind-eq K3 (pi K5 (\z327. K6)))
    | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
    ; by kd-equiv-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dequiv]
      as DequivAB' unboxed;
      by kd-equiv-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dequiv1]
      as DequivBC' unboxed;
      split injective-pi [_ |- DequivAB'] as
      case injective-pi/i:
      { g : conbind-reg,
        K : (g |- kind),
        K1 : (g, z327 : con |- kind),
        K1' : (g |- kind),
        K2' : (g, z327 : con |- kind),
        K3 : (g |- kind),
        Dequiv : (g |- kd-equiv (pi K (\a. K1)) K3),
        Dequiv1 : (g |- kd-equiv K3 (pi K1' (\a. K2'))),
        K5 : (g |- kind),
        K6 : (g, x774 : con |- kind),
        Deq : (g |- kind-eq K3 (pi K5 (\z327. K6))),
        DequivAB' : (g |- kd-equiv (pi K (\a. K1)) (pi K5 (\z327. K6))),
        DequivBC' : (g |- kd-equiv (pi K5 (\z327. K6)) (pi K1' (\a. K2'))),
        Dequiv2 : (g |- kd-equiv K K5),
        Dequiv3 :
          (g, a : con, z799 : cn-of a (K[..]) |-
             kd-equiv (K1[.., a]) (K6[.., a]))
      | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
      ; split injective-pi [_ |- DequivBC'] as
        case injective-pi/i:
        { g : conbind-reg,
          K : (g |- kind),
          K1 : (g, z327 : con |- kind),
          K1' : (g |- kind),
          K2' : (g, z327 : con |- kind),
          K3 : (g |- kind),
          Dequiv : (g |- kd-equiv (pi K (\a. K1)) K3),
          Dequiv1 : (g |- kd-equiv K3 (pi K1' (\a. K2'))),
          K5 : (g |- kind),
          K6 : (g, x774 : con |- kind),
          Deq : (g |- kind-eq K3 (pi K5 (\z327. K6))),
          DequivAB' : (g |- kd-equiv (pi K (\a. K1)) (pi K5 (\z327. K6))),
          DequivBC' : (g |- kd-equiv (pi K5 (\z327. K6)) (pi K1' (\a. K2'))),
          Dequiv2 : (g |- kd-equiv K K5),
          Dequiv3 :
            (g, a : con, z799 : cn-of a (K[..]) |-
               kd-equiv (K1[.., a]) (K6[.., a])),
          Dequiv4 : (g |- kd-equiv K5 K1'),
          Dequiv5 :
            (g, a : con, z799 : cn-of a (K5[..]) |-
               kd-equiv (K6[.., a]) (K2'[.., a]))
        | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
        ; by [_ |- kd-equiv/trans Dequiv2 Dequiv4] as Dequiv1' unboxed;
          by [_, a : con, z799 : cn-of a (K[..]) |-
                kd-equiv/trans Dequiv3 (Dequiv5[.., a, _])]
          as Dequiv2' unboxed;
          solve [_ |- injective-pi/i Dequiv1' (\a. \da. Dequiv2')]
        }
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv (pi K1' (\a. K2')) (pi K (\a. K1)))
  | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
  ; split injective-pi [_ |- Dequiv] as
    case injective-pi/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z327 : con |- kind),
      Dequiv : (g |- kd-equiv (pi K1' (\a. K2')) (pi K (\a. K1))),
      Dequiv1 : (g |- kd-equiv K1' K),
      Dequiv2 :
        (g, a : con, z799 : cn-of a (K1'[..]) |-
           kd-equiv (K2'[.., a]) (K1[.., a]))
    | equiv : [g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))]
    ; by [_ |- kd-equiv/symm Dequiv1] as Dequiv1' unboxed;
      by [_, a : con, z799 : cn-of a (K1'[..]) |- kd-equiv/symm Dequiv2]
      as Dequiv2' unboxed;
      solve [_ |- injective-pi/i Dequiv1' (\a. \da. Dequiv2'[.., a, _])]
    }
  }
  case kd-equiv/refl:
  { g : conbind-reg,
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    Dwf : (g |- kd-wf (pi K1' (\a. K2')))
  | equiv : [g |- kd-equiv (pi K1' (\a. K2')) (pi K1' (\a. K2'))]
  ; split [_ |- Dwf] as
    case kd-wf/pi:
    { g : conbind-reg,
      K1' : (g |- kind),
      K2' : (g, z327 : con |- kind),
      Dwf1 : (g |- kd-wf K1'),
      Dwf2 : (g, a : con, y388 : cn-of a (K1'[..]) |- kd-wf (K2'[.., a]))
    | equiv : [g |- kd-equiv (pi K1' (\a. K2')) (pi K1' (\a. K2'))]
    ; by [_ |- kd-equiv/refl Dwf1] as Dequiv1' unboxed;
      by [_, a : con, y388 : cn-of a (K1'[..]) |- kd-equiv/refl Dwf2]
      as Dequiv2' unboxed;
      solve [_ |- injective-pi/i Dequiv1' (\a. \da. Dequiv2'[.., a, _])]
    }
  }
}
;

LF injective-sigma/e : kind -> (con -> kind) -> kind -> (con -> kind) -> type =
| injective-sigma/i :
  kd-equiv K1 K1' ->
  ({ a : con } cn-of a K1 -> kd-equiv (K2 a) (K2' a)) ->
    injective-sigma/e K1 K2 K1' K2'
;

proof injective-sigma :
  (g : conbind+conbind-reg)
  [g |- kd-equiv (sigma K1 (\a. K2)) (sigma K1' (\a. K2'))] ->
    [g |- injective-sigma/e K1 (\a. K2) K1' (\a. K2')] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind+conbind-reg,
  K : (g |- kind),
  K1 : (g, z328 : con |- kind),
  K1' : (g |- kind),
  K2' : (g, z328 : con |- kind)
| equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
; split equiv as
  case kd-equiv/sigma:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv K K1'),
    Dequiv1 :
      (g, a : con, z392 : cn-of a (K[..]) |-
         kd-equiv (K1[.., a]) (K2'[.., a]))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
  ; solve [_ |- injective-sigma/i Dequiv (\a. \da. Dequiv1)]
  }
  case kd-equiv/trans:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K3),
    Dequiv1 : (g |- kd-equiv K3 (sigma K1' (\a. K2')))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
  ; split kd-equiv-sigma-form [_ |- Dequiv] as
    case kd-equiv-sigma-form/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z328 : con |- kind),
      K3 : (g |- kind),
      Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K3),
      Dequiv1 : (g |- kd-equiv K3 (sigma K1' (\a. K2'))),
      K5 : (g |- kind),
      K6 : (g, z776 : con |- kind),
      Deq : (g |- kind-eq K3 (sigma K5 (\z328. K6)))
    | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
    ; by kd-equiv-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dequiv]
      as DequivAB' unboxed;
      by kd-equiv-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dequiv1]
      as DequivBC' unboxed;
      split injective-sigma [_ |- DequivAB'] as
      case injective-sigma/i:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g, z328 : con |- kind),
        K1' : (g |- kind),
        K2' : (g, z328 : con |- kind),
        K3 : (g |- kind),
        Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K3),
        Dequiv1 : (g |- kd-equiv K3 (sigma K1' (\a. K2'))),
        K5 : (g |- kind),
        K6 : (g, z776 : con |- kind),
        Deq : (g |- kind-eq K3 (sigma K5 (\z328. K6))),
        DequivAB' : (g |- kd-equiv (sigma K (\a. K1)) (sigma K5 (\z328. K6))),
        DequivBC' :
          (g |- kd-equiv (sigma K5 (\z328. K6)) (sigma K1' (\a. K2'))),
        Dequiv2 : (g |- kd-equiv K K5),
        Dequiv3 :
          (g, a : con, z805 : cn-of a (K[..]) |-
             kd-equiv (K1[.., a]) (K6[.., a]))
      | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
      ; split injective-sigma [_ |- DequivBC'] as
        case injective-sigma/i:
        { g : conbind+conbind-reg,
          K : (g |- kind),
          K1 : (g, z328 : con |- kind),
          K1' : (g |- kind),
          K2' : (g, z328 : con |- kind),
          K3 : (g |- kind),
          Dequiv : (g |- kd-equiv (sigma K (\a. K1)) K3),
          Dequiv1 : (g |- kd-equiv K3 (sigma K1' (\a. K2'))),
          K5 : (g |- kind),
          K6 : (g, z776 : con |- kind),
          Deq : (g |- kind-eq K3 (sigma K5 (\z328. K6))),
          DequivAB' :
            (g |- kd-equiv (sigma K (\a. K1)) (sigma K5 (\z328. K6))),
          DequivBC' :
            (g |- kd-equiv (sigma K5 (\z328. K6)) (sigma K1' (\a. K2'))),
          Dequiv2 : (g |- kd-equiv K K5),
          Dequiv3 :
            (g, a : con, z805 : cn-of a (K[..]) |-
               kd-equiv (K1[.., a]) (K6[.., a])),
          Dequiv4 : (g |- kd-equiv K5 K1'),
          Dequiv5 :
            (g, a : con, z805 : cn-of a (K5[..]) |-
               kd-equiv (K6[.., a]) (K2'[.., a]))
        | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
        ; by [_ |- kd-equiv/trans Dequiv2 Dequiv4] as Dequiv1' unboxed;
          by [_, a : con, z805 : cn-of a (K[..]) |-
                kd-equiv/trans Dequiv3 (Dequiv5[.., a, _])]
          as Dequiv2' unboxed;
          solve [_ |- injective-sigma/i Dequiv1' (\a. \da. Dequiv2')]
        }
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind+conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv (sigma K1' (\a. K2')) (sigma K (\a. K1)))
  | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
  ; split injective-sigma [_ |- Dequiv] as
    case injective-sigma/i:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z328 : con |- kind),
      Dequiv : (g |- kd-equiv (sigma K1' (\a. K2')) (sigma K (\a. K1))),
      Dequiv1 : (g |- kd-equiv K1' K),
      Dequiv2 :
        (g, a : con, z805 : cn-of a (K1'[..]) |-
           kd-equiv (K2'[.., a]) (K1[.., a]))
    | equiv : [g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
    ; by [_ |- kd-equiv/symm Dequiv1] as Dequiv1' unboxed;
      by [_, a : con, z805 : cn-of a (K1'[..]) |- kd-equiv/symm Dequiv2]
      as Dequiv2' unboxed;
      solve [_ |- injective-sigma/i Dequiv1' (\a. \da. Dequiv2'[.., a, _])]
    }
  }
  case kd-equiv/refl:
  { g : conbind+conbind-reg,
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    Dwf : (g |- kd-wf (sigma K1' (\a. K2')))
  | equiv : [g |- kd-equiv (sigma K1' (\a. K2')) (sigma K1' (\a. K2'))]
  ; split [_ |- Dwf] as
    case kd-wf/sigma:
    { g : conbind+conbind-reg,
      K1' : (g |- kind),
      K2' : (g, z328 : con |- kind),
      Dwf1 : (g |- kd-wf K1'),
      Dwf2 : (g, a : con, y389 : cn-of a (K1'[..]) |- kd-wf (K2'[.., a]))
    | equiv : [g |- kd-equiv (sigma K1' (\a. K2')) (sigma K1' (\a. K2'))]
    ; by [_ |- kd-equiv/refl Dwf1] as Dequiv1' unboxed;
      by [_, a : con, y389 : cn-of a (K1'[..]) |- kd-equiv/refl Dwf2]
      as Dequiv2' unboxed;
      solve [_ |- injective-sigma/i Dequiv1' (\a. \da. Dequiv2'[.., a, _])]
    }
  }
}
;

LF kd-sub-pi-invert/e : kind -> (con -> kind) -> kind -> (con -> kind) -> type =
| kd-sub-pi-invert/i :
  kd-sub K1' K1 ->
  ({ a : con } cn-of a K1' -> kd-sub (K2 a) (K2' a)) ->
  ({ a : con } cn-of a K1 -> kd-wf (K2 a)) ->
    kd-sub-pi-invert/e K1 K2 K1' K2'
;

proof kd-sub-pi-invert :
  (g : conbind-reg)
  [g |- kd-sub (pi K1 (\a. K2)) (pi K1' (\a. K2'))] ->
    [g |- kd-sub-pi-invert/e K1 (\a. K2) K1' (\a. K2')] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind-reg,
  K : (g |- kind),
  K1 : (g, z327 : con |- kind),
  K1' : (g |- kind),
  K2' : (g, z327 : con |- kind)
| sub : [g |- kd-sub (pi K (\a. K1)) (pi K1' (\a. K2'))]
; split sub as
  case kd-sub/pi:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    Dsub : (g |- kd-sub K1' K),
    Dsub1 :
      (g, a : con, z395 : cn-of a (K1'[..]) |-
         kd-sub (K1[.., a]) (K2'[.., a])),
    Dwf : (g, a : con, x395 : cn-of a (K[..]) |- kd-wf (K1[.., a]))
  | sub : [g |- kd-sub (pi K (\a. K1)) (pi K1' (\a. K2'))]
  ; solve [_ |- kd-sub-pi-invert/i Dsub (\a. \da. Dsub1) (\a. \da. Dwf)]
  }
  case kd-sub/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    K3 : (g |- kind),
    Dsub : (g |- kd-sub (pi K (\a. K1)) K3),
    Dsub1 : (g |- kd-sub K3 (pi K1' (\a. K2')))
  | sub : [g |- kd-sub (pi K (\a. K1)) (pi K1' (\a. K2'))]
  ; split kd-sub-pi-form [g |- Dsub] as
    case kd-sub-pi-form/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z327 : con |- kind),
      K3 : (g |- kind),
      Dsub : (g |- kd-sub (pi K (\a. K1)) K3),
      Dsub1 : (g |- kd-sub K3 (pi K1' (\a. K2'))),
      K5 : (g |- kind),
      K6 : (g, y781 : con |- kind),
      Deq : (g |- kind-eq K3 (pi K5 (\z327. K6)))
    | sub : [g |- kd-sub (pi K (\a. K1)) (pi K1' (\a. K2'))]
    ; by kd-sub-resp [g |- kind-eq/i ] [g |- Deq] [g |- Dsub]
      as DsubAB' unboxed;
      by kd-sub-resp [g |- Deq] [g |- kind-eq/i ] [g |- Dsub1]
      as DsubBC' unboxed;
      split kd-sub-pi-invert [g |- DsubAB'] as
      case kd-sub-pi-invert/i:
      { g : conbind-reg,
        K : (g |- kind),
        K1 : (g, z327 : con |- kind),
        K1' : (g |- kind),
        K2' : (g, z327 : con |- kind),
        K3 : (g |- kind),
        Dsub : (g |- kd-sub (pi K (\a. K1)) K3),
        Dsub1 : (g |- kd-sub K3 (pi K1' (\a. K2'))),
        K5 : (g |- kind),
        K6 : (g, y781 : con |- kind),
        Deq : (g |- kind-eq K3 (pi K5 (\z327. K6))),
        DsubAB' : (g |- kd-sub (pi K (\a. K1)) (pi K5 (\z327. K6))),
        DsubBC' : (g |- kd-sub (pi K5 (\z327. K6)) (pi K1' (\a. K2'))),
        Dsub2 : (g |- kd-sub K5 K),
        Dsub3 :
          (g, a : con, x812 : cn-of a (K5[..]) |-
             kd-sub (K1[.., a]) (K6[.., a])),
        Dwf : (g, a : con, y812 : cn-of a (K[..]) |- kd-wf (K1[.., a]))
      | sub : [g |- kd-sub (pi K (\a. K1)) (pi K1' (\a. K2'))]
      ; split kd-sub-pi-invert [g |- DsubBC'] as
        case kd-sub-pi-invert/i:
        { g : conbind-reg,
          K : (g |- kind),
          K1 : (g, z327 : con |- kind),
          K1' : (g |- kind),
          K2' : (g, z327 : con |- kind),
          K3 : (g |- kind),
          Dsub : (g |- kd-sub (pi K (\a. K1)) K3),
          Dsub1 : (g |- kd-sub K3 (pi K1' (\a. K2'))),
          K5 : (g |- kind),
          K6 : (g, y781 : con |- kind),
          Deq : (g |- kind-eq K3 (pi K5 (\z327. K6))),
          DsubAB' : (g |- kd-sub (pi K (\a. K1)) (pi K5 (\z327. K6))),
          DsubBC' : (g |- kd-sub (pi K5 (\z327. K6)) (pi K1' (\a. K2'))),
          Dsub2 : (g |- kd-sub K5 K),
          Dsub3 :
            (g, a : con, x812 : cn-of a (K5[..]) |-
               kd-sub (K1[.., a]) (K6[.., a])),
          Dwf : (g, a : con, y812 : cn-of a (K[..]) |- kd-wf (K1[.., a])),
          Dsub4 : (g |- kd-sub K1' K5),
          Dsub5 :
            (g, a : con, x812 : cn-of a (K1'[..]) |-
               kd-sub (K6[.., a]) (K2'[.., a])),
          Dwf1 : (g, a : con, y812 : cn-of a (K5[..]) |- kd-wf (K6[.., a]))
        | sub : [g |- kd-sub (pi K (\a. K1)) (pi K1' (\a. K2'))]
        ; by [g |- kd-sub/trans Dsub4 Dsub2] as Dsub1' unboxed;
          by [g, a : con, x812 : cn-of a (K5[..]) |-
                kd-sub/trans Dsub3 (Dsub5[.., a, _])]
          as Dsub2' unboxed;
          solve [g |-
                kd-sub-pi-invert/i Dsub1'
                (\a. \da. Dsub2'[.., a, _]) (\a. \da. Dwf)]
        }
      }
    }
  }
  case kd-sub/refl:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z327 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z327 : con |- kind),
    Dequiv : (g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2')))
  | sub : [g |- kd-sub (pi K (\a. K1)) (pi K1' (\a. K2'))]
  ; split injective-pi [g |- Dequiv] as
    case injective-pi/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g, z327 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z327 : con |- kind),
      Dequiv : (g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))),
      Dequiv1 : (g |- kd-equiv K K1'),
      Dequiv2 :
        (g, a : con, z799 : cn-of a (K[..]) |-
           kd-equiv (K1[.., a]) (K2'[.., a]))
    | sub : [g |- kd-sub (pi K (\a. K1)) (pi K1' (\a. K2'))]
    ; split kd-equiv-reg [g |- Dequiv] as
      case kd-equiv-reg/i:
      { g : conbind-reg,
        K : (g |- kind),
        K1 : (g, z327 : con |- kind),
        K1' : (g |- kind),
        K2' : (g, z327 : con |- kind),
        Dequiv : (g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))),
        Dequiv1 : (g |- kd-equiv K K1'),
        Dequiv2 :
          (g, a : con, z799 : cn-of a (K[..]) |-
             kd-equiv (K1[.., a]) (K2'[.., a])),
        Dwf : (g |- kd-wf (pi K (\a. K1))),
        Dwf1 : (g |- kd-wf (pi K1' (\a. K2')))
      | sub : [g |- kd-sub (pi K (\a. K1)) (pi K1' (\a. K2'))]
      ; by [g |- kd-sub/refl (kd-equiv/symm Dequiv1)] as Dsub1' unboxed;
        by [g, a : con, z799 : cn-of a (K[..]) |- kd-sub/refl Dequiv2]
        as Dsub2' unboxed;
        split [g |- Dwf] as
        case kd-wf/pi:
        { g : conbind-reg,
          K : (g |- kind),
          K1 : (g, z327 : con |- kind),
          K1' : (g |- kind),
          K2' : (g, z327 : con |- kind),
          Dequiv : (g |- kd-equiv (pi K (\a. K1)) (pi K1' (\a. K2'))),
          Dequiv1 : (g |- kd-equiv K K1'),
          Dequiv2 :
            (g, a : con, z799 : cn-of a (K[..]) |-
               kd-equiv (K1[.., a]) (K2'[.., a])),
          Dwf2 : (g |- kd-wf K),
          Dwf3 : (g, a : con, y388 : cn-of a (K[..]) |- kd-wf (K1[.., a])),
          Dwf1 : (g |- kd-wf (pi K1' (\a. K2'))),
          Dsub1' : (g |- kd-sub K1' K),
          Dsub2' :
            (g, a : con, z799 : cn-of a (K[..]) |-
               kd-sub (K1[.., a]) (K2'[.., a]))
        | sub : [g |- kd-sub (pi K (\a. K1)) (pi K1' (\a. K2'))]
        ; solve [g |-
                kd-sub-pi-invert/i Dsub1'
                (\a. \da. Dsub2'[.., a, _]) (\a. \da. Dwf3[.., a, _])]
        }
      }
    }
  }
}
;

LF kd-sub-sigma-invert/e :
  kind -> (con -> kind) -> kind -> (con -> kind) -> type =
| kd-sub-sigma-invert/i :
  kd-sub K1 K1' ->
  ({ a : con } cn-of a K1 -> kd-sub (K2 a) (K2' a)) ->
  ({ a : con } cn-of a K1' -> kd-wf (K2' a)) ->
    kd-sub-sigma-invert/e K1 K2 K1' K2'
;

proof kd-sub-sigma-invert :
  (g : conbind-reg)
  [g |- kd-sub (sigma K1 (\a. K2)) (sigma K1' (\a. K2'))] ->
    [g |- kd-sub-sigma-invert/e K1 (\a. K2) K1' (\a. K2')] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind-reg,
  K : (g |- kind),
  K1 : (g, z328 : con |- kind),
  K1' : (g |- kind),
  K2' : (g, z328 : con |- kind)
| sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
; split sub as
  case kd-sub/sigma:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    Dsub : (g |- kd-sub K K1'),
    Dsub1 :
      (g, a : con, x397 : cn-of a (K[..]) |- kd-sub (K1[.., a]) (K2'[.., a])),
    Dwf : (g, a : con, y397 : cn-of a (K1'[..]) |- kd-wf (K2'[.., a]))
  | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
  ; solve [_ |- kd-sub-sigma-invert/i Dsub (\a. \da. Dsub1) (\a. \da. Dwf)]
  }
  case kd-sub/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    K3 : (g |- kind),
    Dsub : (g |- kd-sub (sigma K (\a. K1)) K3),
    Dsub1 : (g |- kd-sub K3 (sigma K1' (\a. K2')))
  | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
  ; split kd-sub-sigma-form [_ |- Dsub] as
    case kd-sub-sigma-form/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z328 : con |- kind),
      K3 : (g |- kind),
      Dsub : (g |- kd-sub (sigma K (\a. K1)) K3),
      Dsub1 : (g |- kd-sub K3 (sigma K1' (\a. K2'))),
      K5 : (g |- kind),
      K6 : (g, x786 : con |- kind),
      Deq : (g |- kind-eq K3 (sigma K5 (\z328. K6)))
    | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
    ; by kd-sub-resp [_ |- kind-eq/i ] [_ |- Deq] [_ |- Dsub]
      as DsubAB' unboxed;
      by kd-sub-resp [_ |- Deq] [_ |- kind-eq/i ] [_ |- Dsub1]
      as DsubBC' unboxed;
      split kd-sub-sigma-invert [_ |- DsubAB'] as
      case kd-sub-sigma-invert/i:
      { g : conbind-reg,
        K : (g |- kind),
        K1 : (g, z328 : con |- kind),
        K1' : (g |- kind),
        K2' : (g, z328 : con |- kind),
        K3 : (g |- kind),
        Dsub : (g |- kd-sub (sigma K (\a. K1)) K3),
        Dsub1 : (g |- kd-sub K3 (sigma K1' (\a. K2'))),
        K5 : (g |- kind),
        K6 : (g, x786 : con |- kind),
        Deq : (g |- kind-eq K3 (sigma K5 (\z328. K6))),
        DsubAB' : (g |- kd-sub (sigma K (\a. K1)) (sigma K5 (\z328. K6))),
        DsubBC' : (g |- kd-sub (sigma K5 (\z328. K6)) (sigma K1' (\a. K2'))),
        Dsub2 : (g |- kd-sub K K5),
        Dsub3 :
          (g, a : con, z816 : cn-of a (K[..]) |-
             kd-sub (K1[.., a]) (K6[.., a])),
        Dwf : (g, a : con, x816 : cn-of a (K5[..]) |- kd-wf (K6[.., a]))
      | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
      ; split kd-sub-sigma-invert [_ |- DsubBC'] as
        case kd-sub-sigma-invert/i:
        { g : conbind-reg,
          K : (g |- kind),
          K1 : (g, z328 : con |- kind),
          K1' : (g |- kind),
          K2' : (g, z328 : con |- kind),
          K3 : (g |- kind),
          Dsub : (g |- kd-sub (sigma K (\a. K1)) K3),
          Dsub1 : (g |- kd-sub K3 (sigma K1' (\a. K2'))),
          K5 : (g |- kind),
          K6 : (g, x786 : con |- kind),
          Deq : (g |- kind-eq K3 (sigma K5 (\z328. K6))),
          DsubAB' : (g |- kd-sub (sigma K (\a. K1)) (sigma K5 (\z328. K6))),
          DsubBC' :
            (g |- kd-sub (sigma K5 (\z328. K6)) (sigma K1' (\a. K2'))),
          Dsub2 : (g |- kd-sub K K5),
          Dsub3 :
            (g, a : con, z816 : cn-of a (K[..]) |-
               kd-sub (K1[.., a]) (K6[.., a])),
          Dwf : (g, a : con, x816 : cn-of a (K5[..]) |- kd-wf (K6[.., a])),
          Dsub4 : (g |- kd-sub K5 K1'),
          Dsub5 :
            (g, a : con, z816 : cn-of a (K5[..]) |-
               kd-sub (K6[.., a]) (K2'[.., a])),
          Dwf1 : (g, a : con, x816 : cn-of a (K1'[..]) |- kd-wf (K2'[.., a]))
        | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
        ; by [_ |- kd-sub/trans Dsub2 Dsub4] as Dsub1' unboxed;
          by [_, a : con, z816 : cn-of a (K[..]) |-
                kd-sub/trans Dsub3 (Dsub5[.., a, _])]
          as Dsub2' unboxed;
          solve [_ |-
                kd-sub-sigma-invert/i Dsub1'
                (\a. \da. Dsub2'[.., a, _]) (\a. \da. Dwf1)]
        }
      }
    }
  }
  case kd-sub/refl:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, z328 : con |- kind),
    K1' : (g |- kind),
    K2' : (g, z328 : con |- kind),
    Dequiv : (g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2')))
  | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
  ; split injective-sigma [_ |- Dequiv] as
    case injective-sigma/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g, z328 : con |- kind),
      K1' : (g |- kind),
      K2' : (g, z328 : con |- kind),
      Dequiv : (g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))),
      Dequiv1 : (g |- kd-equiv K K1'),
      Dequiv2 :
        (g, a : con, z805 : cn-of a (K[..]) |-
           kd-equiv (K1[.., a]) (K2'[.., a]))
    | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
    ; split kd-equiv-reg [_ |- Dequiv] as
      case kd-equiv-reg/i:
      { g : conbind-reg,
        K : (g |- kind),
        K1 : (g, z328 : con |- kind),
        K1' : (g |- kind),
        K2' : (g, z328 : con |- kind),
        Dequiv : (g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))),
        Dequiv1 : (g |- kd-equiv K K1'),
        Dequiv2 :
          (g, a : con, z805 : cn-of a (K[..]) |-
             kd-equiv (K1[.., a]) (K2'[.., a])),
        Dwf : (g |- kd-wf (sigma K (\a. K1))),
        Dwf1 : (g |- kd-wf (sigma K1' (\a. K2')))
      | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
      ; split [_ |- Dwf1] as
        case kd-wf/sigma:
        { g : conbind-reg,
          K : (g |- kind),
          K1 : (g, z328 : con |- kind),
          K1' : (g |- kind),
          K2' : (g, z328 : con |- kind),
          Dequiv : (g |- kd-equiv (sigma K (\a. K1)) (sigma K1' (\a. K2'))),
          Dequiv1 : (g |- kd-equiv K K1'),
          Dequiv2 :
            (g, a : con, z805 : cn-of a (K[..]) |-
               kd-equiv (K1[.., a]) (K2'[.., a])),
          Dwf : (g |- kd-wf (sigma K (\a. K1))),
          Dwf2 : (g |- kd-wf K1'),
          Dwf3 : (g, a : con, y389 : cn-of a (K1'[..]) |- kd-wf (K2'[.., a]))
        | sub : [g |- kd-sub (sigma K (\a. K1)) (sigma K1' (\a. K2'))]
        ; by [_ |- kd-sub/refl Dequiv1] as Dsub1' unboxed;
          by [_, a : con, z805 : cn-of a (K[..]) |- kd-sub/refl Dequiv2]
          as Dsub2' unboxed;
          solve [_ |-
                kd-sub-sigma-invert/i Dsub1'
                (\a. \da. Dsub2'[.., a, _]) (\a. \da. Dwf3)]
        }
      }
    }
  }
}
;

proof kd-sub-antisymm :
  (g : conbind-reg)
  [g |- kd-sub K1 K2] ->
  [g |- kd-sub K2 K1] ->
    [g |- kd-equiv K1 K2] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind-reg, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-sub K K1], sub : [g |- kd-sub K1 K]
; split x as
  case kd-sub/sigma:
  { g : conbind-reg,
    K2 : (g |- kind),
    K4 : (g, a11 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a12 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, x397 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, y397 : cn-of a (K3[..]) |- kd-wf (K5[.., a]))
  | x : [g |- kd-sub (sigma K2 (\z328. K4)) (sigma K3 (\z328. K5))],
    sub : [g |- kd-sub (sigma K3 (\z328. K5)) (sigma K2 (\z328. K4))]
  ; split kd-sub-sigma-invert sub as
    case kd-sub-sigma-invert/i:
    { g : conbind-reg,
      K2 : (g |- kind),
      K4 : (g, a11 : con |- kind),
      K3 : (g |- kind),
      K5 : (g, a12 : con |- kind),
      Dsub : (g |- kd-sub K2 K3),
      Dsub1 :
        (g, a : con, x397 : cn-of a (K2[..]) |-
           kd-sub (K4[.., a]) (K5[.., a])),
      Dwf : (g, a : con, y397 : cn-of a (K3[..]) |- kd-wf (K5[.., a])),
      Dsub2 : (g |- kd-sub K3 K2),
      Dsub3 :
        (g, a : con, z816 : cn-of a (K3[..]) |-
           kd-sub (K5[.., a]) (K4[.., a])),
      Dwf1 : (g, a : con, x816 : cn-of a (K2[..]) |- kd-wf (K4[.., a]))
    | x : [g |- kd-sub (sigma K2 (\z328. K4)) (sigma K3 (\z328. K5))],
      sub : [g |- kd-sub (sigma K3 (\z328. K5)) (sigma K2 (\z328. K4))]
    ; by kd-sub-antisymm [g |- Dsub] [g |- Dsub2] as Dequiv1 unboxed;
      split kd-sub-reg [g |- Dsub] as
      case kd-sub-reg/i:
      { g : conbind-reg,
        K2 : (g |- kind),
        K4 : (g, a11 : con |- kind),
        K3 : (g |- kind),
        K5 : (g, a12 : con |- kind),
        Dsub : (g |- kd-sub K2 K3),
        Dsub1 :
          (g, a : con, x397 : cn-of a (K2[..]) |-
             kd-sub (K4[.., a]) (K5[.., a])),
        Dwf : (g, a : con, y397 : cn-of a (K3[..]) |- kd-wf (K5[.., a])),
        Dsub2 : (g |- kd-sub K3 K2),
        Dsub3 :
          (g, a : con, z816 : cn-of a (K3[..]) |-
             kd-sub (K5[.., a]) (K4[.., a])),
        Dwf1 : (g, a : con, x816 : cn-of a (K2[..]) |- kd-wf (K4[.., a])),
        Dequiv1 : (g |- kd-equiv K2 K3),
        Dwf2 : (g |- kd-wf K2),
        Dwf3 : (g |- kd-wf K3)
      | x : [g |- kd-sub (sigma K2 (\z328. K4)) (sigma K3 (\z328. K5))],
        sub : [g |- kd-sub (sigma K3 (\z328. K5)) (sigma K2 (\z328. K4))]
      ; by kd-sub-antisymm
             [g, b : block (a : con, da : cn-of a _) |- Dsub1[.., b.1, b.2]]
             [g, b : block (a : con, da : cn-of a _) |- Dsub3[.., b.1, _]]
        as Dequiv2 unboxed;
        solve [g |- kd-equiv/sigma Dequiv1 (\a. \da. Dequiv2[.., <a; _>])]
      }
    }
  }
  case kd-sub/pi:
  { g : conbind-reg,
    K3 : (g |- kind),
    K4 : (g, a9 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a10 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, z395 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, x395 : cn-of a (K3[..]) |- kd-wf (K4[.., a]))
  | x : [g |- kd-sub (pi K3 (\z327. K4)) (pi K2 (\z327. K5))],
    sub : [g |- kd-sub (pi K2 (\z327. K5)) (pi K3 (\z327. K4))]
  ; split kd-sub-pi-invert sub as
    case kd-sub-pi-invert/i:
    { g : conbind-reg,
      K3 : (g |- kind),
      K4 : (g, a9 : con |- kind),
      K2 : (g |- kind),
      K5 : (g, a10 : con |- kind),
      Dsub : (g |- kd-sub K2 K3),
      Dsub1 :
        (g, a : con, z395 : cn-of a (K2[..]) |-
           kd-sub (K4[.., a]) (K5[.., a])),
      Dwf : (g, a : con, x395 : cn-of a (K3[..]) |- kd-wf (K4[.., a])),
      Dsub2 : (g |- kd-sub K3 K2),
      Dsub3 :
        (g, a : con, x812 : cn-of a (K3[..]) |-
           kd-sub (K5[.., a]) (K4[.., a])),
      Dwf1 : (g, a : con, y812 : cn-of a (K2[..]) |- kd-wf (K5[.., a]))
    | x : [g |- kd-sub (pi K3 (\z327. K4)) (pi K2 (\z327. K5))],
      sub : [g |- kd-sub (pi K2 (\z327. K5)) (pi K3 (\z327. K4))]
    ; by kd-sub-antisymm [g |- Dsub2] [g |- Dsub] as Dequiv1 unboxed;
      by kd-sub-antisymm
           [g, b : block (a : con, da : cn-of a _) |- Dsub1[.., b.1, _]]
           [g, b : block (a : con, da : cn-of a _) |- Dsub3[.., b.1, _]]
      as Dequiv2 unboxed;
      solve [g |- kd-equiv/pi Dequiv1 (\a. \da. Dequiv2[.., <a; da>])]
    }
  }
  case kd-sub/sing-t:
  { g : conbind-reg, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-sub (sing C) t], sub : [g |- kd-sub t (sing C)]
  ; by sub as Dsub unboxed;
    split kd-sub-sing-form' [g |- Dsub] as
    case kd-sub-sing-form'/i:
    { g : conbind-reg,
      C : (g |- con),
      Dof : (g |- cn-of C t),
      Dsub : (g |- kd-sub t (sing C)),
      C1 : (g |- con),
      Deq : (g |- kind-eq t (sing C1))
    | x : [g |- kd-sub (sing C) t], sub : [g |- kd-sub t (sing C)]
    ; impossible [g |- Deq]
    }
  }
  case kd-sub/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- kd-sub K K3),
    Dsub1 : (g |- kd-sub K3 K1)
  | x : [g |- kd-sub K K1], sub : [g |- kd-sub K1 K]
  ; by sub as Dsub' unboxed;
    by kd-sub-antisymm [g |- Dsub] [g |- kd-sub/trans Dsub1 Dsub']
    as Dequiv12 unboxed;
    by kd-sub-antisymm [g |- Dsub1] [g |- kd-sub/trans Dsub' Dsub]
    as Dequiv23 unboxed;
    solve [g |- kd-equiv/trans Dequiv12 Dequiv23]
  }
  case kd-sub/refl:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K K1)
  | x : [g |- kd-sub K K1], sub : [g |- kd-sub K1 K]
  ; solve [_ |- Dequiv]
  }
}
;

% Consistency for Signatures

LF similar-sg : sg -> sg -> type =
| similar-sg/one : similar-sg sg/one sg/one
| similar-sg/satom : similar-sg (sg/satom _) (sg/satom _)
| similar-sg/datom : similar-sg (sg/datom _) (sg/datom _)
| similar-sg/sgatom : similar-sg (sg/sgatom _) (sg/sgatom _)
| similar-sg/pi : similar-sg (sg/pi _ _) (sg/pi _ _)
| similar-sg/sigma : similar-sg (sg/sigma _ _) (sg/sigma _ _)
| similar-sg/named : similar-sg (sg/named _ _) (sg/named _ _)
;

proof similar-sg-symm :
  (g : conblock)
  [g |- similar-sg S1 S2] ->
    [g |- similar-sg S2 S1] =
/ total /
intros
{ g : conblock, S : (g |- sg), S1 : (g |- sg)
| x : [g |- similar-sg S S1]
; split x as
  case similar-sg/named:
  { g : conblock,
    L : ( |- name),
    S2 : (g |- sg),
    L1 : ( |- name),
    S3 : (g |- sg)
  | x : [g |- similar-sg (sg/named L[] S2) (sg/named L1[] S3)]
  ; solve [_ |- similar-sg/named ]
  }
  case similar-sg/sigma:
  { g : conblock,
    S2 : (g |- sg),
    S3 : (g, a133 : con |- sg),
    S4 : (g |- sg),
    S5 : (g, a134 : con |- sg)
  | x : [g |- similar-sg (sg/sigma S2 (\x343. S3)) (sg/sigma S4 (\x343. S5))]
  ; solve [_ |- similar-sg/sigma ]
  }
  case similar-sg/pi:
  { g : conblock,
    S2 : (g |- sg),
    S3 : (g, a131 : con |- sg),
    S4 : (g |- sg),
    S5 : (g, a132 : con |- sg)
  | x : [g |- similar-sg (sg/pi S2 (\x342. S3)) (sg/pi S4 (\x342. S5))]
  ; solve [_ |- similar-sg/pi ]
  }
  case similar-sg/sgatom:
  { g : conblock, S2 : (g |- sg), S3 : (g |- sg)
  | x : [g |- similar-sg (sg/sgatom S2) (sg/sgatom S3)]
  ; solve [_ |- similar-sg/sgatom ]
  }
  case similar-sg/datom:
  { g : conblock, C : (g |- con), C1 : (g |- con)
  | x : [g |- similar-sg (sg/datom C) (sg/datom C1)]
  ; solve [_ |- similar-sg/datom ]
  }
  case similar-sg/satom:
  { g : conblock, K : (g |- kind), K1 : (g |- kind)
  | x : [g |- similar-sg (sg/satom K) (sg/satom K1)]
  ; solve [_ |- similar-sg/satom ]
  }
  case similar-sg/one:
  { g : conblock
  | x : [g |- similar-sg sg/one sg/one]
  ; solve x
  }
}
;

proof similar-sg-trans :
  (g : conblock)
  [g |- similar-sg S1 S2] ->
  [g |- similar-sg S2 S3] ->
    [g |- similar-sg S1 S3] =
/ total /
intros
{ g : conblock, S : (g |- sg), S1 : (g |- sg), S2 : (g |- sg)
| x : [g |- similar-sg S S1], x1 : [g |- similar-sg S1 S2]
; split x as
  case similar-sg/named:
  { g : conblock,
    L : ( |- name),
    S3 : (g |- sg),
    L1 : ( |- name),
    S4 : (g |- sg),
    S2 : (g |- sg)
  | x : [g |- similar-sg (sg/named L[] S3) (sg/named L1[] S4)],
    x1 : [g |- similar-sg (sg/named L1[] S4) S2]
  ; split x1 as
    case similar-sg/named:
    { g : conblock,
      L : ( |- name),
      S3 : (g |- sg),
      L1 : ( |- name),
      S4 : (g |- sg),
      L3 : ( |- name),
      S6 : (g |- sg)
    | x : [g |- similar-sg (sg/named L[] S3) (sg/named L1[] S4)],
      x1 : [g |- similar-sg (sg/named L1[] S4) (sg/named L3[] S6)]
    ; solve [_ |- similar-sg/named ]
    }
  }
  case similar-sg/sigma:
  { g : conblock,
    S3 : (g |- sg),
    S4 : (g, a133 : con |- sg),
    S5 : (g |- sg),
    S6 : (g, a134 : con |- sg),
    S2 : (g |- sg)
  | x : [g |- similar-sg (sg/sigma S3 (\x343. S4)) (sg/sigma S5 (\x343. S6))],
    x1 : [g |- similar-sg (sg/sigma S5 (\x343. S6)) S2]
  ; split x1 as
    case similar-sg/sigma:
    { g : conblock,
      S3 : (g |- sg),
      S4 : (g, a133 : con |- sg),
      S5 : (g |- sg),
      S6 : (g, a134 : con |- sg),
      S9 : (g |- sg),
      S10 : (g, a134 : con |- sg)
    | x :
        [g |- similar-sg (sg/sigma S3 (\x343. S4)) (sg/sigma S5 (\x343. S6))],
      x1 :
        [g |- similar-sg (sg/sigma S5 (\x343. S6)) (sg/sigma S9 (\x343. S10))]
    ; solve [_ |- similar-sg/sigma ]
    }
  }
  case similar-sg/pi:
  { g : conblock,
    S3 : (g |- sg),
    S4 : (g, a131 : con |- sg),
    S5 : (g |- sg),
    S6 : (g, a132 : con |- sg),
    S2 : (g |- sg)
  | x : [g |- similar-sg (sg/pi S3 (\x342. S4)) (sg/pi S5 (\x342. S6))],
    x1 : [g |- similar-sg (sg/pi S5 (\x342. S6)) S2]
  ; split x1 as
    case similar-sg/pi:
    { g : conblock,
      S3 : (g |- sg),
      S4 : (g, a131 : con |- sg),
      S5 : (g |- sg),
      S6 : (g, a132 : con |- sg),
      S9 : (g |- sg),
      S10 : (g, a132 : con |- sg)
    | x : [g |- similar-sg (sg/pi S3 (\x342. S4)) (sg/pi S5 (\x342. S6))],
      x1 : [g |- similar-sg (sg/pi S5 (\x342. S6)) (sg/pi S9 (\x342. S10))]
    ; solve [_ |- similar-sg/pi ]
    }
  }
  case similar-sg/sgatom:
  { g : conblock, S3 : (g |- sg), S4 : (g |- sg), S2 : (g |- sg)
  | x : [g |- similar-sg (sg/sgatom S3) (sg/sgatom S4)],
    x1 : [g |- similar-sg (sg/sgatom S4) S2]
  ; split x1 as
    case similar-sg/sgatom:
    { g : conblock, S3 : (g |- sg), S4 : (g |- sg), S6 : (g |- sg)
    | x : [g |- similar-sg (sg/sgatom S3) (sg/sgatom S4)],
      x1 : [g |- similar-sg (sg/sgatom S4) (sg/sgatom S6)]
    ; solve [_ |- similar-sg/sgatom ]
    }
  }
  case similar-sg/datom:
  { g : conblock, C : (g |- con), C1 : (g |- con), S2 : (g |- sg)
  | x : [g |- similar-sg (sg/datom C) (sg/datom C1)],
    x1 : [g |- similar-sg (sg/datom C1) S2]
  ; split x1 as
    case similar-sg/datom:
    { g : conblock, C : (g |- con), C1 : (g |- con), C3 : (g |- con)
    | x : [g |- similar-sg (sg/datom C) (sg/datom C1)],
      x1 : [g |- similar-sg (sg/datom C1) (sg/datom C3)]
    ; solve [_ |- similar-sg/datom ]
    }
  }
  case similar-sg/satom:
  { g : conblock, K : (g |- kind), K1 : (g |- kind), S2 : (g |- sg)
  | x : [g |- similar-sg (sg/satom K) (sg/satom K1)],
    x1 : [g |- similar-sg (sg/satom K1) S2]
  ; split x1 as
    case similar-sg/satom:
    { g : conblock, K : (g |- kind), K1 : (g |- kind), K3 : (g |- kind)
    | x : [g |- similar-sg (sg/satom K) (sg/satom K1)],
      x1 : [g |- similar-sg (sg/satom K1) (sg/satom K3)]
    ; solve [_ |- similar-sg/satom ]
    }
  }
  case similar-sg/one:
  { g : conblock, S2 : (g |- sg)
  | x : [g |- similar-sg sg/one sg/one], x1 : [g |- similar-sg sg/one S2]
  ; solve x1
  }
}
;

proof sg-equiv-similar :
  (g : conbind)
  [g |- sg-equiv S1 S2] ->
    [g |- similar-sg S1 S2] =
/ total 1 /
intros
{ g : conbind, S : (g |- sg), S1 : (g |- sg)
| x : [g |- sg-equiv S S1]
; split x as
  case sg-equiv/named:
  { g : conbind,
    L : ( |- name),
    S2 : (g |- sg),
    S3 : (g |- sg),
    Dequiv : (g |- sg-equiv S2 S3)
  | x : [g |- sg-equiv (sg/named L[] S2) (sg/named L[] S3)]
  ; solve [_ |- similar-sg/named ]
  }
  case sg-equiv/sigma:
  { g : conbind,
    S2 : (g |- sg),
    S4 : (g, a51 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a52 : con |- sg),
    K : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3),
    Dfst : (g |- sg-fst S2 K),
    Dequiv1 :
      (g, a : con, x462 : cn-of a (K[..]) |- sg-equiv (S4[.., a]) (S5[.., a]))
  | x : [g |- sg-equiv (sg/sigma S2 (\x343. S4)) (sg/sigma S3 (\x343. S5))]
  ; solve [_ |- similar-sg/sigma ]
  }
  case sg-equiv/pi:
  { g : conbind,
    S2 : (g |- sg),
    S4 : (g, a49 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a50 : con |- sg),
    K : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3),
    Dfst : (g |- sg-fst S2 K),
    Dequiv1 :
      (g, a : con, y461 : cn-of a (K[..]) |- sg-equiv (S4[.., a]) (S5[.., a]))
  | x : [g |- sg-equiv (sg/pi S2 (\x342. S4)) (sg/pi S3 (\x342. S5))]
  ; solve [_ |- similar-sg/pi ]
  }
  case sg-equiv/sgatom:
  { g : conbind,
    S2 : (g |- sg),
    S3 : (g |- sg),
    Dequiv : (g |- sg-equiv S2 S3)
  | x : [g |- sg-equiv (sg/sgatom S2) (sg/sgatom S3)]
  ; solve [_ |- similar-sg/sgatom ]
  }
  case sg-equiv/datom:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- sg-equiv (sg/datom C) (sg/datom C1)]
  ; solve [_ |- similar-sg/datom ]
  }
  case sg-equiv/satom:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K K1)
  | x : [g |- sg-equiv (sg/satom K) (sg/satom K1)]
  ; solve [_ |- similar-sg/satom ]
  }
  case sg-equiv/trans:
  { g : conbind,
    S : (g |- sg),
    S1 : (g |- sg),
    S3 : (g |- sg),
    Dequiv : (g |- sg-equiv S S3),
    Dequiv1 : (g |- sg-equiv S3 S1)
  | x : [g |- sg-equiv S S1]
  ; by sg-equiv-similar [_ |- Dequiv] as D12' unboxed;
    by sg-equiv-similar [_ |- Dequiv1] as D23' unboxed;
    solve similar-sg-trans [_ |- D12'] [_ |- D23']
  }
  case sg-equiv/symm:
  { g : conbind, S : (g |- sg), S1 : (g |- sg), Dequiv : (g |- sg-equiv S1 S)
  | x : [g |- sg-equiv S S1]
  ; by sg-equiv-similar [_ |- Dequiv] as D' unboxed;
    solve similar-sg-symm [_ |- D']
  }
  case sg-equiv/refl:
  { g : conbind, S1 : (g |- sg), Dwf : (g |- sg-wf S1)
  | x : [g |- sg-equiv S1 S1]
  ; split [_ |- S1] as
    case sg/named:
    { g : conbind,
      L : ( |- name),
      S2 : (g |- sg),
      Dwf : (g |- sg-wf (sg/named L[] S2))
    | x : [g |- sg-equiv (sg/named L[] S2) (sg/named L[] S2)]
    ; solve [_ |- similar-sg/named ]
    }
    case sg/sigma:
    { g : conbind,
      S2 : (g |- sg),
      S3 : (g, x343 : con |- sg),
      Dwf : (g |- sg-wf (sg/sigma S2 (\x343. S3)))
    | x : [g |- sg-equiv (sg/sigma S2 (\x343. S3)) (sg/sigma S2 (\x343. S3))]
    ; solve [_ |- similar-sg/sigma ]
    }
    case sg/pi:
    { g : conbind,
      S2 : (g |- sg),
      S3 : (g, x342 : con |- sg),
      Dwf : (g |- sg-wf (sg/pi S2 (\x342. S3)))
    | x : [g |- sg-equiv (sg/pi S2 (\x342. S3)) (sg/pi S2 (\x342. S3))]
    ; solve [_ |- similar-sg/pi ]
    }
    case sg/sgatom:
    { g : conbind, S2 : (g |- sg), Dwf : (g |- sg-wf (sg/sgatom S2))
    | x : [g |- sg-equiv (sg/sgatom S2) (sg/sgatom S2)]
    ; solve [_ |- similar-sg/sgatom ]
    }
    case sg/datom:
    { g : conbind, C : (g |- con), Dwf : (g |- sg-wf (sg/datom C))
    | x : [g |- sg-equiv (sg/datom C) (sg/datom C)]
    ; solve [_ |- similar-sg/datom ]
    }
    case sg/satom:
    { g : conbind, K : (g |- kind), Dwf : (g |- sg-wf (sg/satom K))
    | x : [g |- sg-equiv (sg/satom K) (sg/satom K)]
    ; solve [_ |- similar-sg/satom ]
    }
    case sg/one:
    { g : conbind, Dwf : (g |- sg-wf sg/one)
    | x : [g |- sg-equiv sg/one sg/one]
    ; solve [_ |- similar-sg/one]
    }
  }
}
;

proof sg-sub-similar :
  (g : conbind)
  [g |- sg-sub S1 S2] ->
    [g |- similar-sg S1 S2] =
/ total 1 /
intros
{ g : conbind, S : (g |- sg), S1 : (g |- sg)
| x : [g |- sg-sub S S1]
; split x as
  case sg-sub/named:
  { g : conbind,
    L : ( |- name),
    S2 : (g |- sg),
    S3 : (g |- sg),
    Dsub : (g |- sg-sub S2 S3)
  | x : [g |- sg-sub (sg/named L[] S2) (sg/named L[] S3)]
  ; solve [_ |- similar-sg/named ]
  }
  case sg-sub/sigma:
  { g : conbind,
    S2 : (g |- sg),
    S4 : (g, a55 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a56 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- sg-sub S2 S3),
    Dfst : (g |- sg-fst S2 K),
    Dsub1 :
      (g, a : con, z468 : cn-of a (K[..]) |- sg-sub (S4[.., a]) (S5[.., a])),
    Dfst1 : (g |- sg-fst S3 K1),
    Dwf : (g, a : con, x468 : cn-of a (K1[..]) |- sg-wf (S5[.., a]))
  | x : [g |- sg-sub (sg/sigma S2 (\x343. S4)) (sg/sigma S3 (\x343. S5))]
  ; solve [_ |- similar-sg/sigma ]
  }
  case sg-sub/pi:
  { g : conbind,
    S3 : (g |- sg),
    S4 : (g, a53 : con |- sg),
    S2 : (g |- sg),
    S5 : (g, a54 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- sg-sub S2 S3),
    Dfst : (g |- sg-fst S2 K),
    Dsub1 :
      (g, a : con, x466 : cn-of a (K[..]) |- sg-sub (S4[.., a]) (S5[.., a])),
    Dfst1 : (g |- sg-fst S3 K1),
    Dwf : (g, a : con, y466 : cn-of a (K1[..]) |- sg-wf (S4[.., a]))
  | x : [g |- sg-sub (sg/pi S3 (\x342. S4)) (sg/pi S2 (\x342. S5))]
  ; solve [_ |- similar-sg/pi ]
  }
  case sg-sub/satom:
  { g : conbind, K : (g |- kind), K1 : (g |- kind), Dsub : (g |- kd-sub K K1)
  | x : [g |- sg-sub (sg/satom K) (sg/satom K1)]
  ; solve [_ |- similar-sg/satom ]
  }
  case sg-sub/trans:
  { g : conbind,
    S : (g |- sg),
    S1 : (g |- sg),
    S3 : (g |- sg),
    Dsub : (g |- sg-sub S S3),
    Dsub1 : (g |- sg-sub S3 S1)
  | x : [g |- sg-sub S S1]
  ; by sg-sub-similar [_ |- Dsub] as D12' unboxed;
    by sg-sub-similar [_ |- Dsub1] as D23' unboxed;
    solve similar-sg-trans [_ |- D12'] [_ |- D23']
  }
  case sg-sub/refl:
  { g : conbind, S : (g |- sg), S1 : (g |- sg), Dequiv : (g |- sg-equiv S S1)
  | x : [g |- sg-sub S S1]
  ; solve sg-equiv-similar [_ |- Dequiv]
  }
}
;
