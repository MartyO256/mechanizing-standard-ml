% Constructor Regularity

schema conbind-reg = some [K : kind, wf : kd-wf K]
                     block (a : con, da : cn-of a K);

proof cn-of/equiv/conbind-reg :
  (g : conbind-reg)
  [g |- cn-of C K] ->
  [g |- kd-equiv K K'] ->
    [g |- cn-of C K'] =
/ total /
intros
{ g : conbind-reg, C : (g |- con), K : (g |- kind), K' : (g |- kind)
| cof : [g |- cn-of C K], equiv : [g |- kd-equiv K K']
; by cof as Dof unboxed;
  by equiv as Dequiv unboxed;
  solve [_ |- cn-of/subsume Dof (kd-sub/refl Dequiv)]
}
;

% FIXME: See issue #1
proof functionality-kd-reg :
  (g : conbind-reg)
  [g, a : con, da : cn-of a K[..] |- kd-wf (K'[.., a])] ->
  [g |- cn-equiv C1 C2 K] ->
  [g |- cn-of C1 K] ->
    [g |- kd-equiv (K'[.., C1]) (K'[.., C2])] =
/ total 1 /
?
;

LF kd-equiv-reg/e : kind -> kind -> type =
| kd-equiv-reg/i : kd-wf K1 -> kd-wf K2 -> kd-equiv-reg/e K1 K2
;

LF kd-sub-reg/e : kind -> kind -> type =
| kd-sub-reg/i : kd-wf K1 -> kd-wf K2 -> kd-sub-reg/e K1 K2
;

LF cn-equiv-reg/e :  con -> con -> kind -> type =
| cn-equiv-reg/i : cn-of C1 K -> cn-of C2 K -> kd-wf K -> cn-equiv-reg/e C1 C2 K
;

proof kd-equiv-reg :
  (g : conbind-reg)
  [g |- kd-equiv K1 K2] ->
    [g |- kd-equiv-reg/e K1 K2] =
/ total 1 /
intros
{ g : conbind-reg, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-equiv K K1]
; split x as
  case kd-equiv/sigma:
  { g : conbind-reg,
    K2 : (g |- kind),
    K4 : (g, a7 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, y404 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (sigma K2 (\y340. K4)) (sigma K3 (\y340. K5))]
  ; split kd-equiv-reg [_ |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K2 : (g |- kind),
      K4 : (g, a7 : con |- kind),
      K3 : (g |- kind),
      K5 : (g, a8 : con |- kind),
      Dequiv : (g |- kd-equiv K2 K3),
      Dequiv1 :
        (g, a : con, y404 : cn-of a (K2[..]) |-
           kd-equiv (K4[.., a]) (K5[.., a])),
      Dwf : (g |- kd-wf K2),
      Dwf1 : (g |- kd-wf K3)
    | x : [g |- kd-equiv (sigma K2 (\y340. K4)) (sigma K3 (\y340. K5))]
    ; split
      kd-equiv-reg
        [_, b : block (a : con, da : cn-of a _) |- Dequiv1[.., b.1, b.2]] as
      case kd-equiv-reg/i:
      { g : conbind-reg,
        K2 : (g |- kind),
        K6 : (g, a : con |- kind),
        K3 : (g |- kind),
        K7 : (g, a : con |- kind),
        Dequiv : (g |- kd-equiv K2 K3),
        Dequiv1 :
          (g, a : con, y404 : cn-of a (K2[..]) |-
             kd-equiv (K6[.., a]) (K7[.., a])),
        Dwf : (g |- kd-wf K2),
        Dwf1 : (g |- kd-wf K3),
        Dwf2 : (g, a : con, z5 : cn-of a (K2[..]) |- kd-wf (K6[.., a])),
        Dwf3 : (g, a : con, y6 : cn-of a (K2[..]) |- kd-wf (K7[.., a]))
      | x : [g |- kd-equiv (sigma K2 (\y340. K6)) (sigma K3 (\y340. K7))]
      ; by [_ |- kd-wf/sigma Dwf (\a. \da. Dwf2)] as Dwf1' unboxed;
        by [g |- kd-wf/sigma Dwf1 (\a. \da. Dwf3[.., a, _])] as Dwf2' unboxed;
        solve [g |- kd-equiv-reg/i Dwf1' Dwf2']
      }
    }
  }
  case kd-equiv/pi:
  { g : conbind-reg,
    K2 : (g |- kind),
    K4 : (g, a5 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, y403 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (pi K2 (\y339. K4)) (pi K3 (\y339. K5))]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K2 : (g |- kind),
      K4 : (g, a5 : con |- kind),
      K3 : (g |- kind),
      K5 : (g, a6 : con |- kind),
      Dequiv : (g |- kd-equiv K2 K3),
      Dequiv1 :
        (g, a : con, y403 : cn-of a (K2[..]) |-
           kd-equiv (K4[.., a]) (K5[.., a])),
      Dwf : (g |- kd-wf K2),
      Dwf1 : (g |- kd-wf K3)
    | x : [g |- kd-equiv (pi K2 (\z349. K4)) (pi K3 (\z349. K5))]
    ; split
      kd-equiv-reg
        [g, b : block (a : con, da : cn-of a (K2[..])) |-
           Dequiv1[.., b.1, b.2]] as
      case kd-equiv-reg/i:
      { g : conbind-reg,
        K2 : (g |- kind),
        K6 : (g, a : con |- kind),
        K3 : (g |- kind),
        K7 : (g, a : con |- kind),
        Dequiv : (g |- kd-equiv K2 K3),
        Dequiv1 :
          (g, a : con, y403 : cn-of a (K2[..]) |-
             kd-equiv (K6[.., a]) (K7[.., a])),
        Dwf : (g |- kd-wf K2),
        Dwf1 : (g |- kd-wf K3),
        Dwf2 : (g, a : con, z1108 : cn-of a (K2[..]) |- kd-wf (K6[.., a])),
        Dwf3 : (g, a : con, y1109 : cn-of a (K2[..]) |- kd-wf (K7[.., a]))
      | x : [g |- kd-equiv (pi K2 (\z349. K6)) (pi K3 (\z349. K7))]
      ; by [g |- kd-wf/pi Dwf (\a. \da. Dwf2)] as Dwf1' unboxed;
        by [g |- kd-wf/pi Dwf1 (\a. \da. Dwf3[.., a, _])] as Dwf2' unboxed;
        solve [g |- kd-equiv-reg/i Dwf1' Dwf2']
      }
    }
  }
  case kd-equiv/sing:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      Dequiv : (g |- cn-equiv C C1 t),
      Dof : (g |- cn-of C t),
      Dof1 : (g |- cn-of C1 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- kd-equiv (sing C) (sing C1)]
    ; solve [g |- kd-equiv-reg/i (kd-wf/sing Dof) (kd-wf/sing Dof1)]
    }
  }
  case kd-equiv/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv K K3),
    Dequiv1 : (g |- kd-equiv K3 K1)
  | x : [g |- kd-equiv K K1]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K3 : (g |- kind),
      Dequiv : (g |- kd-equiv K K3),
      Dequiv1 : (g |- kd-equiv K3 K1),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g |- kd-wf K3)
    | x : [g |- kd-equiv K K1]
    ; split kd-equiv-reg [g |- Dequiv1] as
      case kd-equiv-reg/i:
      { g : conbind-reg,
        K : (g |- kind),
        K1 : (g |- kind),
        K3 : (g |- kind),
        Dequiv : (g |- kd-equiv K K3),
        Dequiv1 : (g |- kd-equiv K3 K1),
        Dwf : (g |- kd-wf K),
        Dwf1 : (g |- kd-wf K3),
        Dwf2 : (g |- kd-wf K3),
        Dwf3 : (g |- kd-wf K1)
      | x : [g |- kd-equiv K K1]
      ; solve [g |- kd-equiv-reg/i Dwf Dwf3]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K1 K)
  | x : [g |- kd-equiv K K1]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- kd-equiv K1 K),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g |- kd-wf K)
    | x : [g |- kd-equiv K K1]
    ; solve [g |- kd-equiv-reg/i Dwf1 Dwf]
    }
  }
  case kd-equiv/refl:
  { g : conbind-reg, K1 : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- kd-equiv K1 K1]
  ; solve [g |- kd-equiv-reg/i Dwf Dwf]
  }
}

and proof kd-sub-reg :
  (g : conbind-reg)
  [g |- kd-sub K1 K2] ->
    [g |- kd-sub-reg/e K1 K2] =
/ total 1 /
intros
{ g : conbind-reg, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-sub K K1]
; split x as
  case kd-sub/sigma:
  { g : conbind-reg,
    K2 : (g |- kind),
    K4 : (g, a11 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a12 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, x419 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, y419 : cn-of a (K3[..]) |- kd-wf (K5[.., a]))
  | x : [g |- kd-sub (sigma K2 (\z350. K4)) (sigma K3 (\z350. K5))]
  ; split kd-sub-reg [g |- Dsub] as
    case kd-sub-reg/i:
    { g : conbind-reg,
      K2 : (g |- kind),
      K4 : (g, a11 : con |- kind),
      K3 : (g |- kind),
      K5 : (g, a12 : con |- kind),
      Dsub : (g |- kd-sub K2 K3),
      Dsub1 :
        (g, a : con, x419 : cn-of a (K2[..]) |-
           kd-sub (K4[.., a]) (K5[.., a])),
      Dwf : (g, a : con, y419 : cn-of a (K3[..]) |- kd-wf (K5[.., a])),
      Dwf1 : (g |- kd-wf K2),
      Dwf2 : (g |- kd-wf K3)
    | x : [g |- kd-sub (sigma K2 (\z350. K4)) (sigma K3 (\z350. K5))]
    ; split
      kd-sub-reg
        [g, b : block (a : con, da : cn-of a (K2[..])) |- Dsub1[.., b.1, b.2]] as
      case kd-sub-reg/i:
      { g : conbind-reg,
        K2 : (g |- kind),
        K6 : (g, a : con |- kind),
        K3 : (g |- kind),
        K7 : (g, a : con |- kind),
        Dsub : (g |- kd-sub K2 K3),
        Dsub1 :
          (g, a : con, x419 : cn-of a (K2[..]) |-
             kd-sub (K6[.., a]) (K7[.., a])),
        Dwf : (g, a : con, y419 : cn-of a (K3[..]) |- kd-wf (K7[.., a])),
        Dwf1 : (g |- kd-wf K2),
        Dwf2 : (g |- kd-wf K3),
        Dwf3 : (g, a : con, y1112 : cn-of a (K2[..]) |- kd-wf (K6[.., a])),
        Dwf4 : (g, a : con, x1112 : cn-of a (K2[..]) |- kd-wf (K7[.., a]))
      | x : [g |- kd-sub (sigma K2 (\z350. K6)) (sigma K3 (\z350. K7))]
      ; solve
          [g |-
             kd-sub-reg/i (kd-wf/sigma Dwf1 (\a. \da. Dwf3))
             (kd-wf/sigma Dwf2 (\a. \da. Dwf))]
      }
    }
  }
  case kd-sub/pi:
  { g : conbind-reg,
    K3 : (g |- kind),
    K4 : (g, a9 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a10 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, z417 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, x417 : cn-of a (K3[..]) |- kd-wf (K4[.., a]))
  | x : [g |- kd-sub (pi K3 (\z349. K4)) (pi K2 (\z349. K5))]
  ; split kd-sub-reg [g |- Dsub] as
    case kd-sub-reg/i:
    { g : conbind-reg,
      K3 : (g |- kind),
      K4 : (g, a9 : con |- kind),
      K2 : (g |- kind),
      K5 : (g, a10 : con |- kind),
      Dsub : (g |- kd-sub K2 K3),
      Dsub1 :
        (g, a : con, z417 : cn-of a (K2[..]) |-
           kd-sub (K4[.., a]) (K5[.., a])),
      Dwf : (g, a : con, x417 : cn-of a (K3[..]) |- kd-wf (K4[.., a])),
      Dwf1 : (g |- kd-wf K2),
      Dwf2 : (g |- kd-wf K3)
    | x : [g |- kd-sub (pi K3 (\z349. K4)) (pi K2 (\z349. K5))]
    ; split
      kd-sub-reg
        [g, b : block (a : con, da : cn-of a (K2[..])) |- Dsub1[.., b.1, b.2]] as
      case kd-sub-reg/i:
      { g : conbind-reg,
        K3 : (g |- kind),
        K6 : (g, a : con |- kind),
        K2 : (g |- kind),
        K7 : (g, a : con |- kind),
        Dsub : (g |- kd-sub K2 K3),
        Dsub1 :
          (g, a : con, z417 : cn-of a (K2[..]) |-
             kd-sub (K6[.., a]) (K7[.., a])),
        Dwf : (g, a : con, x417 : cn-of a (K3[..]) |- kd-wf (K6[.., a])),
        Dwf1 : (g |- kd-wf K2),
        Dwf2 : (g |- kd-wf K3),
        Dwf3 : (g, a : con, z1108 : cn-of a (K2[..]) |- kd-wf (K6[.., a])),
        Dwf4 : (g, a : con, y1109 : cn-of a (K2[..]) |- kd-wf (K7[.., a]))
      | x : [g |- kd-sub (pi K3 (\z349. K6)) (pi K2 (\z349. K7))]
      ; solve
          [g |-
             kd-sub-reg/i (kd-wf/pi Dwf2 (\a. \da. Dwf))
             (kd-wf/pi Dwf1 (\a. \da. Dwf4))]
      }
    }
  }
  case kd-sub/sing-t:
  { g : conbind-reg, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-sub (sing C) t]
  ; solve [g |- kd-sub-reg/i (kd-wf/sing Dof) kd-wf/t]
  }
  case kd-sub/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- kd-sub K K3),
    Dsub1 : (g |- kd-sub K3 K1)
  | x : [g |- kd-sub K K1]
  ; split kd-sub-reg [g |- Dsub] as
    case kd-sub-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K3 : (g |- kind),
      Dsub : (g |- kd-sub K K3),
      Dsub1 : (g |- kd-sub K3 K1),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g |- kd-wf K3)
    | x : [g |- kd-sub K K1]
    ; split kd-sub-reg [g |- Dsub1] as
      case kd-sub-reg/i:
      { g : conbind-reg,
        K : (g |- kind),
        K1 : (g |- kind),
        K3 : (g |- kind),
        Dsub : (g |- kd-sub K K3),
        Dsub1 : (g |- kd-sub K3 K1),
        Dwf : (g |- kd-wf K),
        Dwf1 : (g |- kd-wf K3),
        Dwf2 : (g |- kd-wf K3),
        Dwf3 : (g |- kd-wf K1)
      | x : [g |- kd-sub K K1]
      ; solve [g |- kd-sub-reg/i Dwf Dwf3]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K K1)
  | x : [g |- kd-sub K K1]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- kd-equiv K K1),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g |- kd-wf K1)
    | x : [g |- kd-sub K K1]
    ; solve [g |- kd-sub-reg/i Dwf Dwf1]
    }
  }
}

and proof cn-of-reg :
  (g : conbind-reg) [g |- cn-of C K] ->
    [g |- kd-wf K] =
/ total 1 /
intros
{ g : conbind-reg, C : (g |- con), K : (g |- kind)
| x : [g |- cn-of C K]
; split x as
  case cn-of/subsume:
  { g : conbind-reg,
    C : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C K1),
    Dsub : (g |- kd-sub K1 K)
  | x : [g |- cn-of C K]
  ; split kd-sub-reg [g |- Dsub] as
    case kd-sub-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      K : (g |- kind),
      K1 : (g |- kind),
      Dof : (g |- cn-of C K1),
      Dsub : (g |- kd-sub K1 K),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g |- kd-wf K)
    | x : [g |- cn-of C K]
    ; solve [g |- Dwf1]
    }
  }
  case cn-of/extsigma:
  { g : conbind-reg,
    C : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a23 : con |- kind),
    Dof : (g |- cn-of (pi1 C) K1),
    Dof1 : (g |- cn-of (pi2 C) (K2[.., pi1 C])),
    Dwf : (g, a : con, y178 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of C (sigma K1 (\x98. K2))]
  ; by cn-of-reg [_ |- Dof] as Dwf1 unboxed;
    solve [_ |- kd-wf/sigma Dwf1 (\a. \da. Dwf)]
  }
  case cn-of/extpi:
  { g : conbind-reg,
    C : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a22 : con |- kind),
    K2 : (g, a21 : con |- kind),
    Dof : (g |- cn-of C (pi K1 (\x97. K2))),
    Dof1 :
      (g, a : con, z176 : cn-of a (K1[..]) |-
         cn-of (app (C[..]) a) (K3[.., a]))
  | x : [g |- cn-of C (pi K1 (\x97. K3))]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/pi:
    { g : conbind-reg,
      C : (g |- con),
      K1 : (g |- kind),
      K3 : (g, a22 : con |- kind),
      K2 : (g, a21 : con |- kind),
      Dof : (g |- cn-of C (pi K1 (\x97. K2))),
      Dof1 :
        (g, a : con, z176 : cn-of a (K1[..]) |-
           cn-of (app (C[..]) a) (K3[.., a])),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z157 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of C (pi K1 (\x97. K3))]
    ; by cn-of-reg
           [g, b : block (a : con, da : cn-of a (K1[..])) |-
              Dof1[.., b.1, b.2]]
      as Dwf2 unboxed;
      solve [g |- kd-wf/pi Dwf (\a. \da. Dwf2[.., <a; da>])]
    }
  }
  case cn-of/sing:
  { g : conbind-reg, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of C (sing C)]
  ; solve [g |- kd-wf/sing Dof]
  }
  case cn-of/labeled:
  { g : conbind-reg,
    X : (g |- label),
    C1 : (g |- con),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (labeled X C1) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/rec:
  { g : conbind-reg,
    K1 : (g |- kind),
    C1 : (g, a20 : con, a19 : con |- con),
    C2 : (g |- con),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, z174 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y175 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
    Dof1 : (g |- cn-of C2 K1)
  | x : [g |- cn-of (rec' K1 (\x105. \z105. C1) C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/tagged:
  { g : conbind-reg
  | x : [g |- cn-of tagged t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/tag:
  { g : conbind-reg, C1 : (g |- con), Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (tag C1) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/ref:
  { g : conbind-reg, C1 : (g |- con), Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (ref C1) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/plus:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (plus C1 C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/arrow:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (arrow C1 C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/prod:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (prod C1 C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/void:
  { g : conbind-reg
  | x : [g |- cn-of void t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/unit:
  { g : conbind-reg
  | x : [g |- cn-of unit t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/star:
  { g : conbind-reg
  | x : [g |- cn-of star one]
  ; solve [g |- kd-wf/one]
  }
  case cn-of/app:
  { g : conbind-reg,
    C2 : (g |- con),
    C1 : (g |- con),
    K2 : (g, a18 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of C2 (pi K1 (\x97. K2)))
  | x : [g |- cn-of (app C2 C1) (K2[.., C1])]
  ; split cn-of-reg [g |- Dof1] as
    case kd-wf/pi:
    { g : conbind-reg,
      C2 : (g |- con),
      C1 : (g |- con),
      K2 : (g, a18 : con |- kind),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 K1),
      Dof1 : (g |- cn-of C2 (pi K1 (\x97. K2))),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z157 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of (app C2 C1) (K2[.., C1])]
    ; solve [g |- Dwf1[.., C1, Dof]]
    }
  }
  case cn-of/lam:
  { g : conbind-reg,
    K1 : (g |- kind),
    C1 : (g, a16 : con |- con),
    K2 : (g, a17 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, y170 : cn-of a (K1[..]) |- cn-of (C1[.., a]) (K2[.., a]))
  | x : [g |- cn-of (lam K1 (\z100. C1)) (pi K1 (\x97. K2))]
  ; by cn-of-reg
     [g, b : block (a : con, da : cn-of a (K1[..])) |- Dof[.., b.1, b.2]]
as Dwf2 unboxed;
    solve [g |- kd-wf/pi Dwf (\a. \da. Dwf2[.., <a; da>])]
  }
  case cn-of/pi2:
  { g : conbind-reg,
    C1 : (g |- con),
    K2 : (g, a15 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 (sigma K1 (\x98. K2)))
  | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/sigma:
    { g : conbind-reg,
      C1 : (g |- con),
      K2 : (g, a15 : con |- kind),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 (sigma K1 (\x98. K2))),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z158 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])]
    ; by [g |- cn-of/pi1 Dof] as Dof1 unboxed;
      solve [g |- Dwf1[.., _, Dof1]]
    }
  }
  case cn-of/pi1:
  { g : conbind-reg,
    C1 : (g |- con),
    K : (g |- kind),
    K2 : (g, a14 : con |- kind),
    Dof : (g |- cn-of C1 (sigma K (\x98. K2)))
  | x : [g |- cn-of (pi1 C1) K]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/sigma:
    { g : conbind-reg,
      C1 : (g |- con),
      K : (g |- kind),
      K2 : (g, a14 : con |- kind),
      Dof : (g |- cn-of C1 (sigma K (\x98. K2))),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g, a : con, z158 : cn-of a (K[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of (pi1 C1) K]
    ; solve [g |- Dwf]
    }
  }
  case cn-of/pair:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a13 : con |- kind),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of C2 (K2[.., C1])),
    Dwf : (g, a : con, x168 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of (pair C1 C2) (sigma K1 (\x98. K2))]
  ; by cn-of-reg [g |- Dof] as Dwf1 unboxed;
    solve [g |- kd-wf/sigma Dwf1 (\a. \da. Dwf)]
  }
  case #.2:
  { g : conbind-reg,
    K : (g |- kind),
    #cof : #(g |- block (a : con, da : cn-of a (K[..]))),
    Dwf32 : (g |- kd-wf K)
  | x : [g |- cn-of #cof.1 K]
  ; solve [_ |- Dwf32]
  }
}

and proof cn-equiv-reg :
  (g : conbind-reg)
  [g |- cn-equiv C1 C2 K] ->
    [g |- cn-equiv-reg/e C1 C2 K] =
/ total 1 /
intros
{ g : conbind-reg, C : (g |- con), C1 : (g |- con), K : (g |- kind)
| x : [g |- cn-equiv C C1 K]
; split x as
  case cn-equiv/beta2:
  { g : conbind-reg,
    C2 : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C2 K1),
    Dof1 : (g |- cn-of C1 K)
  | x : [g |- cn-equiv (pi2 (pair C2 C1)) C1 K]
  ; by cn-of-reg [g |- Dof1] as Dwf2 unboxed;
    solve
  [g |-
     cn-equiv-reg/i (cn-of/pi2 (cn-of/pair Dof Dof1 (\a. \da. Dwf2[..])))
     Dof1 Dwf2]
  }
  case cn-equiv/beta1:
  { g : conbind-reg,
    C1 : (g |- con),
    C3 : (g |- con),
    K : (g |- kind),
    K2 : (g |- kind),
    Dof : (g |- cn-of C1 K),
    Dof1 : (g |- cn-of C3 K2)
  | x : [g |- cn-equiv (pi1 (pair C1 C3)) C1 K]
  ; by cn-of-reg [g |- Dof] as Dwf1 unboxed;
    by cn-of-reg [g |- Dof1] as Dwf2 unboxed;
    by [g |- cn-of/pair Dof Dof1 (\a. \da. Dwf2[..])] as Dof1' unboxed;
    solve [g |- cn-equiv-reg/i (cn-of/pi1 Dof1') Dof Dwf1]
  }
  case cn-equiv/beta:
  { g : conbind-reg,
    K1 : (g |- kind),
    C3 : (g, a41 : con |- con),
    C2 : (g |- con),
    K2 : (g, a42 : con |- kind),
    Dof : (g |- cn-of C2 K1),
    Dof1 :
      (g, a : con, z436 : cn-of a (K1[..]) |- cn-of (C3[.., a]) (K2[.., a]))
  | x :
      [g |- cn-equiv (app (lam K1 (\x342. C3)) C2) (C3[.., C2]) (K2[.., C2])]
  ; by cn-of-reg [g |- Dof] as DwfA unboxed;
    by cn-of-reg
         [g, b : block (a : con, da : cn-of a _) |- Dof1[.., b.1, b.2]]
    as DwfB unboxed;
    by [g |- cn-of/app Dof (cn-of/lam DwfA (\a. \da. Dof1))] as Dof1' unboxed;
    by [g |- Dof1[.., _, Dof]] as Dof2' unboxed;
    by [g |- DwfB[.., <_; Dof>]] as Dwf' unboxed;
    solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
  }
  case cn-equiv/subsume:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- kd-sub K1 K),
    Dequiv : (g |- cn-equiv C C1 K1)
  | x : [g |- cn-equiv C C1 K]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K : (g |- kind),
      K1 : (g |- kind),
      Dsub : (g |- kd-sub K1 K),
      Dequiv : (g |- cn-equiv C C1 K1),
      Dof : (g |- cn-of C K1),
      Dof1 : (g |- cn-of C1 K1),
      Dwf : (g |- kd-wf K1)
    | x : [g |- cn-equiv C C1 K]
    ; split kd-sub-reg [g |- Dsub] as
      case kd-sub-reg/i:
      { g : conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        K : (g |- kind),
        K1 : (g |- kind),
        Dsub : (g |- kd-sub K1 K),
        Dequiv : (g |- cn-equiv C C1 K1),
        Dof : (g |- cn-of C K1),
        Dof1 : (g |- cn-of C1 K1),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g |- kd-wf K1),
        Dwf2 : (g |- kd-wf K)
      | x : [g |- cn-equiv C C1 K]
      ; solve
          [g |-
             cn-equiv-reg/i (cn-of/subsume Dof Dsub)
             (cn-of/subsume Dof1 Dsub) Dwf2]
      }
    }
  }
  case cn-equiv/one:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C one),
    Dof1 : (g |- cn-of C1 one)
  | x : [g |- cn-equiv C C1 one]
  ; solve [g |- cn-equiv-reg/i Dof Dof1 kd-wf/one]
  }
  case cn-equiv/extsigma:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a40 : con |- kind),
    Dequiv : (g |- cn-equiv (pi1 C) (pi1 C1) K1),
    Dequiv1 : (g |- cn-equiv (pi2 C) (pi2 C1) (K2[.., pi1 C])),
    Dwf : (g, a : con, x434 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-equiv C C1 (sigma K1 (\y340. K2))]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K1 : (g |- kind),
      K2 : (g, a40 : con |- kind),
      Dequiv : (g |- cn-equiv (pi1 C) (pi1 C1) K1),
      Dequiv1 : (g |- cn-equiv (pi2 C) (pi2 C1) (K2[.., pi1 C])),
      Dwf : (g, a : con, x434 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      Dof : (g |- cn-of (pi1 C) K1),
      Dof1 : (g |- cn-of (pi1 C1) K1),
      Dwf1 : (g |- kd-wf K1)
    | x : [g |- cn-equiv C C1 (sigma K1 (\y340. K2))]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        K1 : (g |- kind),
        K2 : (g, a40 : con |- kind),
        Dequiv : (g |- cn-equiv (pi1 C) (pi1 C1) K1),
        Dequiv1 : (g |- cn-equiv (pi2 C) (pi2 C1) (K2[.., pi1 C])),
        Dwf : (g, a : con, x434 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
        Dof : (g |- cn-of (pi1 C) K1),
        Dof1 : (g |- cn-of (pi1 C1) K1),
        Dwf1 : (g |- kd-wf K1),
        Dof2 : (g |- cn-of (pi2 C) (K2[.., pi1 C])),
        Dof3 : (g |- cn-of (pi2 C1) (K2[.., pi1 C])),
        Dwf2 : (g |- kd-wf (K2[.., pi1 C]))
      | x : [g |- cn-equiv C C1 (sigma K1 (\y340. K2))]
      ; by functionality-kd-reg [g, a : con, da : cn-of a (K1[..]) |- Dwf]
             [g |- Dequiv] [g |- Dof]
        as Dequiv' unboxed;
        by [g |- cn-of/extsigma Dof Dof2 (\a. \da. Dwf)] as Dof1' unboxed;
        by cn-of/equiv/conbind-reg [g |- Dof3] [g |- Dequiv'] as Dof3' unboxed;
        by [g |- cn-of/extsigma Dof1 Dof3' (\a. \da. Dwf)] as Dof2' unboxed;
        by [g |- kd-wf/sigma Dwf1 (\a. \da. Dwf)] as Dwf' unboxed;
        solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
      }
    }
  }
  case cn-equiv/extpiw:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a39 : con |- kind),
    K2 : (g, a38 : con |- kind),
    Dequiv : (g |- cn-equiv C C1 (pi K1 (\y339. K2))),
    Dequiv1 :
      (g, a : con, y433 : cn-of a (K1[..]) |-
         cn-equiv (app (C[..]) a) (app (C1[..]) a) (K3[.., a]))
  | x : [g |- cn-equiv C C1 (pi K1 (\y339. K3))]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K1 : (g |- kind),
      K3 : (g, a39 : con |- kind),
      K2 : (g, a38 : con |- kind),
      Dequiv : (g |- cn-equiv C C1 (pi K1 (\y339. K2))),
      Dequiv1 :
        (g, a : con, y433 : cn-of a (K1[..]) |-
           cn-equiv (app (C[..]) a) (app (C1[..]) a) (K3[.., a])),
      Dof : (g |- cn-of C (pi K1 (\y339. K2))),
      Dof1 : (g |- cn-of C1 (pi K1 (\y339. K2))),
      Dwf : (g |- kd-wf (pi K1 (\y339. K2)))
    | x : [g |- cn-equiv C C1 (pi K1 (\y339. K3))]
    ; split
      cn-equiv-reg
        [g, b : block (a : con, da : cn-of a _) |- Dequiv1[.., b.1, b.2]] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        K1 : (g |- kind),
        K4 : (g, a : con |- kind),
        K2 : (g, a38 : con |- kind),
        Dequiv : (g |- cn-equiv C C1 (pi K1 (\y339. K2))),
        Dequiv1 :
          (g, a : con, y433 : cn-of a (K1[..]) |-
             cn-equiv (app (C[..]) a) (app (C1[..]) a) (K4[.., a])),
        Dof : (g |- cn-of C (pi K1 (\y339. K2))),
        Dof1 : (g |- cn-of C1 (pi K1 (\y339. K2))),
        Dwf : (g |- kd-wf (pi K1 (\y339. K2))),
        Dof2 :
          (g, a : con, x1143 : cn-of a (K1[..]) |-
             cn-of (app (C[..]) a) (K4[.., a])),
        Dof3 :
          (g, a : con, z1143 : cn-of a (K1[..]) |-
             cn-of (app (C1[..]) a) (K4[.., a])),
        Dwf1 : (g, a : con, y1144 : cn-of a (K1[..]) |- kd-wf (K4[.., a]))
      | x : [g |- cn-equiv C C1 (pi K1 (\y339. K4))]
      ; by [g |- cn-of/extpi Dof (\a. \da. Dof2)] as Dof1' unboxed;
        by [g |- cn-of/extpi Dof1 (\a. \da. Dof3)] as Dof2' unboxed;
        split [g |- Dwf] as
        case kd-wf/pi:
        { g : conbind-reg,
          C : (g |- con),
          C1 : (g |- con),
          K1 : (g |- kind),
          K4 : (g, a : con |- kind),
          K2 : (g, a38 : con |- kind),
          Dequiv : (g |- cn-equiv C C1 (pi K1 (\y339. K2))),
          Dequiv1 :
            (g, a : con, y433 : cn-of a (K1[..]) |-
               cn-equiv (app (C[..]) a) (app (C1[..]) a) (K4[.., a])),
          Dof : (g |- cn-of C (pi K1 (\y339. K2))),
          Dof1 : (g |- cn-of C1 (pi K1 (\y339. K2))),
          Dwf2 : (g |- kd-wf K1),
          Dwf3 : (g, a : con, x399 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
          Dof2 :
            (g, a : con, x1143 : cn-of a (K1[..]) |-
               cn-of (app (C[..]) a) (K4[.., a])),
          Dof3 :
            (g, a : con, z1143 : cn-of a (K1[..]) |-
               cn-of (app (C1[..]) a) (K4[.., a])),
          Dwf1 : (g, a : con, y1144 : cn-of a (K1[..]) |- kd-wf (K4[.., a])),
          Dof1' : (g |- cn-of C (pi K1 (\y339. K4))),
          Dof2' : (g |- cn-of C1 (pi K1 (\y339. K4)))
        | x : [g |- cn-equiv C C1 (pi K1 (\y339. K4))]
        ; by [g |- kd-wf/pi Dwf2 (\a. \da. Dwf1)] as Dwf' unboxed;
          solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
        }
      }
    }
  }
  case cn-equiv/extpi:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K4 : (g, a37 : con |- kind),
    K2 : (g, a35 : con |- kind),
    K3 : (g, a36 : con |- kind),
    Dof : (g |- cn-of C (pi K1 (\y339. K2))),
    Dof1 : (g |- cn-of C1 (pi K1 (\y339. K3))),
    Dequiv :
      (g, a : con, y432 : cn-of a (K1[..]) |-
         cn-equiv (app (C[..]) a) (app (C1[..]) a) (K4[.., a]))
  | x : [g |- cn-equiv C C1 (pi K1 (\y339. K4))]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/pi:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K1 : (g |- kind),
      K4 : (g, a37 : con |- kind),
      K2 : (g, a35 : con |- kind),
      K3 : (g, a36 : con |- kind),
      Dof : (g |- cn-of C (pi K1 (\y339. K2))),
      Dof1 : (g |- cn-of C1 (pi K1 (\y339. K3))),
      Dequiv :
        (g, a : con, y432 : cn-of a (K1[..]) |-
           cn-equiv (app (C[..]) a) (app (C1[..]) a) (K4[.., a])),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, x399 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-equiv C C1 (pi K1 (\y339. K4))]
    ; split
      cn-equiv-reg
        [g, b : block (a : con, da : cn-of a _) |- Dequiv[.., b.1, b.2]] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        K1 : (g |- kind),
        K5 : (g, a : con |- kind),
        K2 : (g, a35 : con |- kind),
        K3 : (g, a36 : con |- kind),
        Dof : (g |- cn-of C (pi K1 (\y339. K2))),
        Dof1 : (g |- cn-of C1 (pi K1 (\y339. K3))),
        Dequiv :
          (g, a : con, y432 : cn-of a (K1[..]) |-
             cn-equiv (app (C[..]) a) (app (C1[..]) a) (K5[.., a])),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g, a : con, x399 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
        Dof2 :
          (g, a : con, z1136 : cn-of a (K1[..]) |-
             cn-of (app (C[..]) a) (K5[.., a])),
        Dof3 :
          (g, a : con, y1137 : cn-of a (K1[..]) |-
             cn-of (app (C1[..]) a) (K5[.., a])),
        Dwf2 : (g, a : con, x1137 : cn-of a (K1[..]) |- kd-wf (K5[.., a]))
      | x : [g |- cn-equiv C C1 (pi K1 (\y339. K5))]
      ; by [g |- cn-of/extpi Dof (\a. \da. Dof2)] as Dof1' unboxed;
        by [g |- cn-of/extpi Dof1 (\a. \da. Dof3)] as Dof2' unboxed;
        by [g |- kd-wf/pi Dwf (\a. \da. Dwf2)] as Dwf' unboxed;
        solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
      }
    }
  }
  case cn-equiv/singelim:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C (sing C1))
  | x : [g |- cn-equiv C C1 t]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/sing:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      Dof : (g |- cn-of C (sing C1)),
      Dof1 : (g |- cn-of C1 t)
    | x : [g |- cn-equiv C C1 t]
    ; solve
        [g |-
           cn-equiv-reg/i (cn-of/subsume Dof (kd-sub/sing-t Dof1))
           Dof1 kd-wf/t]
    }
  }
  case cn-equiv/sing:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- cn-equiv C C1 (sing C)]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      Dequiv : (g |- cn-equiv C C1 t),
      Dof : (g |- cn-of C t),
      Dof1 : (g |- cn-of C1 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv C C1 (sing C)]
    ; by cn-of/equiv/conbind-reg [g |- cn-of/sing Dof1]
           [g |- kd-equiv/symm (kd-equiv/sing Dequiv)]
      as Dof2' unboxed;
      solve [g |- cn-equiv-reg/i (cn-of/sing Dof) Dof2' (kd-wf/sing Dof)]
    }
  }
  case cn-equiv/labeled:
  { g : conbind-reg,
    X : (g |- label),
    C2 : (g |- con),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t)
  | x : [g |- cn-equiv (labeled X C2) (labeled X C3) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      X : (g |- label),
      C2 : (g |- con),
      C3 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (labeled X C2) (labeled X C3) t]
    ; solve
        [g |- cn-equiv-reg/i (cn-of/labeled Dof) (cn-of/labeled Dof1) kd-wf/t]
    }
  }
  case cn-equiv/rec:
  { g : conbind-reg,
    K1 : (g |- kind),
    C2 : (g, a32 : con, a31 : con |- con),
    C4 : (g |- con),
    K2 : (g |- kind),
    C3 : (g, a34 : con, a33 : con |- con),
    C5 : (g |- con),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, x429 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       z429 : cn-of b (K1[..]) |- cn-equiv (C2[.., a, b]) (C3[.., a, b]) t),
    Dequiv2 : (g |- cn-equiv C4 C5 K1)
  | x :
      [g |-
         cn-equiv
           (rec' K1 (\y347. \x347. C2) C4) (rec' K2 (\y347. \x347. C3) C5) t]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K1 : (g |- kind),
      C2 : (g, a32 : con, a31 : con |- con),
      C4 : (g |- con),
      K2 : (g |- kind),
      C3 : (g, a34 : con, a33 : con |- con),
      C5 : (g |- con),
      Dequiv : (g |- kd-equiv K1 K2),
      Dequiv1 :
        (g, a : con, x429 : cn-of a (pi (K1[..]) (\l. t)), b : con,
         z429 : cn-of b (K1[..]) |- cn-equiv (C2[.., a, b]) (C3[.., a, b]) t),
      Dequiv2 : (g |- cn-equiv C4 C5 K1),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g |- kd-wf K2)
    | x :
        [g |-
           cn-equiv
             (rec' K1 (\y347. \x347. C2) C4)
             (rec' K2 (\y347. \x347. C3) C5) t]
    ; ?
    }
  }
  case cn-equiv/tag:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t)
  | x : [g |- cn-equiv (tag C2) (tag C3) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C3 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (tag C2) (tag C3) t]
    ; solve [g |- cn-equiv-reg/i (cn-of/tag Dof) (cn-of/tag Dof1) kd-wf/t]
    }
  }
  case cn-equiv/ref:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t)
  | x : [g |- cn-equiv (ref C2) (ref C3) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C3 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (ref C2) (ref C3) t]
    ; solve [g |- cn-equiv-reg/i (cn-of/ref Dof) (cn-of/ref Dof1) kd-wf/t]
    }
  }
  case cn-equiv/plus:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t),
    Dequiv1 : (g |- cn-equiv C4 C5 t)
  | x : [g |- cn-equiv (plus C2 C4) (plus C3 C5) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C4 : (g |- con),
      C3 : (g |- con),
      C5 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dequiv1 : (g |- cn-equiv C4 C5 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (plus C2 C4) (plus C3 C5) t]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C2 : (g |- con),
        C4 : (g |- con),
        C3 : (g |- con),
        C5 : (g |- con),
        Dequiv : (g |- cn-equiv C2 C3 t),
        Dequiv1 : (g |- cn-equiv C4 C5 t),
        Dof : (g |- cn-of C2 t),
        Dof1 : (g |- cn-of C3 t),
        Dwf : (g |- kd-wf t),
        Dof2 : (g |- cn-of C4 t),
        Dof3 : (g |- cn-of C5 t),
        Dwf1 : (g |- kd-wf t)
      | x : [g |- cn-equiv (plus C2 C4) (plus C3 C5) t]
      ; solve
          [g |-
             cn-equiv-reg/i (cn-of/plus Dof Dof2)
             (cn-of/plus Dof1 Dof3) kd-wf/t]
      }
    }
  }
  case cn-equiv/arrow:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t),
    Dequiv1 : (g |- cn-equiv C4 C5 t)
  | x : [g |- cn-equiv (arrow C2 C4) (arrow C3 C5) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C4 : (g |- con),
      C3 : (g |- con),
      C5 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dequiv1 : (g |- cn-equiv C4 C5 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (arrow C2 C4) (arrow C3 C5) t]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C2 : (g |- con),
        C4 : (g |- con),
        C3 : (g |- con),
        C5 : (g |- con),
        Dequiv : (g |- cn-equiv C2 C3 t),
        Dequiv1 : (g |- cn-equiv C4 C5 t),
        Dof : (g |- cn-of C2 t),
        Dof1 : (g |- cn-of C3 t),
        Dwf : (g |- kd-wf t),
        Dof2 : (g |- cn-of C4 t),
        Dof3 : (g |- cn-of C5 t),
        Dwf1 : (g |- kd-wf t)
      | x : [g |- cn-equiv (arrow C2 C4) (arrow C3 C5) t]
      ; solve
          [g |-
             cn-equiv-reg/i (cn-of/arrow Dof Dof2)
             (cn-of/arrow Dof1 Dof3) kd-wf/t]
      }
    }
  }
  case cn-equiv/prod:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t),
    Dequiv1 : (g |- cn-equiv C4 C5 t)
  | x : [g |- cn-equiv (prod C2 C4) (prod C3 C5) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C4 : (g |- con),
      C3 : (g |- con),
      C5 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dequiv1 : (g |- cn-equiv C4 C5 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (prod C2 C4) (prod C3 C5) t]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C2 : (g |- con),
        C4 : (g |- con),
        C3 : (g |- con),
        C5 : (g |- con),
        Dequiv : (g |- cn-equiv C2 C3 t),
        Dequiv1 : (g |- cn-equiv C4 C5 t),
        Dof : (g |- cn-of C2 t),
        Dof1 : (g |- cn-of C3 t),
        Dwf : (g |- kd-wf t),
        Dof2 : (g |- cn-of C4 t),
        Dof3 : (g |- cn-of C5 t),
        Dwf1 : (g |- kd-wf t)
      | x : [g |- cn-equiv (prod C2 C4) (prod C3 C5) t]
      ; solve
          [g |-
             cn-equiv-reg/i (cn-of/prod Dof Dof2)
             (cn-of/prod Dof1 Dof3) kd-wf/t]
      }
    }
  }
  case cn-equiv/app:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    K2 : (g, a30 : con |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C2 C3 (pi K1 (\y339. K2))),
    Dequiv1 : (g |- cn-equiv C4 C5 K1)
  | x : [g |- cn-equiv (app C2 C4) (app C3 C5) (K2[.., C4])]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C4 : (g |- con),
      C3 : (g |- con),
      C5 : (g |- con),
      K2 : (g, a30 : con |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- cn-equiv C2 C3 (pi K1 (\y339. K2))),
      Dequiv1 : (g |- cn-equiv C4 C5 K1),
      Dof : (g |- cn-of C2 (pi K1 (\y339. K2))),
      Dof1 : (g |- cn-of C3 (pi K1 (\y339. K2))),
      Dwf : (g |- kd-wf (pi K1 (\y339. K2)))
    | x : [g |- cn-equiv (app C2 C4) (app C3 C5) (K2[.., C4])]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C2 : (g |- con),
        C4 : (g |- con),
        C3 : (g |- con),
        C5 : (g |- con),
        K2 : (g, a30 : con |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- cn-equiv C2 C3 (pi K1 (\y339. K2))),
        Dequiv1 : (g |- cn-equiv C4 C5 K1),
        Dof : (g |- cn-of C2 (pi K1 (\y339. K2))),
        Dof1 : (g |- cn-of C3 (pi K1 (\y339. K2))),
        Dwf : (g |- kd-wf (pi K1 (\y339. K2))),
        Dof2 : (g |- cn-of C4 K1),
        Dof3 : (g |- cn-of C5 K1),
        Dwf1 : (g |- kd-wf K1)
      | x : [g |- cn-equiv (app C2 C4) (app C3 C5) (K2[.., C4])]
      ; split [g |- Dwf] as
        case kd-wf/pi:
        { g : conbind-reg,
          C2 : (g |- con),
          C4 : (g |- con),
          C3 : (g |- con),
          C5 : (g |- con),
          K2 : (g, a30 : con |- kind),
          K1 : (g |- kind),
          Dequiv : (g |- cn-equiv C2 C3 (pi K1 (\y339. K2))),
          Dequiv1 : (g |- cn-equiv C4 C5 K1),
          Dof : (g |- cn-of C2 (pi K1 (\y339. K2))),
          Dof1 : (g |- cn-of C3 (pi K1 (\y339. K2))),
          Dwf2 : (g |- kd-wf K1),
          Dwf3 : (g, a : con, x399 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
          Dof2 : (g |- cn-of C4 K1),
          Dof3 : (g |- cn-of C5 K1),
          Dwf1 : (g |- kd-wf K1)
        | x : [g |- cn-equiv (app C2 C4) (app C3 C5) (K2[.., C4])]
        ; by functionality-kd-reg [g, a : con, da : cn-of a (K1[..]) |- Dwf3]
               [g |- Dequiv1] [g |- Dof2]
          as Dequiv' unboxed;
          by [g |- cn-of/app Dof2 Dof] as Dof1' unboxed;
          by cn-of/equiv/conbind-reg [g |- cn-of/app Dof3 Dof1]
     [g |- kd-equiv/symm Dequiv']
as Dof2' unboxed;
          by [g |- Dwf3[.., C4, _]] as Dwf' unboxed;
          solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
        }
      }
    }
  }
  case cn-equiv/lam:
  { g : conbind-reg,
    K1 : (g |- kind),
    C2 : (g, a27 : con |- con),
    K2 : (g |- kind),
    C3 : (g, a28 : con |- con),
    K3 : (g, a29 : con |- kind),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, z424 : cn-of a (K1[..]) |-
         cn-equiv (C2[.., a]) (C3[.., a]) (K3[.., a]))
  | x :
      [g |-
         cn-equiv
           (lam K1 (\x342. C2)) (lam K2 (\x342. C3)) (pi K1 (\y339. K3))]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K1 : (g |- kind),
      C2 : (g, a27 : con |- con),
      K2 : (g |- kind),
      C3 : (g, a28 : con |- con),
      K3 : (g, a29 : con |- kind),
      Dequiv : (g |- kd-equiv K1 K2),
      Dequiv1 :
        (g, a : con, z424 : cn-of a (K1[..]) |-
           cn-equiv (C2[.., a]) (C3[.., a]) (K3[.., a])),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g |- kd-wf K2)
    | x :
        [g |-
           cn-equiv
             (lam K1 (\x342. C2)) (lam K2 (\x342. C3)) (pi K1 (\y339. K3))]
    ; split
      cn-equiv-reg
        [g, b : block (a : con, da : cn-of a _) |- Dequiv1[.., b.1, b.2]] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        K1 : (g |- kind),
        C4 : (g, a : con |- con),
        K2 : (g |- kind),
        C5 : (g, a : con |- con),
        K4 : (g, a : con |- kind),
        Dequiv : (g |- kd-equiv K1 K2),
        Dequiv1 :
          (g, a : con, z424 : cn-of a (K1[..]) |-
             cn-equiv (C4[.., a]) (C5[.., a]) (K4[.., a])),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g |- kd-wf K2),
        Dof :
          (g, a : con, y1132 : cn-of a (K1[..]) |-
             cn-of (C4[.., a]) (K4[.., a])),
        Dof1 :
          (g, a : con, x1132 : cn-of a (K1[..]) |-
             cn-of (C5[.., a]) (K4[.., a])),
        Dwf2 : (g, a : con, z1132 : cn-of a (K1[..]) |- kd-wf (K4[.., a]))
      | x :
          [g |-
             cn-equiv
               (lam K1 (\x342. C4)) (lam K2 (\x342. C5)) (pi K1 (\y339. K4))]
      ; by [g |- cn-of/lam Dwf (\a. \da. Dof)] as Dof1' unboxed;
        by [g |- kd-wf/pi Dwf (\a. \da. Dwf2)] as Dwf' unboxed;
        ?
      }
    }
  }
  case cn-equiv/pi2:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    K2 : (g, a26 : con |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C2 C3 (sigma K1 (\y340. K2)))
  | x : [g |- cn-equiv (pi2 C2) (pi2 C3) (K2[.., pi1 C2])]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C3 : (g |- con),
      K2 : (g, a26 : con |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- cn-equiv C2 C3 (sigma K1 (\y340. K2))),
      Dof : (g |- cn-of C2 (sigma K1 (\y340. K2))),
      Dof1 : (g |- cn-of C3 (sigma K1 (\y340. K2))),
      Dwf : (g |- kd-wf (sigma K1 (\y340. K2)))
    | x : [g |- cn-equiv (pi2 C2) (pi2 C3) (K2[.., pi1 C2])]
    ; split [g |- Dwf] as
      case kd-wf/sigma:
      { g : conbind-reg,
        C2 : (g |- con),
        C3 : (g |- con),
        K2 : (g, a26 : con |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- cn-equiv C2 C3 (sigma K1 (\y340. K2))),
        Dof : (g |- cn-of C2 (sigma K1 (\y340. K2))),
        Dof1 : (g |- cn-of C3 (sigma K1 (\y340. K2))),
        Dwf1 : (g |- kd-wf K1),
        Dwf2 : (g, a : con, x400 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
      | x : [g |- cn-equiv (pi2 C2) (pi2 C3) (K2[.., pi1 C2])]
      ; by functionality-kd-reg [g, a : con, da : cn-of a (K1[..]) |- Dwf2]
     [g |- cn-equiv/pi1 Dequiv] [g |- cn-of/pi1 Dof]
as Dequiv' unboxed;
        by [g |- cn-of/pi2 Dof] as Dof1' unboxed;
        by cn-of/equiv/conbind-reg [g |- cn-of/pi2 Dof1]
             [g |- kd-equiv/symm Dequiv']
        as Dof2' unboxed;
        by [g |- cn-of/pi1 Dof] as Dof1'' unboxed;
        by [g |- Dwf2[.., _, Dof1'']] as Dwf' unboxed;
        solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
      }
    }
  }
  case cn-equiv/pi1:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    K : (g |- kind),
    K2 : (g, a25 : con |- kind),
    Dequiv : (g |- cn-equiv C2 C3 (sigma K (\y340. K2)))
  | x : [g |- cn-equiv (pi1 C2) (pi1 C3) K]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C3 : (g |- con),
      K : (g |- kind),
      K2 : (g, a25 : con |- kind),
      Dequiv : (g |- cn-equiv C2 C3 (sigma K (\y340. K2))),
      Dof : (g |- cn-of C2 (sigma K (\y340. K2))),
      Dof1 : (g |- cn-of C3 (sigma K (\y340. K2))),
      Dwf : (g |- kd-wf (sigma K (\y340. K2)))
    | x : [g |- cn-equiv (pi1 C2) (pi1 C3) K]
    ; split [g |- Dwf] as
      case kd-wf/sigma:
      { g : conbind-reg,
        C2 : (g |- con),
        C3 : (g |- con),
        K : (g |- kind),
        K2 : (g, a25 : con |- kind),
        Dequiv : (g |- cn-equiv C2 C3 (sigma K (\y340. K2))),
        Dof : (g |- cn-of C2 (sigma K (\y340. K2))),
        Dof1 : (g |- cn-of C3 (sigma K (\y340. K2))),
        Dwf1 : (g |- kd-wf K),
        Dwf2 : (g, a : con, x400 : cn-of a (K[..]) |- kd-wf (K2[.., a]))
      | x : [g |- cn-equiv (pi1 C2) (pi1 C3) K]
      ; solve [g |- cn-equiv-reg/i (cn-of/pi1 Dof) (cn-of/pi1 Dof1) Dwf1]
      }
    }
  }
  case cn-equiv/pair:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a24 : con |- kind),
    Dequiv : (g |- cn-equiv C2 C3 K1),
    Dequiv1 : (g |- cn-equiv C4 C5 (K2[.., C2])),
    Dwf : (g, a : con, y423 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-equiv (pair C2 C4) (pair C3 C5) (sigma K1 (\y340. K2))]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C4 : (g |- con),
      C3 : (g |- con),
      C5 : (g |- con),
      K1 : (g |- kind),
      K2 : (g, a24 : con |- kind),
      Dequiv : (g |- cn-equiv C2 C3 K1),
      Dequiv1 : (g |- cn-equiv C4 C5 (K2[.., C2])),
      Dwf : (g, a : con, y423 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      Dof : (g |- cn-of C2 K1),
      Dof1 : (g |- cn-of C3 K1),
      Dwf1 : (g |- kd-wf K1)
    | x : [g |- cn-equiv (pair C2 C4) (pair C3 C5) (sigma K1 (\y340. K2))]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C2 : (g |- con),
        C4 : (g |- con),
        C3 : (g |- con),
        C5 : (g |- con),
        K1 : (g |- kind),
        K2 : (g, a24 : con |- kind),
        Dequiv : (g |- cn-equiv C2 C3 K1),
        Dequiv1 : (g |- cn-equiv C4 C5 (K2[.., C2])),
        Dwf : (g, a : con, y423 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
        Dof : (g |- cn-of C2 K1),
        Dof1 : (g |- cn-of C3 K1),
        Dwf1 : (g |- kd-wf K1),
        Dof2 : (g |- cn-of C4 (K2[.., C2])),
        Dof3 : (g |- cn-of C5 (K2[.., C2])),
        Dwf2 : (g |- kd-wf (K2[.., C2]))
      | x : [g |- cn-equiv (pair C2 C4) (pair C3 C5) (sigma K1 (\y340. K2))]
      ; by functionality-kd-reg [g, a : con, da : cn-of a (K1[..]) |- Dwf]
     [g |- Dequiv] [g |- Dof]
as DequivK unboxed;
        by [g |- cn-of/pair Dof Dof2 (\a. \da. Dwf)] as Dof1' unboxed;
        by cn-of/equiv/conbind-reg [g |- Dof3] [g |- DequivK] as Dof3' unboxed;
        by [g |- cn-of/pair Dof1 Dof3' (\a. \da. Dwf)] as Dof2' unboxed;
        by [g |- kd-wf/sigma Dwf1 (\a. \da. Dwf)] as Dwf' unboxed;
        solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
      }
    }
  }
  case cn-equiv/trans:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C C3 K),
    Dequiv1 : (g |- cn-equiv C3 C1 K)
  | x : [g |- cn-equiv C C1 K]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K : (g |- kind),
      C3 : (g |- con),
      Dequiv : (g |- cn-equiv C C3 K),
      Dequiv1 : (g |- cn-equiv C3 C1 K),
      Dof : (g |- cn-of C K),
      Dof1 : (g |- cn-of C3 K),
      Dwf : (g |- kd-wf K)
    | x : [g |- cn-equiv C C1 K]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        K : (g |- kind),
        C3 : (g |- con),
        Dequiv : (g |- cn-equiv C C3 K),
        Dequiv1 : (g |- cn-equiv C3 C1 K),
        Dof : (g |- cn-of C K),
        Dof1 : (g |- cn-of C3 K),
        Dwf : (g |- kd-wf K),
        Dof2 : (g |- cn-of C3 K),
        Dof3 : (g |- cn-of C1 K),
        Dwf1 : (g |- kd-wf K)
      | x : [g |- cn-equiv C C1 K]
      ; solve [g |- cn-equiv-reg/i Dof Dof3 Dwf1]
      }
    }
  }
  case cn-equiv/symm:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    Dequiv : (g |- cn-equiv C1 C K)
  | x : [g |- cn-equiv C C1 K]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K : (g |- kind),
      Dequiv : (g |- cn-equiv C1 C K),
      Dof : (g |- cn-of C1 K),
      Dof1 : (g |- cn-of C K),
      Dwf : (g |- kd-wf K)
    | x : [g |- cn-equiv C C1 K]
    ; solve [g |- cn-equiv-reg/i Dof1 Dof Dwf]
    }
  }
  case cn-equiv/refl:
  { g : conbind-reg,
    C1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of C1 K)
  | x : [g |- cn-equiv C1 C1 K]
  ; by cn-of-reg [g |- Dof] as Dwf unboxed;
    solve [g |- cn-equiv-reg/i Dof Dof Dwf]
  }
}
;

LF inhabitation/e : kind -> type =
| inhabitation/i :
  { C : con }
  cn-of C K ->
    inhabitation/e K
;

proof inhabitation :
  (g : conbind) [g |- kd-wf K] ->
    [g |- inhabitation/e K] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind)
| x : [g |- kd-wf K]
; split x as
  case kd-wf/one:
  { g : conbind
  | x : [g |- kd-wf one]
  ; solve [g |- inhabitation/i _ cn-of/star]
  }
  case kd-wf/sigma:
  { g : conbind,
    K1 : (g |- kind),
    K2 : (g, a4 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, z160 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (sigma K1 (\x100. K2))]
  ; split inhabitation [g |- Dwf] as
    case inhabitation/i:
    { g : conbind,
      K1 : (g |- kind),
      K2 : (g, a4 : con |- kind),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z160 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      C : (g |- con),
      Dof : (g |- cn-of C K1)
    | x : [g |- kd-wf (sigma K1 (\x100. K2))]
    ; split
      inhabitation
        [g, b : block (a : con, d : cn-of a (K1[..])) |- Dwf1[.., b.1, b.2]] as
      case inhabitation/i:
      { g : conbind,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g, a : con, z160 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
        C : (g |- con),
        Dof : (g |- cn-of C K1),
        C1 : (g, a : con |- con),
        Dof1 :
          (g, a : con, y665 : cn-of a (K1[..]) |-
             cn-of (C1[.., a]) (K3[.., a]))
      | x : [g |- kd-wf (sigma K1 (\x100. K3))]
      ; solve
  [g |- inhabitation/i _ (cn-of/pair Dof (Dof1[.., C, Dof]) (\x. \y. Dwf1))]
      }
    }
  }
  case kd-wf/pi:
  { g : conbind,
    K1 : (g |- kind),
    K2 : (g, a3 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, z159 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (pi K1 (\x99. K2))]
  ; split
    inhabitation
      [_, b : block (a : con, d : cn-of a (K1[..])) |- Dwf1[.., b.1, b.2]] as
    case inhabitation/i:
    { g : conbind,
      K1 : (g |- kind),
      K3 : (g, a : con |- kind),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z159 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
      C : (g, a : con |- con),
      Dof :
        (g, a : con, y668 : cn-of a (K1[..]) |- cn-of (C[.., a]) (K3[.., a]))
    | x : [g |- kd-wf (pi K1 (\x99. K3))]
    ; solve [g |- inhabitation/i _ (cn-of/lam Dwf (\x. \y. Dof))]
    }
  }
  case kd-wf/sing:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-wf (sing C)]
  ; solve [g |- inhabitation/i _ (cn-of/sing Dof)]
  }
  case kd-wf/t:
  { g : conbind
  | x : [g |- kd-wf t]
  ; solve [g |- inhabitation/i _ cn-of/unit]
  }
}
;

% Similarity

LF similar : con -> con -> type =
| similar/unit : similar unit unit
| similar/void : similar void void
| similar/prod : similar (prod _ _) (prod _ _)
| similar/arrow : similar (arrow _ _) (arrow _ _)
| similar/plus : similar (plus _ _) (plus _ _)
| similar/ref : similar (ref _) (ref _)
| similar/tag : similar (tag _) (tag _)
| similar/tagged : similar tagged tagged
| similar/rec : similar (rec' _ _ _) (rec' _ _ _)
| similar/labeled : similar (labeled _ _) (labeled _ _)
;
--name similar Dsim sim.

% Type Formation Inversion

LF typeish : kind -> type =
| typeish/t : typeish t
| typeish/sing : typeish (sing _)
;
--name typeish Dtypeish typeish.

proof typeish-equiv :
  (g : conbind) [g |- kd-equiv K1 K2] ->
    [g |- typeish K2] ->
      [g |- typeish K1] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-equiv K K1], typeish : [g |- typeish K1]
; split x as
  case kd-equiv/sigma:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a7 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x162 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (sigma K2 (\x98. K4)) (sigma K3 (\x98. K5))],
    typeish : [g |- typeish (sigma K3 (\x98. K5))]
  ; impossible typeish
  }
  case kd-equiv/pi:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a5 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x161 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (pi K2 (\x97. K4)) (pi K3 (\x97. K5))],
    typeish : [g |- typeish (pi K3 (\x97. K5))]
  ; impossible typeish
  }
  case kd-equiv/sing:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)],
    typeish : [g |- typeish (sing C1)]
  ; solve [_ |- typeish/sing ]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv K K3),
    Dequiv1 : (g |- kd-equiv K3 K1)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K1]
  ; by typeish-equiv [_ |- Dequiv1] typeish as typeish1;
    solve typeish-equiv [_ |- Dequiv] typeish1
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K1 K)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K1]
  ; solve typeish-equiv' [_ |- Dequiv] typeish
  }
  case kd-equiv/refl:
  { g : conbind, K1 : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- kd-equiv K1 K1], typeish : [g |- typeish K1]
  ; solve typeish
  }
}

and proof typeish-equiv' :
  (g : conbind) [g |- kd-equiv K1 K2] ->
    [g |- typeish K1] ->
      [g |- typeish K2] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-equiv K K1], typeish : [g |- typeish K]
; split x as
  case kd-equiv/sigma:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a7 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x162 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (sigma K2 (\x98. K4)) (sigma K3 (\x98. K5))],
    typeish : [g |- typeish (sigma K2 (\x98. K4))]
  ; impossible typeish
  }
  case kd-equiv/pi:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a5 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x161 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (pi K2 (\x97. K4)) (pi K3 (\x97. K5))],
    typeish : [g |- typeish (pi K2 (\x97. K4))]
  ; impossible typeish
  }
  case kd-equiv/sing:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)], typeish : [g |- typeish (sing C)]
  ; solve [_ |- typeish/sing ]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv K K3),
    Dequiv1 : (g |- kd-equiv K3 K1)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K]
  ; by typeish-equiv' [_ |- Dequiv] typeish as typeish1;
    solve typeish-equiv' [_ |- Dequiv1] typeish1
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K1 K)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K]
  ; solve typeish-equiv [_ |- Dequiv] typeish
  }
  case kd-equiv/refl:
  { g : conbind, K1 : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- kd-equiv K1 K1], typeish : [g |- typeish K1]
  ; solve typeish
  }
}
;

proof typeish-sub :
  (g : conbind) [g |- kd-sub K1 K2] ->
    [g |- typeish K2] ->
      [g |- typeish K1] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-sub K K1], typeish : [g |- typeish K1]
; split x as
  case kd-sub/sigma:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a11 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a12 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, x419 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, y419 : cn-of a (K3[..]) |- kd-wf (K5[.., a]))
  | x : [g |- kd-sub (sigma K2 (\z350. K4)) (sigma K3 (\z350. K5))],
    typeish : [g |- typeish (sigma K3 (\z350. K5))]
  ; impossible typeish
  }
  case kd-sub/pi:
  { g : conbind,
    K3 : (g |- kind),
    K4 : (g, a9 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a10 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, z417 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, x417 : cn-of a (K3[..]) |- kd-wf (K4[.., a]))
  | x : [g |- kd-sub (pi K3 (\z349. K4)) (pi K2 (\z349. K5))],
    typeish : [g |- typeish (pi K2 (\z349. K5))]
  ; impossible typeish
  }
  case kd-sub/sing-t:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-sub (sing C) t], typeish : [g |- typeish t]
  ; solve [g |- typeish/sing ]
  }
  case kd-sub/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- kd-sub K K3),
    Dsub1 : (g |- kd-sub K3 K1)
  | x : [g |- kd-sub K K1], typeish : [g |- typeish K1]
  ; by typeish-sub [g |- Dsub1] typeish as typeish1;
    solve typeish-sub [g |- Dsub] typeish1
  }
  case kd-sub/refl:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K K1)
  | x : [g |- kd-sub K K1], typeish : [g |- typeish K1]
  ; solve typeish-equiv [g |- Dequiv] typeish
  }
}
;

proof type-inversion :
  (g : conbind) [g |- cn-of T K] ->
    [g |- similar T T] ->
      [g |- kd-sub K t] ->
        [g |- cn-of T t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con), K : (g |- kind)
| x : [g |- cn-of T K], sim : [g |- similar T T], sub : [g |- kd-sub K t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of T K1),
    Dsub : (g |- kd-sub K1 K)
  | x : [g |- cn-of T K], sim : [g |- similar T T], sub : [g |- kd-sub K t]
  ; by sub as Dsub1 unboxed;
    solve type-inversion [_ |- Dof] sim [_ |- kd-sub/trans Dsub Dsub1]
  }
  case cn-of/extsigma:
  { g : conbind,
    T : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a23 : con |- kind),
    Dof : (g |- cn-of (pi1 T) K1),
    Dof1 : (g |- cn-of (pi2 T) (K2[.., pi1 T])),
    Dwf : (g, a : con, y178 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of T (sigma K1 (\x98. K2))],
    sim : [g |- similar T T],
    sub : [g |- kd-sub (sigma K1 (\x98. K2)) t]
  ; impossible typeish-sub sub [_ |- typeish/t]
  }
  case cn-of/extpi:
  { g : conbind,
    T : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a22 : con |- kind),
    K2 : (g, a21 : con |- kind),
    Dof : (g |- cn-of T (pi K1 (\x97. K2))),
    Dof1 :
      (g, a : con, z176 : cn-of a (K1[..]) |-
         cn-of (app (T[..]) a) (K3[.., a]))
  | x : [g |- cn-of T (pi K1 (\x97. K3))],
    sim : [g |- similar T T],
    sub : [g |- kd-sub (pi K1 (\x97. K3)) t]
  ; impossible typeish-sub sub [_ |- typeish/t]
  }
  case cn-of/sing:
  { g : conbind, T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of T (sing T)],
    sim : [g |- similar T T],
    sub : [g |- kd-sub (sing T) t]
  ; solve [_ |- Dof]
  }
  case cn-of/labeled:
  { g : conbind, X : (g |- label), C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of (labeled X C) t],
    sim : [g |- similar (labeled X C) (labeled X C)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/rec:
  { g : conbind,
    K1 : (g |- kind),
    C : (g, a20 : con, a19 : con |- con),
    C1 : (g |- con),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, z174 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y175 : cn-of b (K1[..]) |- cn-of (C[.., a, b]) t),
    Dof1 : (g |- cn-of C1 K1)
  | x : [g |- cn-of (rec' K1 (\x105. \z105. C) C1) t],
    sim :
      [g |-
         similar
           (rec' K1 (\x105. \z105. C) C1) (rec' K1 (\x105. \z105. C) C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/tagged:
  { g : conbind
  | x : [g |- cn-of tagged t],
    sim : [g |- similar tagged tagged],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/tag:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of (tag C) t],
    sim : [g |- similar (tag C) (tag C)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/ref:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of (ref C) t],
    sim : [g |- similar (ref C) (ref C)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/plus:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C t),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- cn-of (plus C C1) t],
    sim : [g |- similar (plus C C1) (plus C C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/arrow:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C t),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- cn-of (arrow C C1) t],
    sim : [g |- similar (arrow C C1) (arrow C C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/prod:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C t),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- cn-of (prod C C1) t],
    sim : [g |- similar (prod C C1) (prod C C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/void:
  { g : conbind
  | x : [g |- cn-of void t],
    sim : [g |- similar void void],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/unit:
  { g : conbind
  | x : [g |- cn-of unit t],
    sim : [g |- similar unit unit],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/star:
  { g : conbind
  | x : [g |- cn-of star one],
    sim : [g |- similar star star],
    sub : [g |- kd-sub one t]
  ; impossible sim
  }
  case cn-of/app:
  { g : conbind,
    C1 : (g |- con),
    C : (g |- con),
    K2 : (g, a18 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C K1),
    Dof1 : (g |- cn-of C1 (pi K1 (\x97. K2)))
  | x : [g |- cn-of (app C1 C) (K2[.., C])],
    sim : [g |- similar (app C1 C) (app C1 C)],
    sub : [g |- kd-sub (K2[.., C]) t]
  ; impossible sim
  }
  case cn-of/lam:
  { g : conbind,
    K1 : (g |- kind),
    C : (g, a16 : con |- con),
    K2 : (g, a17 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, y170 : cn-of a (K1[..]) |- cn-of (C[.., a]) (K2[.., a]))
  | x : [g |- cn-of (lam K1 (\z100. C)) (pi K1 (\x97. K2))],
    sim : [g |- similar (lam K1 (\z100. C)) (lam K1 (\z100. C))],
    sub : [g |- kd-sub (pi K1 (\x97. K2)) t]
  ; impossible sim
  }
  case cn-of/pi2:
  { g : conbind,
    C : (g |- con),
    K2 : (g, a15 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C (sigma K1 (\x98. K2)))
  | x : [g |- cn-of (pi2 C) (K2[.., pi1 C])],
    sim : [g |- similar (pi2 C) (pi2 C)],
    sub : [g |- kd-sub (K2[.., pi1 C]) t]
  ; impossible sim
  }
  case cn-of/pi1:
  { g : conbind,
    C : (g |- con),
    K : (g |- kind),
    K2 : (g, a14 : con |- kind),
    Dof : (g |- cn-of C (sigma K (\x98. K2)))
  | x : [g |- cn-of (pi1 C) K],
    sim : [g |- similar (pi1 C) (pi1 C)],
    sub : [g |- kd-sub K t]
  ; impossible sim
  }
  case cn-of/pair:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a13 : con |- kind),
    Dof : (g |- cn-of C K1),
    Dof1 : (g |- cn-of C1 (K2[.., C])),
    Dwf : (g, a : con, x168 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of (pair C C1) (sigma K1 (\x98. K2))],
    sim : [g |- similar (pair C C1) (pair C C1)],
    sub : [g |- kd-sub (sigma K1 (\x98. K2)) t]
  ; impossible sim
  }
  case #.2:
  { g : conbind,
    K : (g |- kind),
    #cof : #(g |- block (a : con, d : cn-of a (K[..])))
  | x : [g |- cn-of #cof.1 K],
    sim : [g |- similar #cof.1 #cof.1],
    sub : [g |- kd-sub K t]
  ; impossible sim
  }
}
;

LF inversion-prod/e : con -> con -> type =
| inversion-prod/i :
  cn-of T1 t -> cn-of T2 t -> inversion-prod/e T1 T2
;

proof inversion-prod :
  (g : conbind)
  [g |- cn-of (prod T1 T2) t] ->
    [g |- inversion-prod/e T1 T2] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| cof : [g |- cn-of (prod T T1) t]
; split cof as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (prod T T1) K),
    Dsub : (g |- kd-sub K t)
  | cof : [g |- cn-of (prod T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/prod ] [_ |- Dsub]
    as Dof' unboxed;
    solve inversion-prod [_ |- Dof']
  }
  case cn-of/prod:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | cof : [g |- cn-of (prod T T1) t]
  ; solve [_ |- inversion-prod/i Dof Dof1]
  }
}
;

LF inversion-arrow/e : con -> con -> type =
| inversion-arrow/i :
  cn-of T1 t -> cn-of T2 t -> inversion-arrow/e T1 T2
;

proof inversion-arrow :
  (g : conbind)
  [g |- cn-of (arrow T1 T2) t] ->
    [g |- inversion-arrow/e T1 T2] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| cof : [g |- cn-of (arrow T T1) t]
; split cof as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (arrow T T1) K),
    Dsub : (g |- kd-sub K t)
  | cof : [g |- cn-of (arrow T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/arrow ] [_ |- Dsub]
    as Dof' unboxed;
    solve inversion-arrow [_ |- Dof']
  }
  case cn-of/arrow:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | cof : [g |- cn-of (arrow T T1) t]
  ; solve [_ |- inversion-arrow/i Dof Dof1]
  }
}
;

LF inversion-plus/e : con -> con -> type =
| inversion-plus/i :
  cn-of T1 t -> cn-of T2 t -> inversion-plus/e T1 T2
;

proof inversion-plus :
  (g : conbind)
  [g |- cn-of (plus T1 T2) t] ->
    [g |- inversion-plus/e T1 T2] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| cof : [g |- cn-of (plus T T1) t]
; split cof as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (plus T T1) K),
    Dsub : (g |- kd-sub K t)
  | cof : [g |- cn-of (plus T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/plus ] [_ |- Dsub]
    as Dof' unboxed;
    solve inversion-plus [_ |- Dof']
  }
  case cn-of/plus:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | cof : [g |- cn-of (plus T T1) t]
  ; solve [_ |- inversion-plus/i Dof Dof1]
  }
}
;

proof inversion-ref :
  (g : conbind)
  [g |- cn-of (ref T) t] ->
    [g |- cn-of T t] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, T : (g |- con)
| x : [g |- cn-of (ref T) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (ref T) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (ref T) t]
  ; by type-inversion [g |- Dof] [g |- similar/ref ] [g |- Dsub]
    as Dof' unboxed;
    solve inversion-ref [g |- Dof']
  }
  case cn-of/ref:
  { g : conbind, T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of (ref T) t]
  ; solve [_ |- Dof]
  }
}
;

proof inversion-tag :
  (g : conbind)
  [g |- cn-of (tag T) t] ->
    [g |- cn-of T t] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, T : (g |- con)
| x : [g |- cn-of (tag T) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (tag T) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (tag T) t]
  ; by type-inversion [g |- Dof] [g |- similar/tag ] [g |- Dsub]
    as Dof' unboxed;
    solve inversion-tag [g |- Dof']
  }
  case cn-of/tag:
  { g : conbind, T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of (tag T) t]
  ; solve [_ |- Dof]
  }
}
;

LF inversion-rec/e : kind -> (con -> con -> con) -> con -> type =
| inversion-rec/i :
  kd-wf K ->
  ({ a : con } cn-of a (pi K (\l. t)) ->
   { b : con } cn-of b K ->
   cn-of (C1 a b) t) ->
  cn-of C2 K ->
    inversion-rec/e K C1 C2
;

proof inversion-rec :
  (g : conbind)
  [g |- cn-of (rec' K (\x. \y. C1) C2) t] ->
    [g |- inversion-rec/e K (\x. \y. C1) C2] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind,
  K : (g |- kind),
  C : (g, y347 : con, x347 : con |- con),
  C1 : (g |- con)
| cof : [g |- cn-of (rec' K (\x. \y. C) C1) t]
; split cof as
  case cn-of/subsume:
  { g : conbind,
    K : (g |- kind),
    C : (g, y347 : con, x347 : con |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    Dof : (g |- cn-of (rec' K (\x. \y. C) C1) K1),
    Dsub : (g |- kd-sub K1 t)
  | cof : [g |- cn-of (rec' K (\x. \y. C) C1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/rec ] [_ |- Dsub]
    as Dof' unboxed;
    solve inversion-rec [_ |- Dof']
  }
  case cn-of/rec:
  { g : conbind,
    K : (g |- kind),
    C : (g, y347 : con, x347 : con |- con),
    C1 : (g |- con),
    Dwf : (g |- kd-wf K),
    Dof :
      (g, a : con, x416 : cn-of a (pi (K[..]) (\l. t)), b : con,
       z416 : cn-of b (K[..]) |- cn-of (C[.., a, b]) t),
    Dof1 : (g |- cn-of C1 K)
  | cof : [g |- cn-of (rec' K (\x. \y. C) C1) t]
  ; solve [_ |- inversion-rec/i Dwf (\a. \da. \b. \db. Dof) Dof1]
  }
}
;

proof inversion-labeled :
  (g : conbind)
  [g |- cn-of (labeled I T) t] ->
    [g |- cn-of T t] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, I : (g |- label), T : (g |- con)
| x : [g |- cn-of (labeled I T) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    I : (g |- label),
    T : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (labeled I T) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (labeled I T) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/labeled ] [_ |- Dsub]
    as Dof' unboxed;
    solve inversion-labeled [g |- Dof']
  }
  case cn-of/labeled:
  { g : conbind, I : (g |- label), T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of (labeled I T) t]
  ; solve [_ |- Dof]
  }
}
;

% Signature Fst Regularity

LF can-sg-fst/e : sg -> type =
| can-sg-fst/i : { K : kind } sg-fst S K -> can-sg-fst/e S
;

proof can-sg-fst :
  (g : conblock)
  { S : [g |- sg] }
  [g |- can-sg-fst/e S] =
/ total 1 /
intros
{ g : conblock, S : (g |- sg)
|
; split [_ |- S] as
  case sg/named:
  { g : conblock, L : ( |- name), S1 : (g |- sg)
  |
  ; split can-sg-fst [_ |- S1] as
    case can-sg-fst/i:
    { g : conblock,
      L : ( |- name),
      S1 : (g |- sg),
      K : (g |- kind),
      Dfst : (g |- sg-fst S1 K)
    |
    ; solve [_ |- can-sg-fst/i K (sg-fst/named Dfst)]
    }
  }
  case sg/sigma:
  { g : conblock, S1 : (g |- sg), S2 : (g, z354 : con |- sg)
  |
  ; split can-sg-fst [_ |- S1] as
    case can-sg-fst/i:
    { g : conblock,
      S1 : (g |- sg),
      S2 : (g, z354 : con |- sg),
      K : (g |- kind),
      Dfst : (g |- sg-fst S1 K)
    |
    ; split can-sg-fst [_, a : con |- S2] as
      case can-sg-fst/i:
      { g : conblock,
        S1 : (g |- sg),
        S2 : (g, z354 : con |- sg),
        K : (g |- kind),
        Dfst : (g |- sg-fst S1 K),
        K1 : (g, a : con |- kind),
        Dfst1 : (g, a : con |- sg-fst S2 K1)
      |
      ; solve [_ |- can-sg-fst/i _ (sg-fst/sigma Dfst (\a. Dfst1))]
      }
    }
  }
  case sg/pi:
  { g : conblock, S1 : (g |- sg), S2 : (g, z353 : con |- sg)
  |
  ; solve [_ |- can-sg-fst/i _ (sg-fst/pi )]
  }
  case sg/sgatom:
  { g : conblock, S1 : (g |- sg)
  |
  ; solve [_ |- can-sg-fst/i _ (sg-fst/sgatom )]
  }
  case sg/datom:
  { g : conblock, C : (g |- con)
  |
  ; solve [_ |- can-sg-fst/i _ (sg-fst/datom )]
  }
  case sg/satom:
  { g : conblock, K : (g |- kind)
  |
  ; solve [_ |- can-sg-fst/i _ (sg-fst/satom )]
  }
  case sg/one:
  { g : conblock
  |
  ; solve [_ |- can-sg-fst/i _ sg-fst/one]
  }
}
;

proof sg-fst-fun :
  (g : conblock)
  [g |- sg-fst S K] ->
  [g |- sg-fst S K'] ->
    [g |- kind-eq K K'] =
/ total 1 /
intros
{ g : conblock, S : (g |- sg), K : (g |- kind), K' : (g |- kind)
| x : [g |- sg-fst S K], fst : [g |- sg-fst S K']
; split x as
  case sg-fst/named:
  { g : conblock,
    L : ( |- name),
    S1 : (g |- sg),
    K : (g |- kind),
    K' : (g |- kind),
    Dfst : (g |- sg-fst S1 K)
  | x : [g |- sg-fst (sg/named L[] S1) K],
    fst : [g |- sg-fst (sg/named L[] S1) K']
  ; split fst as
    case sg-fst/named:
    { g : conblock,
      L : ( |- name),
      S1 : (g |- sg),
      K : (g |- kind),
      K' : (g |- kind),
      Dfst : (g |- sg-fst S1 K),
      Dfst1 : (g |- sg-fst S1 K')
    | x : [g |- sg-fst (sg/named L[] S1) K],
      fst : [g |- sg-fst (sg/named L[] S1) K']
    ; by sg-fst-fun [_ |- Dfst] [_ |- Dfst1] as Deq unboxed;
      solve [_ |- Deq]
    }
  }
  case sg-fst/sigma:
  { g : conblock,
    S1 : (g |- sg),
    S2 : (g, a58 : con |- sg),
    K1 : (g |- kind),
    K2 : (g, a59 : con |- kind),
    K' : (g |- kind),
    Dfst : (g |- sg-fst S1 K1),
    Dfst1 : (g, a : con |- sg-fst S2 K2)
  | x : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K1 (\y340. K2))],
    fst : [g |- sg-fst (sg/sigma S1 (\z354. S2)) K']
  ; split fst as
    case sg-fst/sigma:
    { g : conblock,
      S1 : (g |- sg),
      S2 : (g, a58 : con |- sg),
      K1 : (g |- kind),
      K2 : (g, a59 : con |- kind),
      K3 : (g |- kind),
      K4 : (g, a59 : con |- kind),
      Dfst : (g |- sg-fst S1 K1),
      Dfst1 : (g, a : con |- sg-fst S2 K2),
      Dfst2 : (g |- sg-fst S1 K3),
      Dfst3 : (g, a : con |- sg-fst S2 K4)
    | x : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K1 (\y340. K2))],
      fst : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K3 (\y340. K4))]
    ; by sg-fst-fun [_ |- Dfst] [_ |- Dfst2] as Deq1 unboxed;
      by sg-fst-fun [_, a : con |- Dfst1] [_, a : con |- Dfst3]
      as Deq2 unboxed;
      split [_ |- Deq1] as
      case kind-eq/i:
      { g : conblock,
        S1 : (g |- sg),
        S2 : (g, a58 : con |- sg),
        K3 : (g |- kind),
        K2 : (g, a59 : con |- kind),
        K4 : (g, a59 : con |- kind),
        Dfst : (g |- sg-fst S1 K3),
        Dfst1 : (g, a : con |- sg-fst S2 K2),
        Dfst2 : (g |- sg-fst S1 K3),
        Dfst3 : (g, a : con |- sg-fst S2 K4),
        Deq2 : (g, a : con |- kind-eq K2 K4)
      | x : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K3 (\y340. K2))],
        fst : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K3 (\y340. K4))]
      ; split [_, a : con |- Deq2] as
        case kind-eq/i:
        { g : conblock,
          S1 : (g |- sg),
          S2 : (g, a58 : con |- sg),
          K3 : (g |- kind),
          K4 : (g, a59 : con |- kind),
          Dfst : (g |- sg-fst S1 K3),
          Dfst1 : (g, a : con |- sg-fst S2 K4),
          Dfst2 : (g |- sg-fst S1 K3),
          Dfst3 : (g, a : con |- sg-fst S2 K4)
        | x : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K3 (\y340. K4))],
          fst :
            [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K3 (\y340. K4))]
        ; solve [_ |- kind-eq/i ]
        }
      }
    }
  }
  case sg-fst/pi:
  { g : conblock, S1 : (g |- sg), S2 : (g, a57 : con |- sg), K' : (g |- kind)
  | x : [g |- sg-fst (sg/pi S1 (\z353. S2)) one],
    fst : [g |- sg-fst (sg/pi S1 (\z353. S2)) K']
  ; split fst as
    case sg-fst/pi:
    { g : conblock, S1 : (g |- sg), S2 : (g, a57 : con |- sg)
    | x : [g |- sg-fst (sg/pi S1 (\z353. S2)) one],
      fst : [g |- sg-fst (sg/pi S1 (\z353. S2)) one]
    ; solve [_ |- kind-eq/i ]
    }
  }
  case sg-fst/sgatom:
  { g : conblock, S1 : (g |- sg), K' : (g |- kind)
  | x : [g |- sg-fst (sg/sgatom S1) one],
    fst : [g |- sg-fst (sg/sgatom S1) K']
  ; split fst as
    case sg-fst/sgatom:
    { g : conblock, S1 : (g |- sg)
    | x : [g |- sg-fst (sg/sgatom S1) one],
      fst : [g |- sg-fst (sg/sgatom S1) one]
    ; solve [_ |- kind-eq/i ]
    }
  }
  case sg-fst/datom:
  { g : conblock, C : (g |- con), K' : (g |- kind)
  | x : [g |- sg-fst (sg/datom C) one], fst : [g |- sg-fst (sg/datom C) K']
  ; split fst as
    case sg-fst/datom:
    { g : conblock, C : (g |- con)
    | x : [g |- sg-fst (sg/datom C) one],
      fst : [g |- sg-fst (sg/datom C) one]
    ; solve [_ |- kind-eq/i ]
    }
  }
  case sg-fst/satom:
  { g : conblock, K : (g |- kind), K' : (g |- kind)
  | x : [g |- sg-fst (sg/satom K) K], fst : [g |- sg-fst (sg/satom K) K']
  ; split fst as
    case sg-fst/satom:
    { g : conblock, K' : (g |- kind)
    | x : [g |- sg-fst (sg/satom K') K'],
      fst : [g |- sg-fst (sg/satom K') K']
    ; solve [_ |- kind-eq/i ]
    }
  }
  case sg-fst/one:
  { g : conblock, K' : (g |- kind)
  | x : [g |- sg-fst sg/one one], fst : [g |- sg-fst sg/one K']
  ; split fst as
    case sg-fst/one:
    { g : conblock
    | x : [g |- sg-fst sg/one one], fst : [g |- sg-fst sg/one one]
    ; solve [_ |- kind-eq/i ]
    }
  }
}
;

proof sg-fst-reg :
  (g : conbind)
  [g |- sg-wf S] ->
  [g |- sg-fst S K] ->
    [g |- kd-wf K] =
/ total 1 /
intros
{ g : conbind, S : (g |- sg), K : (g |- kind)
| x : [g |- sg-wf S], fst : [g |- sg-fst S K]
; split x as
  case sg-wf/named:
  { g : conbind,
    L : ( |- name),
    S1 : (g |- sg),
    K : (g |- kind),
    Dwf : (g |- sg-wf S1)
  | x : [g |- sg-wf (sg/named L[] S1)],
    fst : [g |- sg-fst (sg/named L[] S1) K]
  ; split fst as
    case sg-fst/named:
    { g : conbind,
      L : ( |- name),
      S1 : (g |- sg),
      K : (g |- kind),
      Dwf : (g |- sg-wf S1),
      Dfst : (g |- sg-fst S1 K)
    | x : [g |- sg-wf (sg/named L[] S1)],
      fst : [g |- sg-fst (sg/named L[] S1) K]
    ; solve sg-fst-reg [_ |- Dwf] [_ |- Dfst]
    }
  }
  case sg-wf/sigma:
  { g : conbind,
    S1 : (g |- sg),
    S2 : (g, a48 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dwf : (g |- sg-wf S1),
    Dfst : (g |- sg-fst S1 K1),
    Dwf1 : (g, a : con, y479 : cn-of a (K1[..]) |- sg-wf (S2[.., a]))
  | x : [g |- sg-wf (sg/sigma S1 (\x365. S2))],
    fst : [g |- sg-fst (sg/sigma S1 (\x365. S2)) K]
  ; split fst as
    case sg-fst/sigma:
    { g : conbind,
      S1 : (g |- sg),
      S2 : (g, a48 : con |- sg),
      K2 : (g |- kind),
      K3 : (g, a59 : con |- kind),
      K1 : (g |- kind),
      Dwf : (g |- sg-wf S1),
      Dfst : (g |- sg-fst S1 K1),
      Dwf1 : (g, a : con, y479 : cn-of a (K1[..]) |- sg-wf (S2[.., a])),
      Dfst1 : (g |- sg-fst S1 K2),
      Dfst2 : (g, a : con |- sg-fst S2 K3)
    | x : [g |- sg-wf (sg/sigma S1 (\x365. S2))],
      fst : [g |- sg-fst (sg/sigma S1 (\x365. S2)) (sigma K2 (\z350. K3))]
    ; by sg-fst-reg [g |- Dwf] [g |- Dfst] as DwfK1 unboxed;
      by sg-fst-reg
           [g, b : block (a : con, da : cn-of a (K1[..])) |-
              Dwf1[.., b.1, b.2]]
           [g, b : block (a : con, da : cn-of a (K1[..])) |- Dfst2[.., b.1]]
      as DwfK2 unboxed;
      by sg-fst-fun [g |- Dfst] [g |- Dfst1] as DeqK1 unboxed;
      by kind-resp-kind [g, k : kind |- sigma k (\a. K3[.., a])] [g |- DeqK1]
as Deq unboxed;
      by [g |- kd-wf/sigma DwfK1 (\a. \da. DwfK2[.., <a; da>])] as Dwf' unboxed;
      solve kd-wf-resp [g |- Deq] [g |- Dwf']
    }
  }
  case sg-wf/pi:
  { g : conbind,
    S1 : (g |- sg),
    S2 : (g, a47 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dwf : (g |- sg-wf S1),
    Dfst : (g |- sg-fst S1 K1),
    Dwf1 : (g, a : con, z477 : cn-of a (K1[..]) |- sg-wf (S2[.., a]))
  | x : [g |- sg-wf (sg/pi S1 (\x364. S2))],
    fst : [g |- sg-fst (sg/pi S1 (\x364. S2)) K]
  ; split fst as
    case sg-fst/pi:
    { g : conbind,
      S1 : (g |- sg),
      S2 : (g, a47 : con |- sg),
      K1 : (g |- kind),
      Dwf : (g |- sg-wf S1),
      Dfst : (g |- sg-fst S1 K1),
      Dwf1 : (g, a : con, z477 : cn-of a (K1[..]) |- sg-wf (S2[.., a]))
    | x : [g |- sg-wf (sg/pi S1 (\x364. S2))],
      fst : [g |- sg-fst (sg/pi S1 (\x364. S2)) one]
    ; solve [g |- kd-wf/one]
    }
  }
  case sg-wf/sgatom:
  { g : conbind, S1 : (g |- sg), K : (g |- kind), Dwf : (g |- sg-wf S1)
  | x : [g |- sg-wf (sg/sgatom S1)], fst : [g |- sg-fst (sg/sgatom S1) K]
  ; split fst as
    case sg-fst/sgatom:
    { g : conbind, S1 : (g |- sg), Dwf : (g |- sg-wf S1)
    | x : [g |- sg-wf (sg/sgatom S1)], fst : [g |- sg-fst (sg/sgatom S1) one]
    ; solve [g |- kd-wf/one]
    }
  }
  case sg-wf/datom:
  { g : conbind, C : (g |- con), K : (g |- kind), Dof : (g |- cn-of C t)
  | x : [g |- sg-wf (sg/datom C)], fst : [g |- sg-fst (sg/datom C) K]
  ; split fst as
    case sg-fst/datom:
    { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
    | x : [g |- sg-wf (sg/datom C)], fst : [g |- sg-fst (sg/datom C) one]
    ; solve [g |- kd-wf/one]
    }
  }
  case sg-wf/satom:
  { g : conbind, K1 : (g |- kind), K : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- sg-wf (sg/satom K1)], fst : [g |- sg-fst (sg/satom K1) K]
  ; split fst as
    case sg-fst/satom:
    { g : conbind, K : (g |- kind), Dwf : (g |- kd-wf K)
    | x : [g |- sg-wf (sg/satom K)], fst : [g |- sg-fst (sg/satom K) K]
    ; solve [g |- Dwf]
    }
  }
  case sg-wf/one:
  { g : conbind, K : (g |- kind)
  | x : [g |- sg-wf sg/one], fst : [g |- sg-fst sg/one K]
  ; split fst as
    case sg-fst/one:
    { g : conbind
    | x : [g |- sg-wf sg/one], fst : [g |- sg-fst sg/one one]
    ; solve [g |- kd-wf/one]
    }
  }
}
;

proof sg-equiv-fst :
  (g : conbind)
  [g |- sg-equiv S1 S2] ->
  [g |- sg-fst S1 K1] ->
  [g |- sg-fst S2 K2] ->
    [g |- kd-equiv K1 K2] =
/ total 1 /
intros
{ g : conbind,
  S : (g |- sg),
  S1 : (g |- sg),
  K : (g |- kind),
  K1 : (g |- kind)
| x : [g |- sg-equiv S S1],
  fst : [g |- sg-fst S K],
  fst1 : [g |- sg-fst S1 K1]
; split x as
  case sg-equiv/named:
  { g : conbind,
    L : ( |- name),
    S2 : (g |- sg),
    S3 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3)
  | x : [g |- sg-equiv (sg/named L[] S2) (sg/named L[] S3)],
    fst : [g |- sg-fst (sg/named L[] S2) K],
    fst1 : [g |- sg-fst (sg/named L[] S3) K1]
  ; split fst as
    case sg-fst/named:
    { g : conbind,
      L : ( |- name),
      S2 : (g |- sg),
      S3 : (g |- sg),
      K : (g |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- sg-equiv S2 S3),
      Dfst : (g |- sg-fst S2 K)
    | x : [g |- sg-equiv (sg/named L[] S2) (sg/named L[] S3)],
      fst : [g |- sg-fst (sg/named L[] S2) K],
      fst1 : [g |- sg-fst (sg/named L[] S3) K1]
    ; split fst1 as
      case sg-fst/named:
      { g : conbind,
        L : ( |- name),
        S2 : (g |- sg),
        S3 : (g |- sg),
        K : (g |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- sg-equiv S2 S3),
        Dfst : (g |- sg-fst S2 K),
        Dfst1 : (g |- sg-fst S3 K1)
      | x : [g |- sg-equiv (sg/named L[] S2) (sg/named L[] S3)],
        fst : [g |- sg-fst (sg/named L[] S2) K],
        fst1 : [g |- sg-fst (sg/named L[] S3) K1]
      ; solve sg-equiv-fst [_ |- Dequiv] [_ |- Dfst] [_ |- Dfst1]
      }
    }
  }
  case sg-equiv/sigma:
  { g : conbind,
    S2 : (g |- sg),
    S4 : (g, a51 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a52 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3),
    Dfst : (g |- sg-fst S2 K2),
    Dequiv1 :
      (g, a : con, x484 : cn-of a (K2[..]) |-
         sg-equiv (S4[.., a]) (S5[.., a]))
  | x : [g |- sg-equiv (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
    fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) K],
    fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) K1]
  ; split fst as
    case sg-fst/sigma:
    { g : conbind,
      S2 : (g |- sg),
      S4 : (g, a51 : con |- sg),
      S3 : (g |- sg),
      S5 : (g, a52 : con |- sg),
      K3 : (g |- kind),
      K4 : (g, a59 : con |- kind),
      K1 : (g |- kind),
      K2 : (g |- kind),
      Dequiv1 : (g |- sg-equiv S2 S3),
      Dfst1a : (g |- sg-fst S2 K2),
      Dequiv2 :
        (g, a : con, x484 : cn-of a (K2[..]) |-
           sg-equiv (S4[.., a]) (S5[.., a])),
      Dfst : (g |- sg-fst S2 K3),
      Dfst1 : (g, a : con |- sg-fst S4 K4)
    | x : [g |- sg-equiv (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
      fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) (sigma K3 (\z350. K4))],
      fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) K1]
    ; split fst1 as
      case sg-fst/sigma:
      { g : conbind,
        S2 : (g |- sg),
        S4 : (g, a51 : con |- sg),
        S3 : (g |- sg),
        S5 : (g, a52 : con |- sg),
        K3 : (g |- kind),
        K4 : (g, a59 : con |- kind),
        K5 : (g |- kind),
        K6 : (g, a59 : con |- kind),
        K2 : (g |- kind),
        Dequiv1 : (g |- sg-equiv S2 S3),
        Dfst1a : (g |- sg-fst S2 K2),
        Dequiv2 :
          (g, a : con, x484 : cn-of a (K2[..]) |-
             sg-equiv (S4[.., a]) (S5[.., a])),
        Dfst1a' : (g |- sg-fst S2 K3),
        Dfst2a : (g, a : con |- sg-fst S4 K4),
        Dfst : (g |- sg-fst S3 K5),
        Dfst1 : (g, a : con |- sg-fst S5 K6)
      | x :
          [g |- sg-equiv (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
        fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) (sigma K3 (\z350. K4))],
        fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) (sigma K5 (\z350. K6))]
      ; by sg-equiv-fst [g |- Dequiv1] [g |- Dfst1a] [g |- Dfst]
        as Dequiv1' unboxed;
        by sg-equiv-fst
             [g, b : block (a : con, da : cn-of a (K2[..])) |-
                Dequiv2[.., b.1, b.2]]
             [g, b : block (a : con, da : cn-of a (K2[..])) |-
                Dfst2a[.., b.1]]
             [g, b : block (a : con, da : cn-of a (K2[..])) |- Dfst1[.., b.1]]
        as Dequiv2' unboxed;
        by [g |- kd-equiv/sigma Dequiv1' (\a. \da. Dequiv2'[.., <a; da>])]
        as Dequiv' unboxed;
        by sg-fst-fun [g |- Dfst1a] [g |- Dfst1a'] as Deq1a unboxed;
        by kind-resp-kind [g, k : kind |- sigma k (\a. K4[.., a])] [g |- Deq1a]
as Deqa unboxed;
        solve kd-equiv-resp [g |- Deqa] [g |- kind-eq/i ] [g |- Dequiv']
      }
    }
  }
  case sg-equiv/pi:
  { g : conbind,
    S2 : (g |- sg),
    S4 : (g, a49 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a50 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3),
    Dfst : (g |- sg-fst S2 K2),
    Dequiv1 :
      (g, a : con, y483 : cn-of a (K2[..]) |-
         sg-equiv (S4[.., a]) (S5[.., a]))
  | x : [g |- sg-equiv (sg/pi S2 (\x364. S4)) (sg/pi S3 (\x364. S5))],
    fst : [g |- sg-fst (sg/pi S2 (\x364. S4)) K],
    fst1 : [g |- sg-fst (sg/pi S3 (\x364. S5)) K1]
  ; split fst as
    case sg-fst/pi:
    { g : conbind,
      S2 : (g |- sg),
      S4 : (g, a49 : con |- sg),
      S3 : (g |- sg),
      S5 : (g, a50 : con |- sg),
      K1 : (g |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- sg-equiv S2 S3),
      Dfst : (g |- sg-fst S2 K2),
      Dequiv1 :
        (g, a : con, y483 : cn-of a (K2[..]) |-
           sg-equiv (S4[.., a]) (S5[.., a]))
    | x : [g |- sg-equiv (sg/pi S2 (\x364. S4)) (sg/pi S3 (\x364. S5))],
      fst : [g |- sg-fst (sg/pi S2 (\x364. S4)) one],
      fst1 : [g |- sg-fst (sg/pi S3 (\x364. S5)) K1]
    ; split fst1 as
      case sg-fst/pi:
      { g : conbind,
        S2 : (g |- sg),
        S4 : (g, a49 : con |- sg),
        S3 : (g |- sg),
        S5 : (g, a50 : con |- sg),
        K2 : (g |- kind),
        Dequiv : (g |- sg-equiv S2 S3),
        Dfst : (g |- sg-fst S2 K2),
        Dequiv1 :
          (g, a : con, y483 : cn-of a (K2[..]) |-
             sg-equiv (S4[.., a]) (S5[.., a]))
      | x : [g |- sg-equiv (sg/pi S2 (\x364. S4)) (sg/pi S3 (\x364. S5))],
        fst : [g |- sg-fst (sg/pi S2 (\x364. S4)) one],
        fst1 : [g |- sg-fst (sg/pi S3 (\x364. S5)) one]
      ; solve [g |- kd-equiv/refl kd-wf/one]
      }
    }
  }
  case sg-equiv/sgatom:
  { g : conbind,
    S2 : (g |- sg),
    S3 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3)
  | x : [g |- sg-equiv (sg/sgatom S2) (sg/sgatom S3)],
    fst : [g |- sg-fst (sg/sgatom S2) K],
    fst1 : [g |- sg-fst (sg/sgatom S3) K1]
  ; split fst as
    case sg-fst/sgatom:
    { g : conbind,
      S2 : (g |- sg),
      S3 : (g |- sg),
      K1 : (g |- kind),
      Dequiv : (g |- sg-equiv S2 S3)
    | x : [g |- sg-equiv (sg/sgatom S2) (sg/sgatom S3)],
      fst : [g |- sg-fst (sg/sgatom S2) one],
      fst1 : [g |- sg-fst (sg/sgatom S3) K1]
    ; split fst1 as
      case sg-fst/sgatom:
      { g : conbind,
        S2 : (g |- sg),
        S3 : (g |- sg),
        Dequiv : (g |- sg-equiv S2 S3)
      | x : [g |- sg-equiv (sg/sgatom S2) (sg/sgatom S3)],
        fst : [g |- sg-fst (sg/sgatom S2) one],
        fst1 : [g |- sg-fst (sg/sgatom S3) one]
      ; solve [g |- kd-equiv/refl kd-wf/one]
      }
    }
  }
  case sg-equiv/datom:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- sg-equiv (sg/datom C) (sg/datom C1)],
    fst : [g |- sg-fst (sg/datom C) K],
    fst1 : [g |- sg-fst (sg/datom C1) K1]
  ; split fst as
    case sg-fst/datom:
    { g : conbind,
      C : (g |- con),
      C1 : (g |- con),
      K1 : (g |- kind),
      Dequiv : (g |- cn-equiv C C1 t)
    | x : [g |- sg-equiv (sg/datom C) (sg/datom C1)],
      fst : [g |- sg-fst (sg/datom C) one],
      fst1 : [g |- sg-fst (sg/datom C1) K1]
    ; split fst1 as
      case sg-fst/datom:
      { g : conbind,
        C : (g |- con),
        C1 : (g |- con),
        Dequiv : (g |- cn-equiv C C1 t)
      | x : [g |- sg-equiv (sg/datom C) (sg/datom C1)],
        fst : [g |- sg-fst (sg/datom C) one],
        fst1 : [g |- sg-fst (sg/datom C1) one]
      ; solve [g |- kd-equiv/refl kd-wf/one]
      }
    }
  }
  case sg-equiv/satom:
  { g : conbind,
    K2 : (g |- kind),
    K3 : (g |- kind),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K2 K3)
  | x : [g |- sg-equiv (sg/satom K2) (sg/satom K3)],
    fst : [g |- sg-fst (sg/satom K2) K],
    fst1 : [g |- sg-fst (sg/satom K3) K1]
  ; split fst as
    case sg-fst/satom:
    { g : conbind,
      K : (g |- kind),
      K3 : (g |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- kd-equiv K K3)
    | x : [g |- sg-equiv (sg/satom K) (sg/satom K3)],
      fst : [g |- sg-fst (sg/satom K) K],
      fst1 : [g |- sg-fst (sg/satom K3) K1]
    ; split fst1 as
      case sg-fst/satom:
      { g : conbind,
        K : (g |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- kd-equiv K K1)
      | x : [g |- sg-equiv (sg/satom K) (sg/satom K1)],
        fst : [g |- sg-fst (sg/satom K) K],
        fst1 : [g |- sg-fst (sg/satom K1) K1]
      ; solve [g |- Dequiv]
      }
    }
  }
  case sg-equiv/trans:
  { g : conbind,
    S : (g |- sg),
    S1 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    S3 : (g |- sg),
    Dequiv : (g |- sg-equiv S S3),
    Dequiv1 : (g |- sg-equiv S3 S1)
  | x : [g |- sg-equiv S S1],
    fst : [g |- sg-fst S K],
    fst1 : [g |- sg-fst S1 K1]
  ; split can-sg-fst [g |- S3] as
    case can-sg-fst/i:
    { g : conbind,
      S : (g |- sg),
      S1 : (g |- sg),
      K : (g |- kind),
      K1 : (g |- kind),
      S3 : (g |- sg),
      Dequiv : (g |- sg-equiv S S3),
      Dequiv1 : (g |- sg-equiv S3 S1),
      K2 : (g |- kind),
      Dfst : (g |- sg-fst S3 K2)
    | x : [g |- sg-equiv S S1],
      fst : [g |- sg-fst S K],
      fst1 : [g |- sg-fst S1 K1]
    ; by sg-equiv-fst [g |- Dequiv] fst [g |- Dfst] as Dequiv12' unboxed;
      by sg-equiv-fst [g |- Dequiv1] [g |- Dfst] fst1 as Dequiv23' unboxed;
      solve [g |- kd-equiv/trans Dequiv12' Dequiv23']
    }
  }
  case sg-equiv/symm:
  { g : conbind,
    S : (g |- sg),
    S1 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- sg-equiv S1 S)
  | x : [g |- sg-equiv S S1],
    fst : [g |- sg-fst S K],
    fst1 : [g |- sg-fst S1 K1]
  ; by sg-equiv-fst [g |- Dequiv] fst1 fst as Dequiv' unboxed;
    solve [g |- kd-equiv/symm Dequiv']
  }
  case sg-equiv/refl:
  { g : conbind,
    S1 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dwf : (g |- sg-wf S1)
  | x : [g |- sg-equiv S1 S1],
    fst : [g |- sg-fst S1 K],
    fst1 : [g |- sg-fst S1 K1]
  ; by sg-fst-reg [g |- Dwf] fst as DwfK unboxed;
    by sg-fst-fun fst fst1 as Deq unboxed;
    solve kd-equiv-resp [g |- kind-eq/i ] [g |- Deq] [g |- kd-equiv/refl DwfK]
  }
}
;

proof sg-sub-fst :
  (g : conbind)
  [g |- sg-sub S1 S2] ->
  [g |- sg-fst S1 K1] ->
  [g |- sg-fst S2 K2] ->
    [g |- kd-sub K1 K2] =
/ total 1 /
intros
{ g : conbind,
  S : (g |- sg),
  S1 : (g |- sg),
  K : (g |- kind),
  K1 : (g |- kind)
| x : [g |- sg-sub S S1], fst : [g |- sg-fst S K], fst1 : [g |- sg-fst S1 K1]
; split x as
  case sg-sub/named:
  { g : conbind,
    L : ( |- name),
    S2 : (g |- sg),
    S3 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- sg-sub S2 S3)
  | x : [g |- sg-sub (sg/named L[] S2) (sg/named L[] S3)],
    fst : [g |- sg-fst (sg/named L[] S2) K],
    fst1 : [g |- sg-fst (sg/named L[] S3) K1]
  ; split fst as
    case sg-fst/named:
    { g : conbind,
      L : ( |- name),
      S2 : (g |- sg),
      S3 : (g |- sg),
      K : (g |- kind),
      K1 : (g |- kind),
      Dsub : (g |- sg-sub S2 S3),
      Dfst : (g |- sg-fst S2 K)
    | x : [g |- sg-sub (sg/named L[] S2) (sg/named L[] S3)],
      fst : [g |- sg-fst (sg/named L[] S2) K],
      fst1 : [g |- sg-fst (sg/named L[] S3) K1]
    ; split fst1 as
      case sg-fst/named:
      { g : conbind,
        L : ( |- name),
        S2 : (g |- sg),
        S3 : (g |- sg),
        K : (g |- kind),
        K1 : (g |- kind),
        Dsub : (g |- sg-sub S2 S3),
        Dfst : (g |- sg-fst S2 K),
        Dfst1 : (g |- sg-fst S3 K1)
      | x : [g |- sg-sub (sg/named L[] S2) (sg/named L[] S3)],
        fst : [g |- sg-fst (sg/named L[] S2) K],
        fst1 : [g |- sg-fst (sg/named L[] S3) K1]
      ; solve sg-sub-fst [_ |- Dsub] [_ |- Dfst] [_ |- Dfst1]
      }
    }
  }
  case sg-sub/sigma:
  { g : conbind,
    S2 : (g |- sg),
    S4 : (g, a55 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a56 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- sg-sub S2 S3),
    Dfst : (g |- sg-fst S2 K2),
    Dsub1 :
      (g, a : con, z490 : cn-of a (K2[..]) |- sg-sub (S4[.., a]) (S5[.., a])),
    Dfst1 : (g |- sg-fst S3 K3),
    Dwf : (g, a : con, x490 : cn-of a (K3[..]) |- sg-wf (S5[.., a]))
  | x : [g |- sg-sub (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
    fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) K],
    fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) K1]
  ; split fst as
    case sg-fst/sigma:
    { g : conbind,
      S2 : (g |- sg),
      S4 : (g, a55 : con |- sg),
      S3 : (g |- sg),
      S5 : (g, a56 : con |- sg),
      K4 : (g |- kind),
      K5 : (g, a59 : con |- kind),
      K1 : (g |- kind),
      K2 : (g |- kind),
      K3 : (g |- kind),
      Dsub : (g |- sg-sub S2 S3),
      Dfst : (g |- sg-fst S2 K2),
      Dsub1 :
        (g, a : con, z490 : cn-of a (K2[..]) |-
           sg-sub (S4[.., a]) (S5[.., a])),
      Dfst1 : (g |- sg-fst S3 K3),
      Dwf : (g, a : con, x490 : cn-of a (K3[..]) |- sg-wf (S5[.., a])),
      Dfst2 : (g |- sg-fst S2 K4),
      Dfst3 : (g, a : con |- sg-fst S4 K5)
    | x : [g |- sg-sub (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
      fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) (sigma K4 (\z350. K5))],
      fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) K1]
    ; split fst1 as
      case sg-fst/sigma:
      { g : conbind,
        S2 : (g |- sg),
        S4 : (g, a55 : con |- sg),
        S3 : (g |- sg),
        S5 : (g, a56 : con |- sg),
        K4 : (g |- kind),
        K5 : (g, a59 : con |- kind),
        K6 : (g |- kind),
        K7 : (g, a59 : con |- kind),
        K2 : (g |- kind),
        K3 : (g |- kind),
        Dsub : (g |- sg-sub S2 S3),
        Dfst : (g |- sg-fst S2 K2),
        Dsub1 :
          (g, a : con, z490 : cn-of a (K2[..]) |-
             sg-sub (S4[.., a]) (S5[.., a])),
        Dfst1 : (g |- sg-fst S3 K3),
        Dwf : (g, a : con, x490 : cn-of a (K3[..]) |- sg-wf (S5[.., a])),
        Dfst2 : (g |- sg-fst S2 K4),
        Dfst3 : (g, a : con |- sg-fst S4 K5),
        Dfst4 : (g |- sg-fst S3 K6),
        Dfst5 : (g, a : con |- sg-fst S5 K7)
      | x : [g |- sg-sub (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
        fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) (sigma K4 (\z350. K5))],
        fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) (sigma K6 (\z350. K7))]
      ; by sg-fst-fun [g |- Dfst] [g |- Dfst2] as Deq1a unboxed;
        by kind-resp-kind [g, k : kind |- sigma k (\a. K5[.., a])]
             [g |- Deq1a]
        as Deqa unboxed;
        by sg-fst-fun [g |- Dfst1] [g |- Dfst4] as Deq1b unboxed;
        by kind-resp-kind [g, k : kind |- sigma k (\a. K7[.., a])]
             [g |- Deq1b]
        as Deqb unboxed;
        by sg-sub-fst [g |- Dsub] [g |- Dfst] [g |- Dfst1] as Dsub1' unboxed;
        by sg-sub-fst
     [g, b : block (a : con, da : cn-of a (K2[..])) |- Dsub1[.., b.1, b.2]]
     [g, b : block (a : con, da : cn-of a (K2[..])) |- Dfst3[.., b.1]]
     [g, b : block (a : con, da : cn-of a (K2[..])) |- Dfst5[.., b.1]]
as Dsub2' unboxed;
        by sg-fst-reg
             [g, b : block (a : con, da : cn-of a (K3[..])) |-
                Dwf[.., b.1, b.2]]
             [g, b : block (a : con, da : cn-of a (K3[..])) |- Dfst5[.., b.1]]
        as Dwf2b' unboxed;
        by [g |-
              kd-sub/sigma Dsub1'
              (\a. \da. Dsub2'[.., <a; da>]) (\a. \da. Dwf2b'[.., <a; da>])]
        as Dsub' unboxed;
        solve kd-sub-resp [g |- Deqa] [g |- Deqb] [g |- Dsub']
      }
    }
  }
  case sg-sub/pi:
  { g : conbind,
    S3 : (g |- sg),
    S4 : (g, a53 : con |- sg),
    S2 : (g |- sg),
    S5 : (g, a54 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- sg-sub S2 S3),
    Dfst : (g |- sg-fst S2 K2),
    Dsub1 :
      (g, a : con, x488 : cn-of a (K2[..]) |- sg-sub (S4[.., a]) (S5[.., a])),
    Dfst1 : (g |- sg-fst S3 K3),
    Dwf : (g, a : con, y488 : cn-of a (K3[..]) |- sg-wf (S4[.., a]))
  | x : [g |- sg-sub (sg/pi S3 (\x364. S4)) (sg/pi S2 (\x364. S5))],
    fst : [g |- sg-fst (sg/pi S3 (\x364. S4)) K],
    fst1 : [g |- sg-fst (sg/pi S2 (\x364. S5)) K1]
  ; split fst as
    case sg-fst/pi:
    { g : conbind,
      S3 : (g |- sg),
      S4 : (g, a53 : con |- sg),
      S2 : (g |- sg),
      S5 : (g, a54 : con |- sg),
      K1 : (g |- kind),
      K2 : (g |- kind),
      K3 : (g |- kind),
      Dsub : (g |- sg-sub S2 S3),
      Dfst : (g |- sg-fst S2 K2),
      Dsub1 :
        (g, a : con, x488 : cn-of a (K2[..]) |-
           sg-sub (S4[.., a]) (S5[.., a])),
      Dfst1 : (g |- sg-fst S3 K3),
      Dwf : (g, a : con, y488 : cn-of a (K3[..]) |- sg-wf (S4[.., a]))
    | x : [g |- sg-sub (sg/pi S3 (\x364. S4)) (sg/pi S2 (\x364. S5))],
      fst : [g |- sg-fst (sg/pi S3 (\x364. S4)) one],
      fst1 : [g |- sg-fst (sg/pi S2 (\x364. S5)) K1]
    ; split fst1 as
      case sg-fst/pi:
      { g : conbind,
        S3 : (g |- sg),
        S4 : (g, a53 : con |- sg),
        S2 : (g |- sg),
        S5 : (g, a54 : con |- sg),
        K2 : (g |- kind),
        K3 : (g |- kind),
        Dsub : (g |- sg-sub S2 S3),
        Dfst : (g |- sg-fst S2 K2),
        Dsub1 :
          (g, a : con, x488 : cn-of a (K2[..]) |-
             sg-sub (S4[.., a]) (S5[.., a])),
        Dfst1 : (g |- sg-fst S3 K3),
        Dwf : (g, a : con, y488 : cn-of a (K3[..]) |- sg-wf (S4[.., a]))
      | x : [g |- sg-sub (sg/pi S3 (\x364. S4)) (sg/pi S2 (\x364. S5))],
        fst : [g |- sg-fst (sg/pi S3 (\x364. S4)) one],
        fst1 : [g |- sg-fst (sg/pi S2 (\x364. S5)) one]
      ; solve [g |- kd-sub/refl (kd-equiv/refl kd-wf/one)]
      }
    }
  }
  case sg-sub/satom:
  { g : conbind,
    K2 : (g |- kind),
    K3 : (g |- kind),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- kd-sub K2 K3)
  | x : [g |- sg-sub (sg/satom K2) (sg/satom K3)],
    fst : [g |- sg-fst (sg/satom K2) K],
    fst1 : [g |- sg-fst (sg/satom K3) K1]
  ; split fst as
    case sg-fst/satom:
    { g : conbind,
      K : (g |- kind),
      K3 : (g |- kind),
      K1 : (g |- kind),
      Dsub : (g |- kd-sub K K3)
    | x : [g |- sg-sub (sg/satom K) (sg/satom K3)],
      fst : [g |- sg-fst (sg/satom K) K],
      fst1 : [g |- sg-fst (sg/satom K3) K1]
    ; split fst1 as
      case sg-fst/satom:
      { g : conbind,
        K : (g |- kind),
        K1 : (g |- kind),
        Dsub : (g |- kd-sub K K1)
      | x : [g |- sg-sub (sg/satom K) (sg/satom K1)],
        fst : [g |- sg-fst (sg/satom K) K],
        fst1 : [g |- sg-fst (sg/satom K1) K1]
      ; solve [g |- Dsub]
      }
    }
  }
  case sg-sub/trans:
  { g : conbind,
    S : (g |- sg),
    S1 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    S3 : (g |- sg),
    Dsub : (g |- sg-sub S S3),
    Dsub1 : (g |- sg-sub S3 S1)
  | x : [g |- sg-sub S S1],
    fst : [g |- sg-fst S K],
    fst1 : [g |- sg-fst S1 K1]
  ; split can-sg-fst [g |- S3] as
    case can-sg-fst/i:
    { g : conbind,
      S : (g |- sg),
      S1 : (g |- sg),
      K : (g |- kind),
      K1 : (g |- kind),
      S3 : (g |- sg),
      Dsub : (g |- sg-sub S S3),
      Dsub1 : (g |- sg-sub S3 S1),
      K2 : (g |- kind),
      Dfst : (g |- sg-fst S3 K2)
    | x : [g |- sg-sub S S1],
      fst : [g |- sg-fst S K],
      fst1 : [g |- sg-fst S1 K1]
    ; by sg-sub-fst [g |- Dsub] fst [g |- Dfst] as Dsub12' unboxed;
      by sg-sub-fst [g |- Dsub1] [g |- Dfst] fst1 as Dsub23' unboxed;
      solve [g |- kd-sub/trans Dsub12' Dsub23']
    }
  }
  case sg-sub/refl:
  { g : conbind,
    S : (g |- sg),
    S1 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- sg-equiv S S1)
  | x : [g |- sg-sub S S1],
    fst : [g |- sg-fst S K],
    fst1 : [g |- sg-fst S1 K1]
  ; by sg-equiv-fst [g |- Dequiv] fst fst1 as Dequiv' unboxed;
    solve [g |- kd-sub/refl Dequiv']
  }
}
;
