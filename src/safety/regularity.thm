% Constructor Regularity

schema conbind-reg = some [K : kind, wf : kd-wf K]
                     block (a : con, da : cn-of a K);

proof cn-of/equiv/conbind-reg :
  (g : conbind-reg)
  [g |- cn-of C K] ->
  [g |- kd-equiv K K'] ->
    [g |- cn-of C K'] =
/ total /
intros
{ g : conbind-reg, C : (g |- con), K : (g |- kind), K' : (g |- kind)
| cof : [g |- cn-of C K], equiv : [g |- kd-equiv K K']
; by cof as Dof unboxed;
  by equiv as Dequiv unboxed;
  solve [_ |- cn-of/subsume Dof (kd-sub/refl Dequiv)]
}
;

proof kd-equiv-reg/1 :
  (g : conbind-reg) [g |- kd-equiv K1 K2] ->
    [g |- kd-wf K1] =
/ total 1 /
intros
{ g : conbind-reg, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-equiv K K1]
; split x as
  case kd-equiv/sigma:
  { g : conbind-reg,
    K2 : (g |- kind),
    K4 : (g, a7 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x162 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (sigma K2 (\x98. K4)) (sigma K3 (\x98. K5))]
  ; by kd-equiv-reg/1 [_ |- Dequiv] as Dwf1a unboxed;
    by kd-equiv-reg/1
     [g, b : block (a : con, da : cn-of a (K2[..])) |- Dequiv1[.., b.1, b.2]]
as Dwf1b unboxed;
    solve [g |- kd-wf/sigma Dwf1a (\a. \da. Dwf1b[.., <a; da>])]
  }
  case kd-equiv/pi:
  { g : conbind-reg,
    K2 : (g |- kind),
    K4 : (g, a5 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x161 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (pi K2 (\x97. K4)) (pi K3 (\x97. K5))]
  ; by kd-equiv-reg/1 [g |- Dequiv] as Dwf1a unboxed;
    by kd-equiv-reg/1
         [g, b : block (a : con, da : cn-of a (K2[..])) |-
            Dequiv1[.., b.1, b.2]]
    as Dwf1b unboxed;
    solve [g |- kd-wf/pi Dwf1a (\a. \da. Dwf1b[.., <a; da>])]
  }
  case kd-equiv/sing:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1 unboxed;
    solve [g |- kd-wf/sing Dof1]
  }
  case kd-equiv/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv K K3),
    Dequiv1 : (g |- kd-equiv K3 K1)
  | x : [g |- kd-equiv K K1]
  ; solve kd-equiv-reg/1 [g |- Dequiv]
  }
  case kd-equiv/symm:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K1 K)
  | x : [g |- kd-equiv K K1]
  ; solve kd-equiv-reg/2 [g |- Dequiv]
  }
  case kd-equiv/refl:
  { g : conbind-reg, K1 : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- kd-equiv K1 K1]
  ; solve [_ |- Dwf]
  }
}

and proof kd-equiv-reg/2 :
  (g : conbind-reg) [g |- kd-equiv K1 K2] ->
    [g |- kd-wf K2] =
/ total 1 /
?

and proof kd-sub-reg/1 :
  (g : conbind-reg) [g |- kd-sub K1 K2] ->
    [g |- kd-wf K1] =
/ total 1 /
intros
{ g : conbind-reg, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-sub K K1]
; split x as
  case kd-sub/sigma:
  { g : conbind-reg,
    K3 : (g |- kind),
    K4 : (g, a11 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a12 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, y167 : cn-of a (K3[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, z166 : cn-of a (K2[..]) |- kd-wf (K5[.., a]))
  | x : [g |- kd-sub (sigma K3 (\x98. K4)) (sigma K2 (\x98. K5))]
  ; by kd-sub-reg/2 [g |- Dsub] as Dwf1a unboxed;
    by kd-sub-reg/1
         [g, b : block (a : con, da : cn-of a (K3[..])) |-
            Dsub1[.., b.1, b.2]]
    as Dwf1b unboxed;
    solve [g |- kd-wf/sigma Dwf1a (\a. \da. Dwf1b[.., <a; da>])]
  }
  case kd-sub/pi:
  { g : conbind-reg,
    K3 : (g |- kind),
    K4 : (g, a9 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a10 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, x165 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, y165 : cn-of a (K3[..]) |- kd-wf (K4[.., a]))
  | x : [g |- kd-sub (pi K3 (\x97. K4)) (pi K2 (\x97. K5))]
  ; by kd-sub-reg/2 [g |- Dsub] as Dwf1a unboxed;
    solve [g |- kd-wf/pi Dwf1a (\a. \da. Dwf)]
  }
  case kd-sub/sing-t:
  { g : conbind-reg, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-sub (sing C) t]
  ; solve [g |- kd-wf/sing Dof]
  }
  case kd-sub/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- kd-sub K K3),
    Dsub1 : (g |- kd-sub K3 K1)
  | x : [g |- kd-sub K K1]
  ; solve kd-sub-reg/1 [g |- Dsub]
  }
  case kd-sub/refl:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K K1)
  | x : [g |- kd-sub K K1]
  ; solve kd-equiv-reg/1 [g |- Dequiv]
  }
}

and proof kd-sub-reg/2 :
  (g : conbind-reg) [g |- kd-sub K1 K2] ->
    [g |- kd-wf K2] =
/ total 1 /
intros
{ g : conbind-reg, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-sub K K1]
; split x as
  case kd-sub/sigma:
  { g : conbind-reg,
    K3 : (g |- kind),
    K4 : (g, a11 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a12 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, y167 : cn-of a (K3[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, z166 : cn-of a (K2[..]) |- kd-wf (K5[.., a]))
  | x : [g |- kd-sub (sigma K3 (\x98. K4)) (sigma K2 (\x98. K5))]
  ; by kd-sub-reg/1 [_ |- Dsub] as Dwf2a unboxed;
    solve [g |- kd-wf/sigma Dwf2a (\a. \da. Dwf)]
  }
  case kd-sub/pi:
  { g : conbind-reg,
    K3 : (g |- kind),
    K4 : (g, a9 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a10 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, x165 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, y165 : cn-of a (K3[..]) |- kd-wf (K4[.., a]))
  | x : [g |- kd-sub (pi K3 (\x97. K4)) (pi K2 (\x97. K5))]
  ; by kd-sub-reg/1 [_ |- Dsub] as Dwf2a unboxed;
    by kd-sub-reg/2
     [g, b : block (a : con, da : cn-of a (K2[..])) |- Dsub1[.., b.1, b.2]]
as Dwf2b unboxed;
    solve [g |- kd-wf/pi Dwf2a (\a. \da. Dwf2b[.., <a; da>])]
  }
  case kd-sub/sing-t:
  { g : conbind-reg, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-sub (sing C) t]
  ; solve [g |- kd-wf/t]
  }
  case kd-sub/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- kd-sub K K3),
    Dsub1 : (g |- kd-sub K3 K1)
  | x : [g |- kd-sub K K1]
  ; solve kd-sub-reg/2 [g |- Dsub1]
  }
  case kd-sub/refl:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K K1)
  | x : [g |- kd-sub K K1]
  ; solve kd-equiv-reg/2 [g |- Dequiv]
  }
}

and proof cn-of-reg :
  (g : conbind-reg) [g |- cn-of C K] ->
    [g |- kd-wf K] =
/ total 1 /
intros
{ g : conbind-reg, C : (g |- con), K : (g |- kind)
| x : [g |- cn-of C K]
; split x as
  case cn-of/subsume:
  { g : conbind-reg,
    C : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C K1),
    Dsub : (g |- kd-sub K1 K)
  | x : [g |- cn-of C K]
  ; solve kd-sub-reg/2 [_ |- Dsub]
  }
  case cn-of/extsigma:
  { g : conbind-reg,
    C : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a23 : con |- kind),
    Dof : (g |- cn-of (pi1 C) K1),
    Dof1 : (g |- cn-of (pi2 C) (K2[.., pi1 C])),
    Dwf : (g, a : con, y178 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of C (sigma K1 (\x98. K2))]
  ; by cn-of-reg [_ |- Dof] as Dwf1 unboxed;
    solve [_ |- kd-wf/sigma Dwf1 (\a. \da. Dwf)]
  }
  case cn-of/extpi:
  { g : conbind-reg,
    C : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a22 : con |- kind),
    K2 : (g, a21 : con |- kind),
    Dof : (g |- cn-of C (pi K1 (\x97. K2))),
    Dof1 :
      (g, a : con, z176 : cn-of a (K1[..]) |-
         cn-of (app (C[..]) a) (K3[.., a]))
  | x : [g |- cn-of C (pi K1 (\x97. K3))]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/pi:
    { g : conbind-reg,
      C : (g |- con),
      K1 : (g |- kind),
      K3 : (g, a22 : con |- kind),
      K2 : (g, a21 : con |- kind),
      Dof : (g |- cn-of C (pi K1 (\x97. K2))),
      Dof1 :
        (g, a : con, z176 : cn-of a (K1[..]) |-
           cn-of (app (C[..]) a) (K3[.., a])),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z157 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of C (pi K1 (\x97. K3))]
    ; by cn-of-reg
           [g, b : block (a : con, da : cn-of a (K1[..])) |-
              Dof1[.., b.1, b.2]]
      as Dwf2 unboxed;
      solve [g |- kd-wf/pi Dwf (\a. \da. Dwf2[.., <a; da>])]
    }
  }
  case cn-of/sing:
  { g : conbind-reg, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of C (sing C)]
  ; solve [g |- kd-wf/sing Dof]
  }
  case cn-of/labeled:
  { g : conbind-reg,
    X : (g |- label),
    C1 : (g |- con),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (labeled X C1) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/rec:
  { g : conbind-reg,
    K1 : (g |- kind),
    C1 : (g, a20 : con, a19 : con |- con),
    C2 : (g |- con),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, z174 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y175 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
    Dof1 : (g |- cn-of C2 K1)
  | x : [g |- cn-of (rec' K1 (\x105. \z105. C1) C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/tagged:
  { g : conbind-reg
  | x : [g |- cn-of tagged t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/tag:
  { g : conbind-reg, C1 : (g |- con), Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (tag C1) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/ref:
  { g : conbind-reg, C1 : (g |- con), Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (ref C1) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/plus:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (plus C1 C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/arrow:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (arrow C1 C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/prod:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (prod C1 C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/void:
  { g : conbind-reg
  | x : [g |- cn-of void t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/unit:
  { g : conbind-reg
  | x : [g |- cn-of unit t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/star:
  { g : conbind-reg
  | x : [g |- cn-of star one]
  ; solve [g |- kd-wf/one]
  }
  case cn-of/app:
  { g : conbind-reg,
    C2 : (g |- con),
    C1 : (g |- con),
    K2 : (g, a18 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of C2 (pi K1 (\x97. K2)))
  | x : [g |- cn-of (app C2 C1) (K2[.., C1])]
  ; split cn-of-reg [g |- Dof1] as
    case kd-wf/pi:
    { g : conbind-reg,
      C2 : (g |- con),
      C1 : (g |- con),
      K2 : (g, a18 : con |- kind),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 K1),
      Dof1 : (g |- cn-of C2 (pi K1 (\x97. K2))),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z157 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of (app C2 C1) (K2[.., C1])]
    ; solve [g |- Dwf1[.., C1, Dof]]
    }
  }
  case cn-of/lam:
  { g : conbind-reg,
    K1 : (g |- kind),
    C1 : (g, a16 : con |- con),
    K2 : (g, a17 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, y170 : cn-of a (K1[..]) |- cn-of (C1[.., a]) (K2[.., a]))
  | x : [g |- cn-of (lam K1 (\z100. C1)) (pi K1 (\x97. K2))]
  ; by cn-of-reg
     [g, b : block (a : con, da : cn-of a (K1[..])) |- Dof[.., b.1, b.2]]
as Dwf2 unboxed;
    solve [g |- kd-wf/pi Dwf (\a. \da. Dwf2[.., <a; da>])]
  }
  case cn-of/pi2:
  { g : conbind-reg,
    C1 : (g |- con),
    K2 : (g, a15 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 (sigma K1 (\x98. K2)))
  | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/sigma:
    { g : conbind-reg,
      C1 : (g |- con),
      K2 : (g, a15 : con |- kind),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 (sigma K1 (\x98. K2))),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z158 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])]
    ; by [g |- cn-of/pi1 Dof] as Dof1 unboxed;
      solve [g |- Dwf1[.., _, Dof1]]
    }
  }
  case cn-of/pi1:
  { g : conbind-reg,
    C1 : (g |- con),
    K : (g |- kind),
    K2 : (g, a14 : con |- kind),
    Dof : (g |- cn-of C1 (sigma K (\x98. K2)))
  | x : [g |- cn-of (pi1 C1) K]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/sigma:
    { g : conbind-reg,
      C1 : (g |- con),
      K : (g |- kind),
      K2 : (g, a14 : con |- kind),
      Dof : (g |- cn-of C1 (sigma K (\x98. K2))),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g, a : con, z158 : cn-of a (K[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of (pi1 C1) K]
    ; solve [g |- Dwf]
    }
  }
  case cn-of/pair:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a13 : con |- kind),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of C2 (K2[.., C1])),
    Dwf : (g, a : con, x168 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of (pair C1 C2) (sigma K1 (\x98. K2))]
  ; by cn-of-reg [g |- Dof] as Dwf1 unboxed;
    solve [g |- kd-wf/sigma Dwf1 (\a. \da. Dwf)]
  }
  case #.2:
  { g : conbind-reg,
    K : (g |- kind),
    #cof : #(g |- block (a : con, da : cn-of a (K[..]))),
    Dwf32 : (g |- kd-wf K)
  | x : [g |- cn-of #cof.1 K]
  ; solve [_ |- Dwf32]
  }
}

and proof cn-equiv-reg/cn-of1 :
  (g : conbind-reg) [g |- cn-equiv C1 C2 K] ->
    [g |- cn-of C1 K] =
/ total 1 /
intros
{ g : conbind-reg, C : (g |- con), C1 : (g |- con), K : (g |- kind)
| x : [g |- cn-equiv C C1 K]
; split x as
  case cn-equiv/beta2:
  { g : conbind-reg,
    C2 : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C2 K1),
    Dof1 : (g |- cn-of C1 K)
  | x : [g |- cn-equiv (pi2 (pair C2 C1)) C1 K]
  ; by cn-of-reg [g |- Dof1] as Dwf2 unboxed;
    by [g |- cn-of/pair Dof Dof1 (\a1. \a2. Dwf2[..])] as Dof' unboxed;
    solve [g |- cn-of/pi2 Dof']
  }
  case cn-equiv/beta1:
  { g : conbind-reg,
    C1 : (g |- con),
    C3 : (g |- con),
    K : (g |- kind),
    K2 : (g |- kind),
    Dof : (g |- cn-of C1 K),
    Dof1 : (g |- cn-of C3 K2)
  | x : [g |- cn-equiv (pi1 (pair C1 C3)) C1 K]
  ; by cn-of-reg [g |- Dof1] as Dwf1 unboxed;
    by [g |- cn-of/pair Dof Dof1 (\a1. \a2. Dwf1[..])] as Dof' unboxed;
    solve [g |- cn-of/pi1 Dof']
  }
  case cn-equiv/beta:
  { g : conbind-reg,
    K1 : (g |- kind),
    C3 : (g, a41 : con |- con),
    C2 : (g |- con),
    K2 : (g, a42 : con |- kind),
    Dof : (g |- cn-of C2 K1),
    Dof1 :
      (g, a : con, y195 : cn-of a (K1[..]) |- cn-of (C3[.., a]) (K2[.., a]))
  | x :
      [g |- cn-equiv (app (lam K1 (\z100. C3)) C2) (C3[.., C2]) (K2[.., C2])]
  ; by cn-of-reg [g |- Dof] as DwfA unboxed;
    solve [g |- cn-of/app Dof (cn-of/lam DwfA (\a. \da. Dof1))]
  }
  case cn-equiv/subsume:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- kd-sub K1 K),
    Dequiv : (g |- cn-equiv C C1 K1)
  | x : [g |- cn-equiv C C1 K]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1 unboxed;
    solve [g |- cn-of/subsume Dof1 Dsub]
  }
  case cn-equiv/one:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C one),
    Dof1 : (g |- cn-of C1 one)
  | x : [g |- cn-equiv C C1 one]
  ; solve [_ |- Dof]
  }
  case cn-equiv/extsigma:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a40 : con |- kind),
    Dequiv : (g |- cn-equiv (pi1 C) (pi1 C1) K1),
    Dequiv1 : (g |- cn-equiv (pi2 C) (pi2 C1) (K2[.., pi1 C])),
    Dwf : (g, a : con, z192 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-equiv C C1 (sigma K1 (\x98. K2))]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1a unboxed;
    by cn-equiv-reg/cn-of1 [g |- Dequiv1] as Dof1b unboxed;
    solve [g |- cn-of/extsigma Dof1a Dof1b (\a. \da. Dwf)]
  }
  case cn-equiv/extpiw:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a39 : con |- kind),
    K2 : (g, a38 : con |- kind),
    Dequiv : (g |- cn-equiv C C1 (pi K1 (\x97. K2))),
    Dequiv1 :
      (g, a : con, x191 : cn-of a (K1[..]) |-
         cn-equiv (app (C[..]) a) (app (C1[..]) a) (K3[.., a]))
  | x : [g |- cn-equiv C C1 (pi K1 (\x97. K3))]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1 unboxed;
    by cn-equiv-reg/cn-of1
         [g, b : block (a : con, da : cn-of a (K1[..])) |-
            Dequiv1[.., b.1, b.2]]
    as Dof1' unboxed;
    solve [g |- cn-of/extpi Dof1 (\a. \da. Dof1'[.., <a; da>])]
  }
  case cn-equiv/extpi:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K4 : (g, a37 : con |- kind),
    K2 : (g, a35 : con |- kind),
    K3 : (g, a36 : con |- kind),
    Dof : (g |- cn-of C (pi K1 (\x97. K2))),
    Dof1 : (g |- cn-of C1 (pi K1 (\x97. K3))),
    Dequiv :
      (g, a : con, x190 : cn-of a (K1[..]) |-
         cn-equiv (app (C[..]) a) (app (C1[..]) a) (K4[.., a]))
  | x : [g |- cn-equiv C C1 (pi K1 (\x97. K4))]
  ; by cn-equiv-reg/cn-of1
     [g, b : block (a : con, da : cn-of a (K1[..])) |- Dequiv[.., b.1, b.2]]
as Dof1' unboxed;
    solve [g |- cn-of/extpi Dof (\a. \da. Dof1'[.., <a; da>])]
  }
  case cn-equiv/singelim:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C (sing C1))
  | x : [g |- cn-equiv C C1 t]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/sing:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      Dof : (g |- cn-of C (sing C1)),
      Dof1 : (g |- cn-of C1 t)
    | x : [g |- cn-equiv C C1 t]
    ; solve [g |- cn-of/subsume Dof (kd-sub/sing-t Dof1)]
    }
  }
  case cn-equiv/sing:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- cn-equiv C C1 (sing C)]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1 unboxed;
    solve [g |- cn-of/sing Dof1]
  }
  case cn-equiv/labeled:
  { g : conbind-reg,
    X : (g |- label),
    C2 : (g |- con),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t)
  | x : [g |- cn-equiv (labeled X C2) (labeled X C3) t]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1 unboxed;
    solve [g |- cn-of/labeled Dof1]
  }
  case cn-equiv/rec:
  { g : conbind-reg,
    K1 : (g |- kind),
    C2 : (g, a32 : con, a31 : con |- con),
    C4 : (g |- con),
    K2 : (g |- kind),
    C3 : (g, a34 : con, a33 : con |- con),
    C5 : (g |- con),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, z187 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y188 : cn-of b (K1[..]) |- cn-equiv (C2[.., a, b]) (C3[.., a, b]) t),
    Dequiv2 : (g |- cn-equiv C4 C5 K1)
  | x :
      [g |-
         cn-equiv
           (rec' K1 (\x105. \z105. C2) C4) (rec' K2 (\x105. \z105. C3) C5) t]
  ; by kd-equiv-reg/1 [g |- Dequiv] as DwfK1 unboxed;
    by cn-equiv-reg/cn-of1
         [g, b1 : block (a : con, da : cn-of a (pi (K1[..]) (\l. t))),
          b2 : block (b : con, db : cn-of b (K1[..])) |-
            Dequiv1[.., b1.1, b1.2, b2.1, b2.2]]
    as DofC1 unboxed;
    by cn-equiv-reg/cn-of1 [g |- Dequiv2] as DofD1 unboxed;
    solve
  [g |- cn-of/rec DwfK1 (\a. \da. \b. \db. DofC1[.., <a; da>, <b; db>]) DofD1]
  }
  case cn-equiv/tag:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t)
  | x : [g |- cn-equiv (tag C2) (tag C3) t]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1 unboxed;
    solve [g |- cn-of/tag Dof1]
  }
  case cn-equiv/ref:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t)
  | x : [g |- cn-equiv (ref C2) (ref C3) t]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1 unboxed;
    solve [g |- cn-of/ref Dof1]
  }
  case cn-equiv/plus:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t),
    Dequiv1 : (g |- cn-equiv C4 C5 t)
  | x : [g |- cn-equiv (plus C2 C4) (plus C3 C5) t]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1a unboxed;
    by cn-equiv-reg/cn-of1 [g |- Dequiv1] as Dof1b unboxed;
    solve [g |- cn-of/plus Dof1a Dof1b]
  }
  case cn-equiv/arrow:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t),
    Dequiv1 : (g |- cn-equiv C4 C5 t)
  | x : [g |- cn-equiv (arrow C2 C4) (arrow C3 C5) t]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1a unboxed;
    by cn-equiv-reg/cn-of1 [g |- Dequiv1] as Dof1b unboxed;
    solve [g |- cn-of/arrow Dof1a Dof1b]
  }
  case cn-equiv/prod:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t),
    Dequiv1 : (g |- cn-equiv C4 C5 t)
  | x : [g |- cn-equiv (prod C2 C4) (prod C3 C5) t]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1a unboxed;
    by cn-equiv-reg/cn-of1 [g |- Dequiv1] as Dof1b unboxed;
    solve [g |- cn-of/prod Dof1a Dof1b]
  }
  case cn-equiv/app:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    K2 : (g, a30 : con |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C2 C3 (pi K1 (\x97. K2))),
    Dequiv1 : (g |- cn-equiv C4 C5 K1)
  | x : [g |- cn-equiv (app C2 C4) (app C3 C5) (K2[.., C4])]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1a unboxed;
    by cn-equiv-reg/cn-of1 [g |- Dequiv1] as Dof1b unboxed;
    solve [g |- cn-of/app Dof1b Dof1a]
  }
  case cn-equiv/lam:
  { g : conbind-reg,
    K1 : (g |- kind),
    C2 : (g, a27 : con |- con),
    K2 : (g |- kind),
    C3 : (g, a28 : con |- con),
    K3 : (g, a29 : con |- kind),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, y183 : cn-of a (K1[..]) |-
         cn-equiv (C2[.., a]) (C3[.., a]) (K3[.., a]))
  | x :
      [g |-
         cn-equiv
           (lam K1 (\z100. C2)) (lam K2 (\z100. C3)) (pi K1 (\x97. K3))]
  ; by kd-equiv-reg/1 [g |- Dequiv] as Dwf1a unboxed;
    by cn-equiv-reg/cn-of1
         [g, b : block (a : con, da : cn-of a (K1[..])) |-
            Dequiv1[.., b.1, b.2]]
    as Dof1b unboxed;
    solve [g |- cn-of/lam Dwf1a (\a. \da. Dof1b[.., <a; da>])]
  }
  case cn-equiv/pi2:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    K2 : (g, a26 : con |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C2 C3 (sigma K1 (\x98. K2)))
  | x : [g |- cn-equiv (pi2 C2) (pi2 C3) (K2[.., pi1 C2])]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1 unboxed;
    solve [g |- cn-of/pi2 Dof1]
  }
  case cn-equiv/pi1:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    K : (g |- kind),
    K2 : (g, a25 : con |- kind),
    Dequiv : (g |- cn-equiv C2 C3 (sigma K (\x98. K2)))
  | x : [g |- cn-equiv (pi1 C2) (pi1 C3) K]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1 unboxed;
    solve [g |- cn-of/pi1 Dof1]
  }
  case cn-equiv/pair:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a24 : con |- kind),
    Dequiv : (g |- cn-equiv C2 C3 K1),
    Dequiv1 : (g |- cn-equiv C4 C5 (K2[.., C2])),
    Dwf : (g, a : con, x181 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-equiv (pair C2 C4) (pair C3 C5) (sigma K1 (\x98. K2))]
  ; by cn-equiv-reg/cn-of1 [g |- Dequiv] as Dof1a unboxed;
    by cn-equiv-reg/cn-of1 [g |- Dequiv1] as Dof1b unboxed;
    solve [g |- cn-of/pair Dof1a Dof1b (\a. \da. Dwf)]
  }
  case cn-equiv/trans:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C C3 K),
    Dequiv1 : (g |- cn-equiv C3 C1 K)
  | x : [g |- cn-equiv C C1 K]
  ; solve cn-equiv-reg/cn-of1 [g |- Dequiv]
  }
  case cn-equiv/symm:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    Dequiv : (g |- cn-equiv C1 C K)
  | x : [g |- cn-equiv C C1 K]
  ; solve cn-equiv-reg/cn-of2 [g |- Dequiv]
  }
  case cn-equiv/refl:
  { g : conbind-reg,
    C1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of C1 K)
  | x : [g |- cn-equiv C1 C1 K]
  ; solve [_ |- Dof]
  }
}

and proof cn-equiv-reg/cn-of2 :
  (g : conbind-reg) [g |- cn-equiv C1 C2 K] ->
    [g |- cn-of C2 K] =
/ total 1 /
?

and proof cn-equiv-reg/kd-wf :
  (g : conbind-reg) [g |- cn-equiv C1 C2 K] ->
    [g |- kd-wf K] =
/ total 1 /
?
;

LF inhabitation/existsC : kind -> type =
| inhabitation/existsC/i : { C : con } cn-of C K -> inhabitation/existsC K
;

proof inhabitation/existsC/i :
  (g : conbind) { C : [g |- con] } [g |- cn-of C K] ->
    [g |- inhabitation/existsC K] =
/ total /
intros
{ g : conbind, K : (g |- kind), C : (g |- con)
| cof : [g |- cn-of C K]
; by cof as Dof unboxed;
  solve [_ |- inhabitation/existsC/i C Dof]
}
;

proof inhabitation :
  (g : conbind) [g |- kd-wf K] ->
    [g |- inhabitation/existsC K] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind)
| x : [g |- kd-wf K]
; split x as
  case kd-wf/one:
  { g : conbind
  | x : [g |- kd-wf one]
  ; suffices by inhabitation/existsC/i [_ |- star] toshow
    [g |- cn-of star one] {
      solve [_ |- cn-of/star]
    }
  }
  case kd-wf/sigma:
  { g : conbind,
    K1 : (g |- kind),
    K2 : (g, a4 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, z160 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (sigma K1 (\x100. K2))]
  ; split inhabitation [g |- Dwf] as
    case inhabitation/existsC/i:
    { g : conbind,
      K1 : (g |- kind),
      K2 : (g, a4 : con |- kind),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z160 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      C : (g |- con),
      Dof : (g |- cn-of C K1)
    | x : [g |- kd-wf (sigma K1 (\x100. K2))]
    ; split
      inhabitation
        [g, b : block (a : con, d : cn-of a (K1[..])) |- Dwf1[.., b.1, b.2]] as
      case inhabitation/existsC/i:
      { g : conbind,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g, a : con, z160 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
        C : (g |- con),
        Dof : (g |- cn-of C K1),
        C1 : (g, a : con |- con),
        Dof1 :
          (g, a : con, y665 : cn-of a (K1[..]) |-
             cn-of (C1[.., a]) (K3[.., a]))
      | x : [g |- kd-wf (sigma K1 (\x100. K3))]
      ; suffices by inhabitation/existsC/i [g |- pair C (C1[.., C])] toshow
        [g |- cn-of (pair C (C1[.., C])) (sigma K1 (\y. K3))] {
          solve [g |- cn-of/pair Dof (Dof1[.., C, Dof]) (\x. \y. Dwf1)]
        }
      }
    }
  }
  case kd-wf/pi:
  { g : conbind,
    K1 : (g |- kind),
    K2 : (g, a3 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, z159 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (pi K1 (\x99. K2))]
  ; split
    inhabitation
      [_, b : block (a : con, d : cn-of a (K1[..])) |- Dwf1[.., b.1, b.2]] as
    case inhabitation/existsC/i:
    { g : conbind,
      K1 : (g |- kind),
      K3 : (g, a : con |- kind),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z159 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
      C : (g, a : con |- con),
      Dof :
        (g, a : con, y668 : cn-of a (K1[..]) |- cn-of (C[.., a]) (K3[.., a]))
    | x : [g |- kd-wf (pi K1 (\x99. K3))]
    ; suffices by inhabitation/existsC/i [_ |- lam K1 (\x. C)] toshow
      [g |- cn-of (lam K1 (\x. C)) (pi K1 (\y. K3))] {
        solve [_ |- cn-of/lam Dwf (\x. \y. Dof)]
      }
    }
  }
  case kd-wf/sing:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-wf (sing C)]
  ; suffices by inhabitation/existsC/i [g |- C] toshow
    [g |- cn-of C (sing C)] {
      solve [g |- cn-of/sing Dof]
    }
  }
  case kd-wf/t:
  { g : conbind
  | x : [g |- kd-wf t]
  ; suffices by inhabitation/existsC/i [g |- unit] toshow
    [g |- cn-of unit t] {
      solve [g |- cn-of/unit]
    }
  }
}
;

% Similarity

LF similar : con -> con -> type =
| similar/unit : similar unit unit
| similar/void : similar void void
| similar/prod : similar (prod _ _) (prod _ _)
| similar/arrow : similar (arrow _ _) (arrow _ _)
| similar/plus : similar (plus _ _) (plus _ _)
| similar/ref : similar (ref _) (ref _)
| similar/tag : similar (tag _) (tag _)
| similar/tagged : similar tagged tagged
| similar/rec : similar (rec' _ _ _) (rec' _ _ _)
| similar/labeled : similar (labeled _ _) (labeled _ _)
;
--name similar Dsim sim.

% Type Formation Inversion

LF typeish : kind -> type =
| typeish/t : typeish t
| typeish/sing : typeish (sing _)
;
--name typeish Dtypeish typeish.

proof typeish-equiv :
  (g : conbind) [g |- kd-equiv K1 K2] ->
    [g |- typeish K2] ->
      [g |- typeish K1] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-equiv K K1], typeish : [g |- typeish K1]
; split x as
  case kd-equiv/sigma:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a7 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x162 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (sigma K2 (\x98. K4)) (sigma K3 (\x98. K5))],
    typeish : [g |- typeish (sigma K3 (\x98. K5))]
  ; impossible typeish
  }
  case kd-equiv/pi:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a5 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x161 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (pi K2 (\x97. K4)) (pi K3 (\x97. K5))],
    typeish : [g |- typeish (pi K3 (\x97. K5))]
  ; impossible typeish
  }
  case kd-equiv/sing:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)],
    typeish : [g |- typeish (sing C1)]
  ; solve [_ |- typeish/sing ]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv K K3),
    Dequiv1 : (g |- kd-equiv K3 K1)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K1]
  ; by typeish-equiv [_ |- Dequiv1] typeish as typeish1;
    solve typeish-equiv [_ |- Dequiv] typeish1
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K1 K)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K1]
  ; solve typeish-equiv' [_ |- Dequiv] typeish
  }
  case kd-equiv/refl:
  { g : conbind, K1 : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- kd-equiv K1 K1], typeish : [g |- typeish K1]
  ; solve typeish
  }
}

and proof typeish-equiv' :
  (g : conbind) [g |- kd-equiv K1 K2] ->
    [g |- typeish K1] ->
      [g |- typeish K2] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-equiv K K1], typeish : [g |- typeish K]
; split x as
  case kd-equiv/sigma:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a7 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x162 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (sigma K2 (\x98. K4)) (sigma K3 (\x98. K5))],
    typeish : [g |- typeish (sigma K2 (\x98. K4))]
  ; impossible typeish
  }
  case kd-equiv/pi:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a5 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x161 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (pi K2 (\x97. K4)) (pi K3 (\x97. K5))],
    typeish : [g |- typeish (pi K2 (\x97. K4))]
  ; impossible typeish
  }
  case kd-equiv/sing:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)], typeish : [g |- typeish (sing C)]
  ; solve [_ |- typeish/sing ]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv K K3),
    Dequiv1 : (g |- kd-equiv K3 K1)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K]
  ; by typeish-equiv' [_ |- Dequiv] typeish as typeish1;
    solve typeish-equiv' [_ |- Dequiv1] typeish1
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K1 K)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K]
  ; solve typeish-equiv [_ |- Dequiv] typeish
  }
  case kd-equiv/refl:
  { g : conbind, K1 : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- kd-equiv K1 K1], typeish : [g |- typeish K1]
  ; solve typeish
  }
}
;

proof typeish-sub :
  (g : conbind) [g |- kd-sub K1 K2] ->
    [g |- typeish K2] ->
      [g |- typeish K1] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-sub K K1], typeish : [g |- typeish K1]
; split x as
  case kd-sub/sigma:
  { g : conbind,
    K3 : (g |- kind),
    K4 : (g, a11 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a12 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, y167 : cn-of a (K3[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, z166 : cn-of a (K2[..]) |- kd-wf (K5[.., a]))
  | x : [g |- kd-sub (sigma K3 (\x98. K4)) (sigma K2 (\x98. K5))],
    typeish : [g |- typeish (sigma K2 (\x98. K5))]
  ; impossible typeish
  }
  case kd-sub/pi:
  { g : conbind,
    K3 : (g |- kind),
    K4 : (g, a9 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a10 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, x165 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, y165 : cn-of a (K3[..]) |- kd-wf (K4[.., a]))
  | x : [g |- kd-sub (pi K3 (\x97. K4)) (pi K2 (\x97. K5))],
    typeish : [g |- typeish (pi K2 (\x97. K5))]
  ; impossible typeish
  }
  case kd-sub/sing-t:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-sub (sing C) t], typeish : [g |- typeish t]
  ; solve [_ |- typeish/sing ]
  }
  case kd-sub/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- kd-sub K K3),
    Dsub1 : (g |- kd-sub K3 K1)
  | x : [g |- kd-sub K K1], typeish : [g |- typeish K1]
  ; by typeish-sub [_ |- Dsub1] typeish as typeish1;
    solve typeish-sub [_ |- Dsub] typeish1
  }
  case kd-sub/refl:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K K1)
  | x : [g |- kd-sub K K1], typeish : [g |- typeish K1]
  ; solve typeish-equiv [_ |- Dequiv] typeish
  }
}
;

proof type-inversion :
  (g : conbind) [g |- cn-of T K] ->
    [g |- similar T T] ->
      [g |- kd-sub K t] ->
        [g |- cn-of T t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con), K : (g |- kind)
| x : [g |- cn-of T K], sim : [g |- similar T T], sub : [g |- kd-sub K t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of T K1),
    Dsub : (g |- kd-sub K1 K)
  | x : [g |- cn-of T K], sim : [g |- similar T T], sub : [g |- kd-sub K t]
  ; by sub as Dsub1 unboxed;
    solve type-inversion [_ |- Dof] sim [_ |- kd-sub/trans Dsub Dsub1]
  }
  case cn-of/extsigma:
  { g : conbind,
    T : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a23 : con |- kind),
    Dof : (g |- cn-of (pi1 T) K1),
    Dof1 : (g |- cn-of (pi2 T) (K2[.., pi1 T])),
    Dwf : (g, a : con, y178 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of T (sigma K1 (\x98. K2))],
    sim : [g |- similar T T],
    sub : [g |- kd-sub (sigma K1 (\x98. K2)) t]
  ; impossible typeish-sub sub [_ |- typeish/t]
  }
  case cn-of/extpi:
  { g : conbind,
    T : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a22 : con |- kind),
    K2 : (g, a21 : con |- kind),
    Dof : (g |- cn-of T (pi K1 (\x97. K2))),
    Dof1 :
      (g, a : con, z176 : cn-of a (K1[..]) |-
         cn-of (app (T[..]) a) (K3[.., a]))
  | x : [g |- cn-of T (pi K1 (\x97. K3))],
    sim : [g |- similar T T],
    sub : [g |- kd-sub (pi K1 (\x97. K3)) t]
  ; impossible typeish-sub sub [_ |- typeish/t]
  }
  case cn-of/sing:
  { g : conbind, T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of T (sing T)],
    sim : [g |- similar T T],
    sub : [g |- kd-sub (sing T) t]
  ; solve [_ |- Dof]
  }
  case cn-of/labeled:
  { g : conbind, X : (g |- label), C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of (labeled X C) t],
    sim : [g |- similar (labeled X C) (labeled X C)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/rec:
  { g : conbind,
    K1 : (g |- kind),
    C : (g, a20 : con, a19 : con |- con),
    C1 : (g |- con),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, z174 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y175 : cn-of b (K1[..]) |- cn-of (C[.., a, b]) t),
    Dof1 : (g |- cn-of C1 K1)
  | x : [g |- cn-of (rec' K1 (\x105. \z105. C) C1) t],
    sim :
      [g |-
         similar
           (rec' K1 (\x105. \z105. C) C1) (rec' K1 (\x105. \z105. C) C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/tagged:
  { g : conbind
  | x : [g |- cn-of tagged t],
    sim : [g |- similar tagged tagged],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/tag:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of (tag C) t],
    sim : [g |- similar (tag C) (tag C)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/ref:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of (ref C) t],
    sim : [g |- similar (ref C) (ref C)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/plus:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C t),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- cn-of (plus C C1) t],
    sim : [g |- similar (plus C C1) (plus C C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/arrow:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C t),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- cn-of (arrow C C1) t],
    sim : [g |- similar (arrow C C1) (arrow C C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/prod:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C t),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- cn-of (prod C C1) t],
    sim : [g |- similar (prod C C1) (prod C C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/void:
  { g : conbind
  | x : [g |- cn-of void t],
    sim : [g |- similar void void],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/unit:
  { g : conbind
  | x : [g |- cn-of unit t],
    sim : [g |- similar unit unit],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/star:
  { g : conbind
  | x : [g |- cn-of star one],
    sim : [g |- similar star star],
    sub : [g |- kd-sub one t]
  ; impossible sim
  }
  case cn-of/app:
  { g : conbind,
    C1 : (g |- con),
    C : (g |- con),
    K2 : (g, a18 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C K1),
    Dof1 : (g |- cn-of C1 (pi K1 (\x97. K2)))
  | x : [g |- cn-of (app C1 C) (K2[.., C])],
    sim : [g |- similar (app C1 C) (app C1 C)],
    sub : [g |- kd-sub (K2[.., C]) t]
  ; impossible sim
  }
  case cn-of/lam:
  { g : conbind,
    K1 : (g |- kind),
    C : (g, a16 : con |- con),
    K2 : (g, a17 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, y170 : cn-of a (K1[..]) |- cn-of (C[.., a]) (K2[.., a]))
  | x : [g |- cn-of (lam K1 (\z100. C)) (pi K1 (\x97. K2))],
    sim : [g |- similar (lam K1 (\z100. C)) (lam K1 (\z100. C))],
    sub : [g |- kd-sub (pi K1 (\x97. K2)) t]
  ; impossible sim
  }
  case cn-of/pi2:
  { g : conbind,
    C : (g |- con),
    K2 : (g, a15 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C (sigma K1 (\x98. K2)))
  | x : [g |- cn-of (pi2 C) (K2[.., pi1 C])],
    sim : [g |- similar (pi2 C) (pi2 C)],
    sub : [g |- kd-sub (K2[.., pi1 C]) t]
  ; impossible sim
  }
  case cn-of/pi1:
  { g : conbind,
    C : (g |- con),
    K : (g |- kind),
    K2 : (g, a14 : con |- kind),
    Dof : (g |- cn-of C (sigma K (\x98. K2)))
  | x : [g |- cn-of (pi1 C) K],
    sim : [g |- similar (pi1 C) (pi1 C)],
    sub : [g |- kd-sub K t]
  ; impossible sim
  }
  case cn-of/pair:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a13 : con |- kind),
    Dof : (g |- cn-of C K1),
    Dof1 : (g |- cn-of C1 (K2[.., C])),
    Dwf : (g, a : con, x168 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of (pair C C1) (sigma K1 (\x98. K2))],
    sim : [g |- similar (pair C C1) (pair C C1)],
    sub : [g |- kd-sub (sigma K1 (\x98. K2)) t]
  ; impossible sim
  }
  case #.2:
  { g : conbind,
    K : (g |- kind),
    #cof : #(g |- block (a : con, d : cn-of a (K[..])))
  | x : [g |- cn-of #cof.1 K],
    sim : [g |- similar #cof.1 #cof.1],
    sub : [g |- kd-sub K t]
  ; impossible sim
  }
}
;

% FIXME: `solve inversion-prod/1 [_|-Q]` Recursive call not structurally smaller.
proof inversion-prod/1 :
  (g : conbind) [g |- cn-of (prod T1 T2) t] ->
    [g |- cn-of T1 t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| x : [g |- cn-of (prod T T1) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (prod T T1) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (prod T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/prod ] [_ |- Dsub]
    as Q unboxed;
    ?
  }
  case cn-of/prod:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | x : [g |- cn-of (prod T T1) t]
  ; solve [_ |- Dof]
  }
}
;

% FIXME: `solve inversion-prod/2 [_|-Q]` Recursive call not structurally smaller.
proof inversion-prod/2 :
  (g : conbind) [g |- cn-of (prod T1 T2) t] ->
    [g |- cn-of T2 t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| x : [g |- cn-of (prod T T1) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (prod T T1) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (prod T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/prod ] [_ |- Dsub]
    as Q unboxed;
    ?
  }
  case cn-of/prod:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | x : [g |- cn-of (prod T T1) t]
  ; solve [_ |- Dof1]
  }
}
;

% FIXME: `solve inversion-arrow/1 [_|-Q]` Recursive call not structurally smaller.
proof inversion-arrow/1 :
  (g : conbind) [g |- cn-of (arrow T1 T2) t] ->
    [g |- cn-of T1 t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| x : [g |- cn-of (arrow T T1) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (arrow T T1) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (arrow T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/arrow ] [_ |- Dsub]
    as Q unboxed;
    ?
  }
  case cn-of/arrow:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | x : [g |- cn-of (arrow T T1) t]
  ; solve [_ |- Dof]
  }
}
;

% FIXME: `solve inversion-arrow/2 [_|-Q]` Recursive call not structurally smaller.
proof inversion-arrow/2 :
  (g : conbind) [g |- cn-of (arrow T1 T2) t] ->
    [g |- cn-of T2 t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| x : [g |- cn-of (arrow T T1) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (arrow T T1) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (arrow T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/arrow ] [_ |- Dsub]
    as Q unboxed;
    ?
  }
  case cn-of/arrow:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | x : [g |- cn-of (arrow T T1) t]
  ; solve [_ |- Dof1]
  }
}
;

% FIXME: `solve inversion-plus/1 [_|-Q]` Recursive call not structurally smaller.
proof inversion-plus/1 :
  (g : conbind) [g |- cn-of (plus T1 T2) t] ->
    [g |- cn-of T1 t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| x : [g |- cn-of (plus T T1) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (plus T T1) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (plus T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/plus ] [_ |- Dsub]
    as Q unboxed;
    ?
  }
  case cn-of/plus:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | x : [g |- cn-of (plus T T1) t]
  ; solve [_ |- Dof]
  }
}
;

% FIXME: `solve inversion-plus/2 [_|-Q]` Recursive call not structurally smaller.
proof inversion-plus/2 :
  (g : conbind) [g |- cn-of (plus T1 T2) t] ->
    [g |- cn-of T2 t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| x : [g |- cn-of (plus T T1) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (plus T T1) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (plus T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/plus ] [_ |- Dsub]
    as Q unboxed;
    ?
  }
  case cn-of/plus:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | x : [g |- cn-of (plus T T1) t]
  ; solve [_ |- Dof1]
  }
}
;

% FIXME: `solve inversion-ref [_|-Q]` Recursive call not structurally smaller.
proof inversion-ref :
  (g : conbind) [g |- cn-of (ref T) t] ->
    [g |- cn-of T t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con)
| x : [g |- cn-of (ref T) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (ref T) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (ref T) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/ref ] [_ |- Dsub] as Q unboxed;
    ?
  }
  case cn-of/ref:
  { g : conbind, T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of (ref T) t]
  ; solve [_ |- Dof]
  }
}
;

% FIXME: `solve inversion-tag [_|-Q]` Recursive call not structurally smaller.
proof inversion-tag :
  (g : conbind) [g |- cn-of (tag T) t] ->
    [g |- cn-of T t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con)
| x : [g |- cn-of (tag T) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (tag T) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (tag T) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/tag ] [_ |- Dsub] as Q unboxed;
    ?
  }
  case cn-of/tag:
  { g : conbind, T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of (tag T) t]
  ; solve [_ |- Dof]
  }
}
;

% FIXME: `solve inversion-rec/kd-wf [_|-Q]` Recursive call not structurally smaller.
proof inversion-rec/kd-wf :
  (g : conbind) [g |- cn-of (rec' K (\x. \y. C1[x, y]) C2) t] ->
    [g |- kd-wf K] =
/ total 1 /
intros
{ g : conbind,
  K : (g |- kind),
  C : (x107 : con, z107 : con |- con),
  C1 : (g |- con)
| x : [g |- cn-of (rec' K (\x. \y. C[x, y]) C1) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    K : (g |- kind),
    C : (x107 : con, z107 : con |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    Dof : (g |- cn-of (rec' K (\x. \y. C[x, y]) C1) K1),
    Dsub : (g |- kd-sub K1 t)
  | x : [g |- cn-of (rec' K (\x. \y. C[x, y]) C1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/rec ] [_ |- Dsub] as Q unboxed;
    ?
  }
  case cn-of/rec:
  { g : conbind,
    K : (g |- kind),
    C : (x107 : con, z107 : con |- con),
    C1 : (g |- con),
    Dwf : (g |- kd-wf K),
    Dof :
      (g, a : con, z176 : cn-of a (pi (K[..]) (\l. t)), b : con,
       y177 : cn-of b (K[..]) |- cn-of (C[a, b]) t),
    Dof1 : (g |- cn-of C1 K)
  | x : [g |- cn-of (rec' K (\x. \y. C[x, y]) C1) t]
  ; solve [_ |- Dwf]
  }
}
;

% FIXME: `solve inversion-rec/1 [_|-Q]` Recursive call not structurally smaller.
proof inversion-rec/1 :
  (g : conbind) [g |- cn-of (rec' K (\x. \y. C1[x, y]) C2) t] ->
    [g, a : con, da : cn-of a (pi (K[..]) (\l. t)),
        b : con, db : cn-of b (K[..]) |- cn-of (C1[a, b]) t] =
/ total 1 /
intros
{ g : conbind,
  K : (g |- kind),
  C : (x107 : con, z107 : con |- con),
  C1 : (g |- con)
| x : [g |- cn-of (rec' K (\x. \y. C[x, y]) C1) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    K : (g |- kind),
    C : (x107 : con, z107 : con |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    Dof : (g |- cn-of (rec' K (\x. \y. C[x, y]) C1) K1),
    Dsub : (g |- kd-sub K1 t)
  | x : [g |- cn-of (rec' K (\x. \y. C[x, y]) C1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/rec ] [_ |- Dsub] as Q unboxed;
    ?
  }
  case cn-of/rec:
  { g : conbind,
    K : (g |- kind),
    C : (x107 : con, z107 : con |- con),
    C1 : (g |- con),
    Dwf : (g |- kd-wf K),
    Dof :
      (g, a : con, z176 : cn-of a (pi (K[..]) (\l. t)), b : con,
       y177 : cn-of b (K[..]) |- cn-of (C[a, b]) t),
    Dof1 : (g |- cn-of C1 K)
  | x : [g |- cn-of (rec' K (\x. \y. C[x, y]) C1) t]
  ; solve
      [_, a : con, z176 : cn-of a (pi (K[..]) (\l. t)), b : con,
       y177 : cn-of b (K[..]) |- Dof]
  }
}
;

% FIXME: `solve inversion-rec/2 [_|-Q]` Recursive call not structurally smaller.
proof inversion-rec/2 :
  (g : conbind) [g |- cn-of (rec' K (\x. \y. C1[x, y]) C2) t] ->
    [g |- cn-of C2 K] =
/ total 1 /
intros
{ g : conbind,
  K : (g |- kind),
  C : (x107 : con, z107 : con |- con),
  C1 : (g |- con)
| x : [g |- cn-of (rec' K (\x. \y. C[x, y]) C1) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    K : (g |- kind),
    C : (x107 : con, z107 : con |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    Dof : (g |- cn-of (rec' K (\x. \y. C[x, y]) C1) K1),
    Dsub : (g |- kd-sub K1 t)
  | x : [g |- cn-of (rec' K (\x. \y. C[x, y]) C1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/rec ] [_ |- Dsub] as Q unboxed;
    ?
  }
  case cn-of/rec:
  { g : conbind,
    K : (g |- kind),
    C : (x107 : con, z107 : con |- con),
    C1 : (g |- con),
    Dwf : (g |- kd-wf K),
    Dof :
      (g, a : con, z176 : cn-of a (pi (K[..]) (\l. t)), b : con,
       y177 : cn-of b (K[..]) |- cn-of (C[a, b]) t),
    Dof1 : (g |- cn-of C1 K)
  | x : [g |- cn-of (rec' K (\x. \y. C[x, y]) C1) t]
  ; solve [_ |- Dof1]
  }
}
;

% FIXME: `solve inversion-labeled [_|-Q]` Recursive call not structurally smaller.
proof inversion-labeled :
  (g : conbind) [g |- cn-of (labeled I T) t] ->
    [g |- cn-of T t] =
/ total 1 /
intros
{ g : conbind, I : (g |- label), T : (g |- con)
| x : [g |- cn-of (labeled I T) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    I : (g |- label),
    T : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (labeled I T) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (labeled I T) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/labeled ] [_ |- Dsub]
    as Q unboxed;
    ?
  }
  case cn-of/labeled:
  { g : conbind, I : (g |- label), T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of (labeled I T) t]
  ; solve [_ |- Dof]
  }
}
;
