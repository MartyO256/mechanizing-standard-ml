% Constructor Regularity

schema conbind-reg = some [K : kind, wf : kd-wf K]
                     block (a : con, da : cn-of a K);

proof kd-equiv-reg/1 :
  (g : conbind-reg) [g |- kd-equiv K1 K2] ->
    [g |- kd-wf K1] =
/ total 1 /
?

and proof kd-equiv-reg/2 :
  (g : conbind-reg) [g |- kd-equiv K1 K2] ->
    [g |- kd-wf K2] =
/ total 1 /
?

and proof kd-sub-reg/1 :
  (g : conbind-reg) [g |- kd-sub K1 K2] ->
    [g |- kd-wf K1] =
/ total 1 /
?

and proof kd-sub-reg/2 :
  (g : conbind-reg) [g |- kd-sub K1 K2] ->
    [g |- kd-wf K2] =
/ total 1 /
?

and proof cn-of-reg :
  (g : conbind-reg) [g |- cn-of C K] ->
    [g |- kd-wf K] =
/ total 1 /
?

and proof cn-equiv-reg/cn-of1 :
  (g : conbind-reg) [g |- cn-equiv C1 C2 K] ->
    [g |- cn-of C1 K] =
/ total 1 /
?

and proof cn-equiv-reg/cn-of2 :
  (g : conbind-reg) [g |- cn-equiv C1 C2 K] ->
    [g |- cn-of C2 K] =
/ total 1 /
?

and proof cn-equiv-reg/kd-wf :
  (g : conbind-reg) [g |- cn-equiv C1 C2 K] ->
    [g |- kd-wf K] =
/ total 1 /
?
;

LF inhabitation/existsC : kind -> type =
| inhabitation/existsC/i : {C : con} cn-of C K -> inhabitation/existsC K
;

proof inhabitation/existsC/i :
  (g : conbind) {C : [g |- con]} [g |- cn-of C K] ->
    [g |- inhabitation/existsC K] =
/ total /
?
;

proof inhabitation :
  (g : conbind) [g |- kd-wf K] ->
    [g |- inhabitation/existsC K] =
/ total 1 /
?
;

% Similarity

LF similar : con -> con -> type =
| similar/unit : similar unit unit
| similar/void : similar void void
| similar/prod : similar (prod _ _) (prod _ _)
| similar/arrow : similar (arrow _ _) (arrow _ _)
| similar/plus : similar (plus _ _) (plus _ _)
| similar/ref : similar (ref _) (ref _)
| similar/tag : similar (tag _) (tag _)
| similar/tagged : similar tagged tagged
| similar/rec : similar (rec' _ _ _) (rec' _ _ _)
| similar/labeled : similar (labeled _ _) (labeled _ _)
;

% Type Formation Inversion

LF typeish : kind -> type =
| typeish/t : typeish t
| typeish/sing : typeish (sing _)
;

proof typeish-equiv :
  (g : conbind) [g |- kd-equiv K1 K2] ->
    [g |- typeish K2] ->
      [g |- typeish K1] =
/ total 1 /
?

and proof typeish-equiv' :
  (g : conbind) [g |- kd-equiv K1 K2] ->
    [g |- typeish K1] ->
      [g |- typeish K2] =
/ total 1 /
?
;

proof typeish-sub :
  (g : conbind) [g |- kd-sub K1 K2] ->
    [g |- typeish K2] ->
      [g |- typeish K1] =
/ total 1 /
?
;

proof type-inversion :
  (g : conbind) [g |- cn-of T K] ->
    [g |- similar T T] ->
      [g |- kd-sub K t] ->
        [g |- cn-of T t] =
/ total 1 /
?
;

% FIXME: `solve inversion-prod/1 [_|-Q]` Recursive call not structurally smaller.
proof inversion-prod/1 :
  (g : conbind) [g |- cn-of (prod T1 T2) t] ->
    [g |- cn-of T1 t] =
/ total 1 /
?
;

% FIXME: `solve inversion-prod/2 [_|-Q]` Recursive call not structurally smaller.
proof inversion-prod/2 :
  (g : conbind) [g |- cn-of (prod T1 T2) t] ->
    [g |- cn-of T2 t] =
/ total 1 /
?
;

% FIXME: `solve inversion-arrow/1 [_|-Q]` Recursive call not structurally smaller.
proof inversion-arrow/1 :
  (g : conbind) [g |- cn-of (arrow T1 T2) t] ->
    [g |- cn-of T1 t] =
/ total 1 /
?
;

% FIXME: `solve inversion-arrow/2 [_|-Q]` Recursive call not structurally smaller.
proof inversion-arrow/2 :
  (g : conbind) [g |- cn-of (arrow T1 T2) t] ->
    [g |- cn-of T2 t] =
/ total 1 /
?
;

% FIXME: `solve inversion-plus/1 [_|-Q]` Recursive call not structurally smaller.
proof inversion-plus/1 :
  (g : conbind) [g |- cn-of (plus T1 T2) t] ->
    [g |- cn-of T1 t] =
/ total 1 /
?
;

% FIXME: `solve inversion-plus/2 [_|-Q]` Recursive call not structurally smaller.
proof inversion-plus/2 :
  (g : conbind) [g |- cn-of (plus T1 T2) t] ->
    [g |- cn-of T2 t] =
/ total 1 /
?
;

% FIXME: `solve inversion-ref [_|-Q]` Recursive call not structurally smaller.
proof inversion-ref :
  (g : conbind) [g |- cn-of (ref T) t] ->
    [g |- cn-of T t] =
/ total 1 /
?
;

% FIXME: `solve inversion-tag [_|-Q]` Recursive call not structurally smaller.
proof inversion-tag :
  (g : conbind) [g |- cn-of (tag T) t] ->
    [g |- cn-of T t] =
/ total 1 /
?
;

% FIXME: `solve inversion-rec/kd-wf [_|-Q]` Recursive call not structurally smaller.
proof inversion-rec/kd-wf :
  (g : conbind) [g |- cn-of (rec' K (\x. \y. C1[x, y]) C2) t] ->
    [g |- kd-wf K] =
/ total 1 /
?
;

% FIXME: `solve inversion-rec/1 [_|-Q]` Recursive call not structurally smaller.
proof inversion-rec/1 :
  (g : conbind) [g |- cn-of (rec' K (\x. \y. C1[x, y]) C2) t] ->
    [g, a : con, da : cn-of a (pi (K[..]) (\l. t)),
        b : con, db : cn-of b (K[..]) |- cn-of (C1[a, b]) t] =
/ total 1 /
?
;

% FIXME: `solve inversion-rec/2 [_|-Q]` Recursive call not structurally smaller.
proof inversion-rec/2 :
  (g : conbind) [g |- cn-of (rec' K (\x. \y. C1[x, y]) C2) t] ->
    [g |- cn-of C2 K] =
/ total 1 /
?
;

% FIXME: `solve inversion-labeled [_|-Q]` Recursive call not structurally smaller.
proof inversion-labeled :
  (g : conbind) [g |- cn-of (labeled I T) t] ->
    [g |- cn-of T t] =
/ total 1 /
?
;
