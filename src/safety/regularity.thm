% Constructor Regularity

schema conbind-reg =
  some [K : kind, wf : kd-wf K]
  block (a : con, da : cn-of a K);

LF kd-equiv-reg/e : kind -> kind -> type =
| kd-equiv-reg/i : kd-wf K1 -> kd-wf K2 -> kd-equiv-reg/e K1 K2
;

LF kd-sub-reg/e : kind -> kind -> type =
| kd-sub-reg/i : kd-wf K1 -> kd-wf K2 -> kd-sub-reg/e K1 K2
;

LF cn-equiv-reg/e :  con -> con -> kind -> type =
| cn-equiv-reg/i : cn-of C1 K -> cn-of C2 K -> kd-wf K -> cn-equiv-reg/e C1 C2 K
;

proof kd-equiv-reg :
  (g : conbind-reg)
  [g |- kd-equiv K1 K2] ->
    [g |- kd-equiv-reg/e K1 K2] =
/ total 1 /
intros
{ g : conbind-reg, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-equiv K K1]
; split x as
  case kd-equiv/sigma:
  { g : conbind-reg,
    K2 : (g |- kind),
    K4 : (g, a7 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, y404 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (sigma K2 (\y340. K4)) (sigma K3 (\y340. K5))]
  ; split kd-equiv-reg [_ |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K2 : (g |- kind),
      K4 : (g, a7 : con |- kind),
      K3 : (g |- kind),
      K5 : (g, a8 : con |- kind),
      Dequiv : (g |- kd-equiv K2 K3),
      Dequiv1 :
        (g, a : con, y404 : cn-of a (K2[..]) |-
           kd-equiv (K4[.., a]) (K5[.., a])),
      Dwf : (g |- kd-wf K2),
      Dwf1 : (g |- kd-wf K3)
    | x : [g |- kd-equiv (sigma K2 (\y340. K4)) (sigma K3 (\y340. K5))]
    ; split
      kd-equiv-reg
        [_, b : block (a : con, da : cn-of a _) |- Dequiv1[.., b.1, b.2]] as
      case kd-equiv-reg/i:
      { g : conbind-reg,
        K2 : (g |- kind),
        K6 : (g, a : con |- kind),
        K3 : (g |- kind),
        K7 : (g, a : con |- kind),
        Dequiv : (g |- kd-equiv K2 K3),
        Dequiv1 :
          (g, a : con, y404 : cn-of a (K2[..]) |-
             kd-equiv (K6[.., a]) (K7[.., a])),
        Dwf : (g |- kd-wf K2),
        Dwf1 : (g |- kd-wf K3),
        Dwf2 : (g, a : con, z5 : cn-of a (K2[..]) |- kd-wf (K6[.., a])),
        Dwf3 : (g, a : con, y6 : cn-of a (K2[..]) |- kd-wf (K7[.., a]))
      | x : [g |- kd-equiv (sigma K2 (\y340. K6)) (sigma K3 (\y340. K7))]
      ; by [_ |- kd-wf/sigma Dwf (\a. \da. Dwf2)] as Dwf1' unboxed;
        by [g |- kd-wf/sigma Dwf1 (\a. \da. Dwf3[.., a, _])] as Dwf2' unboxed;
        solve [g |- kd-equiv-reg/i Dwf1' Dwf2']
      }
    }
  }
  case kd-equiv/pi:
  { g : conbind-reg,
    K2 : (g |- kind),
    K4 : (g, a5 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, y403 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (pi K2 (\y339. K4)) (pi K3 (\y339. K5))]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K2 : (g |- kind),
      K4 : (g, a5 : con |- kind),
      K3 : (g |- kind),
      K5 : (g, a6 : con |- kind),
      Dequiv : (g |- kd-equiv K2 K3),
      Dequiv1 :
        (g, a : con, y403 : cn-of a (K2[..]) |-
           kd-equiv (K4[.., a]) (K5[.., a])),
      Dwf : (g |- kd-wf K2),
      Dwf1 : (g |- kd-wf K3)
    | x : [g |- kd-equiv (pi K2 (\z349. K4)) (pi K3 (\z349. K5))]
    ; split
      kd-equiv-reg
        [g, b : block (a : con, da : cn-of a (K2[..])) |-
           Dequiv1[.., b.1, b.2]] as
      case kd-equiv-reg/i:
      { g : conbind-reg,
        K2 : (g |- kind),
        K6 : (g, a : con |- kind),
        K3 : (g |- kind),
        K7 : (g, a : con |- kind),
        Dequiv : (g |- kd-equiv K2 K3),
        Dequiv1 :
          (g, a : con, y403 : cn-of a (K2[..]) |-
             kd-equiv (K6[.., a]) (K7[.., a])),
        Dwf : (g |- kd-wf K2),
        Dwf1 : (g |- kd-wf K3),
        Dwf2 : (g, a : con, z1108 : cn-of a (K2[..]) |- kd-wf (K6[.., a])),
        Dwf3 : (g, a : con, y1109 : cn-of a (K2[..]) |- kd-wf (K7[.., a]))
      | x : [g |- kd-equiv (pi K2 (\z349. K6)) (pi K3 (\z349. K7))]
      ; by [g |- kd-wf/pi Dwf (\a. \da. Dwf2)] as Dwf1' unboxed;
        by [g |- kd-wf/pi Dwf1 (\a. \da. Dwf3[.., a, _])] as Dwf2' unboxed;
        solve [g |- kd-equiv-reg/i Dwf1' Dwf2']
      }
    }
  }
  case kd-equiv/sing:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      Dequiv : (g |- cn-equiv C C1 t),
      Dof : (g |- cn-of C t),
      Dof1 : (g |- cn-of C1 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- kd-equiv (sing C) (sing C1)]
    ; solve [g |- kd-equiv-reg/i (kd-wf/sing Dof) (kd-wf/sing Dof1)]
    }
  }
  case kd-equiv/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv K K3),
    Dequiv1 : (g |- kd-equiv K3 K1)
  | x : [g |- kd-equiv K K1]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K3 : (g |- kind),
      Dequiv : (g |- kd-equiv K K3),
      Dequiv1 : (g |- kd-equiv K3 K1),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g |- kd-wf K3)
    | x : [g |- kd-equiv K K1]
    ; split kd-equiv-reg [g |- Dequiv1] as
      case kd-equiv-reg/i:
      { g : conbind-reg,
        K : (g |- kind),
        K1 : (g |- kind),
        K3 : (g |- kind),
        Dequiv : (g |- kd-equiv K K3),
        Dequiv1 : (g |- kd-equiv K3 K1),
        Dwf : (g |- kd-wf K),
        Dwf1 : (g |- kd-wf K3),
        Dwf2 : (g |- kd-wf K3),
        Dwf3 : (g |- kd-wf K1)
      | x : [g |- kd-equiv K K1]
      ; solve [g |- kd-equiv-reg/i Dwf Dwf3]
      }
    }
  }
  case kd-equiv/symm:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K1 K)
  | x : [g |- kd-equiv K K1]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- kd-equiv K1 K),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g |- kd-wf K)
    | x : [g |- kd-equiv K K1]
    ; solve [g |- kd-equiv-reg/i Dwf1 Dwf]
    }
  }
  case kd-equiv/refl:
  { g : conbind-reg, K1 : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- kd-equiv K1 K1]
  ; solve [g |- kd-equiv-reg/i Dwf Dwf]
  }
}

and proof kd-sub-reg :
  (g : conbind-reg)
  [g |- kd-sub K1 K2] ->
    [g |- kd-sub-reg/e K1 K2] =
/ total 1 /
intros
{ g : conbind-reg, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-sub K K1]
; split x as
  case kd-sub/sigma:
  { g : conbind-reg,
    K2 : (g |- kind),
    K4 : (g, a11 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a12 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, x419 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, y419 : cn-of a (K3[..]) |- kd-wf (K5[.., a]))
  | x : [g |- kd-sub (sigma K2 (\z350. K4)) (sigma K3 (\z350. K5))]
  ; split kd-sub-reg [g |- Dsub] as
    case kd-sub-reg/i:
    { g : conbind-reg,
      K2 : (g |- kind),
      K4 : (g, a11 : con |- kind),
      K3 : (g |- kind),
      K5 : (g, a12 : con |- kind),
      Dsub : (g |- kd-sub K2 K3),
      Dsub1 :
        (g, a : con, x419 : cn-of a (K2[..]) |-
           kd-sub (K4[.., a]) (K5[.., a])),
      Dwf : (g, a : con, y419 : cn-of a (K3[..]) |- kd-wf (K5[.., a])),
      Dwf1 : (g |- kd-wf K2),
      Dwf2 : (g |- kd-wf K3)
    | x : [g |- kd-sub (sigma K2 (\z350. K4)) (sigma K3 (\z350. K5))]
    ; split
      kd-sub-reg
        [g, b : block (a : con, da : cn-of a (K2[..])) |- Dsub1[.., b.1, b.2]] as
      case kd-sub-reg/i:
      { g : conbind-reg,
        K2 : (g |- kind),
        K6 : (g, a : con |- kind),
        K3 : (g |- kind),
        K7 : (g, a : con |- kind),
        Dsub : (g |- kd-sub K2 K3),
        Dsub1 :
          (g, a : con, x419 : cn-of a (K2[..]) |-
             kd-sub (K6[.., a]) (K7[.., a])),
        Dwf : (g, a : con, y419 : cn-of a (K3[..]) |- kd-wf (K7[.., a])),
        Dwf1 : (g |- kd-wf K2),
        Dwf2 : (g |- kd-wf K3),
        Dwf3 : (g, a : con, y1112 : cn-of a (K2[..]) |- kd-wf (K6[.., a])),
        Dwf4 : (g, a : con, x1112 : cn-of a (K2[..]) |- kd-wf (K7[.., a]))
      | x : [g |- kd-sub (sigma K2 (\z350. K6)) (sigma K3 (\z350. K7))]
      ; solve
          [g |-
             kd-sub-reg/i (kd-wf/sigma Dwf1 (\a. \da. Dwf3))
             (kd-wf/sigma Dwf2 (\a. \da. Dwf))]
      }
    }
  }
  case kd-sub/pi:
  { g : conbind-reg,
    K3 : (g |- kind),
    K4 : (g, a9 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a10 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, z417 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, x417 : cn-of a (K3[..]) |- kd-wf (K4[.., a]))
  | x : [g |- kd-sub (pi K3 (\z349. K4)) (pi K2 (\z349. K5))]
  ; split kd-sub-reg [g |- Dsub] as
    case kd-sub-reg/i:
    { g : conbind-reg,
      K3 : (g |- kind),
      K4 : (g, a9 : con |- kind),
      K2 : (g |- kind),
      K5 : (g, a10 : con |- kind),
      Dsub : (g |- kd-sub K2 K3),
      Dsub1 :
        (g, a : con, z417 : cn-of a (K2[..]) |-
           kd-sub (K4[.., a]) (K5[.., a])),
      Dwf : (g, a : con, x417 : cn-of a (K3[..]) |- kd-wf (K4[.., a])),
      Dwf1 : (g |- kd-wf K2),
      Dwf2 : (g |- kd-wf K3)
    | x : [g |- kd-sub (pi K3 (\z349. K4)) (pi K2 (\z349. K5))]
    ; split
      kd-sub-reg
        [g, b : block (a : con, da : cn-of a (K2[..])) |- Dsub1[.., b.1, b.2]] as
      case kd-sub-reg/i:
      { g : conbind-reg,
        K3 : (g |- kind),
        K6 : (g, a : con |- kind),
        K2 : (g |- kind),
        K7 : (g, a : con |- kind),
        Dsub : (g |- kd-sub K2 K3),
        Dsub1 :
          (g, a : con, z417 : cn-of a (K2[..]) |-
             kd-sub (K6[.., a]) (K7[.., a])),
        Dwf : (g, a : con, x417 : cn-of a (K3[..]) |- kd-wf (K6[.., a])),
        Dwf1 : (g |- kd-wf K2),
        Dwf2 : (g |- kd-wf K3),
        Dwf3 : (g, a : con, z1108 : cn-of a (K2[..]) |- kd-wf (K6[.., a])),
        Dwf4 : (g, a : con, y1109 : cn-of a (K2[..]) |- kd-wf (K7[.., a]))
      | x : [g |- kd-sub (pi K3 (\z349. K6)) (pi K2 (\z349. K7))]
      ; solve
          [g |-
             kd-sub-reg/i (kd-wf/pi Dwf2 (\a. \da. Dwf))
             (kd-wf/pi Dwf1 (\a. \da. Dwf4))]
      }
    }
  }
  case kd-sub/sing-t:
  { g : conbind-reg, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-sub (sing C) t]
  ; solve [g |- kd-sub-reg/i (kd-wf/sing Dof) kd-wf/t]
  }
  case kd-sub/trans:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- kd-sub K K3),
    Dsub1 : (g |- kd-sub K3 K1)
  | x : [g |- kd-sub K K1]
  ; split kd-sub-reg [g |- Dsub] as
    case kd-sub-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      K3 : (g |- kind),
      Dsub : (g |- kd-sub K K3),
      Dsub1 : (g |- kd-sub K3 K1),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g |- kd-wf K3)
    | x : [g |- kd-sub K K1]
    ; split kd-sub-reg [g |- Dsub1] as
      case kd-sub-reg/i:
      { g : conbind-reg,
        K : (g |- kind),
        K1 : (g |- kind),
        K3 : (g |- kind),
        Dsub : (g |- kd-sub K K3),
        Dsub1 : (g |- kd-sub K3 K1),
        Dwf : (g |- kd-wf K),
        Dwf1 : (g |- kd-wf K3),
        Dwf2 : (g |- kd-wf K3),
        Dwf3 : (g |- kd-wf K1)
      | x : [g |- kd-sub K K1]
      ; solve [g |- kd-sub-reg/i Dwf Dwf3]
      }
    }
  }
  case kd-sub/refl:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K K1)
  | x : [g |- kd-sub K K1]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- kd-equiv K K1),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g |- kd-wf K1)
    | x : [g |- kd-sub K K1]
    ; solve [g |- kd-sub-reg/i Dwf Dwf1]
    }
  }
}

and proof cn-of-reg :
  (g : conbind-reg) [g |- cn-of C K] ->
    [g |- kd-wf K] =
/ total 1 /
intros
{ g : conbind-reg, C : (g |- con), K : (g |- kind)
| x : [g |- cn-of C K]
; split x as
  case cn-of/subsume:
  { g : conbind-reg,
    C : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C K1),
    Dsub : (g |- kd-sub K1 K)
  | x : [g |- cn-of C K]
  ; split kd-sub-reg [g |- Dsub] as
    case kd-sub-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      K : (g |- kind),
      K1 : (g |- kind),
      Dof : (g |- cn-of C K1),
      Dsub : (g |- kd-sub K1 K),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g |- kd-wf K)
    | x : [g |- cn-of C K]
    ; solve [g |- Dwf1]
    }
  }
  case cn-of/extsigma:
  { g : conbind-reg,
    C : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a23 : con |- kind),
    Dof : (g |- cn-of (pi1 C) K1),
    Dof1 : (g |- cn-of (pi2 C) (K2[.., pi1 C])),
    Dwf : (g, a : con, y178 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of C (sigma K1 (\x98. K2))]
  ; by cn-of-reg [_ |- Dof] as Dwf1 unboxed;
    solve [_ |- kd-wf/sigma Dwf1 (\a. \da. Dwf)]
  }
  case cn-of/extpi:
  { g : conbind-reg,
    C : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a22 : con |- kind),
    K2 : (g, a21 : con |- kind),
    Dof : (g |- cn-of C (pi K1 (\x97. K2))),
    Dof1 :
      (g, a : con, z176 : cn-of a (K1[..]) |-
         cn-of (app (C[..]) a) (K3[.., a]))
  | x : [g |- cn-of C (pi K1 (\x97. K3))]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/pi:
    { g : conbind-reg,
      C : (g |- con),
      K1 : (g |- kind),
      K3 : (g, a22 : con |- kind),
      K2 : (g, a21 : con |- kind),
      Dof : (g |- cn-of C (pi K1 (\x97. K2))),
      Dof1 :
        (g, a : con, z176 : cn-of a (K1[..]) |-
           cn-of (app (C[..]) a) (K3[.., a])),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z157 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of C (pi K1 (\x97. K3))]
    ; by cn-of-reg
           [g, b : block (a : con, da : cn-of a (K1[..])) |-
              Dof1[.., b.1, b.2]]
      as Dwf2 unboxed;
      solve [g |- kd-wf/pi Dwf (\a. \da. Dwf2[.., <a; da>])]
    }
  }
  case cn-of/sing:
  { g : conbind-reg, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of C (sing C)]
  ; solve [g |- kd-wf/sing Dof]
  }
  case cn-of/labeled:
  { g : conbind-reg,
    X : ( |- label),
    C1 : (g |- con),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (labeled X[] C1) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/rec:
  { g : conbind-reg,
    K1 : (g |- kind),
    C1 : (g, a20 : con, a19 : con |- con),
    C2 : (g |- con),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, z174 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y175 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
    Dof1 : (g |- cn-of C2 K1)
  | x : [g |- cn-of (rec' K1 (\x105. \z105. C1) C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/tagged:
  { g : conbind-reg
  | x : [g |- cn-of tagged t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/tag:
  { g : conbind-reg, C1 : (g |- con), Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (tag C1) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/ref:
  { g : conbind-reg, C1 : (g |- con), Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (ref C1) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/plus:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (plus C1 C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/arrow:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (arrow C1 C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/prod:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (prod C1 C2) t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/void:
  { g : conbind-reg
  | x : [g |- cn-of void t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/unit:
  { g : conbind-reg
  | x : [g |- cn-of unit t]
  ; solve [g |- kd-wf/t]
  }
  case cn-of/star:
  { g : conbind-reg
  | x : [g |- cn-of star one]
  ; solve [g |- kd-wf/one]
  }
  case cn-of/app:
  { g : conbind-reg,
    C2 : (g |- con),
    C1 : (g |- con),
    K2 : (g, a18 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of C2 (pi K1 (\x97. K2)))
  | x : [g |- cn-of (app C2 C1) (K2[.., C1])]
  ; split cn-of-reg [g |- Dof1] as
    case kd-wf/pi:
    { g : conbind-reg,
      C2 : (g |- con),
      C1 : (g |- con),
      K2 : (g, a18 : con |- kind),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 K1),
      Dof1 : (g |- cn-of C2 (pi K1 (\x97. K2))),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z157 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of (app C2 C1) (K2[.., C1])]
    ; solve [g |- Dwf1[.., C1, Dof]]
    }
  }
  case cn-of/lam:
  { g : conbind-reg,
    K1 : (g |- kind),
    C1 : (g, a16 : con |- con),
    K2 : (g, a17 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, y170 : cn-of a (K1[..]) |- cn-of (C1[.., a]) (K2[.., a]))
  | x : [g |- cn-of (lam K1 (\z100. C1)) (pi K1 (\x97. K2))]
  ; by cn-of-reg
     [g, b : block (a : con, da : cn-of a (K1[..])) |- Dof[.., b.1, b.2]]
as Dwf2 unboxed;
    solve [g |- kd-wf/pi Dwf (\a. \da. Dwf2[.., <a; da>])]
  }
  case cn-of/pi2:
  { g : conbind-reg,
    C1 : (g |- con),
    K2 : (g, a15 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 (sigma K1 (\x98. K2)))
  | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/sigma:
    { g : conbind-reg,
      C1 : (g |- con),
      K2 : (g, a15 : con |- kind),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 (sigma K1 (\x98. K2))),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z158 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])]
    ; by [g |- cn-of/pi1 Dof] as Dof1 unboxed;
      solve [g |- Dwf1[.., _, Dof1]]
    }
  }
  case cn-of/pi1:
  { g : conbind-reg,
    C1 : (g |- con),
    K : (g |- kind),
    K2 : (g, a14 : con |- kind),
    Dof : (g |- cn-of C1 (sigma K (\x98. K2)))
  | x : [g |- cn-of (pi1 C1) K]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/sigma:
    { g : conbind-reg,
      C1 : (g |- con),
      K : (g |- kind),
      K2 : (g, a14 : con |- kind),
      Dof : (g |- cn-of C1 (sigma K (\x98. K2))),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g, a : con, z158 : cn-of a (K[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-of (pi1 C1) K]
    ; solve [g |- Dwf]
    }
  }
  case cn-of/pair:
  { g : conbind-reg,
    C1 : (g |- con),
    C2 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a13 : con |- kind),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of C2 (K2[.., C1])),
    Dwf : (g, a : con, x168 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of (pair C1 C2) (sigma K1 (\x98. K2))]
  ; by cn-of-reg [g |- Dof] as Dwf1 unboxed;
    solve [g |- kd-wf/sigma Dwf1 (\a. \da. Dwf)]
  }
  case #.2:
  { g : conbind-reg,
    K : (g |- kind),
    #cof : #(g |- block (a : con, da : cn-of a (K[..]))),
    Dwf32 : (g |- kd-wf K)
  | x : [g |- cn-of #cof.1 K]
  ; solve [_ |- Dwf32]
  }
}

and proof cn-equiv-reg :
  (g : conbind-reg)
  [g |- cn-equiv C1 C2 K] ->
    [g |- cn-equiv-reg/e C1 C2 K] =
/ total 1 /
intros
{ g : conbind-reg, C : (g |- con), C1 : (g |- con), K : (g |- kind)
| x : [g |- cn-equiv C C1 K]
; split x as
  case cn-equiv/beta2:
  { g : conbind-reg,
    C2 : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C2 K1),
    Dof1 : (g |- cn-of C1 K)
  | x : [g |- cn-equiv (pi2 (pair C2 C1)) C1 K]
  ; by cn-of-reg [g |- Dof1] as Dwf2 unboxed;
    solve
  [g |-
     cn-equiv-reg/i (cn-of/pi2 (cn-of/pair Dof Dof1 (\a. \da. Dwf2[..])))
     Dof1 Dwf2]
  }
  case cn-equiv/beta1:
  { g : conbind-reg,
    C1 : (g |- con),
    C3 : (g |- con),
    K : (g |- kind),
    K2 : (g |- kind),
    Dof : (g |- cn-of C1 K),
    Dof1 : (g |- cn-of C3 K2)
  | x : [g |- cn-equiv (pi1 (pair C1 C3)) C1 K]
  ; by cn-of-reg [g |- Dof] as Dwf1 unboxed;
    by cn-of-reg [g |- Dof1] as Dwf2 unboxed;
    by [g |- cn-of/pair Dof Dof1 (\a. \da. Dwf2[..])] as Dof1' unboxed;
    solve [g |- cn-equiv-reg/i (cn-of/pi1 Dof1') Dof Dwf1]
  }
  case cn-equiv/beta:
  { g : conbind-reg,
    K1 : (g |- kind),
    C3 : (g, a41 : con |- con),
    C2 : (g |- con),
    K2 : (g, a42 : con |- kind),
    Dof : (g |- cn-of C2 K1),
    Dof1 :
      (g, a : con, z436 : cn-of a (K1[..]) |- cn-of (C3[.., a]) (K2[.., a]))
  | x :
      [g |- cn-equiv (app (lam K1 (\x342. C3)) C2) (C3[.., C2]) (K2[.., C2])]
  ; by cn-of-reg [g |- Dof] as DwfA unboxed;
    by cn-of-reg
         [g, b : block (a : con, da : cn-of a _) |- Dof1[.., b.1, b.2]]
    as DwfB unboxed;
    by [g |- cn-of/app Dof (cn-of/lam DwfA (\a. \da. Dof1))] as Dof1' unboxed;
    by [g |- Dof1[.., _, Dof]] as Dof2' unboxed;
    by [g |- DwfB[.., <_; Dof>]] as Dwf' unboxed;
    solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
  }
  case cn-equiv/subsume:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- kd-sub K1 K),
    Dequiv : (g |- cn-equiv C C1 K1)
  | x : [g |- cn-equiv C C1 K]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K : (g |- kind),
      K1 : (g |- kind),
      Dsub : (g |- kd-sub K1 K),
      Dequiv : (g |- cn-equiv C C1 K1),
      Dof : (g |- cn-of C K1),
      Dof1 : (g |- cn-of C1 K1),
      Dwf : (g |- kd-wf K1)
    | x : [g |- cn-equiv C C1 K]
    ; split kd-sub-reg [g |- Dsub] as
      case kd-sub-reg/i:
      { g : conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        K : (g |- kind),
        K1 : (g |- kind),
        Dsub : (g |- kd-sub K1 K),
        Dequiv : (g |- cn-equiv C C1 K1),
        Dof : (g |- cn-of C K1),
        Dof1 : (g |- cn-of C1 K1),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g |- kd-wf K1),
        Dwf2 : (g |- kd-wf K)
      | x : [g |- cn-equiv C C1 K]
      ; solve
          [g |-
             cn-equiv-reg/i (cn-of/subsume Dof Dsub)
             (cn-of/subsume Dof1 Dsub) Dwf2]
      }
    }
  }
  case cn-equiv/one:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C one),
    Dof1 : (g |- cn-of C1 one)
  | x : [g |- cn-equiv C C1 one]
  ; solve [g |- cn-equiv-reg/i Dof Dof1 kd-wf/one]
  }
  case cn-equiv/extsigma:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a40 : con |- kind),
    Dequiv : (g |- cn-equiv (pi1 C) (pi1 C1) K1),
    Dequiv1 : (g |- cn-equiv (pi2 C) (pi2 C1) (K2[.., pi1 C])),
    Dwf : (g, a : con, x434 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-equiv C C1 (sigma K1 (\y340. K2))]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K1 : (g |- kind),
      K2 : (g, a40 : con |- kind),
      Dequiv : (g |- cn-equiv (pi1 C) (pi1 C1) K1),
      Dequiv1 : (g |- cn-equiv (pi2 C) (pi2 C1) (K2[.., pi1 C])),
      Dwf : (g, a : con, x434 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      Dof : (g |- cn-of (pi1 C) K1),
      Dof1 : (g |- cn-of (pi1 C1) K1),
      Dwf1 : (g |- kd-wf K1)
    | x : [g |- cn-equiv C C1 (sigma K1 (\y340. K2))]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        K1 : (g |- kind),
        K2 : (g, a40 : con |- kind),
        Dequiv : (g |- cn-equiv (pi1 C) (pi1 C1) K1),
        Dequiv1 : (g |- cn-equiv (pi2 C) (pi2 C1) (K2[.., pi1 C])),
        Dwf : (g, a : con, x434 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
        Dof : (g |- cn-of (pi1 C) K1),
        Dof1 : (g |- cn-of (pi1 C1) K1),
        Dwf1 : (g |- kd-wf K1),
        Dof2 : (g |- cn-of (pi2 C) (K2[.., pi1 C])),
        Dof3 : (g |- cn-of (pi2 C1) (K2[.., pi1 C])),
        Dwf2 : (g |- kd-wf (K2[.., pi1 C]))
      | x : [g |- cn-equiv C C1 (sigma K1 (\y340. K2))]
      ; by functionality-kd-reg [g, a : con, da : cn-of a (K1[..]) |- Dwf]
             [g |- Dequiv] [g |- Dof]
        as Dequiv' unboxed;
        by [g |- cn-of/extsigma Dof Dof2 (\a. \da. Dwf)] as Dof1' unboxed;
        by cn-of/equiv/conbind-reg [g |- Dof3] [g |- Dequiv'] as Dof3' unboxed;
        by [g |- cn-of/extsigma Dof1 Dof3' (\a. \da. Dwf)] as Dof2' unboxed;
        by [g |- kd-wf/sigma Dwf1 (\a. \da. Dwf)] as Dwf' unboxed;
        solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
      }
    }
  }
  case cn-equiv/extpiw:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a39 : con |- kind),
    K2 : (g, a38 : con |- kind),
    Dequiv : (g |- cn-equiv C C1 (pi K1 (\y339. K2))),
    Dequiv1 :
      (g, a : con, y433 : cn-of a (K1[..]) |-
         cn-equiv (app (C[..]) a) (app (C1[..]) a) (K3[.., a]))
  | x : [g |- cn-equiv C C1 (pi K1 (\y339. K3))]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K1 : (g |- kind),
      K3 : (g, a39 : con |- kind),
      K2 : (g, a38 : con |- kind),
      Dequiv : (g |- cn-equiv C C1 (pi K1 (\y339. K2))),
      Dequiv1 :
        (g, a : con, y433 : cn-of a (K1[..]) |-
           cn-equiv (app (C[..]) a) (app (C1[..]) a) (K3[.., a])),
      Dof : (g |- cn-of C (pi K1 (\y339. K2))),
      Dof1 : (g |- cn-of C1 (pi K1 (\y339. K2))),
      Dwf : (g |- kd-wf (pi K1 (\y339. K2)))
    | x : [g |- cn-equiv C C1 (pi K1 (\y339. K3))]
    ; split
      cn-equiv-reg
        [g, b : block (a : con, da : cn-of a _) |- Dequiv1[.., b.1, b.2]] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        K1 : (g |- kind),
        K4 : (g, a : con |- kind),
        K2 : (g, a38 : con |- kind),
        Dequiv : (g |- cn-equiv C C1 (pi K1 (\y339. K2))),
        Dequiv1 :
          (g, a : con, y433 : cn-of a (K1[..]) |-
             cn-equiv (app (C[..]) a) (app (C1[..]) a) (K4[.., a])),
        Dof : (g |- cn-of C (pi K1 (\y339. K2))),
        Dof1 : (g |- cn-of C1 (pi K1 (\y339. K2))),
        Dwf : (g |- kd-wf (pi K1 (\y339. K2))),
        Dof2 :
          (g, a : con, x1143 : cn-of a (K1[..]) |-
             cn-of (app (C[..]) a) (K4[.., a])),
        Dof3 :
          (g, a : con, z1143 : cn-of a (K1[..]) |-
             cn-of (app (C1[..]) a) (K4[.., a])),
        Dwf1 : (g, a : con, y1144 : cn-of a (K1[..]) |- kd-wf (K4[.., a]))
      | x : [g |- cn-equiv C C1 (pi K1 (\y339. K4))]
      ; by [g |- cn-of/extpi Dof (\a. \da. Dof2)] as Dof1' unboxed;
        by [g |- cn-of/extpi Dof1 (\a. \da. Dof3)] as Dof2' unboxed;
        split [g |- Dwf] as
        case kd-wf/pi:
        { g : conbind-reg,
          C : (g |- con),
          C1 : (g |- con),
          K1 : (g |- kind),
          K4 : (g, a : con |- kind),
          K2 : (g, a38 : con |- kind),
          Dequiv : (g |- cn-equiv C C1 (pi K1 (\y339. K2))),
          Dequiv1 :
            (g, a : con, y433 : cn-of a (K1[..]) |-
               cn-equiv (app (C[..]) a) (app (C1[..]) a) (K4[.., a])),
          Dof : (g |- cn-of C (pi K1 (\y339. K2))),
          Dof1 : (g |- cn-of C1 (pi K1 (\y339. K2))),
          Dwf2 : (g |- kd-wf K1),
          Dwf3 : (g, a : con, x399 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
          Dof2 :
            (g, a : con, x1143 : cn-of a (K1[..]) |-
               cn-of (app (C[..]) a) (K4[.., a])),
          Dof3 :
            (g, a : con, z1143 : cn-of a (K1[..]) |-
               cn-of (app (C1[..]) a) (K4[.., a])),
          Dwf1 : (g, a : con, y1144 : cn-of a (K1[..]) |- kd-wf (K4[.., a])),
          Dof1' : (g |- cn-of C (pi K1 (\y339. K4))),
          Dof2' : (g |- cn-of C1 (pi K1 (\y339. K4)))
        | x : [g |- cn-equiv C C1 (pi K1 (\y339. K4))]
        ; by [g |- kd-wf/pi Dwf2 (\a. \da. Dwf1)] as Dwf' unboxed;
          solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
        }
      }
    }
  }
  case cn-equiv/extpi:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K4 : (g, a37 : con |- kind),
    K2 : (g, a35 : con |- kind),
    K3 : (g, a36 : con |- kind),
    Dof : (g |- cn-of C (pi K1 (\y339. K2))),
    Dof1 : (g |- cn-of C1 (pi K1 (\y339. K3))),
    Dequiv :
      (g, a : con, y432 : cn-of a (K1[..]) |-
         cn-equiv (app (C[..]) a) (app (C1[..]) a) (K4[.., a]))
  | x : [g |- cn-equiv C C1 (pi K1 (\y339. K4))]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/pi:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K1 : (g |- kind),
      K4 : (g, a37 : con |- kind),
      K2 : (g, a35 : con |- kind),
      K3 : (g, a36 : con |- kind),
      Dof : (g |- cn-of C (pi K1 (\y339. K2))),
      Dof1 : (g |- cn-of C1 (pi K1 (\y339. K3))),
      Dequiv :
        (g, a : con, y432 : cn-of a (K1[..]) |-
           cn-equiv (app (C[..]) a) (app (C1[..]) a) (K4[.., a])),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, x399 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
    | x : [g |- cn-equiv C C1 (pi K1 (\y339. K4))]
    ; split
      cn-equiv-reg
        [g, b : block (a : con, da : cn-of a _) |- Dequiv[.., b.1, b.2]] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        K1 : (g |- kind),
        K5 : (g, a : con |- kind),
        K2 : (g, a35 : con |- kind),
        K3 : (g, a36 : con |- kind),
        Dof : (g |- cn-of C (pi K1 (\y339. K2))),
        Dof1 : (g |- cn-of C1 (pi K1 (\y339. K3))),
        Dequiv :
          (g, a : con, y432 : cn-of a (K1[..]) |-
             cn-equiv (app (C[..]) a) (app (C1[..]) a) (K5[.., a])),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g, a : con, x399 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
        Dof2 :
          (g, a : con, z1136 : cn-of a (K1[..]) |-
             cn-of (app (C[..]) a) (K5[.., a])),
        Dof3 :
          (g, a : con, y1137 : cn-of a (K1[..]) |-
             cn-of (app (C1[..]) a) (K5[.., a])),
        Dwf2 : (g, a : con, x1137 : cn-of a (K1[..]) |- kd-wf (K5[.., a]))
      | x : [g |- cn-equiv C C1 (pi K1 (\y339. K5))]
      ; by [g |- cn-of/extpi Dof (\a. \da. Dof2)] as Dof1' unboxed;
        by [g |- cn-of/extpi Dof1 (\a. \da. Dof3)] as Dof2' unboxed;
        by [g |- kd-wf/pi Dwf (\a. \da. Dwf2)] as Dwf' unboxed;
        solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
      }
    }
  }
  case cn-equiv/singelim:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C (sing C1))
  | x : [g |- cn-equiv C C1 t]
  ; split cn-of-reg [g |- Dof] as
    case kd-wf/sing:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      Dof : (g |- cn-of C (sing C1)),
      Dof1 : (g |- cn-of C1 t)
    | x : [g |- cn-equiv C C1 t]
    ; solve
        [g |-
           cn-equiv-reg/i (cn-of/subsume Dof (kd-sub/sing-t Dof1))
           Dof1 kd-wf/t]
    }
  }
  case cn-equiv/sing:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- cn-equiv C C1 (sing C)]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      Dequiv : (g |- cn-equiv C C1 t),
      Dof : (g |- cn-of C t),
      Dof1 : (g |- cn-of C1 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv C C1 (sing C)]
    ; by cn-of/equiv/conbind-reg [g |- cn-of/sing Dof1]
           [g |- kd-equiv/symm (kd-equiv/sing Dequiv)]
      as Dof2' unboxed;
      solve [g |- cn-equiv-reg/i (cn-of/sing Dof) Dof2' (kd-wf/sing Dof)]
    }
  }
  case cn-equiv/labeled:
  { g : conbind-reg,
    X : ( |- label),
    C2 : (g |- con),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t)
  | x : [g |- cn-equiv (labeled X[] C2) (labeled X[] C3) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      X : ( |- label),
      C2 : (g |- con),
      C3 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (labeled X[] C2) (labeled X[] C3) t]
    ; solve
        [g |- cn-equiv-reg/i (cn-of/labeled Dof) (cn-of/labeled Dof1) kd-wf/t]
    }
  }
  case cn-equiv/rec:
  { g : conbind-reg,
    K1 : (g |- kind),
    C2 : (g, a32 : con, a31 : con |- con),
    C4 : (g |- con),
    K2 : (g |- kind),
    C3 : (g, a34 : con, a33 : con |- con),
    C5 : (g |- con),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, x429 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       z429 : cn-of b (K1[..]) |- cn-equiv (C2[.., a, b]) (C3[.., a, b]) t),
    Dequiv2 : (g |- cn-equiv C4 C5 K1)
  | x :
      [g |-
         cn-equiv
           (rec' K1 (\y347. \x347. C2) C4) (rec' K2 (\y347. \x347. C3) C5) t]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K1 : (g |- kind),
      C2 : (g, a32 : con, a31 : con |- con),
      C4 : (g |- con),
      K2 : (g |- kind),
      C3 : (g, a34 : con, a33 : con |- con),
      C5 : (g |- con),
      Dequiv : (g |- kd-equiv K1 K2),
      Dequiv1 :
        (g, a : con, x429 : cn-of a (pi (K1[..]) (\l. t)), b : con,
         z429 : cn-of b (K1[..]) |- cn-equiv (C2[.., a, b]) (C3[.., a, b]) t),
      Dequiv2 : (g |- cn-equiv C4 C5 K1),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g |- kd-wf K2)
    | x :
        [g |-
           cn-equiv
             (rec' K1 (\y347. \x347. C2) C4)
             (rec' K2 (\y347. \x347. C3) C5) t]
    ; split cn-equiv-reg [g |- Dequiv2] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        K1 : (g |- kind),
        C2 : (g, a32 : con, a31 : con |- con),
        C4 : (g |- con),
        K2 : (g |- kind),
        C3 : (g, a34 : con, a33 : con |- con),
        C5 : (g |- con),
        Dequiv : (g |- kd-equiv K1 K2),
        Dequiv1 :
          (g, a : con, x429 : cn-of a (pi (K1[..]) (\l. t)), b : con,
           z429 : cn-of b (K1[..]) |-
             cn-equiv (C2[.., a, b]) (C3[.., a, b]) t),
        Dequiv2 : (g |- cn-equiv C4 C5 K1),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g |- kd-wf K2),
        Dof : (g |- cn-of C4 K1),
        Dof1 : (g |- cn-of C5 K1),
        Dwf2 : (g |- kd-wf K1)
      | x :
          [g |-
             cn-equiv
               (rec' K1 (\z357. \y358. C2) C4)
               (rec' K2 (\z357. \y358. C3) C5) t]
      ; ? % FIXME: See https://github.com/Beluga-lang/Beluga/issues/228
      }
    }
  }
  case cn-equiv/tag:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t)
  | x : [g |- cn-equiv (tag C2) (tag C3) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C3 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (tag C2) (tag C3) t]
    ; solve [g |- cn-equiv-reg/i (cn-of/tag Dof) (cn-of/tag Dof1) kd-wf/t]
    }
  }
  case cn-equiv/ref:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t)
  | x : [g |- cn-equiv (ref C2) (ref C3) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C3 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (ref C2) (ref C3) t]
    ; solve [g |- cn-equiv-reg/i (cn-of/ref Dof) (cn-of/ref Dof1) kd-wf/t]
    }
  }
  case cn-equiv/plus:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t),
    Dequiv1 : (g |- cn-equiv C4 C5 t)
  | x : [g |- cn-equiv (plus C2 C4) (plus C3 C5) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C4 : (g |- con),
      C3 : (g |- con),
      C5 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dequiv1 : (g |- cn-equiv C4 C5 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (plus C2 C4) (plus C3 C5) t]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C2 : (g |- con),
        C4 : (g |- con),
        C3 : (g |- con),
        C5 : (g |- con),
        Dequiv : (g |- cn-equiv C2 C3 t),
        Dequiv1 : (g |- cn-equiv C4 C5 t),
        Dof : (g |- cn-of C2 t),
        Dof1 : (g |- cn-of C3 t),
        Dwf : (g |- kd-wf t),
        Dof2 : (g |- cn-of C4 t),
        Dof3 : (g |- cn-of C5 t),
        Dwf1 : (g |- kd-wf t)
      | x : [g |- cn-equiv (plus C2 C4) (plus C3 C5) t]
      ; solve
          [g |-
             cn-equiv-reg/i (cn-of/plus Dof Dof2)
             (cn-of/plus Dof1 Dof3) kd-wf/t]
      }
    }
  }
  case cn-equiv/arrow:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t),
    Dequiv1 : (g |- cn-equiv C4 C5 t)
  | x : [g |- cn-equiv (arrow C2 C4) (arrow C3 C5) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C4 : (g |- con),
      C3 : (g |- con),
      C5 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dequiv1 : (g |- cn-equiv C4 C5 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (arrow C2 C4) (arrow C3 C5) t]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C2 : (g |- con),
        C4 : (g |- con),
        C3 : (g |- con),
        C5 : (g |- con),
        Dequiv : (g |- cn-equiv C2 C3 t),
        Dequiv1 : (g |- cn-equiv C4 C5 t),
        Dof : (g |- cn-of C2 t),
        Dof1 : (g |- cn-of C3 t),
        Dwf : (g |- kd-wf t),
        Dof2 : (g |- cn-of C4 t),
        Dof3 : (g |- cn-of C5 t),
        Dwf1 : (g |- kd-wf t)
      | x : [g |- cn-equiv (arrow C2 C4) (arrow C3 C5) t]
      ; solve
          [g |-
             cn-equiv-reg/i (cn-of/arrow Dof Dof2)
             (cn-of/arrow Dof1 Dof3) kd-wf/t]
      }
    }
  }
  case cn-equiv/prod:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    Dequiv : (g |- cn-equiv C2 C3 t),
    Dequiv1 : (g |- cn-equiv C4 C5 t)
  | x : [g |- cn-equiv (prod C2 C4) (prod C3 C5) t]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C4 : (g |- con),
      C3 : (g |- con),
      C5 : (g |- con),
      Dequiv : (g |- cn-equiv C2 C3 t),
      Dequiv1 : (g |- cn-equiv C4 C5 t),
      Dof : (g |- cn-of C2 t),
      Dof1 : (g |- cn-of C3 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- cn-equiv (prod C2 C4) (prod C3 C5) t]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C2 : (g |- con),
        C4 : (g |- con),
        C3 : (g |- con),
        C5 : (g |- con),
        Dequiv : (g |- cn-equiv C2 C3 t),
        Dequiv1 : (g |- cn-equiv C4 C5 t),
        Dof : (g |- cn-of C2 t),
        Dof1 : (g |- cn-of C3 t),
        Dwf : (g |- kd-wf t),
        Dof2 : (g |- cn-of C4 t),
        Dof3 : (g |- cn-of C5 t),
        Dwf1 : (g |- kd-wf t)
      | x : [g |- cn-equiv (prod C2 C4) (prod C3 C5) t]
      ; solve
          [g |-
             cn-equiv-reg/i (cn-of/prod Dof Dof2)
             (cn-of/prod Dof1 Dof3) kd-wf/t]
      }
    }
  }
  case cn-equiv/app:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    K2 : (g, a30 : con |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C2 C3 (pi K1 (\y339. K2))),
    Dequiv1 : (g |- cn-equiv C4 C5 K1)
  | x : [g |- cn-equiv (app C2 C4) (app C3 C5) (K2[.., C4])]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C4 : (g |- con),
      C3 : (g |- con),
      C5 : (g |- con),
      K2 : (g, a30 : con |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- cn-equiv C2 C3 (pi K1 (\y339. K2))),
      Dequiv1 : (g |- cn-equiv C4 C5 K1),
      Dof : (g |- cn-of C2 (pi K1 (\y339. K2))),
      Dof1 : (g |- cn-of C3 (pi K1 (\y339. K2))),
      Dwf : (g |- kd-wf (pi K1 (\y339. K2)))
    | x : [g |- cn-equiv (app C2 C4) (app C3 C5) (K2[.., C4])]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C2 : (g |- con),
        C4 : (g |- con),
        C3 : (g |- con),
        C5 : (g |- con),
        K2 : (g, a30 : con |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- cn-equiv C2 C3 (pi K1 (\y339. K2))),
        Dequiv1 : (g |- cn-equiv C4 C5 K1),
        Dof : (g |- cn-of C2 (pi K1 (\y339. K2))),
        Dof1 : (g |- cn-of C3 (pi K1 (\y339. K2))),
        Dwf : (g |- kd-wf (pi K1 (\y339. K2))),
        Dof2 : (g |- cn-of C4 K1),
        Dof3 : (g |- cn-of C5 K1),
        Dwf1 : (g |- kd-wf K1)
      | x : [g |- cn-equiv (app C2 C4) (app C3 C5) (K2[.., C4])]
      ; split [g |- Dwf] as
        case kd-wf/pi:
        { g : conbind-reg,
          C2 : (g |- con),
          C4 : (g |- con),
          C3 : (g |- con),
          C5 : (g |- con),
          K2 : (g, a30 : con |- kind),
          K1 : (g |- kind),
          Dequiv : (g |- cn-equiv C2 C3 (pi K1 (\y339. K2))),
          Dequiv1 : (g |- cn-equiv C4 C5 K1),
          Dof : (g |- cn-of C2 (pi K1 (\y339. K2))),
          Dof1 : (g |- cn-of C3 (pi K1 (\y339. K2))),
          Dwf2 : (g |- kd-wf K1),
          Dwf3 : (g, a : con, x399 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
          Dof2 : (g |- cn-of C4 K1),
          Dof3 : (g |- cn-of C5 K1),
          Dwf1 : (g |- kd-wf K1)
        | x : [g |- cn-equiv (app C2 C4) (app C3 C5) (K2[.., C4])]
        ; by functionality-kd-reg [g, a : con, da : cn-of a (K1[..]) |- Dwf3]
               [g |- Dequiv1] [g |- Dof2]
          as Dequiv' unboxed;
          by [g |- cn-of/app Dof2 Dof] as Dof1' unboxed;
          by cn-of/equiv/conbind-reg [g |- cn-of/app Dof3 Dof1]
     [g |- kd-equiv/symm Dequiv']
as Dof2' unboxed;
          by [g |- Dwf3[.., C4, _]] as Dwf' unboxed;
          solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
        }
      }
    }
  }
  case cn-equiv/lam:
  { g : conbind-reg,
    K1 : (g |- kind),
    C2 : (g, a27 : con |- con),
    K2 : (g |- kind),
    C3 : (g, a28 : con |- con),
    K3 : (g, a29 : con |- kind),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, z424 : cn-of a (K1[..]) |-
         cn-equiv (C2[.., a]) (C3[.., a]) (K3[.., a]))
  | x :
      [g |-
         cn-equiv
           (lam K1 (\x342. C2)) (lam K2 (\x342. C3)) (pi K1 (\y339. K3))]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K1 : (g |- kind),
      C2 : (g, a27 : con |- con),
      K2 : (g |- kind),
      C3 : (g, a28 : con |- con),
      K3 : (g, a29 : con |- kind),
      Dequiv : (g |- kd-equiv K1 K2),
      Dequiv1 :
        (g, a : con, z424 : cn-of a (K1[..]) |-
           cn-equiv (C2[.., a]) (C3[.., a]) (K3[.., a])),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g |- kd-wf K2)
    | x :
        [g |-
           cn-equiv
             (lam K1 (\x342. C2)) (lam K2 (\x342. C3)) (pi K1 (\y339. K3))]
    ; split
      cn-equiv-reg
        [g, b : block (a : con, da : cn-of a _) |- Dequiv1[.., b.1, b.2]] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        K1 : (g |- kind),
        C4 : (g, a : con |- con),
        K2 : (g |- kind),
        C5 : (g, a : con |- con),
        K4 : (g, a : con |- kind),
        Dequiv : (g |- kd-equiv K1 K2),
        Dequiv1 :
          (g, a : con, z424 : cn-of a (K1[..]) |-
             cn-equiv (C4[.., a]) (C5[.., a]) (K4[.., a])),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g |- kd-wf K2),
        Dof :
          (g, a : con, y1132 : cn-of a (K1[..]) |-
             cn-of (C4[.., a]) (K4[.., a])),
        Dof1 :
          (g, a : con, x1132 : cn-of a (K1[..]) |-
             cn-of (C5[.., a]) (K4[.., a])),
        Dwf2 : (g, a : con, z1132 : cn-of a (K1[..]) |- kd-wf (K4[.., a]))
      | x :
          [g |-
             cn-equiv
               (lam K1 (\x342. C4)) (lam K2 (\x342. C5)) (pi K1 (\y339. K4))]
      ; by [g |- cn-of/lam Dwf (\a. \da. Dof)] as Dof1' unboxed;
        by [g |- kd-wf/pi Dwf (\a. \da. Dwf2)] as Dwf' unboxed;
        by [g |- cn-of/lam Dwf1 (\a. \da. Dof1[.., a, _])] as Dof2'' unboxed;
        by [g |-
              kd-equiv/pi (kd-equiv/symm Dequiv)
              (\a. \da. kd-equiv/refl (Dwf2[.., a, _]))]
        as Dequiv' unboxed;
        by cn-of/equiv/conbind-reg [g |- Dof2''] [g |- Dequiv']
        as Dof2' unboxed;
        solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
      }
    }
  }
  case cn-equiv/pi2:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    K2 : (g, a26 : con |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C2 C3 (sigma K1 (\y340. K2)))
  | x : [g |- cn-equiv (pi2 C2) (pi2 C3) (K2[.., pi1 C2])]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C3 : (g |- con),
      K2 : (g, a26 : con |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- cn-equiv C2 C3 (sigma K1 (\y340. K2))),
      Dof : (g |- cn-of C2 (sigma K1 (\y340. K2))),
      Dof1 : (g |- cn-of C3 (sigma K1 (\y340. K2))),
      Dwf : (g |- kd-wf (sigma K1 (\y340. K2)))
    | x : [g |- cn-equiv (pi2 C2) (pi2 C3) (K2[.., pi1 C2])]
    ; split [g |- Dwf] as
      case kd-wf/sigma:
      { g : conbind-reg,
        C2 : (g |- con),
        C3 : (g |- con),
        K2 : (g, a26 : con |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- cn-equiv C2 C3 (sigma K1 (\y340. K2))),
        Dof : (g |- cn-of C2 (sigma K1 (\y340. K2))),
        Dof1 : (g |- cn-of C3 (sigma K1 (\y340. K2))),
        Dwf1 : (g |- kd-wf K1),
        Dwf2 : (g, a : con, x400 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
      | x : [g |- cn-equiv (pi2 C2) (pi2 C3) (K2[.., pi1 C2])]
      ; by functionality-kd-reg [g, a : con, da : cn-of a (K1[..]) |- Dwf2]
     [g |- cn-equiv/pi1 Dequiv] [g |- cn-of/pi1 Dof]
as Dequiv' unboxed;
        by [g |- cn-of/pi2 Dof] as Dof1' unboxed;
        by cn-of/equiv/conbind-reg [g |- cn-of/pi2 Dof1]
             [g |- kd-equiv/symm Dequiv']
        as Dof2' unboxed;
        by [g |- cn-of/pi1 Dof] as Dof1'' unboxed;
        by [g |- Dwf2[.., _, Dof1'']] as Dwf' unboxed;
        solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
      }
    }
  }
  case cn-equiv/pi1:
  { g : conbind-reg,
    C2 : (g |- con),
    C3 : (g |- con),
    K : (g |- kind),
    K2 : (g, a25 : con |- kind),
    Dequiv : (g |- cn-equiv C2 C3 (sigma K (\y340. K2)))
  | x : [g |- cn-equiv (pi1 C2) (pi1 C3) K]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C3 : (g |- con),
      K : (g |- kind),
      K2 : (g, a25 : con |- kind),
      Dequiv : (g |- cn-equiv C2 C3 (sigma K (\y340. K2))),
      Dof : (g |- cn-of C2 (sigma K (\y340. K2))),
      Dof1 : (g |- cn-of C3 (sigma K (\y340. K2))),
      Dwf : (g |- kd-wf (sigma K (\y340. K2)))
    | x : [g |- cn-equiv (pi1 C2) (pi1 C3) K]
    ; split [g |- Dwf] as
      case kd-wf/sigma:
      { g : conbind-reg,
        C2 : (g |- con),
        C3 : (g |- con),
        K : (g |- kind),
        K2 : (g, a25 : con |- kind),
        Dequiv : (g |- cn-equiv C2 C3 (sigma K (\y340. K2))),
        Dof : (g |- cn-of C2 (sigma K (\y340. K2))),
        Dof1 : (g |- cn-of C3 (sigma K (\y340. K2))),
        Dwf1 : (g |- kd-wf K),
        Dwf2 : (g, a : con, x400 : cn-of a (K[..]) |- kd-wf (K2[.., a]))
      | x : [g |- cn-equiv (pi1 C2) (pi1 C3) K]
      ; solve [g |- cn-equiv-reg/i (cn-of/pi1 Dof) (cn-of/pi1 Dof1) Dwf1]
      }
    }
  }
  case cn-equiv/pair:
  { g : conbind-reg,
    C2 : (g |- con),
    C4 : (g |- con),
    C3 : (g |- con),
    C5 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a24 : con |- kind),
    Dequiv : (g |- cn-equiv C2 C3 K1),
    Dequiv1 : (g |- cn-equiv C4 C5 (K2[.., C2])),
    Dwf : (g, a : con, y423 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-equiv (pair C2 C4) (pair C3 C5) (sigma K1 (\y340. K2))]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C2 : (g |- con),
      C4 : (g |- con),
      C3 : (g |- con),
      C5 : (g |- con),
      K1 : (g |- kind),
      K2 : (g, a24 : con |- kind),
      Dequiv : (g |- cn-equiv C2 C3 K1),
      Dequiv1 : (g |- cn-equiv C4 C5 (K2[.., C2])),
      Dwf : (g, a : con, y423 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      Dof : (g |- cn-of C2 K1),
      Dof1 : (g |- cn-of C3 K1),
      Dwf1 : (g |- kd-wf K1)
    | x : [g |- cn-equiv (pair C2 C4) (pair C3 C5) (sigma K1 (\y340. K2))]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C2 : (g |- con),
        C4 : (g |- con),
        C3 : (g |- con),
        C5 : (g |- con),
        K1 : (g |- kind),
        K2 : (g, a24 : con |- kind),
        Dequiv : (g |- cn-equiv C2 C3 K1),
        Dequiv1 : (g |- cn-equiv C4 C5 (K2[.., C2])),
        Dwf : (g, a : con, y423 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
        Dof : (g |- cn-of C2 K1),
        Dof1 : (g |- cn-of C3 K1),
        Dwf1 : (g |- kd-wf K1),
        Dof2 : (g |- cn-of C4 (K2[.., C2])),
        Dof3 : (g |- cn-of C5 (K2[.., C2])),
        Dwf2 : (g |- kd-wf (K2[.., C2]))
      | x : [g |- cn-equiv (pair C2 C4) (pair C3 C5) (sigma K1 (\y340. K2))]
      ; by functionality-kd-reg [g, a : con, da : cn-of a (K1[..]) |- Dwf]
     [g |- Dequiv] [g |- Dof]
as DequivK unboxed;
        by [g |- cn-of/pair Dof Dof2 (\a. \da. Dwf)] as Dof1' unboxed;
        by cn-of/equiv/conbind-reg [g |- Dof3] [g |- DequivK] as Dof3' unboxed;
        by [g |- cn-of/pair Dof1 Dof3' (\a. \da. Dwf)] as Dof2' unboxed;
        by [g |- kd-wf/sigma Dwf1 (\a. \da. Dwf)] as Dwf' unboxed;
        solve [g |- cn-equiv-reg/i Dof1' Dof2' Dwf']
      }
    }
  }
  case cn-equiv/trans:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    C3 : (g |- con),
    Dequiv : (g |- cn-equiv C C3 K),
    Dequiv1 : (g |- cn-equiv C3 C1 K)
  | x : [g |- cn-equiv C C1 K]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K : (g |- kind),
      C3 : (g |- con),
      Dequiv : (g |- cn-equiv C C3 K),
      Dequiv1 : (g |- cn-equiv C3 C1 K),
      Dof : (g |- cn-of C K),
      Dof1 : (g |- cn-of C3 K),
      Dwf : (g |- kd-wf K)
    | x : [g |- cn-equiv C C1 K]
    ; split cn-equiv-reg [g |- Dequiv1] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        K : (g |- kind),
        C3 : (g |- con),
        Dequiv : (g |- cn-equiv C C3 K),
        Dequiv1 : (g |- cn-equiv C3 C1 K),
        Dof : (g |- cn-of C K),
        Dof1 : (g |- cn-of C3 K),
        Dwf : (g |- kd-wf K),
        Dof2 : (g |- cn-of C3 K),
        Dof3 : (g |- cn-of C1 K),
        Dwf1 : (g |- kd-wf K)
      | x : [g |- cn-equiv C C1 K]
      ; solve [g |- cn-equiv-reg/i Dof Dof3 Dwf1]
      }
    }
  }
  case cn-equiv/symm:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    Dequiv : (g |- cn-equiv C1 C K)
  | x : [g |- cn-equiv C C1 K]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K : (g |- kind),
      Dequiv : (g |- cn-equiv C1 C K),
      Dof : (g |- cn-of C1 K),
      Dof1 : (g |- cn-of C K),
      Dwf : (g |- kd-wf K)
    | x : [g |- cn-equiv C C1 K]
    ; solve [g |- cn-equiv-reg/i Dof1 Dof Dwf]
    }
  }
  case cn-equiv/refl:
  { g : conbind-reg,
    C1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of C1 K)
  | x : [g |- cn-equiv C1 C1 K]
  ; by cn-of-reg [g |- Dof] as Dwf unboxed;
    solve [g |- cn-equiv-reg/i Dof Dof Dwf]
  }
}
;

LF inhabitation/e : kind -> type =
| inhabitation/i :
  { C : con }
  cn-of C K ->
    inhabitation/e K
;

proof inhabitation :
  (g : conbind) [g |- kd-wf K] ->
    [g |- inhabitation/e K] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind)
| x : [g |- kd-wf K]
; split x as
  case kd-wf/one:
  { g : conbind
  | x : [g |- kd-wf one]
  ; solve [g |- inhabitation/i _ cn-of/star]
  }
  case kd-wf/sigma:
  { g : conbind,
    K1 : (g |- kind),
    K2 : (g, a4 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, z160 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (sigma K1 (\x100. K2))]
  ; split inhabitation [g |- Dwf] as
    case inhabitation/i:
    { g : conbind,
      K1 : (g |- kind),
      K2 : (g, a4 : con |- kind),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z160 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      C : (g |- con),
      Dof : (g |- cn-of C K1)
    | x : [g |- kd-wf (sigma K1 (\x100. K2))]
    ; split
      inhabitation
        [g, b : block (a : con, d : cn-of a (K1[..])) |- Dwf1[.., b.1, b.2]] as
      case inhabitation/i:
      { g : conbind,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g, a : con, z160 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
        C : (g |- con),
        Dof : (g |- cn-of C K1),
        C1 : (g, a : con |- con),
        Dof1 :
          (g, a : con, y665 : cn-of a (K1[..]) |-
             cn-of (C1[.., a]) (K3[.., a]))
      | x : [g |- kd-wf (sigma K1 (\x100. K3))]
      ; solve
  [g |- inhabitation/i _ (cn-of/pair Dof (Dof1[.., C, Dof]) (\x. \y. Dwf1))]
      }
    }
  }
  case kd-wf/pi:
  { g : conbind,
    K1 : (g |- kind),
    K2 : (g, a3 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, z159 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (pi K1 (\x99. K2))]
  ; split
    inhabitation
      [_, b : block (a : con, d : cn-of a (K1[..])) |- Dwf1[.., b.1, b.2]] as
    case inhabitation/i:
    { g : conbind,
      K1 : (g |- kind),
      K3 : (g, a : con |- kind),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, z159 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
      C : (g, a : con |- con),
      Dof :
        (g, a : con, y668 : cn-of a (K1[..]) |- cn-of (C[.., a]) (K3[.., a]))
    | x : [g |- kd-wf (pi K1 (\x99. K3))]
    ; solve [g |- inhabitation/i _ (cn-of/lam Dwf (\x. \y. Dof))]
    }
  }
  case kd-wf/sing:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-wf (sing C)]
  ; solve [g |- inhabitation/i _ (cn-of/sing Dof)]
  }
  case kd-wf/t:
  { g : conbind
  | x : [g |- kd-wf t]
  ; solve [g |- inhabitation/i _ cn-of/unit]
  }
}
;

% Functionality Redux

proof functionality-kd :
  (g : conbind-reg)
  [g, b : con, db : cn-of b K[..] |- kd-wf (K'[.., b])] ->
  [g |- cn-equiv C1 C2 K] ->
    [g |- kd-equiv (K'[.., C1]) (K'[.., C2])] =
/ total /
intros
{ g : conbind-reg,
  K : (g |- kind),
  K' : (g, b : con |- kind),
  C : (g |- con),
  C1 : (g |- con)
| wf : [g, b : con, db : cn-of b (K[..]) |- kd-wf (K'[.., b])],
  equiv : [g |- cn-equiv C C1 K]
; split cn-equiv-reg equiv as
  case cn-equiv-reg/i:
  { g : conbind-reg,
    K : (g |- kind),
    K' : (g, b : con |- kind),
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C K),
    Dof1 : (g |- cn-of C1 K),
    Dwf : (g |- kd-wf K)
  | wf : [g, b : con, db : cn-of b (K[..]) |- kd-wf (K'[.., b])],
    equiv : [g |- cn-equiv C C1 K]
  ; solve functionality-kd-reg wf equiv [_ |- Dof]
  }
}
;

proof functionality-cn :
  (g : conbind-reg)
  [g, c : con, dc : cn-of c K[..] |- cn-of (C[.., c]) (K'[.., c])] ->
  [g |- cn-equiv C1 C2 K] ->
    [g |- cn-equiv (C[.., C1]) (C[.., C2]) (K'[.., C1])] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind-reg,
  K : (g |- kind),
  C : (g, c : con |- con),
  K' : (g, c : con |- kind),
  C1 : (g |- con),
  C2 : (g |- con)
| x : [g, c : con, dc : cn-of c (K[..]) |- cn-of (C[.., c]) (K'[.., c])],
  equiv : [g |- cn-equiv C1 C2 K]
; split x as
  case cn-of/subsume:
  { g : conbind-reg,
    K : (g |- kind),
    C : (g, c : con |- con),
    K' : (g, c : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    K1 : (g, c : con |- kind),
    Dof : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C[.., c]) (K1[.., c])),
    Dsub :
      (g, c : con, dc : cn-of c (K[..]) |- kd-sub (K1[.., c]) (K'[.., c]))
  | x : [g, c : con, dc : cn-of c (K[..]) |- cn-of (C[.., c]) (K'[.., c])],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv unboxed;
    by [g |- Dsub[.., C1, _]] as Dsub' unboxed;
    solve [g |- cn-equiv/subsume Dsub' Dequiv]
  }
  case cn-of/extsigma:
  { g : conbind-reg,
    K : (g |- kind),
    C : (g, c : con |- con),
    K1 : (g, c : con |- kind),
    K2 : (g, c : con, a23 : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    Dof :
      (g, c : con, dc : cn-of c (K[..]) |- cn-of (pi1 (C[.., c])) (K1[.., c])),
    Dof1 :
      (g, c : con, dc : cn-of c (K[..]) |-
         cn-of (pi2 (C[.., c])) (K2[.., c, pi1 (C[.., c])])),
    Dwf :
      (g, c : con, dc : cn-of c (K[..]), a : con, z550 : cn-of a (K1[.., c]) |-
         kd-wf (K2[.., c, a]))
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of (C[.., c]) (sigma (K1[.., c]) (\y471. K2[.., c, y471]))],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv1 unboxed;
    by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof1] equiv
    as Dequiv2 unboxed;
    split cn-equiv-reg equiv as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      C : (g, c : con |- con),
      K1 : (g, c : con |- kind),
      K2 : (g, c : con, a23 : con |- kind),
      C1 : (g |- con),
      C2 : (g |- con),
      Dof :
        (g, c : con, dc : cn-of c (K[..]) |-
           cn-of (pi1 (C[.., c])) (K1[.., c])),
      Dof1 :
        (g, c : con, dc : cn-of c (K[..]) |-
           cn-of (pi2 (C[.., c])) (K2[.., c, pi1 (C[.., c])])),
      Dwf :
        (g, c : con, dc : cn-of c (K[..]), a : con,
         z550 : cn-of a (K1[.., c]) |- kd-wf (K2[.., c, a])),
      Dequiv1 :
        (g |- cn-equiv (pi1 (C[.., C1])) (pi1 (C[.., C2])) (K1[.., C1])),
      Dequiv2 :
        (g |-
           cn-equiv
             (pi2 (C[.., C1]))
             (pi2 (C[.., C2])) (K2[.., C1, pi1 (C[.., C1])])),
      Dof2 : (g |- cn-of C1 K),
      Dof3 : (g |- cn-of C2 K),
      Dwf1 : (g |- kd-wf K)
    | x :
        [g, c : con, dc : cn-of c (K[..]) |-
           cn-of (C[.., c]) (sigma (K1[.., c]) (\y471. K2[.., c, y471]))],
      equiv : [g |- cn-equiv C1 C2 K]
    ; solve
        [g |-
           cn-equiv/extsigma Dequiv1
           Dequiv2 (\a. \da. Dwf[.., (C1[..]), (Dof2[..]), a, da])]
    }
  }
  case cn-of/extpi:
  { g : conbind-reg,
    K : (g |- kind),
    C : (g, c : con |- con),
    K1 : (g, c : con |- kind),
    K3 : (g, c : con, a22 : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    K2 : (g, c : con, a21 : con |- kind),
    Dof :
      (g, c : con, dc : cn-of c (K[..]) |-
         cn-of (C[.., c]) (pi (K1[.., c]) (\y470. K2[.., c, y470]))),
    Dof1 :
      (g, c : con, dc : cn-of c (K[..]), a : con, x549 : cn-of a (K1[.., c]) |-
         cn-of (app (C[.., c]) a) (K3[.., c, a]))
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of (C[.., c]) (pi (K1[.., c]) (\y470. K3[.., c, y470]))],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv' unboxed;
    split cn-equiv-reg [g |- Dequiv'] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      C : (g, c : con |- con),
      K1 : (g, c : con |- kind),
      K3 : (g, c : con, a22 : con |- kind),
      C1 : (g |- con),
      C2 : (g |- con),
      K2 : (g, c : con, a21 : con |- kind),
      Dof :
        (g, c : con, dc : cn-of c (K[..]) |-
           cn-of (C[.., c]) (pi (K1[.., c]) (\y470. K2[.., c, y470]))),
      Dof1 :
        (g, c : con, dc : cn-of c (K[..]), a : con,
         x549 : cn-of a (K1[.., c]) |-
           cn-of (app (C[.., c]) a) (K3[.., c, a])),
      Dequiv' :
        (g |-
           cn-equiv
             (C[.., C1])
             (C[.., C2]) (pi (K1[.., C1]) (\y470. K2[.., (C1[..]), y470]))),
      Dof2 :
        (g |-
           cn-of
             (C[.., C1]) (pi (K1[.., C1]) (\y470. K2[.., (C1[..]), y470]))),
      Dof3 :
        (g |-
           cn-of
             (C[.., C2]) (pi (K1[.., C1]) (\y470. K2[.., (C1[..]), y470]))),
      Dwf : (g |- kd-wf (pi (K1[.., C1]) (\y470. K2[.., (C1[..]), y470])))
    | x :
        [g, c : con, dc : cn-of c (K[..]) |-
           cn-of (C[.., c]) (pi (K1[.., c]) (\y470. K3[.., c, y470]))],
      equiv : [g |- cn-equiv C1 C2 K]
    ; by equiv as Dequiv unboxed;
      by functionality-cn
           [g, b : block (a : con, da : cn-of a (K1[.., (C1[..])])), c : con,
            dc : cn-of c (K[..]) |- Dof1[.., c, dc, b.1, _]]
           [g, b : block (a : con, da : cn-of a (K1[.., (C1[..])])) |-
              Dequiv[..]]
      as Dequiv'' unboxed;
      solve [g |- cn-equiv/extpi Dof2 Dof3 (\a. \da. Dequiv''[.., <a; da>])]
    }
  }
  case cn-of/sing:
  { g : conbind-reg,
    K : (g |- kind),
    C : (g, c : con |- con),
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C[.., c]) t)
  | x :
      [g, c : con, dc : cn-of c (K[..]) |- cn-of (C[.., c]) (sing (C[.., c]))],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv unboxed;
    solve [g |- cn-equiv/sing Dequiv]
  }
  case cn-of/labeled:
  { g : conbind-reg,
    K : (g |- kind),
    X : ( |- label),
    C3 : (g, c : con |- con),
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C3[.., c]) t)
  | x :
      [g, c : con, dc : cn-of c (K[..]) |- cn-of (labeled X[] (C3[.., c])) t],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv unboxed;
    solve [g |- cn-equiv/labeled Dequiv]
  }
  case cn-of/rec:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, c : con |- kind),
    C3 : (g, c : con, a20 : con, a19 : con |- con),
    C4 : (g, c : con |- con),
    C1 : (g |- con),
    C2 : (g |- con),
    Dwf : (g, c : con, dc : cn-of c (K[..]) |- kd-wf (K1[.., c])),
    Dof :
      (g, c : con, dc : cn-of c (K[..]), a : con,
       x547 : cn-of a (pi (K1[.., c]) (\l. t)), b : con,
       z547 : cn-of b (K1[.., c]) |- cn-of (C3[.., c, a, b]) t),
    Dof1 :
      (g, c : con, dc : cn-of c (K[..]) |- cn-of (C4[.., c]) (K1[.., c]))
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of
           (rec' (K1[.., c])
           (\y478. \x478. C3[.., c, y478, x478]) (C4[.., c])) t],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-kd [g, b : con, db : cn-of b (K[..]) |- Dwf] equiv
as Dequiv unboxed;
    %{ FIXME: Wrong block projections
        type [_, b1 : block (a : con, da : cn-of a (pi K1[.., C1[..]] (\l. t))), b2 : block (b : con, db : cn-of b K1[.., C1[..]]), c : con, dc : cn-of c K[..] |- Dof[.., c, dc, b1.a, _, b2.b, _]]
    }%
    ?
  }
  case cn-of/tagged:
  { g : conbind-reg, K : (g |- kind), C1 : (g |- con), C2 : (g |- con)
  | x : [g, c : con, dc : cn-of c (K[..]) |- cn-of tagged t],
    equiv : [g |- cn-equiv C1 C2 K]
  ; solve [g |- cn-equiv/refl cn-of/tagged]
  }
  case cn-of/tag:
  { g : conbind-reg,
    K : (g |- kind),
    C3 : (g, c : con |- con),
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C3[.., c]) t)
  | x : [g, c : con, dc : cn-of c (K[..]) |- cn-of (tag (C3[.., c])) t],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv unboxed;
    solve [g |- cn-equiv/tag Dequiv]
  }
  case cn-of/ref:
  { g : conbind-reg,
    K : (g |- kind),
    C3 : (g, c : con |- con),
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C3[.., c]) t)
  | x : [g, c : con, dc : cn-of c (K[..]) |- cn-of (ref (C3[.., c])) t],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv unboxed;
    solve [g |- cn-equiv/ref Dequiv]
  }
  case cn-of/plus:
  { g : conbind-reg,
    K : (g |- kind),
    C3 : (g, c : con |- con),
    C4 : (g, c : con |- con),
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C3[.., c]) t),
    Dof1 : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C4[.., c]) t)
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of (plus (C3[.., c]) (C4[.., c])) t],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv1 unboxed;
    by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof1] equiv
    as Dequiv2 unboxed;
    solve [g |- cn-equiv/plus Dequiv1 Dequiv2]
  }
  case cn-of/arrow:
  { g : conbind-reg,
    K : (g |- kind),
    C3 : (g, c : con |- con),
    C4 : (g, c : con |- con),
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C3[.., c]) t),
    Dof1 : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C4[.., c]) t)
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of (arrow (C3[.., c]) (C4[.., c])) t],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv1 unboxed;
    by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof1] equiv
    as Dequiv2 unboxed;
    solve [g |- cn-equiv/arrow Dequiv1 Dequiv2]
  }
  case cn-of/prod:
  { g : conbind-reg,
    K : (g |- kind),
    C3 : (g, c : con |- con),
    C4 : (g, c : con |- con),
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C3[.., c]) t),
    Dof1 : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C4[.., c]) t)
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of (prod (C3[.., c]) (C4[.., c])) t],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv1 unboxed;
    by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof1] equiv
    as Dequiv2 unboxed;
    solve [g |- cn-equiv/prod Dequiv1 Dequiv2]
  }
  case cn-of/void:
  { g : conbind-reg, K : (g |- kind), C1 : (g |- con), C2 : (g |- con)
  | x : [g, c : con, dc : cn-of c (K[..]) |- cn-of void t],
    equiv : [g |- cn-equiv C1 C2 K]
  ; solve [g |- cn-equiv/refl cn-of/void]
  }
  case cn-of/unit:
  { g : conbind-reg, K : (g |- kind), C1 : (g |- con), C2 : (g |- con)
  | x : [g, c : con, dc : cn-of c (K[..]) |- cn-of unit t],
    equiv : [g |- cn-equiv C1 C2 K]
  ; solve [g |- cn-equiv/refl cn-of/unit]
  }
  case cn-of/star:
  { g : conbind-reg, K : (g |- kind), C1 : (g |- con), C2 : (g |- con)
  | x : [g, c : con, dc : cn-of c (K[..]) |- cn-of star one],
    equiv : [g |- cn-equiv C1 C2 K]
  ; solve [g |- cn-equiv/refl cn-of/star]
  }
  case cn-of/app:
  { g : conbind-reg,
    K : (g |- kind),
    C4 : (g, c : con |- con),
    C3 : (g, c : con |- con),
    K2 : (g, c : con, a18 : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    K1 : (g, c : con |- kind),
    Dof : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C3[.., c]) (K1[.., c])),
    Dof1 :
      (g, c : con, dc : cn-of c (K[..]) |-
         cn-of (C4[.., c]) (pi (K1[.., c]) (\y470. K2[.., c, y470])))
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of (app (C4[.., c]) (C3[.., c])) (K2[.., c, (C3[.., c])])],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv1 unboxed;
    by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof1] equiv
    as Dequiv2 unboxed;
    solve [g |- cn-equiv/app Dequiv2 Dequiv1]
  }
  case cn-of/lam:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g, c : con |- kind),
    C3 : (g, c : con, a16 : con |- con),
    K2 : (g, c : con, a17 : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    Dwf : (g, c : con, dc : cn-of c (K[..]) |- kd-wf (K1[.., c])),
    Dof :
      (g, c : con, dc : cn-of c (K[..]), a : con, z542 : cn-of a (K1[.., c]) |-
         cn-of (C3[.., c, a]) (K2[.., c, a]))
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of
           (lam (K1[.., c]) (\x473. C3[.., c, x473]))
           (pi (K1[.., c]) (\y470. K2[.., c, y470]))],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-kd [g, b : con, db : cn-of b (K[..]) |- Dwf] equiv
as Dequiv1 unboxed;
    by equiv as Dequiv unboxed;
    by functionality-cn
          [g, d : block (a : con, da : cn-of a (K1[.., (C1[..])])), c : con,
          dc : cn-of c (K[..]) |- Dof[.., c, dc, d.1, _]]
          [g, d : block (a : con, da : cn-of a (K1[.., (C1[..])])) |-
            Dequiv[..]]
    as Dequiv2 unboxed;
    solve [g |- cn-equiv/lam Dequiv1 (\a. \da. Dequiv2[.., <a; da>])]
  }
  case cn-of/pi2:
  { g : conbind-reg,
    K : (g |- kind),
    C3 : (g, c : con |- con),
    K2 : (g, c : con, a15 : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    K1 : (g, c : con |- kind),
    Dof :
      (g, c : con, dc : cn-of c (K[..]) |-
         cn-of (C3[.., c]) (sigma (K1[.., c]) (\y471. K2[.., c, y471])))
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of (pi2 (C3[.., c])) (K2[.., c, pi1 (C3[.., c])])],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv' unboxed;
    solve [g |- cn-equiv/pi2 Dequiv']
  }
  case cn-of/pi1:
  { g : conbind-reg,
    K : (g |- kind),
    C3 : (g, c : con |- con),
    K' : (g, c : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    K2 : (g, c : con, a14 : con |- kind),
    Dof :
      (g, c : con, dc : cn-of c (K[..]) |-
         cn-of (C3[.., c]) (sigma (K'[.., c]) (\y471. K2[.., c, y471])))
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of (pi1 (C3[.., c])) (K'[.., c])],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv' unboxed;
    solve [g |- cn-equiv/pi1 Dequiv']
  }
  case cn-of/pair:
  { g : conbind-reg,
    K : (g |- kind),
    C3 : (g, c : con |- con),
    C4 : (g, c : con |- con),
    K1 : (g, c : con |- kind),
    K2 : (g, c : con, a13 : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    Dof : (g, c : con, dc : cn-of c (K[..]) |- cn-of (C3[.., c]) (K1[.., c])),
    Dof1 :
      (g, c : con, dc : cn-of c (K[..]) |-
         cn-of (C4[.., c]) (K2[.., c, (C3[.., c])])),
    Dwf :
      (g, c : con, dc : cn-of c (K[..]), a : con, y541 : cn-of a (K1[.., c]) |-
         kd-wf (K2[.., c, a]))
  | x :
      [g, c : con, dc : cn-of c (K[..]) |-
         cn-of
           (pair (C3[.., c]) (C4[.., c]))
           (sigma (K1[.., c]) (\y471. K2[.., c, y471]))],
    equiv : [g |- cn-equiv C1 C2 K]
  ; by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof] equiv
as Dequiv1 unboxed;
    by functionality-cn [g, c : con, dc : cn-of c (K[..]) |- Dof1] equiv
    as Dequiv2 unboxed;
    by [g, a : con, da : cn-of a (K1[.., (C1[..])]) |-
          Dwf[.., (C1[..]), _, a, da]]
    as Dwf' unboxed;
    solve [g |- cn-equiv/pair Dequiv1 Dequiv2 (\a. \da. Dwf')]
  }
  %{ FIXME: Parameter variable matching is supported only if the LF context has exactly 1 binder.
  case head variable:
  { g : conbind-reg, K' : (g |- kind), C1 : (g |- con), C2 : (g |- con)
  | x : [g, c : con, dc : cn-of c (K'[..]) |- cn-of c (K'[..])],
    equiv : [g |- cn-equiv C1 C2 K']
  ; solve equiv
  }
  }%
  case #.2:
  { g : conbind-reg,
    K : (g |- kind),
    K' : (g |- kind),
    #cof : #(g |- block (a : con, da : cn-of a (K'[..]))),
    C1 : (g |- con),
    C2 : (g |- con),
    Dwf179 : (g |- kd-wf K')
  | x : [g, c : con, dc : cn-of c (K[..]) |- cn-of (#cof.1[..]) (K'[..])],
    equiv : [g |- cn-equiv C1 C2 K]
  ; solve [_ |- cn-equiv/refl #cof.2]
  }
}
;

% Similarity

LF similar : con -> con -> type =
| similar/unit : similar unit unit
| similar/void : similar void void
| similar/prod : similar (prod _ _) (prod _ _)
| similar/arrow : similar (arrow _ _) (arrow _ _)
| similar/plus : similar (plus _ _) (plus _ _)
| similar/ref : similar (ref _) (ref _)
| similar/tag : similar (tag _) (tag _)
| similar/tagged : similar tagged tagged
| similar/rec : similar (rec' _ _ _) (rec' _ _ _)
| similar/labeled : similar (labeled _ _) (labeled _ _)
;
--name similar Dsim sim.

% Type Formation Inversion

LF typeish : kind -> type =
| typeish/t : typeish t
| typeish/sing : typeish (sing _)
;
--name typeish Dtypeish typeish.

proof typeish-equiv :
  (g : conbind) [g |- kd-equiv K1 K2] ->
    [g |- typeish K2] ->
      [g |- typeish K1] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-equiv K K1], typeish : [g |- typeish K1]
; split x as
  case kd-equiv/sigma:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a7 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x162 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (sigma K2 (\x98. K4)) (sigma K3 (\x98. K5))],
    typeish : [g |- typeish (sigma K3 (\x98. K5))]
  ; impossible typeish
  }
  case kd-equiv/pi:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a5 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x161 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (pi K2 (\x97. K4)) (pi K3 (\x97. K5))],
    typeish : [g |- typeish (pi K3 (\x97. K5))]
  ; impossible typeish
  }
  case kd-equiv/sing:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)],
    typeish : [g |- typeish (sing C1)]
  ; solve [_ |- typeish/sing ]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv K K3),
    Dequiv1 : (g |- kd-equiv K3 K1)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K1]
  ; by typeish-equiv [_ |- Dequiv1] typeish as typeish1;
    solve typeish-equiv [_ |- Dequiv] typeish1
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K1 K)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K1]
  ; solve typeish-equiv' [_ |- Dequiv] typeish
  }
  case kd-equiv/refl:
  { g : conbind, K1 : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- kd-equiv K1 K1], typeish : [g |- typeish K1]
  ; solve typeish
  }
}

and proof typeish-equiv' :
  (g : conbind) [g |- kd-equiv K1 K2] ->
    [g |- typeish K1] ->
      [g |- typeish K2] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-equiv K K1], typeish : [g |- typeish K]
; split x as
  case kd-equiv/sigma:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a7 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a8 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x162 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (sigma K2 (\x98. K4)) (sigma K3 (\x98. K5))],
    typeish : [g |- typeish (sigma K2 (\x98. K4))]
  ; impossible typeish
  }
  case kd-equiv/pi:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a5 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a6 : con |- kind),
    Dequiv : (g |- kd-equiv K2 K3),
    Dequiv1 :
      (g, a : con, x161 : cn-of a (K2[..]) |-
         kd-equiv (K4[.., a]) (K5[.., a]))
  | x : [g |- kd-equiv (pi K2 (\x97. K4)) (pi K3 (\x97. K5))],
    typeish : [g |- typeish (pi K2 (\x97. K4))]
  ; impossible typeish
  }
  case kd-equiv/sing:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)], typeish : [g |- typeish (sing C)]
  ; solve [_ |- typeish/sing ]
  }
  case kd-equiv/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dequiv : (g |- kd-equiv K K3),
    Dequiv1 : (g |- kd-equiv K3 K1)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K]
  ; by typeish-equiv' [_ |- Dequiv] typeish as typeish1;
    solve typeish-equiv' [_ |- Dequiv1] typeish1
  }
  case kd-equiv/symm:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K1 K)
  | x : [g |- kd-equiv K K1], typeish : [g |- typeish K]
  ; solve typeish-equiv [_ |- Dequiv] typeish
  }
  case kd-equiv/refl:
  { g : conbind, K1 : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- kd-equiv K1 K1], typeish : [g |- typeish K1]
  ; solve typeish
  }
}
;

proof typeish-sub :
  (g : conbind) [g |- kd-sub K1 K2] ->
    [g |- typeish K2] ->
      [g |- typeish K1] =
/ total 1 /
intros
{ g : conbind, K : (g |- kind), K1 : (g |- kind)
| x : [g |- kd-sub K K1], typeish : [g |- typeish K1]
; split x as
  case kd-sub/sigma:
  { g : conbind,
    K2 : (g |- kind),
    K4 : (g, a11 : con |- kind),
    K3 : (g |- kind),
    K5 : (g, a12 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, x419 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, y419 : cn-of a (K3[..]) |- kd-wf (K5[.., a]))
  | x : [g |- kd-sub (sigma K2 (\z350. K4)) (sigma K3 (\z350. K5))],
    typeish : [g |- typeish (sigma K3 (\z350. K5))]
  ; impossible typeish
  }
  case kd-sub/pi:
  { g : conbind,
    K3 : (g |- kind),
    K4 : (g, a9 : con |- kind),
    K2 : (g |- kind),
    K5 : (g, a10 : con |- kind),
    Dsub : (g |- kd-sub K2 K3),
    Dsub1 :
      (g, a : con, z417 : cn-of a (K2[..]) |- kd-sub (K4[.., a]) (K5[.., a])),
    Dwf : (g, a : con, x417 : cn-of a (K3[..]) |- kd-wf (K4[.., a]))
  | x : [g |- kd-sub (pi K3 (\z349. K4)) (pi K2 (\z349. K5))],
    typeish : [g |- typeish (pi K2 (\z349. K5))]
  ; impossible typeish
  }
  case kd-sub/sing-t:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- kd-sub (sing C) t], typeish : [g |- typeish t]
  ; solve [g |- typeish/sing ]
  }
  case kd-sub/trans:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- kd-sub K K3),
    Dsub1 : (g |- kd-sub K3 K1)
  | x : [g |- kd-sub K K1], typeish : [g |- typeish K1]
  ; by typeish-sub [g |- Dsub1] typeish as typeish1;
    solve typeish-sub [g |- Dsub] typeish1
  }
  case kd-sub/refl:
  { g : conbind,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K K1)
  | x : [g |- kd-sub K K1], typeish : [g |- typeish K1]
  ; solve typeish-equiv [g |- Dequiv] typeish
  }
}
;

proof type-inversion :
  (g : conbind) [g |- cn-of T K] ->
    [g |- similar T T] ->
      [g |- kd-sub K t] ->
        [g |- cn-of T t] =
/ total 1 /
intros
{ g : conbind, T : (g |- con), K : (g |- kind)
| x : [g |- cn-of T K], sim : [g |- similar T T], sub : [g |- kd-sub K t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of T K1),
    Dsub : (g |- kd-sub K1 K)
  | x : [g |- cn-of T K], sim : [g |- similar T T], sub : [g |- kd-sub K t]
  ; by sub as Dsub1 unboxed;
    solve type-inversion [_ |- Dof] sim [_ |- kd-sub/trans Dsub Dsub1]
  }
  case cn-of/extsigma:
  { g : conbind,
    T : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a23 : con |- kind),
    Dof : (g |- cn-of (pi1 T) K1),
    Dof1 : (g |- cn-of (pi2 T) (K2[.., pi1 T])),
    Dwf : (g, a : con, y178 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of T (sigma K1 (\x98. K2))],
    sim : [g |- similar T T],
    sub : [g |- kd-sub (sigma K1 (\x98. K2)) t]
  ; impossible typeish-sub sub [_ |- typeish/t]
  }
  case cn-of/extpi:
  { g : conbind,
    T : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a22 : con |- kind),
    K2 : (g, a21 : con |- kind),
    Dof : (g |- cn-of T (pi K1 (\x97. K2))),
    Dof1 :
      (g, a : con, z176 : cn-of a (K1[..]) |-
         cn-of (app (T[..]) a) (K3[.., a]))
  | x : [g |- cn-of T (pi K1 (\x97. K3))],
    sim : [g |- similar T T],
    sub : [g |- kd-sub (pi K1 (\x97. K3)) t]
  ; impossible typeish-sub sub [_ |- typeish/t]
  }
  case cn-of/sing:
  { g : conbind, T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of T (sing T)],
    sim : [g |- similar T T],
    sub : [g |- kd-sub (sing T) t]
  ; solve [_ |- Dof]
  }
  case cn-of/labeled:
  { g : conbind, X : ( |- label), C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of (labeled X[] C) t],
    sim : [g |- similar (labeled X[] C) (labeled X[] C)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/rec:
  { g : conbind,
    K1 : (g |- kind),
    C : (g, a20 : con, a19 : con |- con),
    C1 : (g |- con),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, z174 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y175 : cn-of b (K1[..]) |- cn-of (C[.., a, b]) t),
    Dof1 : (g |- cn-of C1 K1)
  | x : [g |- cn-of (rec' K1 (\x105. \z105. C) C1) t],
    sim :
      [g |-
         similar
           (rec' K1 (\x105. \z105. C) C1) (rec' K1 (\x105. \z105. C) C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/tagged:
  { g : conbind
  | x : [g |- cn-of tagged t],
    sim : [g |- similar tagged tagged],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/tag:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of (tag C) t],
    sim : [g |- similar (tag C) (tag C)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/ref:
  { g : conbind, C : (g |- con), Dof : (g |- cn-of C t)
  | x : [g |- cn-of (ref C) t],
    sim : [g |- similar (ref C) (ref C)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/plus:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C t),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- cn-of (plus C C1) t],
    sim : [g |- similar (plus C C1) (plus C C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/arrow:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C t),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- cn-of (arrow C C1) t],
    sim : [g |- similar (arrow C C1) (arrow C C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/prod:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- cn-of C t),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- cn-of (prod C C1) t],
    sim : [g |- similar (prod C C1) (prod C C1)],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/void:
  { g : conbind
  | x : [g |- cn-of void t],
    sim : [g |- similar void void],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/unit:
  { g : conbind
  | x : [g |- cn-of unit t],
    sim : [g |- similar unit unit],
    sub : [g |- kd-sub t t]
  ; solve x
  }
  case cn-of/star:
  { g : conbind
  | x : [g |- cn-of star one],
    sim : [g |- similar star star],
    sub : [g |- kd-sub one t]
  ; impossible sim
  }
  case cn-of/app:
  { g : conbind,
    C1 : (g |- con),
    C : (g |- con),
    K2 : (g, a18 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C K1),
    Dof1 : (g |- cn-of C1 (pi K1 (\x97. K2)))
  | x : [g |- cn-of (app C1 C) (K2[.., C])],
    sim : [g |- similar (app C1 C) (app C1 C)],
    sub : [g |- kd-sub (K2[.., C]) t]
  ; impossible sim
  }
  case cn-of/lam:
  { g : conbind,
    K1 : (g |- kind),
    C : (g, a16 : con |- con),
    K2 : (g, a17 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, y170 : cn-of a (K1[..]) |- cn-of (C[.., a]) (K2[.., a]))
  | x : [g |- cn-of (lam K1 (\z100. C)) (pi K1 (\x97. K2))],
    sim : [g |- similar (lam K1 (\z100. C)) (lam K1 (\z100. C))],
    sub : [g |- kd-sub (pi K1 (\x97. K2)) t]
  ; impossible sim
  }
  case cn-of/pi2:
  { g : conbind,
    C : (g |- con),
    K2 : (g, a15 : con |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C (sigma K1 (\x98. K2)))
  | x : [g |- cn-of (pi2 C) (K2[.., pi1 C])],
    sim : [g |- similar (pi2 C) (pi2 C)],
    sub : [g |- kd-sub (K2[.., pi1 C]) t]
  ; impossible sim
  }
  case cn-of/pi1:
  { g : conbind,
    C : (g |- con),
    K : (g |- kind),
    K2 : (g, a14 : con |- kind),
    Dof : (g |- cn-of C (sigma K (\x98. K2)))
  | x : [g |- cn-of (pi1 C) K],
    sim : [g |- similar (pi1 C) (pi1 C)],
    sub : [g |- kd-sub K t]
  ; impossible sim
  }
  case cn-of/pair:
  { g : conbind,
    C : (g |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a13 : con |- kind),
    Dof : (g |- cn-of C K1),
    Dof1 : (g |- cn-of C1 (K2[.., C])),
    Dwf : (g, a : con, x168 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of (pair C C1) (sigma K1 (\x98. K2))],
    sim : [g |- similar (pair C C1) (pair C C1)],
    sub : [g |- kd-sub (sigma K1 (\x98. K2)) t]
  ; impossible sim
  }
  case #.2:
  { g : conbind,
    K : (g |- kind),
    #cof : #(g |- block (a : con, d : cn-of a (K[..])))
  | x : [g |- cn-of #cof.1 K],
    sim : [g |- similar #cof.1 #cof.1],
    sub : [g |- kd-sub K t]
  ; impossible sim
  }
}
;

LF inversion-prod/e : con -> con -> type =
| inversion-prod/i :
  cn-of T1 t -> cn-of T2 t -> inversion-prod/e T1 T2
;

proof inversion-prod :
  (g : conbind)
  [g |- cn-of (prod T1 T2) t] ->
    [g |- inversion-prod/e T1 T2] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| cof : [g |- cn-of (prod T T1) t]
; split cof as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (prod T T1) K),
    Dsub : (g |- kd-sub K t)
  | cof : [g |- cn-of (prod T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/prod ] [_ |- Dsub]
    as Dof' unboxed;
    solve inversion-prod [_ |- Dof']
  }
  case cn-of/prod:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | cof : [g |- cn-of (prod T T1) t]
  ; solve [_ |- inversion-prod/i Dof Dof1]
  }
}
;

LF inversion-arrow/e : con -> con -> type =
| inversion-arrow/i :
  cn-of T1 t -> cn-of T2 t -> inversion-arrow/e T1 T2
;

proof inversion-arrow :
  (g : conbind)
  [g |- cn-of (arrow T1 T2) t] ->
    [g |- inversion-arrow/e T1 T2] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| cof : [g |- cn-of (arrow T T1) t]
; split cof as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (arrow T T1) K),
    Dsub : (g |- kd-sub K t)
  | cof : [g |- cn-of (arrow T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/arrow ] [_ |- Dsub]
    as Dof' unboxed;
    solve inversion-arrow [_ |- Dof']
  }
  case cn-of/arrow:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | cof : [g |- cn-of (arrow T T1) t]
  ; solve [_ |- inversion-arrow/i Dof Dof1]
  }
}
;

LF inversion-plus/e : con -> con -> type =
| inversion-plus/i :
  cn-of T1 t -> cn-of T2 t -> inversion-plus/e T1 T2
;

proof inversion-plus :
  (g : conbind)
  [g |- cn-of (plus T1 T2) t] ->
    [g |- inversion-plus/e T1 T2] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, T : (g |- con), T1 : (g |- con)
| cof : [g |- cn-of (plus T T1) t]
; split cof as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (plus T T1) K),
    Dsub : (g |- kd-sub K t)
  | cof : [g |- cn-of (plus T T1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/plus ] [_ |- Dsub]
    as Dof' unboxed;
    solve inversion-plus [_ |- Dof']
  }
  case cn-of/plus:
  { g : conbind,
    T : (g |- con),
    T1 : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- cn-of T1 t)
  | cof : [g |- cn-of (plus T T1) t]
  ; solve [_ |- inversion-plus/i Dof Dof1]
  }
}
;

proof inversion-ref :
  (g : conbind)
  [g |- cn-of (ref T) t] ->
    [g |- cn-of T t] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, T : (g |- con)
| x : [g |- cn-of (ref T) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (ref T) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (ref T) t]
  ; by type-inversion [g |- Dof] [g |- similar/ref ] [g |- Dsub]
    as Dof' unboxed;
    solve inversion-ref [g |- Dof']
  }
  case cn-of/ref:
  { g : conbind, T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of (ref T) t]
  ; solve [_ |- Dof]
  }
}
;

proof inversion-tag :
  (g : conbind)
  [g |- cn-of (tag T) t] ->
    [g |- cn-of T t] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, T : (g |- con)
| x : [g |- cn-of (tag T) t]
; split x as
  case cn-of/subsume:
  { g : conbind,
    T : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (tag T) K),
    Dsub : (g |- kd-sub K t)
  | x : [g |- cn-of (tag T) t]
  ; by type-inversion [g |- Dof] [g |- similar/tag ] [g |- Dsub]
    as Dof' unboxed;
    solve inversion-tag [g |- Dof']
  }
  case cn-of/tag:
  { g : conbind, T : (g |- con), Dof : (g |- cn-of T t)
  | x : [g |- cn-of (tag T) t]
  ; solve [_ |- Dof]
  }
}
;

LF inversion-rec/e : kind -> (con -> con -> con) -> con -> type =
| inversion-rec/i :
  kd-wf K ->
  ({ a : con } cn-of a (pi K (\l. t)) ->
   { b : con } cn-of b K ->
   cn-of (C1 a b) t) ->
  cn-of C2 K ->
    inversion-rec/e K C1 C2
;

proof inversion-rec :
  (g : conbind)
  [g |- cn-of (rec' K (\x. \y. C1) C2) t] ->
    [g |- inversion-rec/e K (\x. \y. C1) C2] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind,
  K : (g |- kind),
  C : (g, y347 : con, x347 : con |- con),
  C1 : (g |- con)
| cof : [g |- cn-of (rec' K (\x. \y. C) C1) t]
; split cof as
  case cn-of/subsume:
  { g : conbind,
    K : (g |- kind),
    C : (g, y347 : con, x347 : con |- con),
    C1 : (g |- con),
    K1 : (g |- kind),
    Dof : (g |- cn-of (rec' K (\x. \y. C) C1) K1),
    Dsub : (g |- kd-sub K1 t)
  | cof : [g |- cn-of (rec' K (\x. \y. C) C1) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/rec ] [_ |- Dsub]
    as Dof' unboxed;
    solve inversion-rec [_ |- Dof']
  }
  case cn-of/rec:
  { g : conbind,
    K : (g |- kind),
    C : (g, y347 : con, x347 : con |- con),
    C1 : (g |- con),
    Dwf : (g |- kd-wf K),
    Dof :
      (g, a : con, x416 : cn-of a (pi (K[..]) (\l. t)), b : con,
       z416 : cn-of b (K[..]) |- cn-of (C[.., a, b]) t),
    Dof1 : (g |- cn-of C1 K)
  | cof : [g |- cn-of (rec' K (\x. \y. C) C1) t]
  ; solve [_ |- inversion-rec/i Dwf (\a. \da. \b. \db. Dof) Dof1]
  }
}
;

proof inversion-labeled :
  (g : conbind)
  [g |- cn-of (labeled I[] T) t] ->
    [g |- cn-of T t] =
/ trust / % FIXME: See issue #4
intros
{ g : conbind, I : ( |- label), T : (g |- con)
| cof : [g |- cn-of (labeled I[] T) t]
; split cof as
  case cn-of/subsume:
  { g : conbind,
    I : ( |- label),
    T : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of (labeled I[] T) K),
    Dsub : (g |- kd-sub K t)
  | cof : [g |- cn-of (labeled I[] T) t]
  ; by type-inversion [_ |- Dof] [_ |- similar/labeled ] [_ |- Dsub]
    as Dof' unboxed;
    solve inversion-labeled [_ |- Dof']
  }
  case cn-of/labeled:
  { g : conbind, I : ( |- label), T : (g |- con), Dof : (g |- cn-of T t)
  | cof : [g |- cn-of (labeled I[] T) t]
  ; solve [_ |- Dof]
  }
}
;

% Signature Fst Regularity

LF can-sg-fst/e : sg -> type =
| can-sg-fst/i : { K : kind } sg-fst S K -> can-sg-fst/e S
;

proof can-sg-fst :
  (g : conblock)
  { S : [g |- sg] }
  [g |- can-sg-fst/e S] =
/ total 1 /
intros
{ g : conblock, S : (g |- sg)
|
; split [_ |- S] as
  case sg/named:
  { g : conblock, L : ( |- name), S1 : (g |- sg)
  |
  ; split can-sg-fst [_ |- S1] as
    case can-sg-fst/i:
    { g : conblock,
      L : ( |- name),
      S1 : (g |- sg),
      K : (g |- kind),
      Dfst : (g |- sg-fst S1 K)
    |
    ; solve [_ |- can-sg-fst/i K (sg-fst/named Dfst)]
    }
  }
  case sg/sigma:
  { g : conblock, S1 : (g |- sg), S2 : (g, z354 : con |- sg)
  |
  ; split can-sg-fst [_ |- S1] as
    case can-sg-fst/i:
    { g : conblock,
      S1 : (g |- sg),
      S2 : (g, z354 : con |- sg),
      K : (g |- kind),
      Dfst : (g |- sg-fst S1 K)
    |
    ; split can-sg-fst [_, a : con |- S2] as
      case can-sg-fst/i:
      { g : conblock,
        S1 : (g |- sg),
        S2 : (g, z354 : con |- sg),
        K : (g |- kind),
        Dfst : (g |- sg-fst S1 K),
        K1 : (g, a : con |- kind),
        Dfst1 : (g, a : con |- sg-fst S2 K1)
      |
      ; solve [_ |- can-sg-fst/i _ (sg-fst/sigma Dfst (\a. Dfst1))]
      }
    }
  }
  case sg/pi:
  { g : conblock, S1 : (g |- sg), S2 : (g, z353 : con |- sg)
  |
  ; solve [_ |- can-sg-fst/i _ (sg-fst/pi )]
  }
  case sg/sgatom:
  { g : conblock, S1 : (g |- sg)
  |
  ; solve [_ |- can-sg-fst/i _ (sg-fst/sgatom )]
  }
  case sg/datom:
  { g : conblock, C : (g |- con)
  |
  ; solve [_ |- can-sg-fst/i _ (sg-fst/datom )]
  }
  case sg/satom:
  { g : conblock, K : (g |- kind)
  |
  ; solve [_ |- can-sg-fst/i _ (sg-fst/satom )]
  }
  case sg/one:
  { g : conblock
  |
  ; solve [_ |- can-sg-fst/i _ sg-fst/one]
  }
}
;

proof sg-fst-fun :
  (g : conblock)
  [g |- sg-fst S K] ->
  [g |- sg-fst S K'] ->
    [g |- kind-eq K K'] =
/ total 1 /
intros
{ g : conblock, S : (g |- sg), K : (g |- kind), K' : (g |- kind)
| x : [g |- sg-fst S K], fst : [g |- sg-fst S K']
; split x as
  case sg-fst/named:
  { g : conblock,
    L : ( |- name),
    S1 : (g |- sg),
    K : (g |- kind),
    K' : (g |- kind),
    Dfst : (g |- sg-fst S1 K)
  | x : [g |- sg-fst (sg/named L[] S1) K],
    fst : [g |- sg-fst (sg/named L[] S1) K']
  ; split fst as
    case sg-fst/named:
    { g : conblock,
      L : ( |- name),
      S1 : (g |- sg),
      K : (g |- kind),
      K' : (g |- kind),
      Dfst : (g |- sg-fst S1 K),
      Dfst1 : (g |- sg-fst S1 K')
    | x : [g |- sg-fst (sg/named L[] S1) K],
      fst : [g |- sg-fst (sg/named L[] S1) K']
    ; by sg-fst-fun [_ |- Dfst] [_ |- Dfst1] as Deq unboxed;
      solve [_ |- Deq]
    }
  }
  case sg-fst/sigma:
  { g : conblock,
    S1 : (g |- sg),
    S2 : (g, a58 : con |- sg),
    K1 : (g |- kind),
    K2 : (g, a59 : con |- kind),
    K' : (g |- kind),
    Dfst : (g |- sg-fst S1 K1),
    Dfst1 : (g, a : con |- sg-fst S2 K2)
  | x : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K1 (\y340. K2))],
    fst : [g |- sg-fst (sg/sigma S1 (\z354. S2)) K']
  ; split fst as
    case sg-fst/sigma:
    { g : conblock,
      S1 : (g |- sg),
      S2 : (g, a58 : con |- sg),
      K1 : (g |- kind),
      K2 : (g, a59 : con |- kind),
      K3 : (g |- kind),
      K4 : (g, a59 : con |- kind),
      Dfst : (g |- sg-fst S1 K1),
      Dfst1 : (g, a : con |- sg-fst S2 K2),
      Dfst2 : (g |- sg-fst S1 K3),
      Dfst3 : (g, a : con |- sg-fst S2 K4)
    | x : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K1 (\y340. K2))],
      fst : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K3 (\y340. K4))]
    ; by sg-fst-fun [_ |- Dfst] [_ |- Dfst2] as Deq1 unboxed;
      by sg-fst-fun [_, a : con |- Dfst1] [_, a : con |- Dfst3]
      as Deq2 unboxed;
      split [_ |- Deq1] as
      case kind-eq/i:
      { g : conblock,
        S1 : (g |- sg),
        S2 : (g, a58 : con |- sg),
        K3 : (g |- kind),
        K2 : (g, a59 : con |- kind),
        K4 : (g, a59 : con |- kind),
        Dfst : (g |- sg-fst S1 K3),
        Dfst1 : (g, a : con |- sg-fst S2 K2),
        Dfst2 : (g |- sg-fst S1 K3),
        Dfst3 : (g, a : con |- sg-fst S2 K4),
        Deq2 : (g, a : con |- kind-eq K2 K4)
      | x : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K3 (\y340. K2))],
        fst : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K3 (\y340. K4))]
      ; split [_, a : con |- Deq2] as
        case kind-eq/i:
        { g : conblock,
          S1 : (g |- sg),
          S2 : (g, a58 : con |- sg),
          K3 : (g |- kind),
          K4 : (g, a59 : con |- kind),
          Dfst : (g |- sg-fst S1 K3),
          Dfst1 : (g, a : con |- sg-fst S2 K4),
          Dfst2 : (g |- sg-fst S1 K3),
          Dfst3 : (g, a : con |- sg-fst S2 K4)
        | x : [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K3 (\y340. K4))],
          fst :
            [g |- sg-fst (sg/sigma S1 (\z354. S2)) (sigma K3 (\y340. K4))]
        ; solve [_ |- kind-eq/i ]
        }
      }
    }
  }
  case sg-fst/pi:
  { g : conblock, S1 : (g |- sg), S2 : (g, a57 : con |- sg), K' : (g |- kind)
  | x : [g |- sg-fst (sg/pi S1 (\z353. S2)) one],
    fst : [g |- sg-fst (sg/pi S1 (\z353. S2)) K']
  ; split fst as
    case sg-fst/pi:
    { g : conblock, S1 : (g |- sg), S2 : (g, a57 : con |- sg)
    | x : [g |- sg-fst (sg/pi S1 (\z353. S2)) one],
      fst : [g |- sg-fst (sg/pi S1 (\z353. S2)) one]
    ; solve [_ |- kind-eq/i ]
    }
  }
  case sg-fst/sgatom:
  { g : conblock, S1 : (g |- sg), K' : (g |- kind)
  | x : [g |- sg-fst (sg/sgatom S1) one],
    fst : [g |- sg-fst (sg/sgatom S1) K']
  ; split fst as
    case sg-fst/sgatom:
    { g : conblock, S1 : (g |- sg)
    | x : [g |- sg-fst (sg/sgatom S1) one],
      fst : [g |- sg-fst (sg/sgatom S1) one]
    ; solve [_ |- kind-eq/i ]
    }
  }
  case sg-fst/datom:
  { g : conblock, C : (g |- con), K' : (g |- kind)
  | x : [g |- sg-fst (sg/datom C) one], fst : [g |- sg-fst (sg/datom C) K']
  ; split fst as
    case sg-fst/datom:
    { g : conblock, C : (g |- con)
    | x : [g |- sg-fst (sg/datom C) one],
      fst : [g |- sg-fst (sg/datom C) one]
    ; solve [_ |- kind-eq/i ]
    }
  }
  case sg-fst/satom:
  { g : conblock, K : (g |- kind), K' : (g |- kind)
  | x : [g |- sg-fst (sg/satom K) K], fst : [g |- sg-fst (sg/satom K) K']
  ; split fst as
    case sg-fst/satom:
    { g : conblock, K' : (g |- kind)
    | x : [g |- sg-fst (sg/satom K') K'],
      fst : [g |- sg-fst (sg/satom K') K']
    ; solve [_ |- kind-eq/i ]
    }
  }
  case sg-fst/one:
  { g : conblock, K' : (g |- kind)
  | x : [g |- sg-fst sg/one one], fst : [g |- sg-fst sg/one K']
  ; split fst as
    case sg-fst/one:
    { g : conblock
    | x : [g |- sg-fst sg/one one], fst : [g |- sg-fst sg/one one]
    ; solve [_ |- kind-eq/i ]
    }
  }
}
;

schema conbind+conbind-reg =
  % conbind
  some [K : kind]
  block (a : con, d : cn-of a K) +
  % conbind-reg
  some [K : kind, wf : kd-wf K]
  block (a : con, da : cn-of a K);

proof sg-fst-reg :
  (g : conbind+conbind-reg)
  [g |- sg-wf S] ->
  [g |- sg-fst S K] ->
    [g |- kd-wf K] =
/ total 1 /
intros
{ g : conbind+conbind-reg, S : (g |- sg), K : (g |- kind)
| x : [g |- sg-wf S], fst : [g |- sg-fst S K]
; split x as
  case sg-wf/named:
  { g : conbind+conbind-reg,
    L : ( |- name),
    S1 : (g |- sg),
    K : (g |- kind),
    Dwf : (g |- sg-wf S1)
  | x : [g |- sg-wf (sg/named L[] S1)],
    fst : [g |- sg-fst (sg/named L[] S1) K]
  ; split fst as
    case sg-fst/named:
    { g : conbind+conbind-reg,
      L : ( |- name),
      S1 : (g |- sg),
      K : (g |- kind),
      Dwf : (g |- sg-wf S1),
      Dfst : (g |- sg-fst S1 K)
    | x : [g |- sg-wf (sg/named L[] S1)],
      fst : [g |- sg-fst (sg/named L[] S1) K]
    ; solve sg-fst-reg [_ |- Dwf] [_ |- Dfst]
    }
  }
  case sg-wf/sigma:
  { g : conbind+conbind-reg,
    S1 : (g |- sg),
    S2 : (g, a48 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dwf : (g |- sg-wf S1),
    Dfst : (g |- sg-fst S1 K1),
    Dwf1 : (g, a : con, y479 : cn-of a (K1[..]) |- sg-wf (S2[.., a]))
  | x : [g |- sg-wf (sg/sigma S1 (\x365. S2))],
    fst : [g |- sg-fst (sg/sigma S1 (\x365. S2)) K]
  ; split fst as
    case sg-fst/sigma:
    { g : conbind+conbind-reg,
      S1 : (g |- sg),
      S2 : (g, a48 : con |- sg),
      K2 : (g |- kind),
      K3 : (g, a59 : con |- kind),
      K1 : (g |- kind),
      Dwf : (g |- sg-wf S1),
      Dfst : (g |- sg-fst S1 K1),
      Dwf1 : (g, a : con, y479 : cn-of a (K1[..]) |- sg-wf (S2[.., a])),
      Dfst1 : (g |- sg-fst S1 K2),
      Dfst2 : (g, a : con |- sg-fst S2 K3)
    | x : [g |- sg-wf (sg/sigma S1 (\x365. S2))],
      fst : [g |- sg-fst (sg/sigma S1 (\x365. S2)) (sigma K2 (\z350. K3))]
    ; by sg-fst-reg [g |- Dwf] [g |- Dfst] as DwfK1 unboxed;
      by sg-fst-reg
           [g, b : block (a : con, da : cn-of a (K1[..])) |-
              Dwf1[.., b.1, b.2]]
           [g, b : block (a : con, da : cn-of a (K1[..])) |- Dfst2[.., b.1]]
      as DwfK2 unboxed;
      by sg-fst-fun [g |- Dfst] [g |- Dfst1] as DeqK1 unboxed;
      by kind-resp-kind [g, k : kind |- sigma k (\a. K3[.., a])] [g |- DeqK1]
as Deq unboxed;
      by [g |- kd-wf/sigma DwfK1 (\a. \da. DwfK2[.., <a; da>])] as Dwf' unboxed;
      solve kd-wf-resp [g |- Deq] [g |- Dwf']
    }
  }
  case sg-wf/pi:
  { g : conbind+conbind-reg,
    S1 : (g |- sg),
    S2 : (g, a47 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dwf : (g |- sg-wf S1),
    Dfst : (g |- sg-fst S1 K1),
    Dwf1 : (g, a : con, z477 : cn-of a (K1[..]) |- sg-wf (S2[.., a]))
  | x : [g |- sg-wf (sg/pi S1 (\x364. S2))],
    fst : [g |- sg-fst (sg/pi S1 (\x364. S2)) K]
  ; split fst as
    case sg-fst/pi:
    { g : conbind+conbind-reg,
      S1 : (g |- sg),
      S2 : (g, a47 : con |- sg),
      K1 : (g |- kind),
      Dwf : (g |- sg-wf S1),
      Dfst : (g |- sg-fst S1 K1),
      Dwf1 : (g, a : con, z477 : cn-of a (K1[..]) |- sg-wf (S2[.., a]))
    | x : [g |- sg-wf (sg/pi S1 (\x364. S2))],
      fst : [g |- sg-fst (sg/pi S1 (\x364. S2)) one]
    ; solve [g |- kd-wf/one]
    }
  }
  case sg-wf/sgatom:
  { g : conbind+conbind-reg, S1 : (g |- sg), K : (g |- kind), Dwf : (g |- sg-wf S1)
  | x : [g |- sg-wf (sg/sgatom S1)], fst : [g |- sg-fst (sg/sgatom S1) K]
  ; split fst as
    case sg-fst/sgatom:
    { g : conbind+conbind-reg, S1 : (g |- sg), Dwf : (g |- sg-wf S1)
    | x : [g |- sg-wf (sg/sgatom S1)], fst : [g |- sg-fst (sg/sgatom S1) one]
    ; solve [g |- kd-wf/one]
    }
  }
  case sg-wf/datom:
  { g : conbind+conbind-reg, C : (g |- con), K : (g |- kind), Dof : (g |- cn-of C t)
  | x : [g |- sg-wf (sg/datom C)], fst : [g |- sg-fst (sg/datom C) K]
  ; split fst as
    case sg-fst/datom:
    { g : conbind+conbind-reg, C : (g |- con), Dof : (g |- cn-of C t)
    | x : [g |- sg-wf (sg/datom C)], fst : [g |- sg-fst (sg/datom C) one]
    ; solve [g |- kd-wf/one]
    }
  }
  case sg-wf/satom:
  { g : conbind+conbind-reg, K1 : (g |- kind), K : (g |- kind), Dwf : (g |- kd-wf K1)
  | x : [g |- sg-wf (sg/satom K1)], fst : [g |- sg-fst (sg/satom K1) K]
  ; split fst as
    case sg-fst/satom:
    { g : conbind+conbind-reg, K : (g |- kind), Dwf : (g |- kd-wf K)
    | x : [g |- sg-wf (sg/satom K)], fst : [g |- sg-fst (sg/satom K) K]
    ; solve [g |- Dwf]
    }
  }
  case sg-wf/one:
  { g : conbind+conbind-reg, K : (g |- kind)
  | x : [g |- sg-wf sg/one], fst : [g |- sg-fst sg/one K]
  ; split fst as
    case sg-fst/one:
    { g : conbind+conbind-reg
    | x : [g |- sg-wf sg/one], fst : [g |- sg-fst sg/one one]
    ; solve [g |- kd-wf/one]
    }
  }
}
;

proof sg-equiv-fst :
  (g : conbind+conbind-reg)
  [g |- sg-equiv S1 S2] ->
  [g |- sg-fst S1 K1] ->
  [g |- sg-fst S2 K2] ->
    [g |- kd-equiv K1 K2] =
/ total 1 /
intros
{ g : conbind+conbind-reg,
  S : (g |- sg),
  S1 : (g |- sg),
  K : (g |- kind),
  K1 : (g |- kind)
| x : [g |- sg-equiv S S1],
  fst : [g |- sg-fst S K],
  fst1 : [g |- sg-fst S1 K1]
; split x as
  case sg-equiv/named:
  { g : conbind+conbind-reg,
    L : ( |- name),
    S2 : (g |- sg),
    S3 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3)
  | x : [g |- sg-equiv (sg/named L[] S2) (sg/named L[] S3)],
    fst : [g |- sg-fst (sg/named L[] S2) K],
    fst1 : [g |- sg-fst (sg/named L[] S3) K1]
  ; split fst as
    case sg-fst/named:
    { g : conbind+conbind-reg,
      L : ( |- name),
      S2 : (g |- sg),
      S3 : (g |- sg),
      K : (g |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- sg-equiv S2 S3),
      Dfst : (g |- sg-fst S2 K)
    | x : [g |- sg-equiv (sg/named L[] S2) (sg/named L[] S3)],
      fst : [g |- sg-fst (sg/named L[] S2) K],
      fst1 : [g |- sg-fst (sg/named L[] S3) K1]
    ; split fst1 as
      case sg-fst/named:
      { g : conbind+conbind-reg,
        L : ( |- name),
        S2 : (g |- sg),
        S3 : (g |- sg),
        K : (g |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- sg-equiv S2 S3),
        Dfst : (g |- sg-fst S2 K),
        Dfst1 : (g |- sg-fst S3 K1)
      | x : [g |- sg-equiv (sg/named L[] S2) (sg/named L[] S3)],
        fst : [g |- sg-fst (sg/named L[] S2) K],
        fst1 : [g |- sg-fst (sg/named L[] S3) K1]
      ; solve sg-equiv-fst [_ |- Dequiv] [_ |- Dfst] [_ |- Dfst1]
      }
    }
  }
  case sg-equiv/sigma:
  { g : conbind+conbind-reg,
    S2 : (g |- sg),
    S4 : (g, a51 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a52 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3),
    Dfst : (g |- sg-fst S2 K2),
    Dequiv1 :
      (g, a : con, x484 : cn-of a (K2[..]) |-
         sg-equiv (S4[.., a]) (S5[.., a]))
  | x : [g |- sg-equiv (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
    fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) K],
    fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) K1]
  ; split fst as
    case sg-fst/sigma:
    { g : conbind+conbind-reg,
      S2 : (g |- sg),
      S4 : (g, a51 : con |- sg),
      S3 : (g |- sg),
      S5 : (g, a52 : con |- sg),
      K3 : (g |- kind),
      K4 : (g, a59 : con |- kind),
      K1 : (g |- kind),
      K2 : (g |- kind),
      Dequiv1 : (g |- sg-equiv S2 S3),
      Dfst1a : (g |- sg-fst S2 K2),
      Dequiv2 :
        (g, a : con, x484 : cn-of a (K2[..]) |-
           sg-equiv (S4[.., a]) (S5[.., a])),
      Dfst : (g |- sg-fst S2 K3),
      Dfst1 : (g, a : con |- sg-fst S4 K4)
    | x : [g |- sg-equiv (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
      fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) (sigma K3 (\z350. K4))],
      fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) K1]
    ; split fst1 as
      case sg-fst/sigma:
      { g : conbind+conbind-reg,
        S2 : (g |- sg),
        S4 : (g, a51 : con |- sg),
        S3 : (g |- sg),
        S5 : (g, a52 : con |- sg),
        K3 : (g |- kind),
        K4 : (g, a59 : con |- kind),
        K5 : (g |- kind),
        K6 : (g, a59 : con |- kind),
        K2 : (g |- kind),
        Dequiv1 : (g |- sg-equiv S2 S3),
        Dfst1a : (g |- sg-fst S2 K2),
        Dequiv2 :
          (g, a : con, x484 : cn-of a (K2[..]) |-
             sg-equiv (S4[.., a]) (S5[.., a])),
        Dfst1a' : (g |- sg-fst S2 K3),
        Dfst2a : (g, a : con |- sg-fst S4 K4),
        Dfst : (g |- sg-fst S3 K5),
        Dfst1 : (g, a : con |- sg-fst S5 K6)
      | x :
          [g |- sg-equiv (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
        fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) (sigma K3 (\z350. K4))],
        fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) (sigma K5 (\z350. K6))]
      ; by sg-equiv-fst [g |- Dequiv1] [g |- Dfst1a] [g |- Dfst]
        as Dequiv1' unboxed;
        by sg-equiv-fst
             [g, b : block (a : con, da : cn-of a (K2[..])) |-
                Dequiv2[.., b.1, b.2]]
             [g, b : block (a : con, da : cn-of a (K2[..])) |-
                Dfst2a[.., b.1]]
             [g, b : block (a : con, da : cn-of a (K2[..])) |- Dfst1[.., b.1]]
        as Dequiv2' unboxed;
        by [g |- kd-equiv/sigma Dequiv1' (\a. \da. Dequiv2'[.., <a; da>])]
        as Dequiv' unboxed;
        by sg-fst-fun [g |- Dfst1a] [g |- Dfst1a'] as Deq1a unboxed;
        by kind-resp-kind [g, k : kind |- sigma k (\a. K4[.., a])] [g |- Deq1a]
as Deqa unboxed;
        solve kd-equiv-resp [g |- Deqa] [g |- kind-eq/i ] [g |- Dequiv']
      }
    }
  }
  case sg-equiv/pi:
  { g : conbind+conbind-reg,
    S2 : (g |- sg),
    S4 : (g, a49 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a50 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3),
    Dfst : (g |- sg-fst S2 K2),
    Dequiv1 :
      (g, a : con, y483 : cn-of a (K2[..]) |-
         sg-equiv (S4[.., a]) (S5[.., a]))
  | x : [g |- sg-equiv (sg/pi S2 (\x364. S4)) (sg/pi S3 (\x364. S5))],
    fst : [g |- sg-fst (sg/pi S2 (\x364. S4)) K],
    fst1 : [g |- sg-fst (sg/pi S3 (\x364. S5)) K1]
  ; split fst as
    case sg-fst/pi:
    { g : conbind+conbind-reg,
      S2 : (g |- sg),
      S4 : (g, a49 : con |- sg),
      S3 : (g |- sg),
      S5 : (g, a50 : con |- sg),
      K1 : (g |- kind),
      K2 : (g |- kind),
      Dequiv : (g |- sg-equiv S2 S3),
      Dfst : (g |- sg-fst S2 K2),
      Dequiv1 :
        (g, a : con, y483 : cn-of a (K2[..]) |-
           sg-equiv (S4[.., a]) (S5[.., a]))
    | x : [g |- sg-equiv (sg/pi S2 (\x364. S4)) (sg/pi S3 (\x364. S5))],
      fst : [g |- sg-fst (sg/pi S2 (\x364. S4)) one],
      fst1 : [g |- sg-fst (sg/pi S3 (\x364. S5)) K1]
    ; split fst1 as
      case sg-fst/pi:
      { g : conbind+conbind-reg,
        S2 : (g |- sg),
        S4 : (g, a49 : con |- sg),
        S3 : (g |- sg),
        S5 : (g, a50 : con |- sg),
        K2 : (g |- kind),
        Dequiv : (g |- sg-equiv S2 S3),
        Dfst : (g |- sg-fst S2 K2),
        Dequiv1 :
          (g, a : con, y483 : cn-of a (K2[..]) |-
             sg-equiv (S4[.., a]) (S5[.., a]))
      | x : [g |- sg-equiv (sg/pi S2 (\x364. S4)) (sg/pi S3 (\x364. S5))],
        fst : [g |- sg-fst (sg/pi S2 (\x364. S4)) one],
        fst1 : [g |- sg-fst (sg/pi S3 (\x364. S5)) one]
      ; solve [g |- kd-equiv/refl kd-wf/one]
      }
    }
  }
  case sg-equiv/sgatom:
  { g : conbind+conbind-reg,
    S2 : (g |- sg),
    S3 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3)
  | x : [g |- sg-equiv (sg/sgatom S2) (sg/sgatom S3)],
    fst : [g |- sg-fst (sg/sgatom S2) K],
    fst1 : [g |- sg-fst (sg/sgatom S3) K1]
  ; split fst as
    case sg-fst/sgatom:
    { g : conbind+conbind-reg,
      S2 : (g |- sg),
      S3 : (g |- sg),
      K1 : (g |- kind),
      Dequiv : (g |- sg-equiv S2 S3)
    | x : [g |- sg-equiv (sg/sgatom S2) (sg/sgatom S3)],
      fst : [g |- sg-fst (sg/sgatom S2) one],
      fst1 : [g |- sg-fst (sg/sgatom S3) K1]
    ; split fst1 as
      case sg-fst/sgatom:
      { g : conbind+conbind-reg,
        S2 : (g |- sg),
        S3 : (g |- sg),
        Dequiv : (g |- sg-equiv S2 S3)
      | x : [g |- sg-equiv (sg/sgatom S2) (sg/sgatom S3)],
        fst : [g |- sg-fst (sg/sgatom S2) one],
        fst1 : [g |- sg-fst (sg/sgatom S3) one]
      ; solve [g |- kd-equiv/refl kd-wf/one]
      }
    }
  }
  case sg-equiv/datom:
  { g : conbind+conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- sg-equiv (sg/datom C) (sg/datom C1)],
    fst : [g |- sg-fst (sg/datom C) K],
    fst1 : [g |- sg-fst (sg/datom C1) K1]
  ; split fst as
    case sg-fst/datom:
    { g : conbind+conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      K1 : (g |- kind),
      Dequiv : (g |- cn-equiv C C1 t)
    | x : [g |- sg-equiv (sg/datom C) (sg/datom C1)],
      fst : [g |- sg-fst (sg/datom C) one],
      fst1 : [g |- sg-fst (sg/datom C1) K1]
    ; split fst1 as
      case sg-fst/datom:
      { g : conbind+conbind-reg,
        C : (g |- con),
        C1 : (g |- con),
        Dequiv : (g |- cn-equiv C C1 t)
      | x : [g |- sg-equiv (sg/datom C) (sg/datom C1)],
        fst : [g |- sg-fst (sg/datom C) one],
        fst1 : [g |- sg-fst (sg/datom C1) one]
      ; solve [g |- kd-equiv/refl kd-wf/one]
      }
    }
  }
  case sg-equiv/satom:
  { g : conbind+conbind-reg,
    K2 : (g |- kind),
    K3 : (g |- kind),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K2 K3)
  | x : [g |- sg-equiv (sg/satom K2) (sg/satom K3)],
    fst : [g |- sg-fst (sg/satom K2) K],
    fst1 : [g |- sg-fst (sg/satom K3) K1]
  ; split fst as
    case sg-fst/satom:
    { g : conbind+conbind-reg,
      K : (g |- kind),
      K3 : (g |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- kd-equiv K K3)
    | x : [g |- sg-equiv (sg/satom K) (sg/satom K3)],
      fst : [g |- sg-fst (sg/satom K) K],
      fst1 : [g |- sg-fst (sg/satom K3) K1]
    ; split fst1 as
      case sg-fst/satom:
      { g : conbind+conbind-reg,
        K : (g |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- kd-equiv K K1)
      | x : [g |- sg-equiv (sg/satom K) (sg/satom K1)],
        fst : [g |- sg-fst (sg/satom K) K],
        fst1 : [g |- sg-fst (sg/satom K1) K1]
      ; solve [g |- Dequiv]
      }
    }
  }
  case sg-equiv/trans:
  { g : conbind+conbind-reg,
    S : (g |- sg),
    S1 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    S3 : (g |- sg),
    Dequiv : (g |- sg-equiv S S3),
    Dequiv1 : (g |- sg-equiv S3 S1)
  | x : [g |- sg-equiv S S1],
    fst : [g |- sg-fst S K],
    fst1 : [g |- sg-fst S1 K1]
  ; split can-sg-fst [g |- S3] as
    case can-sg-fst/i:
    { g : conbind+conbind-reg,
      S : (g |- sg),
      S1 : (g |- sg),
      K : (g |- kind),
      K1 : (g |- kind),
      S3 : (g |- sg),
      Dequiv : (g |- sg-equiv S S3),
      Dequiv1 : (g |- sg-equiv S3 S1),
      K2 : (g |- kind),
      Dfst : (g |- sg-fst S3 K2)
    | x : [g |- sg-equiv S S1],
      fst : [g |- sg-fst S K],
      fst1 : [g |- sg-fst S1 K1]
    ; by sg-equiv-fst [g |- Dequiv] fst [g |- Dfst] as Dequiv12' unboxed;
      by sg-equiv-fst [g |- Dequiv1] [g |- Dfst] fst1 as Dequiv23' unboxed;
      solve [g |- kd-equiv/trans Dequiv12' Dequiv23']
    }
  }
  case sg-equiv/symm:
  { g : conbind+conbind-reg,
    S : (g |- sg),
    S1 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- sg-equiv S1 S)
  | x : [g |- sg-equiv S S1],
    fst : [g |- sg-fst S K],
    fst1 : [g |- sg-fst S1 K1]
  ; by sg-equiv-fst [g |- Dequiv] fst1 fst as Dequiv' unboxed;
    solve [g |- kd-equiv/symm Dequiv']
  }
  case sg-equiv/refl:
  { g : conbind+conbind-reg,
    S1 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dwf : (g |- sg-wf S1)
  | x : [g |- sg-equiv S1 S1],
    fst : [g |- sg-fst S1 K],
    fst1 : [g |- sg-fst S1 K1]
  ; by sg-fst-reg [g |- Dwf] fst as DwfK unboxed;
    by sg-fst-fun fst fst1 as Deq unboxed;
    solve kd-equiv-resp [g |- kind-eq/i ] [g |- Deq] [g |- kd-equiv/refl DwfK]
  }
}
;

proof sg-sub-fst :
  (g : conbind)
  [g |- sg-sub S1 S2] ->
  [g |- sg-fst S1 K1] ->
  [g |- sg-fst S2 K2] ->
    [g |- kd-sub K1 K2] =
/ total 1 /
intros
{ g : conbind,
  S : (g |- sg),
  S1 : (g |- sg),
  K : (g |- kind),
  K1 : (g |- kind)
| x : [g |- sg-sub S S1], fst : [g |- sg-fst S K], fst1 : [g |- sg-fst S1 K1]
; split x as
  case sg-sub/named:
  { g : conbind,
    L : ( |- name),
    S2 : (g |- sg),
    S3 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- sg-sub S2 S3)
  | x : [g |- sg-sub (sg/named L[] S2) (sg/named L[] S3)],
    fst : [g |- sg-fst (sg/named L[] S2) K],
    fst1 : [g |- sg-fst (sg/named L[] S3) K1]
  ; split fst as
    case sg-fst/named:
    { g : conbind,
      L : ( |- name),
      S2 : (g |- sg),
      S3 : (g |- sg),
      K : (g |- kind),
      K1 : (g |- kind),
      Dsub : (g |- sg-sub S2 S3),
      Dfst : (g |- sg-fst S2 K)
    | x : [g |- sg-sub (sg/named L[] S2) (sg/named L[] S3)],
      fst : [g |- sg-fst (sg/named L[] S2) K],
      fst1 : [g |- sg-fst (sg/named L[] S3) K1]
    ; split fst1 as
      case sg-fst/named:
      { g : conbind,
        L : ( |- name),
        S2 : (g |- sg),
        S3 : (g |- sg),
        K : (g |- kind),
        K1 : (g |- kind),
        Dsub : (g |- sg-sub S2 S3),
        Dfst : (g |- sg-fst S2 K),
        Dfst1 : (g |- sg-fst S3 K1)
      | x : [g |- sg-sub (sg/named L[] S2) (sg/named L[] S3)],
        fst : [g |- sg-fst (sg/named L[] S2) K],
        fst1 : [g |- sg-fst (sg/named L[] S3) K1]
      ; solve sg-sub-fst [_ |- Dsub] [_ |- Dfst] [_ |- Dfst1]
      }
    }
  }
  case sg-sub/sigma:
  { g : conbind,
    S2 : (g |- sg),
    S4 : (g, a55 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a56 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- sg-sub S2 S3),
    Dfst : (g |- sg-fst S2 K2),
    Dsub1 :
      (g, a : con, z490 : cn-of a (K2[..]) |- sg-sub (S4[.., a]) (S5[.., a])),
    Dfst1 : (g |- sg-fst S3 K3),
    Dwf : (g, a : con, x490 : cn-of a (K3[..]) |- sg-wf (S5[.., a]))
  | x : [g |- sg-sub (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
    fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) K],
    fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) K1]
  ; split fst as
    case sg-fst/sigma:
    { g : conbind,
      S2 : (g |- sg),
      S4 : (g, a55 : con |- sg),
      S3 : (g |- sg),
      S5 : (g, a56 : con |- sg),
      K4 : (g |- kind),
      K5 : (g, a59 : con |- kind),
      K1 : (g |- kind),
      K2 : (g |- kind),
      K3 : (g |- kind),
      Dsub : (g |- sg-sub S2 S3),
      Dfst : (g |- sg-fst S2 K2),
      Dsub1 :
        (g, a : con, z490 : cn-of a (K2[..]) |-
           sg-sub (S4[.., a]) (S5[.., a])),
      Dfst1 : (g |- sg-fst S3 K3),
      Dwf : (g, a : con, x490 : cn-of a (K3[..]) |- sg-wf (S5[.., a])),
      Dfst2 : (g |- sg-fst S2 K4),
      Dfst3 : (g, a : con |- sg-fst S4 K5)
    | x : [g |- sg-sub (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
      fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) (sigma K4 (\z350. K5))],
      fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) K1]
    ; split fst1 as
      case sg-fst/sigma:
      { g : conbind,
        S2 : (g |- sg),
        S4 : (g, a55 : con |- sg),
        S3 : (g |- sg),
        S5 : (g, a56 : con |- sg),
        K4 : (g |- kind),
        K5 : (g, a59 : con |- kind),
        K6 : (g |- kind),
        K7 : (g, a59 : con |- kind),
        K2 : (g |- kind),
        K3 : (g |- kind),
        Dsub : (g |- sg-sub S2 S3),
        Dfst : (g |- sg-fst S2 K2),
        Dsub1 :
          (g, a : con, z490 : cn-of a (K2[..]) |-
             sg-sub (S4[.., a]) (S5[.., a])),
        Dfst1 : (g |- sg-fst S3 K3),
        Dwf : (g, a : con, x490 : cn-of a (K3[..]) |- sg-wf (S5[.., a])),
        Dfst2 : (g |- sg-fst S2 K4),
        Dfst3 : (g, a : con |- sg-fst S4 K5),
        Dfst4 : (g |- sg-fst S3 K6),
        Dfst5 : (g, a : con |- sg-fst S5 K7)
      | x : [g |- sg-sub (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))],
        fst : [g |- sg-fst (sg/sigma S2 (\x365. S4)) (sigma K4 (\z350. K5))],
        fst1 : [g |- sg-fst (sg/sigma S3 (\x365. S5)) (sigma K6 (\z350. K7))]
      ; by sg-fst-fun [g |- Dfst] [g |- Dfst2] as Deq1a unboxed;
        by kind-resp-kind [g, k : kind |- sigma k (\a. K5[.., a])]
             [g |- Deq1a]
        as Deqa unboxed;
        by sg-fst-fun [g |- Dfst1] [g |- Dfst4] as Deq1b unboxed;
        by kind-resp-kind [g, k : kind |- sigma k (\a. K7[.., a])]
             [g |- Deq1b]
        as Deqb unboxed;
        by sg-sub-fst [g |- Dsub] [g |- Dfst] [g |- Dfst1] as Dsub1' unboxed;
        by sg-sub-fst
     [g, b : block (a : con, da : cn-of a (K2[..])) |- Dsub1[.., b.1, b.2]]
     [g, b : block (a : con, da : cn-of a (K2[..])) |- Dfst3[.., b.1]]
     [g, b : block (a : con, da : cn-of a (K2[..])) |- Dfst5[.., b.1]]
as Dsub2' unboxed;
        by sg-fst-reg
             [g, b : block (a : con, da : cn-of a (K3[..])) |-
                Dwf[.., b.1, b.2]]
             [g, b : block (a : con, da : cn-of a (K3[..])) |- Dfst5[.., b.1]]
        as Dwf2b' unboxed;
        by [g |-
              kd-sub/sigma Dsub1'
              (\a. \da. Dsub2'[.., <a; da>]) (\a. \da. Dwf2b'[.., <a; da>])]
        as Dsub' unboxed;
        solve kd-sub-resp [g |- Deqa] [g |- Deqb] [g |- Dsub']
      }
    }
  }
  case sg-sub/pi:
  { g : conbind,
    S3 : (g |- sg),
    S4 : (g, a53 : con |- sg),
    S2 : (g |- sg),
    S5 : (g, a54 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    K2 : (g |- kind),
    K3 : (g |- kind),
    Dsub : (g |- sg-sub S2 S3),
    Dfst : (g |- sg-fst S2 K2),
    Dsub1 :
      (g, a : con, x488 : cn-of a (K2[..]) |- sg-sub (S4[.., a]) (S5[.., a])),
    Dfst1 : (g |- sg-fst S3 K3),
    Dwf : (g, a : con, y488 : cn-of a (K3[..]) |- sg-wf (S4[.., a]))
  | x : [g |- sg-sub (sg/pi S3 (\x364. S4)) (sg/pi S2 (\x364. S5))],
    fst : [g |- sg-fst (sg/pi S3 (\x364. S4)) K],
    fst1 : [g |- sg-fst (sg/pi S2 (\x364. S5)) K1]
  ; split fst as
    case sg-fst/pi:
    { g : conbind,
      S3 : (g |- sg),
      S4 : (g, a53 : con |- sg),
      S2 : (g |- sg),
      S5 : (g, a54 : con |- sg),
      K1 : (g |- kind),
      K2 : (g |- kind),
      K3 : (g |- kind),
      Dsub : (g |- sg-sub S2 S3),
      Dfst : (g |- sg-fst S2 K2),
      Dsub1 :
        (g, a : con, x488 : cn-of a (K2[..]) |-
           sg-sub (S4[.., a]) (S5[.., a])),
      Dfst1 : (g |- sg-fst S3 K3),
      Dwf : (g, a : con, y488 : cn-of a (K3[..]) |- sg-wf (S4[.., a]))
    | x : [g |- sg-sub (sg/pi S3 (\x364. S4)) (sg/pi S2 (\x364. S5))],
      fst : [g |- sg-fst (sg/pi S3 (\x364. S4)) one],
      fst1 : [g |- sg-fst (sg/pi S2 (\x364. S5)) K1]
    ; split fst1 as
      case sg-fst/pi:
      { g : conbind,
        S3 : (g |- sg),
        S4 : (g, a53 : con |- sg),
        S2 : (g |- sg),
        S5 : (g, a54 : con |- sg),
        K2 : (g |- kind),
        K3 : (g |- kind),
        Dsub : (g |- sg-sub S2 S3),
        Dfst : (g |- sg-fst S2 K2),
        Dsub1 :
          (g, a : con, x488 : cn-of a (K2[..]) |-
             sg-sub (S4[.., a]) (S5[.., a])),
        Dfst1 : (g |- sg-fst S3 K3),
        Dwf : (g, a : con, y488 : cn-of a (K3[..]) |- sg-wf (S4[.., a]))
      | x : [g |- sg-sub (sg/pi S3 (\x364. S4)) (sg/pi S2 (\x364. S5))],
        fst : [g |- sg-fst (sg/pi S3 (\x364. S4)) one],
        fst1 : [g |- sg-fst (sg/pi S2 (\x364. S5)) one]
      ; solve [g |- kd-sub/refl (kd-equiv/refl kd-wf/one)]
      }
    }
  }
  case sg-sub/satom:
  { g : conbind,
    K2 : (g |- kind),
    K3 : (g |- kind),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- kd-sub K2 K3)
  | x : [g |- sg-sub (sg/satom K2) (sg/satom K3)],
    fst : [g |- sg-fst (sg/satom K2) K],
    fst1 : [g |- sg-fst (sg/satom K3) K1]
  ; split fst as
    case sg-fst/satom:
    { g : conbind,
      K : (g |- kind),
      K3 : (g |- kind),
      K1 : (g |- kind),
      Dsub : (g |- kd-sub K K3)
    | x : [g |- sg-sub (sg/satom K) (sg/satom K3)],
      fst : [g |- sg-fst (sg/satom K) K],
      fst1 : [g |- sg-fst (sg/satom K3) K1]
    ; split fst1 as
      case sg-fst/satom:
      { g : conbind,
        K : (g |- kind),
        K1 : (g |- kind),
        Dsub : (g |- kd-sub K K1)
      | x : [g |- sg-sub (sg/satom K) (sg/satom K1)],
        fst : [g |- sg-fst (sg/satom K) K],
        fst1 : [g |- sg-fst (sg/satom K1) K1]
      ; solve [g |- Dsub]
      }
    }
  }
  case sg-sub/trans:
  { g : conbind,
    S : (g |- sg),
    S1 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    S3 : (g |- sg),
    Dsub : (g |- sg-sub S S3),
    Dsub1 : (g |- sg-sub S3 S1)
  | x : [g |- sg-sub S S1],
    fst : [g |- sg-fst S K],
    fst1 : [g |- sg-fst S1 K1]
  ; split can-sg-fst [g |- S3] as
    case can-sg-fst/i:
    { g : conbind,
      S : (g |- sg),
      S1 : (g |- sg),
      K : (g |- kind),
      K1 : (g |- kind),
      S3 : (g |- sg),
      Dsub : (g |- sg-sub S S3),
      Dsub1 : (g |- sg-sub S3 S1),
      K2 : (g |- kind),
      Dfst : (g |- sg-fst S3 K2)
    | x : [g |- sg-sub S S1],
      fst : [g |- sg-fst S K],
      fst1 : [g |- sg-fst S1 K1]
    ; by sg-sub-fst [g |- Dsub] fst [g |- Dfst] as Dsub12' unboxed;
      by sg-sub-fst [g |- Dsub1] [g |- Dfst] fst1 as Dsub23' unboxed;
      solve [g |- kd-sub/trans Dsub12' Dsub23']
    }
  }
  case sg-sub/refl:
  { g : conbind,
    S : (g |- sg),
    S1 : (g |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- sg-equiv S S1)
  | x : [g |- sg-sub S S1],
    fst : [g |- sg-fst S K],
    fst1 : [g |- sg-fst S1 K1]
  ; by sg-equiv-fst [g |- Dequiv] fst fst1 as Dequiv' unboxed;
    solve [g |- kd-sub/refl Dequiv']
  }
}
;

% Signature Regularity

LF sg-equiv-reg/e : sg -> sg -> type =
| sg-equiv-reg/i : sg-wf S1 -> sg-wf S2 -> sg-equiv-reg/e S1 S2
;

proof sg-equiv-reg :
  (g : conbind-reg)
  [g |- sg-equiv S1 S2] ->
    [g |- sg-equiv-reg/e S1 S2] =
/ total 1 /
intros
{ g : conbind-reg, S : (g |- sg), S1 : (g |- sg)
| x : [g |- sg-equiv S S1]
; split x as
  case sg-equiv/named:
  { g : conbind-reg,
    L : ( |- name),
    S2 : (g |- sg),
    S3 : (g |- sg),
    Dequiv : (g |- sg-equiv S2 S3)
  | x : [g |- sg-equiv (sg/named L[] S2) (sg/named L[] S3)]
  ; split sg-equiv-reg [_ |- Dequiv] as
    case sg-equiv-reg/i:
    { g : conbind-reg,
      L : ( |- name),
      S2 : (g |- sg),
      S3 : (g |- sg),
      Dequiv : (g |- sg-equiv S2 S3),
      Dwf : (g |- sg-wf S2),
      Dwf1 : (g |- sg-wf S3)
    | x : [g |- sg-equiv (sg/named L[] S2) (sg/named L[] S3)]
    ; solve [_ |- sg-equiv-reg/i (sg-wf/named Dwf) (sg-wf/named Dwf1)]
    }
  }
  case sg-equiv/sigma:
  { g : conbind-reg,
    S2 : (g |- sg),
    S4 : (g, a51 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a52 : con |- sg),
    K : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3),
    Dfst : (g |- sg-fst S2 K),
    Dequiv1 :
      (g, a : con, x484 : cn-of a (K[..]) |- sg-equiv (S4[.., a]) (S5[.., a]))
  | x : [g |- sg-equiv (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))]
  ; split sg-equiv-reg [g |- Dequiv] as
    case sg-equiv-reg/i:
    { g : conbind-reg,
      S2 : (g |- sg),
      S4 : (g, a51 : con |- sg),
      S3 : (g |- sg),
      S5 : (g, a52 : con |- sg),
      K : (g |- kind),
      Dequiv : (g |- sg-equiv S2 S3),
      Dfst : (g |- sg-fst S2 K),
      Dequiv1 :
        (g, a : con, x484 : cn-of a (K[..]) |-
           sg-equiv (S4[.., a]) (S5[.., a])),
      Dwf : (g |- sg-wf S2),
      Dwf1 : (g |- sg-wf S3)
    | x : [g |- sg-equiv (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))]
    ; split can-sg-fst [g |- S3] as
      case can-sg-fst/i:
      { g : conbind-reg,
        S2 : (g |- sg),
        S4 : (g, a51 : con |- sg),
        S3 : (g |- sg),
        S5 : (g, a52 : con |- sg),
        K : (g |- kind),
        Dequiv : (g |- sg-equiv S2 S3),
        Dfst : (g |- sg-fst S2 K),
        Dequiv1 :
          (g, a : con, x484 : cn-of a (K[..]) |-
             sg-equiv (S4[.., a]) (S5[.., a])),
        Dwf : (g |- sg-wf S2),
        Dwf1 : (g |- sg-wf S3),
        K1 : (g |- kind),
        Dfst1 : (g |- sg-fst S3 K1)
      | x :
          [g |- sg-equiv (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))]
      ; by sg-equiv-fst [g |- Dequiv] [g |- Dfst] [g |- Dfst1]
        as Dequiv1' unboxed;
        split
        sg-equiv-reg
          [g, b : block (a : con, da : cn-of a (K[..])) |-
             Dequiv1[.., b.1, b.2]] as
        case sg-equiv-reg/i:
        { g : conbind-reg,
          S2 : (g |- sg),
          S6 : (g, a : con |- sg),
          S3 : (g |- sg),
          S7 : (g, a : con |- sg),
          K : (g |- kind),
          Dequiv : (g |- sg-equiv S2 S3),
          Dfst : (g |- sg-fst S2 K),
          Dequiv1 :
            (g, a : con, x484 : cn-of a (K[..]) |-
               sg-equiv (S6[.., a]) (S7[.., a])),
          Dwf : (g |- sg-wf S2),
          Dwf1 : (g |- sg-wf S3),
          K1 : (g |- kind),
          Dfst1 : (g |- sg-fst S3 K1),
          Dequiv1' : (g |- kd-equiv K K1),
          Dwf2 : (g, a : con, z1125 : cn-of a (K[..]) |- sg-wf (S6[.., a])),
          Dwf3 : (g, a : con, y1126 : cn-of a (K[..]) |- sg-wf (S7[.., a]))
        | x :
            [g |-
               sg-equiv (sg/sigma S2 (\x365. S6)) (sg/sigma S3 (\x365. S7))]
        ; by [g |- sg-wf/sigma Dwf Dfst (\a. \da. Dwf2)] as Dwf1' unboxed;
          by [g |- sg-wf/sigma Dwf1 Dfst1 (\a. \da. Dwf3[.., a, _])]
          as Dwf2' unboxed;
          solve [g |- sg-equiv-reg/i Dwf1' Dwf2']
        }
      }
    }
  }
  case sg-equiv/pi:
  { g : conbind-reg,
    S2 : (g |- sg),
    S4 : (g, a49 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a50 : con |- sg),
    K : (g |- kind),
    Dequiv : (g |- sg-equiv S2 S3),
    Dfst : (g |- sg-fst S2 K),
    Dequiv1 :
      (g, a : con, y483 : cn-of a (K[..]) |- sg-equiv (S4[.., a]) (S5[.., a]))
  | x : [g |- sg-equiv (sg/pi S2 (\x364. S4)) (sg/pi S3 (\x364. S5))]
  ; split sg-equiv-reg [g |- Dequiv] as
    case sg-equiv-reg/i:
    { g : conbind-reg,
      S2 : (g |- sg),
      S4 : (g, a49 : con |- sg),
      S3 : (g |- sg),
      S5 : (g, a50 : con |- sg),
      K : (g |- kind),
      Dequiv : (g |- sg-equiv S2 S3),
      Dfst : (g |- sg-fst S2 K),
      Dequiv1 :
        (g, a : con, y483 : cn-of a (K[..]) |-
           sg-equiv (S4[.., a]) (S5[.., a])),
      Dwf : (g |- sg-wf S2),
      Dwf1 : (g |- sg-wf S3)
    | x : [g |- sg-equiv (sg/pi S2 (\x364. S4)) (sg/pi S3 (\x364. S5))]
    ; split can-sg-fst [g |- S3] as
      case can-sg-fst/i:
      { g : conbind-reg,
        S2 : (g |- sg),
        S4 : (g, a49 : con |- sg),
        S3 : (g |- sg),
        S5 : (g, a50 : con |- sg),
        K : (g |- kind),
        Dequiv : (g |- sg-equiv S2 S3),
        Dfst : (g |- sg-fst S2 K),
        Dequiv1 :
          (g, a : con, y483 : cn-of a (K[..]) |-
             sg-equiv (S4[.., a]) (S5[.., a])),
        Dwf : (g |- sg-wf S2),
        Dwf1 : (g |- sg-wf S3),
        K1 : (g |- kind),
        Dfst1 : (g |- sg-fst S3 K1)
      | x : [g |- sg-equiv (sg/pi S2 (\x364. S4)) (sg/pi S3 (\x364. S5))]
      ; split can-sg-fst [g |- S3] as
        case can-sg-fst/i:
        { g : conbind-reg,
          S2 : (g |- sg),
          S4 : (g, a49 : con |- sg),
          S3 : (g |- sg),
          S5 : (g, a50 : con |- sg),
          K : (g |- kind),
          Dequiv : (g |- sg-equiv S2 S3),
          Dfst : (g |- sg-fst S2 K),
          Dequiv1 :
            (g, a : con, y483 : cn-of a (K[..]) |-
               sg-equiv (S4[.., a]) (S5[.., a])),
          Dwf : (g |- sg-wf S2),
          Dwf1 : (g |- sg-wf S3),
          K1 : (g |- kind),
          Dfst1 : (g |- sg-fst S3 K1),
          K2 : (g |- kind),
          Dfst2 : (g |- sg-fst S3 K2)
        | x : [g |- sg-equiv (sg/pi S2 (\x364. S4)) (sg/pi S3 (\x364. S5))]
        ; by sg-equiv-fst [g |- Dequiv] [g |- Dfst] [g |- Dfst2]
          as Dequiv1' unboxed;
          split
          sg-equiv-reg
            [g, b : block (a : con, da : cn-of a (K[..])) |-
               Dequiv1[.., b.1, b.2]] as
          case sg-equiv-reg/i:
          { g : conbind-reg,
            S2 : (g |- sg),
            S6 : (g, a : con |- sg),
            S3 : (g |- sg),
            S7 : (g, a : con |- sg),
            K : (g |- kind),
            Dequiv : (g |- sg-equiv S2 S3),
            Dfst : (g |- sg-fst S2 K),
            Dequiv1 :
              (g, a : con, y483 : cn-of a (K[..]) |-
                 sg-equiv (S6[.., a]) (S7[.., a])),
            Dwf : (g |- sg-wf S2),
            Dwf1 : (g |- sg-wf S3),
            K1 : (g |- kind),
            Dfst1 : (g |- sg-fst S3 K1),
            K2 : (g |- kind),
            Dfst2 : (g |- sg-fst S3 K2),
            Dequiv1' : (g |- kd-equiv K K2),
            Dwf2 : (g, a : con, y10 : cn-of a (K[..]) |- sg-wf (S6[.., a])),
            Dwf3 : (g, a : con, x10 : cn-of a (K[..]) |- sg-wf (S7[.., a]))
          | x : [g |- sg-equiv (sg/pi S2 (\x364. S6)) (sg/pi S3 (\x364. S7))]
          ; by [g |- sg-wf/pi Dwf Dfst (\a. \da. Dwf2)] as Dwf1' unboxed;
            by [g |- sg-wf/pi Dwf1 Dfst2 (\a. \da. Dwf3[.., a, _])]
            as Dwf2' unboxed;
            solve [g |- sg-equiv-reg/i Dwf1' Dwf2']
          }
        }
      }
    }
  }
  case sg-equiv/sgatom:
  { g : conbind-reg,
    S2 : (g |- sg),
    S3 : (g |- sg),
    Dequiv : (g |- sg-equiv S2 S3)
  | x : [g |- sg-equiv (sg/sgatom S2) (sg/sgatom S3)]
  ; split sg-equiv-reg [g |- Dequiv] as
    case sg-equiv-reg/i:
    { g : conbind-reg,
      S2 : (g |- sg),
      S3 : (g |- sg),
      Dequiv : (g |- sg-equiv S2 S3),
      Dwf : (g |- sg-wf S2),
      Dwf1 : (g |- sg-wf S3)
    | x : [g |- sg-equiv (sg/sgatom S2) (sg/sgatom S3)]
    ; solve [g |- sg-equiv-reg/i (sg-wf/sgatom Dwf) (sg-wf/sgatom Dwf1)]
    }
  }
  case sg-equiv/datom:
  { g : conbind-reg,
    C : (g |- con),
    C1 : (g |- con),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- sg-equiv (sg/datom C) (sg/datom C1)]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : conbind-reg,
      C : (g |- con),
      C1 : (g |- con),
      Dequiv : (g |- cn-equiv C C1 t),
      Dof : (g |- cn-of C t),
      Dof1 : (g |- cn-of C1 t),
      Dwf : (g |- kd-wf t)
    | x : [g |- sg-equiv (sg/datom C) (sg/datom C1)]
    ; solve [g |- sg-equiv-reg/i (sg-wf/datom Dof) (sg-wf/datom Dof1)]
    }
  }
  case sg-equiv/satom:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- kd-equiv K K1)
  | x : [g |- sg-equiv (sg/satom K) (sg/satom K1)]
  ; split kd-equiv-reg [g |- Dequiv] as
    case kd-equiv-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- kd-equiv K K1),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g |- kd-wf K1)
    | x : [g |- sg-equiv (sg/satom K) (sg/satom K1)]
    ; solve [g |- sg-equiv-reg/i (sg-wf/satom Dwf) (sg-wf/satom Dwf1)]
    }
  }
  case sg-equiv/trans:
  { g : conbind-reg,
    S : (g |- sg),
    S1 : (g |- sg),
    S3 : (g |- sg),
    Dequiv : (g |- sg-equiv S S3),
    Dequiv1 : (g |- sg-equiv S3 S1)
  | x : [g |- sg-equiv S S1]
  ; split sg-equiv-reg [g |- Dequiv] as
    case sg-equiv-reg/i:
    { g : conbind-reg,
      S : (g |- sg),
      S1 : (g |- sg),
      S3 : (g |- sg),
      Dequiv : (g |- sg-equiv S S3),
      Dequiv1 : (g |- sg-equiv S3 S1),
      Dwf : (g |- sg-wf S),
      Dwf1 : (g |- sg-wf S3)
    | x : [g |- sg-equiv S S1]
    ; split sg-equiv-reg [g |- Dequiv1] as
      case sg-equiv-reg/i:
      { g : conbind-reg,
        S : (g |- sg),
        S1 : (g |- sg),
        S3 : (g |- sg),
        Dequiv : (g |- sg-equiv S S3),
        Dequiv1 : (g |- sg-equiv S3 S1),
        Dwf : (g |- sg-wf S),
        Dwf1 : (g |- sg-wf S3),
        Dwf2 : (g |- sg-wf S3),
        Dwf3 : (g |- sg-wf S1)
      | x : [g |- sg-equiv S S1]
      ; solve [g |- sg-equiv-reg/i Dwf Dwf3]
      }
    }
  }
  case sg-equiv/symm:
  { g : conbind-reg,
    S : (g |- sg),
    S1 : (g |- sg),
    Dequiv : (g |- sg-equiv S1 S)
  | x : [g |- sg-equiv S S1]
  ; split sg-equiv-reg [g |- Dequiv] as
    case sg-equiv-reg/i:
    { g : conbind-reg,
      S : (g |- sg),
      S1 : (g |- sg),
      Dequiv : (g |- sg-equiv S1 S),
      Dwf : (g |- sg-wf S1),
      Dwf1 : (g |- sg-wf S)
    | x : [g |- sg-equiv S S1]
    ; solve [g |- sg-equiv-reg/i Dwf1 Dwf]
    }
  }
  case sg-equiv/refl:
  { g : conbind-reg, S1 : (g |- sg), Dwf : (g |- sg-wf S1)
  | x : [g |- sg-equiv S1 S1]
  ; solve [g |- sg-equiv-reg/i Dwf Dwf]
  }
}
;

LF sg-sub-reg/e : sg -> sg -> type =
| sg-sub-reg/i : sg-wf S1 -> sg-wf S2 -> sg-sub-reg/e S1 S2
;

proof sg-sub-reg :
  (g : conbind-reg)
  [g |- sg-sub S1 S2] ->
    [g |- sg-sub-reg/e S1 S2] =
/ total 1 /
intros
{ g : conbind-reg, S : (g |- sg), S1 : (g |- sg)
| x : [g |- sg-sub S S1]
; split x as
  case sg-sub/named:
  { g : conbind-reg,
    L : ( |- name),
    S2 : (g |- sg),
    S3 : (g |- sg),
    Dsub : (g |- sg-sub S2 S3)
  | x : [g |- sg-sub (sg/named L[] S2) (sg/named L[] S3)]
  ; split sg-sub-reg [g |- Dsub] as
    case sg-sub-reg/i:
    { g : conbind-reg,
      L : ( |- name),
      S2 : (g |- sg),
      S3 : (g |- sg),
      Dsub : (g |- sg-sub S2 S3),
      Dwf : (g |- sg-wf S2),
      Dwf1 : (g |- sg-wf S3)
    | x : [g |- sg-sub (sg/named L[] S2) (sg/named L[] S3)]
    ; solve [g |- sg-sub-reg/i (sg-wf/named Dwf) (sg-wf/named Dwf1)]
    }
  }
  case sg-sub/sigma:
  { g : conbind-reg,
    S2 : (g |- sg),
    S4 : (g, a55 : con |- sg),
    S3 : (g |- sg),
    S5 : (g, a56 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- sg-sub S2 S3),
    Dfst : (g |- sg-fst S2 K),
    Dsub1 :
      (g, a : con, z490 : cn-of a (K[..]) |- sg-sub (S4[.., a]) (S5[.., a])),
    Dfst1 : (g |- sg-fst S3 K1),
    Dwf : (g, a : con, x490 : cn-of a (K1[..]) |- sg-wf (S5[.., a]))
  | x : [g |- sg-sub (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))]
  ; split sg-sub-reg [g |- Dsub] as
    case sg-sub-reg/i:
    { g : conbind-reg,
      S2 : (g |- sg),
      S4 : (g, a55 : con |- sg),
      S3 : (g |- sg),
      S5 : (g, a56 : con |- sg),
      K : (g |- kind),
      K1 : (g |- kind),
      Dsub : (g |- sg-sub S2 S3),
      Dfst : (g |- sg-fst S2 K),
      Dsub1 :
        (g, a : con, z490 : cn-of a (K[..]) |- sg-sub (S4[.., a]) (S5[.., a])),
      Dfst1 : (g |- sg-fst S3 K1),
      Dwf : (g, a : con, x490 : cn-of a (K1[..]) |- sg-wf (S5[.., a])),
      Dwf1 : (g |- sg-wf S2),
      Dwf2 : (g |- sg-wf S3)
    | x : [g |- sg-sub (sg/sigma S2 (\x365. S4)) (sg/sigma S3 (\x365. S5))]
    ; split
      sg-sub-reg
        [g, b : block (a : con, da : cn-of a (K[..])) |- Dsub1[.., b.1, b.2]] as
      case sg-sub-reg/i:
      { g : conbind-reg,
        S2 : (g |- sg),
        S6 : (g, a : con |- sg),
        S3 : (g |- sg),
        S7 : (g, a : con |- sg),
        K : (g |- kind),
        K1 : (g |- kind),
        Dsub : (g |- sg-sub S2 S3),
        Dfst : (g |- sg-fst S2 K),
        Dsub1 :
          (g, a : con, z490 : cn-of a (K[..]) |-
             sg-sub (S6[.., a]) (S7[.., a])),
        Dfst1 : (g |- sg-fst S3 K1),
        Dwf : (g, a : con, x490 : cn-of a (K1[..]) |- sg-wf (S7[.., a])),
        Dwf1 : (g |- sg-wf S2),
        Dwf2 : (g |- sg-wf S3),
        Dwf3 : (g, a : con, x1130 : cn-of a (K[..]) |- sg-wf (S6[.., a])),
        Dwf4 : (g, a : con, z1130 : cn-of a (K[..]) |- sg-wf (S7[.., a]))
      | x : [g |- sg-sub (sg/sigma S2 (\x365. S6)) (sg/sigma S3 (\x365. S7))]
      ; by [g |- sg-wf/sigma Dwf1 Dfst (\a. \da. Dwf3[.., a, _])]
        as Dwf1' unboxed;
        by [g |- sg-wf/sigma Dwf2 Dfst1 (\a. \da. Dwf4[.., a, _])]
        as Dwf2' unboxed;
        solve [g |- sg-sub-reg/i Dwf1' Dwf2']
      }
    }
  }
  case sg-sub/pi:
  { g : conbind-reg,
    S3 : (g |- sg),
    S4 : (g, a53 : con |- sg),
    S2 : (g |- sg),
    S5 : (g, a54 : con |- sg),
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- sg-sub S2 S3),
    Dfst : (g |- sg-fst S2 K),
    Dsub1 :
      (g, a : con, x488 : cn-of a (K[..]) |- sg-sub (S4[.., a]) (S5[.., a])),
    Dfst1 : (g |- sg-fst S3 K1),
    Dwf : (g, a : con, y488 : cn-of a (K1[..]) |- sg-wf (S4[.., a]))
  | x : [g |- sg-sub (sg/pi S3 (\x364. S4)) (sg/pi S2 (\x364. S5))]
  ; split sg-sub-reg [g |- Dsub] as
    case sg-sub-reg/i:
    { g : conbind-reg,
      S3 : (g |- sg),
      S4 : (g, a53 : con |- sg),
      S2 : (g |- sg),
      S5 : (g, a54 : con |- sg),
      K : (g |- kind),
      K1 : (g |- kind),
      Dsub : (g |- sg-sub S2 S3),
      Dfst : (g |- sg-fst S2 K),
      Dsub1 :
        (g, a : con, x488 : cn-of a (K[..]) |- sg-sub (S4[.., a]) (S5[.., a])),
      Dfst1 : (g |- sg-fst S3 K1),
      Dwf : (g, a : con, y488 : cn-of a (K1[..]) |- sg-wf (S4[.., a])),
      Dwf1 : (g |- sg-wf S2),
      Dwf2 : (g |- sg-wf S3)
    | x : [g |- sg-sub (sg/pi S3 (\x364. S4)) (sg/pi S2 (\x364. S5))]
    ; split
      sg-sub-reg
        [g, b : block (a : con, da : cn-of a (K[..])) |- Dsub1[.., b.1, b.2]] as
      case sg-sub-reg/i:
      { g : conbind-reg,
        S3 : (g |- sg),
        S6 : (g, a : con |- sg),
        S2 : (g |- sg),
        S7 : (g, a : con |- sg),
        K : (g |- kind),
        K1 : (g |- kind),
        Dsub : (g |- sg-sub S2 S3),
        Dfst : (g |- sg-fst S2 K),
        Dsub1 :
          (g, a : con, x488 : cn-of a (K[..]) |-
             sg-sub (S6[.., a]) (S7[.., a])),
        Dfst1 : (g |- sg-fst S3 K1),
        Dwf : (g, a : con, y488 : cn-of a (K1[..]) |- sg-wf (S6[.., a])),
        Dwf1 : (g |- sg-wf S2),
        Dwf2 : (g |- sg-wf S3),
        Dwf3 : (g, a : con, y1127 : cn-of a (K[..]) |- sg-wf (S6[.., a])),
        Dwf4 : (g, a : con, x1127 : cn-of a (K[..]) |- sg-wf (S7[.., a]))
      | x : [g |- sg-sub (sg/pi S3 (\x364. S6)) (sg/pi S2 (\x364. S7))]
      ; by [g |- sg-wf/pi Dwf2 Dfst1 (\a. \da. Dwf3[.., a, _])]
        as Dwf1' unboxed;
        by [g |- sg-wf/pi Dwf1 Dfst (\a. \da. Dwf4[.., a, _])]
        as Dwf2' unboxed;
        solve [g |- sg-sub-reg/i Dwf1' Dwf2']
      }
    }
  }
  case sg-sub/satom:
  { g : conbind-reg,
    K : (g |- kind),
    K1 : (g |- kind),
    Dsub : (g |- kd-sub K K1)
  | x : [g |- sg-sub (sg/satom K) (sg/satom K1)]
  ; split kd-sub-reg [g |- Dsub] as
    case kd-sub-reg/i:
    { g : conbind-reg,
      K : (g |- kind),
      K1 : (g |- kind),
      Dsub : (g |- kd-sub K K1),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g |- kd-wf K1)
    | x : [g |- sg-sub (sg/satom K) (sg/satom K1)]
    ; solve [g |- sg-sub-reg/i (sg-wf/satom Dwf) (sg-wf/satom Dwf1)]
    }
  }
  case sg-sub/trans:
  { g : conbind-reg,
    S : (g |- sg),
    S1 : (g |- sg),
    S3 : (g |- sg),
    Dsub : (g |- sg-sub S S3),
    Dsub1 : (g |- sg-sub S3 S1)
  | x : [g |- sg-sub S S1]
  ; split sg-sub-reg [g |- Dsub] as
    case sg-sub-reg/i:
    { g : conbind-reg,
      S : (g |- sg),
      S1 : (g |- sg),
      S3 : (g |- sg),
      Dsub : (g |- sg-sub S S3),
      Dsub1 : (g |- sg-sub S3 S1),
      Dwf : (g |- sg-wf S),
      Dwf1 : (g |- sg-wf S3)
    | x : [g |- sg-sub S S1]
    ; split sg-sub-reg [g |- Dsub1] as
      case sg-sub-reg/i:
      { g : conbind-reg,
        S : (g |- sg),
        S1 : (g |- sg),
        S3 : (g |- sg),
        Dsub : (g |- sg-sub S S3),
        Dsub1 : (g |- sg-sub S3 S1),
        Dwf : (g |- sg-wf S),
        Dwf1 : (g |- sg-wf S3),
        Dwf2 : (g |- sg-wf S3),
        Dwf3 : (g |- sg-wf S1)
      | x : [g |- sg-sub S S1]
      ; solve [g |- sg-sub-reg/i Dwf Dwf3]
      }
    }
  }
  case sg-sub/refl:
  { g : conbind-reg,
    S : (g |- sg),
    S1 : (g |- sg),
    Dequiv : (g |- sg-equiv S S1)
  | x : [g |- sg-sub S S1]
  ; split sg-equiv-reg [g |- Dequiv] as
    case sg-equiv-reg/i:
    { g : conbind-reg,
      S : (g |- sg),
      S1 : (g |- sg),
      Dequiv : (g |- sg-equiv S S1),
      Dwf : (g |- sg-wf S),
      Dwf1 : (g |- sg-wf S1)
    | x : [g |- sg-sub S S1]
    ; solve [g |- sg-sub-reg/i Dwf Dwf1]
    }
  }
}
;

% Term/Module Regularity

schema md-fst-fun-ctx =
  % conblock
  block (a : con) +
  % termblock
  block (x : term) +
  % modblock
  block (a : con, m : module', dfst : md-fst m a);

proof md-fst-fun :
  (g : md-fst-fun-ctx)
  [g |- md-fst M C] ->
  [g |- md-fst M C'] ->
    [g |- con-eq C C'] =
/ total 1 /
intros
{ g : md-fst-fun-ctx, M : (g |- module'), C : (g |- con), C' : (g |- con)
| x : [g |- md-fst M C], fst : [g |- md-fst M C']
; split x as
  case md-fst/lete:
  { g : md-fst-fun-ctx,
    E : (g |- term),
    C2 : (g |- con),
    M1 : (g, x8 : term |- module'),
    C : (g |- con),
    C' : (g |- con),
    Dfst : (g, x : term |- md-fst M1 (C[..]))
  | x : [g |- md-fst (md/lete E C2 (\x. M1)) C],
    fst : [g |- md-fst (md/lete E C2 (\x. M1)) C']
  ; split fst as
    case md-fst/lete:
    { g : md-fst-fun-ctx,
      E : (g |- term),
      C2 : (g |- con),
      M1 : (g, x8 : term |- module'),
      C : (g |- con),
      C' : (g |- con),
      Dfst : (g, x : term |- md-fst M1 (C[..])),
      Dfst1 : (g, x : term |- md-fst M1 (C'[..]))
    | x : [g |- md-fst (md/lete E C2 (\x. M1)) C],
      fst : [g |- md-fst (md/lete E C2 (\x. M1)) C']
    ; by md-fst-fun [_, x : term |- Dfst] [_, x : term |- Dfst1]
      as Deq unboxed;
      solve [_ |- Deq[.., E]]
    }
  }
  case md-fst/letp:
  { g : md-fst-fun-ctx,
    M1 : (g |- module'),
    M2 : (g, a73 : con, m7 : module' |- module'),
    C2 : (g, a74 : con |- con),
    C1 : (g |- con),
    C' : (g |- con),
    Dfst : (g |- md-fst M1 C1),
    Dfst1 :
      (g, a : con, m : module', z511 : md-fst m a |-
         md-fst (M2[.., a, m]) (C2[.., a]))
  | x : [g |- md-fst (md/letp M1 (\a. \m. M2)) (C2[.., C1])],
    fst : [g |- md-fst (md/letp M1 (\a. \m. M2)) C']
  ; split fst as
    case md-fst/letp:
    { g : md-fst-fun-ctx,
      M1 : (g |- module'),
      M2 : (g, a73 : con, m7 : module' |- module'),
      C2 : (g, a74 : con |- con),
      C1 : (g |- con),
      C4 : (g, a74 : con |- con),
      C3 : (g |- con),
      Dfst : (g |- md-fst M1 C1),
      Dfst1 :
        (g, a : con, m : module', z511 : md-fst m a |-
           md-fst (M2[.., a, m]) (C2[.., a])),
      Dfst2 : (g |- md-fst M1 C3),
      Dfst3 :
        (g, a : con, m : module', z511 : md-fst m a |-
           md-fst (M2[.., a, m]) (C4[.., a]))
    | x : [g |- md-fst (md/letp M1 (\a. \m. M2)) (C2[.., C1])],
      fst : [g |- md-fst (md/letp M1 (\a. \m. M2)) (C4[.., C3])]
    ; by md-fst-fun [g |- Dfst] [g |- Dfst2] as Deq1 unboxed;
      by md-fst-fun
           [g, b : block (a : con, m : module', dfst : md-fst m a) |-
              Dfst1[.., b.1, b.2, b.3]]
           [g, b : block (a : con, m : module', dfst : md-fst m a) |-
              Dfst3[.., b.1, b.2, b.3]]
      as Deq2 unboxed;
      by con-resp-con [g, c : con |- C2] [g |- Deq1] as Deq1' unboxed;
      solve con-eq-trans [g |- Deq1'] [g |- Deq2[.., <C3; _; _>]]
    }
  }
  case md-fst/out:
  { g : md-fst-fun-ctx,
    M1 : (g |- module'),
    C : (g |- con),
    C' : (g |- con),
    Dfst : (g |- md-fst M1 C)
  | x : [g |- md-fst (md/out M1) C], fst : [g |- md-fst (md/out M1) C']
  ; split fst as
    case md-fst/out:
    { g : md-fst-fun-ctx,
      M1 : (g |- module'),
      C : (g |- con),
      C' : (g |- con),
      Dfst : (g |- md-fst M1 C),
      Dfst1 : (g |- md-fst M1 C')
    | x : [g |- md-fst (md/out M1) C], fst : [g |- md-fst (md/out M1) C']
    ; solve md-fst-fun [g |- Dfst] [g |- Dfst1]
    }
  }
  case md-fst/in:
  { g : md-fst-fun-ctx,
    L : ( |- name),
    M1 : (g |- module'),
    C : (g |- con),
    C' : (g |- con),
    Dfst : (g |- md-fst M1 C)
  | x : [g |- md-fst (md/in L[] M1) C], fst : [g |- md-fst (md/in L[] M1) C']
  ; split fst as
    case md-fst/in:
    { g : md-fst-fun-ctx,
      L : ( |- name),
      M1 : (g |- module'),
      C : (g |- con),
      C' : (g |- con),
      Dfst : (g |- md-fst M1 C),
      Dfst1 : (g |- md-fst M1 C')
    | x : [g |- md-fst (md/in L[] M1) C],
      fst : [g |- md-fst (md/in L[] M1) C']
    ; solve md-fst-fun [g |- Dfst] [g |- Dfst1]
    }
  }
  case md-fst/lam:
  { g : md-fst-fun-ctx,
    S : (g |- sg),
    M1 : (g, a72 : con, m6 : module' |- module'),
    C' : (g |- con)
  | x : [g |- md-fst (md/lam S (\a. \m. M1)) star],
    fst : [g |- md-fst (md/lam S (\a. \m. M1)) C']
  ; split fst as
    case md-fst/lam:
    { g : md-fst-fun-ctx,
      S : (g |- sg),
      M1 : (g, a72 : con, m6 : module' |- module')
    | x : [g |- md-fst (md/lam S (\a. \m. M1)) star],
      fst : [g |- md-fst (md/lam S (\a. \m. M1)) star]
    ; solve [g |- con-eq/i ]
    }
  }
  case md-fst/pi2:
  { g : md-fst-fun-ctx,
    M1 : (g |- module'),
    C1 : (g |- con),
    C' : (g |- con),
    Dfst : (g |- md-fst M1 C1)
  | x : [g |- md-fst (md/pi2 M1) (pi2 C1)],
    fst : [g |- md-fst (md/pi2 M1) C']
  ; split fst as
    case md-fst/pi2:
    { g : md-fst-fun-ctx,
      M1 : (g |- module'),
      C1 : (g |- con),
      C2 : (g |- con),
      Dfst : (g |- md-fst M1 C1),
      Dfst1 : (g |- md-fst M1 C2)
    | x : [g |- md-fst (md/pi2 M1) (pi2 C1)],
      fst : [g |- md-fst (md/pi2 M1) (pi2 C2)]
    ; by md-fst-fun [g |- Dfst] [g |- Dfst1] as Deq unboxed;
      solve con-resp-con [g, c : con |- pi2 c] [g |- Deq]
    }
  }
  case md-fst/pi1:
  { g : md-fst-fun-ctx,
    M1 : (g |- module'),
    C1 : (g |- con),
    C' : (g |- con),
    Dfst : (g |- md-fst M1 C1)
  | x : [g |- md-fst (md/pi1 M1) (pi1 C1)],
    fst : [g |- md-fst (md/pi1 M1) C']
  ; split fst as
    case md-fst/pi1:
    { g : md-fst-fun-ctx,
      M1 : (g |- module'),
      C1 : (g |- con),
      C2 : (g |- con),
      Dfst : (g |- md-fst M1 C1),
      Dfst1 : (g |- md-fst M1 C2)
    | x : [g |- md-fst (md/pi1 M1) (pi1 C1)],
      fst : [g |- md-fst (md/pi1 M1) (pi1 C2)]
    ; by md-fst-fun [g |- Dfst] [g |- Dfst1] as Deq unboxed;
      solve con-resp-con [g, c : con |- pi1 c] [g |- Deq]
    }
  }
  case md-fst/dpair:
  { g : md-fst-fun-ctx,
    M1 : (g |- module'),
    M2 : (g, a70 : con, m5 : module' |- module'),
    C1 : (g |- con),
    C2 : (g, a71 : con |- con),
    C' : (g |- con),
    Dfst : (g |- md-fst M1 C1),
    Dfst1 :
      (g, a : con, m : module', x509 : md-fst m a |-
         md-fst (M2[.., a, m]) (C2[.., a]))
  | x : [g |- md-fst (md/dpair M1 (\a. \m. M2)) (pair C1 (C2[.., C1]))],
    fst : [g |- md-fst (md/dpair M1 (\a. \m. M2)) C']
  ; split fst as
    case md-fst/dpair:
    { g : md-fst-fun-ctx,
      M1 : (g |- module'),
      M2 : (g, a70 : con, m5 : module' |- module'),
      C1 : (g |- con),
      C2 : (g, a71 : con |- con),
      C3 : (g |- con),
      C4 : (g, a71 : con |- con),
      Dfst : (g |- md-fst M1 C1),
      Dfst1 :
        (g, a : con, m : module', x509 : md-fst m a |-
           md-fst (M2[.., a, m]) (C2[.., a])),
      Dfst2 : (g |- md-fst M1 C3),
      Dfst3 :
        (g, a : con, m : module', x509 : md-fst m a |-
           md-fst (M2[.., a, m]) (C4[.., a]))
    | x : [g |- md-fst (md/dpair M1 (\a. \m. M2)) (pair C1 (C2[.., C1]))],
      fst : [g |- md-fst (md/dpair M1 (\a. \m. M2)) (pair C3 (C4[.., C3]))]
    ; by md-fst-fun [g |- Dfst] [g |- Dfst2] as Deq1 unboxed;
      by md-fst-fun
           [g, b : block (a : con, m : module', dfst : md-fst m a) |-
              Dfst1[.., b.1, b.2, b.3]]
           [g, b : block (a : con, m : module', dfst : md-fst m a) |-
              Dfst3[.., b.1, b.2, b.3]]
      as Deq2 unboxed;
      by con-resp-con [g, c : con |- C4] [g |- Deq1] as Deq2' unboxed;
      by con-eq-trans [g |- Deq2[.., <C1; _; _>]] [g |- Deq2']
      as Deq2'' unboxed;
      solve
  con-resp-con2 [g, c1 : con, c2 : con |- pair c1 c2] [g |- Deq1]
    [g |- Deq2'']
    }
  }
  case md-fst/pair:
  { g : md-fst-fun-ctx,
    M1 : (g |- module'),
    M2 : (g |- module'),
    C1 : (g |- con),
    C2 : (g |- con),
    C' : (g |- con),
    Dfst : (g |- md-fst M1 C1),
    Dfst1 : (g |- md-fst M2 C2)
  | x : [g |- md-fst (md/pair M1 M2) (pair C1 C2)],
    fst : [g |- md-fst (md/pair M1 M2) C']
  ; split fst as
    case md-fst/pair:
    { g : md-fst-fun-ctx,
      M1 : (g |- module'),
      M2 : (g |- module'),
      C1 : (g |- con),
      C2 : (g |- con),
      C3 : (g |- con),
      C4 : (g |- con),
      Dfst : (g |- md-fst M1 C1),
      Dfst1 : (g |- md-fst M2 C2),
      Dfst2 : (g |- md-fst M1 C3),
      Dfst3 : (g |- md-fst M2 C4)
    | x : [g |- md-fst (md/pair M1 M2) (pair C1 C2)],
      fst : [g |- md-fst (md/pair M1 M2) (pair C3 C4)]
    ; by md-fst-fun [g |- Dfst] [g |- Dfst2] as Deq1 unboxed;
      by md-fst-fun [g |- Dfst1] [g |- Dfst3] as Deq2 unboxed;
      solve
  con-resp-con2 [g, c1 : con, c2 : con |- pair c1 c2] [g |- Deq1] [g |- Deq2]
    }
  }
  case md-fst/sgatom:
  { g : md-fst-fun-ctx, S : (g |- sg), C' : (g |- con)
  | x : [g |- md-fst (md/sgatom S) star],
    fst : [g |- md-fst (md/sgatom S) C']
  ; split fst as
    case md-fst/sgatom:
    { g : md-fst-fun-ctx, S : (g |- sg)
    | x : [g |- md-fst (md/sgatom S) star],
      fst : [g |- md-fst (md/sgatom S) star]
    ; solve [g |- con-eq/i ]
    }
  }
  case md-fst/datom:
  { g : md-fst-fun-ctx, E : (g |- term), C1 : (g |- con), C' : (g |- con)
  | x : [g |- md-fst (md/datom E C1) star],
    fst : [g |- md-fst (md/datom E C1) C']
  ; split fst as
    case md-fst/datom:
    { g : md-fst-fun-ctx, E : (g |- term), C1 : (g |- con)
    | x : [g |- md-fst (md/datom E C1) star],
      fst : [g |- md-fst (md/datom E C1) star]
    ; solve [g |- con-eq/i ]
    }
  }
  case md-fst/satom:
  { g : md-fst-fun-ctx, C : (g |- con), C' : (g |- con)
  | x : [g |- md-fst (md/satom C) C], fst : [g |- md-fst (md/satom C) C']
  ; split fst as
    case md-fst/satom:
    { g : md-fst-fun-ctx, C' : (g |- con)
    | x : [g |- md-fst (md/satom C') C'],
      fst : [g |- md-fst (md/satom C') C']
    ; solve [g |- con-eq/i ]
    }
  }
  case md-fst/unit:
  { g : md-fst-fun-ctx, C' : (g |- con)
  | x : [g |- md-fst md/unit star], fst : [g |- md-fst md/unit C']
  ; split fst as
    case md-fst/unit:
    { g : md-fst-fun-ctx
    | x : [g |- md-fst md/unit star], fst : [g |- md-fst md/unit star]
    ; solve [g |- con-eq/i ]
    }
  }
  %{ FIXME: File "src/core/reconstruct.ml", line 2248, characters 11-16: Pattern matching failed
  case #.3:
  { g : md-fst-fun-ctx,
    #fst : #(g |- block (a : con, m : module', dfst : md-fst m a)),
    C' : (g |- con)
  | x : [g |- md-fst #fst.2 #fst.1], fst : [g |- md-fst #fst.2 C']
  ; ?
  }
  }%
}
;

schema can-md-fst-ctx =
  % termbind-reg
  some [T : con, Dwf : cn-of T t]
  block (x : term, d : { F' : sttp } tm-of F' x T) +
  % modbind-reg
  some [K : kind, S : sg, DwfK : kd-wf K, DwfS : sg-wf S, DfstS : sg-fst S K]
  block (
    a : con, da : cn-of a K,
    m : module', dm : { P' : purity } { F' : sttp } md-of P' F' m S,
    dfst : md-fst m a
  );

LF can-md-fst/e : module' -> type =
| can-md-fst/i : { C : con } md-fst M C -> can-md-fst/e M
;

proof can-md-fst :
  (g : can-md-fst-ctx)
  [g |- md-of pure F M S] ->
    [g |- can-md-fst/e M] =
/ total 1 /
intros
{ g : can-md-fst-ctx, F : (g |- sttp), M : (g |- module'), S : (g |- sg)
| x : [g |- md-of pure F M S]
; split x as
  case md-of/subsume:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    S : (g |- sg),
    S1 : (g |- sg),
    Dof : (g |- md-of pure F M S1),
    Dsub : (g |- sg-sub S1 S)
  | x : [g |- md-of pure F M S]
  ; solve can-md-fst [_ |- Dof]
  }
  case md-of/extnamed:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    L : ( |- name),
    S2 : (g |- sg),
    S1 : (g |- sg),
    Dof : (g |- md-of pure F M (sg/named L[] S1)),
    Dof1 : (g |- md-of pure F (md/out M) S2)
  | x : [g |- md-of pure F M (sg/named L[] S2)]
  ; split can-md-fst [_ |- Dof] as
    case can-md-fst/i:
    { g : can-md-fst-ctx,
      F : (g |- sttp),
      M : (g |- module'),
      L : ( |- name),
      S2 : (g |- sg),
      S1 : (g |- sg),
      Dof : (g |- md-of pure F M (sg/named L[] S1)),
      Dof1 : (g |- md-of pure F (md/out M) S2),
      C : (g |- con),
      Dfst : (g |- md-fst M C)
    | x : [g |- md-of pure F M (sg/named L[] S2)]
    ; solve [_ |- can-md-fst/i _ Dfst]
    }
  }
  case md-of/extsigma:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    S1 : (g |- sg),
    S2 : (g |- sg),
    Dof : (g |- md-of pure F (md/pi1 M) S1),
    Dof1 : (g |- md-of pure F (md/pi2 M) S2)
  | x : [g |- md-of pure F M (sg/sigma S1 (\x. S2[..]))]
  ; split can-md-fst [_ |- Dof] as
    case can-md-fst/i:
    { g : can-md-fst-ctx,
      F : (g |- sttp),
      M : (g |- module'),
      S1 : (g |- sg),
      S2 : (g |- sg),
      Dof : (g |- md-of pure F (md/pi1 M) S1),
      Dof1 : (g |- md-of pure F (md/pi2 M) S2),
      C : (g |- con),
      Dfst : (g |- md-fst (md/pi1 M) C)
    | x : [g |- md-of pure F M (sg/sigma S1 (\x. S2[..]))]
    ; split [_ |- Dfst] as
      case md-fst/pi1:
      { g : can-md-fst-ctx,
        F : (g |- sttp),
        M : (g |- module'),
        S1 : (g |- sg),
        S2 : (g |- sg),
        Dof : (g |- md-of pure F (md/pi1 M) S1),
        Dof1 : (g |- md-of pure F (md/pi2 M) S2),
        C1 : (g |- con),
        Dfst1 : (g |- md-fst M C1)
      | x : [g |- md-of pure F M (sg/sigma S1 (\x. S2[..]))]
      ; solve [_ |- can-md-fst/i _ Dfst1]
      }
    }
  }
  case md-of/self:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    K1 : (g |- kind),
    K : (g |- kind),
    C : (g |- con),
    Dof : (g |- md-of pure F M (sg/satom K)),
    Dfst : (g |- md-fst M C),
    Dof1 : (g |- cn-of C K1)
  | x : [g |- md-of pure F M (sg/satom K1)]
  ; solve can-md-fst [_ |- Dof]
  }
  case md-of/lete:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    E : (g |- term),
    C : (g |- con),
    M1 : (g, x7 : term |- module'),
    S : (g |- sg),
    Dof : (g |- tm-of F E C),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         md-of pure (F[..]) (M1[.., x]) (S[..]))
  | x : [g |- md-of pure F (md/lete E C (\x. M1)) S]
  ; split
    can-md-fst
      [_, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
         Dof1[.., b.1, b.2]] as
    case can-md-fst/i:
    { g : can-md-fst-ctx,
      F : (g |- sttp),
      E : (g |- term),
      C : (g |- con),
      M2 : (g, x : term |- module'),
      S : (g |- sg),
      Dof : (g |- tm-of F E C),
      Dof1 :
        (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
           md-of pure (F[..]) (M2[.., x]) (S[..])),
      C1 : (g |- con),
      Dfst : (g, x : term |- md-fst M2 (C1[..]))
    | x : [g |- md-of pure F (md/lete E C (\x. M2)) S]
    ; solve [_ |- can-md-fst/i _ (md-fst/lete (\x. Dfst))]
    }
  }
  case md-of/letp:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a68 : con, m4 : module' |- module'),
    S2 : (g, a69 : con |- sg),
    C : (g |- con),
    S1 : (g |- sg),
    K : (g |- kind),
    Dof : (g |- md-of pure F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dfst1 : (g |- md-fst M1 C),
    Dof1 :
      (g, a : con, x629 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       z629 : md-fst m a |- md-of pure (F[..]) (M2[.., a, m]) (S2[.., a]))
  | x : [g |- md-of pure F (md/letp M1 (\z513. \y514. M2)) (S2[.., C])]
  ; split
can-md-fst
  [g,
   b :
     block (
       a : con,
       da : cn-of a (K[..]),
       m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       dfst : md-fst m a) |- Dof1[.., b.1, b.2, b.3, b.4, b.5]] as
    case can-md-fst/i:
    { g : can-md-fst-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      M3 : (g, a : con, m : module' |- module'),
      S2 : (g, a69 : con |- sg),
      C : (g |- con),
      S1 : (g |- sg),
      K : (g |- kind),
      Dof : (g |- md-of pure F M1 S1),
      Dfst : (g |- sg-fst S1 K),
      Dfst1 : (g |- md-fst M1 C),
      Dof1 :
        (g, a : con, x629 : cn-of a (K[..]), m : module',
         u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
         z629 : md-fst m a |- md-of pure (F[..]) (M3[.., a, m]) (S2[.., a])),
      C1 : (g, a : con |- con),
      Dfst2 :
        (g, a : con, m : module', y1587 : md-fst m a |-
           md-fst (M3[.., a, m]) (C1[.., a]))
    | x : [g |- md-of pure F (md/letp M1 (\z513. \y514. M3)) (S2[.., C])]
    ; solve [g |- can-md-fst/i _ (md-fst/letp Dfst1 (\a. \m. \dfst. Dfst2))]
    }
  }
  case md-of/out:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    L : ( |- name),
    Dof : (g |- md-of pure F M1 (sg/named L[] S))
  | x : [g |- md-of pure F (md/out M1) S]
  ; split can-md-fst [g |- Dof] as
    case can-md-fst/i:
    { g : can-md-fst-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      S : (g |- sg),
      L : ( |- name),
      Dof : (g |- md-of pure F M1 (sg/named L[] S)),
      C : (g |- con),
      Dfst : (g |- md-fst M1 C)
    | x : [g |- md-of pure F (md/out M1) S]
    ; solve [g |- can-md-fst/i _ (md-fst/out Dfst)]
    }
  }
  case md-of/in:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    L : ( |- name),
    M1 : (g |- module'),
    S1 : (g |- sg),
    Dof : (g |- md-of pure F M1 S1)
  | x : [g |- md-of pure F (md/in L[] M1) (sg/named L[] S1)]
  ; split can-md-fst [g |- Dof] as
    case can-md-fst/i:
    { g : can-md-fst-ctx,
      F : (g |- sttp),
      L : ( |- name),
      M1 : (g |- module'),
      S1 : (g |- sg),
      Dof : (g |- md-of pure F M1 S1),
      C : (g |- con),
      Dfst : (g |- md-fst M1 C)
    | x : [g |- md-of pure F (md/in L[] M1) (sg/named L[] S1)]
    ; solve [g |- can-md-fst/i _ (md-fst/in Dfst)]
    }
  }
  case md-of/lam:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    S1 : (g |- sg),
    M1 : (g, a64 : con, m2 : module' |- module'),
    S2 : (g, a65 : con |- sg),
    K : (g |- kind),
    P : ( |- purity),
    Dwf : (g |- sg-wf S1),
    Dfst : (g |- sg-fst S1 K),
    Dof :
      (g, a : con, y624 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       x624 : md-fst m a |- md-of P[] (F[..]) (M1[.., a, m]) (S2[.., a]))
  | x :
      [g |-
         md-of pure F (md/lam S1 (\y509. \x509. M1)) (sg/pi S1 (\z484. S2))]
  ; solve [g |- can-md-fst/i _ (md-fst/lam )]
  }
  case md-of/pi2:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S2 : (g, a63 : con |- sg),
    C : (g |- con),
    S1 : (g |- sg),
    Dof : (g |- md-of pure F M1 (sg/sigma S1 (\z485. S2))),
    Dfst : (g |- md-fst M1 C)
  | x : [g |- md-of pure F (md/pi2 M1) (S2[.., pi1 C])]
  ; split can-md-fst [g |- Dof] as
    case can-md-fst/i:
    { g : can-md-fst-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      S2 : (g, a63 : con |- sg),
      C : (g |- con),
      S1 : (g |- sg),
      Dof : (g |- md-of pure F M1 (sg/sigma S1 (\z485. S2))),
      Dfst : (g |- md-fst M1 C),
      C1 : (g |- con),
      Dfst1 : (g |- md-fst M1 C1)
    | x : [g |- md-of pure F (md/pi2 M1) (S2[.., pi1 C])]
    ; solve [g |- can-md-fst/i _ (md-fst/pi2 Dfst)]
    }
  }
  case md-of/pi1:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    S2 : (g, a62 : con |- sg),
    Dof : (g |- md-of pure F M1 (sg/sigma S (\z485. S2)))
  | x : [g |- md-of pure F (md/pi1 M1) S]
  ; split can-md-fst [g |- Dof] as
    case can-md-fst/i:
    { g : can-md-fst-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      S : (g |- sg),
      S2 : (g, a62 : con |- sg),
      Dof : (g |- md-of pure F M1 (sg/sigma S (\z485. S2))),
      C : (g |- con),
      Dfst : (g |- md-fst M1 C)
    | x : [g |- md-of pure F (md/pi1 M1) S]
    ; solve [g |- can-md-fst/i _ (md-fst/pi1 Dfst)]
    }
  }
  case md-of/dpair:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a60 : con, m1 : module' |- module'),
    S1 : (g |- sg),
    S2 : (g, a61 : con |- sg),
    K : (g |- kind),
    Dof : (g |- md-of pure F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dof1 :
      (g, a : con, x621 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       z621 : md-fst m a |- md-of pure (F[..]) (M2[.., a, m]) (S2[.., a]))
  | x :
      [g |- md-of pure F (md/dpair M1 (\a. \m. M2)) (sg/sigma S1 (\z485. S2))]
  ; split can-md-fst [g |- Dof] as
    case can-md-fst/i:
    { g : can-md-fst-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      M2 : (g, a60 : con, m1 : module' |- module'),
      S1 : (g |- sg),
      S2 : (g, a61 : con |- sg),
      K : (g |- kind),
      Dof : (g |- md-of pure F M1 S1),
      Dfst : (g |- sg-fst S1 K),
      Dof1 :
        (g, a : con, x621 : cn-of a (K[..]), m : module',
         u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
         z621 : md-fst m a |- md-of pure (F[..]) (M2[.., a, m]) (S2[.., a])),
      C : (g |- con),
      Dfst1 : (g |- md-fst M1 C)
    | x :
        [g |-
           md-of pure F (md/dpair M1 (\a. \m. M2)) (sg/sigma S1 (\z485. S2))]
    ; split
      can-md-fst
        [g,
         b :
           block (
             a : con,
             da : cn-of a (K[..]),
             m : module',
             u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
             dfst : md-fst m a) |- Dof1[.., b.1, b.2, b.3, b.4, b.5]] as
      case can-md-fst/i:
      { g : can-md-fst-ctx,
        F : (g |- sttp),
        M1 : (g |- module'),
        M3 : (g, a : con, m : module' |- module'),
        S1 : (g |- sg),
        S2 : (g, a61 : con |- sg),
        K : (g |- kind),
        Dof : (g |- md-of pure F M1 S1),
        Dfst : (g |- sg-fst S1 K),
        Dof1 :
          (g, a : con, x621 : cn-of a (K[..]), m : module',
           u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
           z621 : md-fst m a |- md-of pure (F[..]) (M3[.., a, m]) (S2[.., a])),
        C : (g |- con),
        Dfst1 : (g |- md-fst M1 C),
        C1 : (g, a : con |- con),
        Dfst2 :
          (g, a : con, m : module', y8 : md-fst m a |-
             md-fst (M3[.., a, m]) (C1[.., a]))
      | x :
          [g |-
             md-of
               pure F (md/dpair M1 (\a. \m. M3)) (sg/sigma S1 (\z485. S2))]
      ; solve
          [g |- can-md-fst/i _ (md-fst/dpair Dfst1 (\a. \m. \dfst. Dfst2))]
      }
    }
  }
  case md-of/pair:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g |- module'),
    S1 : (g |- sg),
    S2 : (g |- sg),
    Dof : (g |- md-of pure F M1 S1),
    Dof1 : (g |- md-of pure F M2 S2)
  | x : [g |- md-of pure F (md/pair M1 M2) (sg/sigma S1 (\x. S2[..]))]
  ; split can-md-fst [g |- Dof] as
    case can-md-fst/i:
    { g : can-md-fst-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      M2 : (g |- module'),
      S1 : (g |- sg),
      S2 : (g |- sg),
      Dof : (g |- md-of pure F M1 S1),
      Dof1 : (g |- md-of pure F M2 S2),
      C : (g |- con),
      Dfst : (g |- md-fst M1 C)
    | x : [g |- md-of pure F (md/pair M1 M2) (sg/sigma S1 (\x. S2[..]))]
    ; split can-md-fst [g |- Dof1] as
      case can-md-fst/i:
      { g : can-md-fst-ctx,
        F : (g |- sttp),
        M1 : (g |- module'),
        M2 : (g |- module'),
        S1 : (g |- sg),
        S2 : (g |- sg),
        Dof : (g |- md-of pure F M1 S1),
        Dof1 : (g |- md-of pure F M2 S2),
        C : (g |- con),
        Dfst : (g |- md-fst M1 C),
        C1 : (g |- con),
        Dfst1 : (g |- md-fst M2 C1)
      | x : [g |- md-of pure F (md/pair M1 M2) (sg/sigma S1 (\x. S2[..]))]
      ; solve [g |- can-md-fst/i _ (md-fst/pair Dfst Dfst1)]
      }
    }
  }
  case md-of/datom:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    E : (g |- term),
    C : (g |- con),
    Dof : (g |- tm-of F E C)
  | x : [g |- md-of pure F (md/datom E C) (sg/datom C)]
  ; solve [g |- can-md-fst/i _ (md-fst/datom )]
  }
  case md-of/sgatom:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    S1 : (g |- sg),
    Dwf : (g |- sg-wf S1)
  | x : [g |- md-of pure F (md/sgatom S1) (sg/sgatom S1)]
  ; solve [g |- can-md-fst/i _ (md-fst/sgatom )]
  }
  case md-of/satom:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    C : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of C K)
  | x : [g |- md-of pure F (md/satom C) (sg/satom K)]
  ; solve [g |- can-md-fst/i _ (md-fst/satom )]
  }
  case md-of/unit:
  { g : can-md-fst-ctx, F : (g |- sttp)
  | x : [g |- md-of pure F md/unit sg/one]
  ; solve [g |- can-md-fst/i _ md-fst/unit]
  }
  %{ FIXME: Uncaught exception: Not_found
  case #.4:
  { g : can-md-fst-ctx,
    F : (g |- sttp),
    K1133 : (g |- kind),
    S : (g |- sg),
    #fst :
      #(g |-
          block (
            a : con,
            da : cn-of a (K1133[..]),
            m : module',
            dm : {P' : purity}  {F' : sttp}  md-of P' F' m (S[..]),
            dfst : md-fst m a)),
    Dwf190 : (g |- kd-wf K1133),
    Dwf60 : (g |- sg-wf S),
    Dfst64 : (g |- sg-fst S K1133)
  | x : [g |- md-of pure F #fst.3 S]
  ; ?
  }
  }%
}
;

schema md-fst-reg-ctx =
  % conbind
  some [K : kind]
  block (a : con, da : cn-of a K) +
  % conbind-reg
  some [K : kind, wf : kd-wf K]
  block (a : con, da : cn-of a K) +
  % termbind-reg
  some [T : con, Dwf : cn-of T t]
  block (x : term, d : { F' : sttp } tm-of F' x T) +
  % modbind-reg
  some [K : kind, S : sg, DwfK : kd-wf K, DwfS : sg-wf S, DfstS : sg-fst S K]
  block (
    a : con, da : cn-of a K,
    m : module', dm : { P' : purity } { F' : sttp } md-of P' F' m S,
    dfst : md-fst m a
  );

LF md-fst-reg'/e : sg -> con -> type =
| md-fst-reg'/i :
  { K : kind }
  sg-fst S K ->
  cn-of C K ->
    md-fst-reg'/e S C
;

proof md-fst-reg' :
  (g : md-fst-reg-ctx)
  [g |- md-of P F M S] ->
  [g |- md-fst M C] ->
    [g |- md-fst-reg'/e S C] =
/ total 1 /
intros
{ g : md-fst-reg-ctx,
  P : (g |- purity),
  F : (g |- sttp),
  M : (g |- module'),
  S : (g |- sg),
  C : (g |- con)
| x : [g |- md-of P F M S], fst : [g |- md-fst M C]
; split x as
  case md-of/subsume:
  { g : md-fst-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M : (g |- module'),
    S : (g |- sg),
    C : (g |- con),
    S1 : (g |- sg),
    Dof : (g |- md-of P[] F M S1),
    Dsub : (g |- sg-sub S1 S)
  | x : [g |- md-of P[] F M S], fst : [g |- md-fst M C]
  ; by fst as DfstM unboxed;
    split md-fst-reg' [_ |- Dof] [_ |- DfstM] as
    case md-fst-reg'/i:
    { g : md-fst-reg-ctx,
      P : ( |- purity),
      F : (g |- sttp),
      M : (g |- module'),
      S' : (g |- sg),
      C : (g |- con),
      S : (g |- sg),
      DofM : (g |- md-of P[] F M S),
      DsubS : (g |- sg-sub S S'),
      DfstM : (g |- md-fst M C),
      K : (g |- kind),
      Dfst : (g |- sg-fst S K),
      Dof : (g |- cn-of C K)
    | x : [g |- md-of P[] F M S'], fst : [g |- md-fst M C]
    ; split can-sg-fst [_ |- S'] as
      case can-sg-fst/i:
      { g : md-fst-reg-ctx,
        P : ( |- purity),
        F : (g |- sttp),
        M : (g |- module'),
        S' : (g |- sg),
        C : (g |- con),
        S : (g |- sg),
        DofM : (g |- md-of P[] F M S),
        DsubS : (g |- sg-sub S S'),
        DfstM : (g |- md-fst M C),
        K : (g |- kind),
        DfstS : (g |- sg-fst S K),
        Dof : (g |- cn-of C K),
        K1 : (g |- kind),
        Dfst : (g |- sg-fst S' K1)
      | x : [g |- md-of P[] F M S'], fst : [g |- md-fst M C]
      ; by sg-sub-fst [g |- DsubS] [g |- DfstS] [g |- Dfst] as DsubK unboxed;
        solve [g |- md-fst-reg'/i _ Dfst (cn-of/subsume Dof DsubK)]
      }
    }
  }
  case md-of/forget:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    S : (g |- sg),
    C : (g |- con),
    Dof : (g |- md-of pure F M S)
  | x : [g |- md-of impure F M S], fst : [g |- md-fst M C]
  ; split md-fst-reg' [g |- Dof] fst as
    case md-fst-reg'/i:
    { g : md-fst-reg-ctx,
      F : (g |- sttp),
      M : (g |- module'),
      S : (g |- sg),
      C : (g |- con),
      Dof : (g |- md-of pure F M S),
      K : (g |- kind),
      Dfst : (g |- sg-fst S K),
      Dof1 : (g |- cn-of C K)
    | x : [g |- md-of impure F M S], fst : [g |- md-fst M C]
    ; solve [g |- md-fst-reg'/i _ Dfst Dof1]
    }
  }
  case md-of/extnamed:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    L : ( |- name),
    S2 : (g |- sg),
    C : (g |- con),
    S1 : (g |- sg),
    Dof : (g |- md-of pure F M (sg/named L[] S1)),
    Dof1 : (g |- md-of pure F (md/out M) S2)
  | x : [g |- md-of pure F M (sg/named L[] S2)], fst : [g |- md-fst M C]
  ; by fst as DfstM unboxed;
    split md-fst-reg' [g |- Dof1] [g |- md-fst/out DfstM] as
    case md-fst-reg'/i:
    { g : md-fst-reg-ctx,
      F : (g |- sttp),
      M : (g |- module'),
      L : ( |- name),
      S2 : (g |- sg),
      C : (g |- con),
      S1 : (g |- sg),
      Dof : (g |- md-of pure F M (sg/named L[] S1)),
      Dof1 : (g |- md-of pure F (md/out M) S2),
      DfstM : (g |- md-fst M C),
      K : (g |- kind),
      Dfst : (g |- sg-fst S2 K),
      Dof2 : (g |- cn-of C K)
    | x : [g |- md-of pure F M (sg/named L[] S2)], fst : [g |- md-fst M C]
    ; solve [g |- md-fst-reg'/i _ (sg-fst/named Dfst) Dof2]
    }
  }
  case md-of/extsigma:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    S1 : (g |- sg),
    S2 : (g |- sg),
    C : (g |- con),
    Dof : (g |- md-of pure F (md/pi1 M) S1),
    Dof1 : (g |- md-of pure F (md/pi2 M) S2)
  | x : [g |- md-of pure F M (sg/sigma S1 (\x. S2[..]))],
    fst : [g |- md-fst M C]
  ; by fst as Dfst unboxed;
    split md-fst-reg' [g |- Dof] [g |- md-fst/pi1 Dfst] as
    case md-fst-reg'/i:
    { g : md-fst-reg-ctx,
      F : (g |- sttp),
      M : (g |- module'),
      S1 : (g |- sg),
      S2 : (g |- sg),
      C : (g |- con),
      Dof : (g |- md-of pure F (md/pi1 M) S1),
      Dof1 : (g |- md-of pure F (md/pi2 M) S2),
      Dfst : (g |- md-fst M C),
      K : (g |- kind),
      Dfst1 : (g |- sg-fst S1 K),
      Dof2 : (g |- cn-of (pi1 C) K)
    | x : [g |- md-of pure F M (sg/sigma S1 (\x. S2[..]))],
      fst : [g |- md-fst M C]
    ; split md-fst-reg' [g |- Dof1] [g |- md-fst/pi2 Dfst] as
      case md-fst-reg'/i:
      { g : md-fst-reg-ctx,
        F : (g |- sttp),
        M : (g |- module'),
        S1 : (g |- sg),
        S2 : (g |- sg),
        C : (g |- con),
        Dof : (g |- md-of pure F (md/pi1 M) S1),
        Dof1 : (g |- md-of pure F (md/pi2 M) S2),
        Dfst : (g |- md-fst M C),
        K : (g |- kind),
        Dfst1 : (g |- sg-fst S1 K),
        Dof2 : (g |- cn-of (pi1 C) K),
        K1 : (g |- kind),
        Dfst2 : (g |- sg-fst S2 K1),
        Dof3 : (g |- cn-of (pi2 C) K1)
      | x : [g |- md-of pure F M (sg/sigma S1 (\x. S2[..]))],
        fst : [g |- md-fst M C]
      ; by cn-of-reg [g |- Dof3] as DwfK unboxed;
        by [g |- sg-fst/sigma Dfst1 (\a. Dfst2[..])] as Dfst' unboxed;
        by [g |- cn-of/extsigma Dof2 Dof3 (\a. \da. DwfK[..])]
        as Dof' unboxed;
        solve [g |- md-fst-reg'/i _ Dfst' Dof']
      }
    }
  }
  case md-of/self:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    K1 : (g |- kind),
    C : (g |- con),
    K : (g |- kind),
    C1 : (g |- con),
    Dof : (g |- md-of pure F M (sg/satom K)),
    Dfst : (g |- md-fst M C1),
    Dof1 : (g |- cn-of C1 K1)
  | x : [g |- md-of pure F M (sg/satom K1)], fst : [g |- md-fst M C]
  ; split md-fst-fun [g |- Dfst] fst as
    case con-eq/i:
    { g : md-fst-reg-ctx,
      F : (g |- sttp),
      M : (g |- module'),
      K1 : (g |- kind),
      C : (g |- con),
      K : (g |- kind),
      Dof : (g |- md-of pure F M (sg/satom K)),
      Dfst : (g |- md-fst M C),
      Dof1 : (g |- cn-of C K1)
    | x : [g |- md-of pure F M (sg/satom K1)], fst : [g |- md-fst M C]
    ; solve [g |- md-fst-reg'/i _ (sg-fst/satom ) Dof1]
    }
  }
  case md-of/seal:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    C : (g |- con),
    P1 : ( |- purity),
    Dof : (g |- md-of P1[] F M1 S)
  | x : [g |- md-of impure F (md/seal M1 S) S],
    fst : [g |- md-fst (md/seal M1 S) C]
  ; impossible fst
  }
  case md-of/lete:
  { g : md-fst-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    E : (g |- term),
    C1 : (g |- con),
    M1 : (g, x7 : term |- module'),
    S : (g |- sg),
    C : (g |- con),
    Dof : (g |- tm-of F E C1),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C1[..]) |-
         md-of P[] (F[..]) (M1[.., x]) (S[..]))
  | x : [g |- md-of P[] F (md/lete E C1 (\x. M1)) S],
    fst : [g |- md-fst (md/lete E C1 (\x. M1)) C]
  ; split fst as
    case md-fst/lete:
    { g : md-fst-reg-ctx,
      P : ( |- purity),
      F : (g |- sttp),
      E : (g |- term),
      C1 : (g |- con),
      M1 : (g, x7 : term |- module'),
      S : (g |- sg),
      C : (g |- con),
      Dof : (g |- tm-of F E C1),
      Dof1 :
        (g, x : term, u : {F' : sttp}  tm-of F' x (C1[..]) |-
           md-of P[] (F[..]) (M1[.., x]) (S[..])),
      Dfst : (g, x : term |- md-fst M1 (C[..]))
    | x : [g |- md-of P[] F (md/lete E C1 (\x. M1)) S],
      fst : [g |- md-fst (md/lete E C1 (\x. M1)) C]
    ; split
      md-fst-reg'
        [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C1[..])) |-
           Dof1[.., b.1, b.2]]
        [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C1[..])) |-
           Dfst[.., b.1]] as
      case md-fst-reg'/i:
      { g : md-fst-reg-ctx,
        P : ( |- purity),
        F : (g |- sttp),
        E : (g |- term),
        C1 : (g |- con),
        M1 : (g, x7 : term |- module'),
        S : (g |- sg),
        C : (g |- con),
        Dof : (g |- tm-of F E C1),
        Dof1 :
          (g, x : term, u : {F' : sttp}  tm-of F' x (C1[..]) |-
             md-of P[] (F[..]) (M1[.., x]) (S[..])),
        Dfst : (g, x : term |- md-fst M1 (C[..])),
        K : (g |- kind),
        Dfst1 : (g |- sg-fst S K),
        Dof2 : (g |- cn-of C K)
      | x : [g |- md-of P[] F (md/lete E C1 (\x. M1)) S],
        fst : [g |- md-fst (md/lete E C1 (\x. M1)) C]
      ; solve [g |- md-fst-reg'/i _ Dfst1 Dof2]
      }
    }
  }
  case md-of/letp:
  { g : md-fst-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a68 : con, m4 : module' |- module'),
    S2 : (g, a69 : con |- sg),
    C1 : (g |- con),
    C : (g |- con),
    S1 : (g |- sg),
    K : (g |- kind),
    Dof : (g |- md-of pure F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dfst1 : (g |- md-fst M1 C1),
    Dof1 :
      (g, a : con, z675 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       y676 : md-fst m a |- md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a]))
  | x : [g |- md-of P[] F (md/letp M1 (\y560. \x560. M2)) (S2[.., C1])],
    fst : [g |- md-fst (md/letp M1 (\y560. \x560. M2)) C]
  ; split fst as
    case md-fst/letp:
    { g : md-fst-reg-ctx,
      P : ( |- purity),
      F : (g |- sttp),
      M1 : (g |- module'),
      M2 : (g, a68 : con, m4 : module' |- module'),
      S2 : (g, a69 : con |- sg),
      C1 : (g |- con),
      C3 : (g, a74 : con |- con),
      C2 : (g |- con),
      S1 : (g |- sg),
      K : (g |- kind),
      Dof : (g |- md-of pure F M1 S1),
      Dfst : (g |- sg-fst S1 K),
      Dfst1 : (g |- md-fst M1 C1),
      Dof1 :
        (g, a : con, z675 : cn-of a (K[..]), m : module',
         u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
         y676 : md-fst m a |- md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a])),
      Dfst2 : (g |- md-fst M1 C2),
      Dfst3 :
        (g, a : con, m : module', z689 : md-fst m a |-
           md-fst (M2[.., a, m]) (C3[.., a]))
    | x : [g |- md-of P[] F (md/letp M1 (\x565. \z565. M2)) (S2[.., C1])],
      fst : [g |- md-fst (md/letp M1 (\x565. \z565. M2)) (C3[.., C2])]
    ; split md-fst-fun [g |- Dfst1] [g |- Dfst2] as
      case con-eq/i:
      { g : md-fst-reg-ctx,
        P : ( |- purity),
        F : (g |- sttp),
        M1 : (g |- module'),
        M2 : (g, a68 : con, m4 : module' |- module'),
        S2 : (g, a69 : con |- sg),
        C2 : (g |- con),
        C3 : (g, a74 : con |- con),
        S1 : (g |- sg),
        K : (g |- kind),
        Dof : (g |- md-of pure F M1 S1),
        Dfst : (g |- sg-fst S1 K),
        Dfst1 : (g |- md-fst M1 C2),
        Dof1 :
          (g, a : con, z675 : cn-of a (K[..]), m : module',
           u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
           y676 : md-fst m a |- md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a])),
        Dfst2 : (g |- md-fst M1 C2),
        Dfst3 :
          (g, a : con, m : module', z689 : md-fst m a |-
             md-fst (M2[.., a, m]) (C3[.., a]))
      | x : [g |- md-of P[] F (md/letp M1 (\x565. \z565. M2)) (S2[.., C2])],
        fst : [g |- md-fst (md/letp M1 (\x565. \z565. M2)) (C3[.., C2])]
      ; split md-fst-reg' [g |- Dof] [g |- Dfst1] as
        case md-fst-reg'/i:
        { g : md-fst-reg-ctx,
          P : ( |- purity),
          F : (g |- sttp),
          M1 : (g |- module'),
          M2 : (g, a68 : con, m4 : module' |- module'),
          S2 : (g, a69 : con |- sg),
          C2 : (g |- con),
          C3 : (g, a74 : con |- con),
          S1 : (g |- sg),
          K : (g |- kind),
          Dof : (g |- md-of pure F M1 S1),
          Dfst : (g |- sg-fst S1 K),
          Dfst1 : (g |- md-fst M1 C2),
          Dof1 :
            (g, a : con, z675 : cn-of a (K[..]), m : module',
             u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
             y676 : md-fst m a |-
               md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a])),
          Dfst2 : (g |- md-fst M1 C2),
          Dfst3 :
            (g, a : con, m : module', z689 : md-fst m a |-
               md-fst (M2[.., a, m]) (C3[.., a])),
          K1 : (g |- kind),
          Dfst4 : (g |- sg-fst S1 K1),
          Dof2 : (g |- cn-of C2 K1)
        | x : [g |- md-of P[] F (md/letp M1 (\x565. \z565. M2)) (S2[.., C2])],
          fst : [g |- md-fst (md/letp M1 (\x565. \z565. M2)) (C3[.., C2])]
        ; split can-sg-fst [g, a69 : con |- S2] as
          case can-sg-fst/i:
          { g : md-fst-reg-ctx,
            P : ( |- purity),
            F : (g |- sttp),
            M1 : (g |- module'),
            M2 : (g, a68 : con, m4 : module' |- module'),
            S2 : (g, a69 : con |- sg),
            C2 : (g |- con),
            C3 : (g, a74 : con |- con),
            S1 : (g |- sg),
            K : (g |- kind),
            Dof : (g |- md-of pure F M1 S1),
            Dfst : (g |- sg-fst S1 K),
            Dfst1 : (g |- md-fst M1 C2),
            Dof1 :
              (g, a : con, z675 : cn-of a (K[..]), m : module',
               u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
               y676 : md-fst m a |-
                 md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a])),
            Dfst2 : (g |- md-fst M1 C2),
            Dfst3 :
              (g, a : con, m : module', z689 : md-fst m a |-
                 md-fst (M2[.., a, m]) (C3[.., a])),
            K1 : (g |- kind),
            Dfst4 : (g |- sg-fst S1 K1),
            Dof2 : (g |- cn-of C2 K1),
            K2 : (g, a69 : con |- kind),
            Dfst5 : (g, a69 : con |- sg-fst S2 K2)
          | x :
              [g |- md-of P[] F (md/letp M1 (\x565. \z565. M2)) (S2[.., C2])],
            fst : [g |- md-fst (md/letp M1 (\x565. \z565. M2)) (C3[.., C2])]
          ; split
            md-fst-reg'
              [g,
               b :
                 block (
                   a : con,
                   da : cn-of a (K[..]),
                   m : module',
                   u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
                   dfst : md-fst m a) |- Dof1[.., b.1, b.2, b.3, b.4, b.5]]
              [g,
               b :
                 block (
                   a : con,
                   da : cn-of a (K[..]),
                   m : module',
                   u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
                   dfst : md-fst m a) |- Dfst3[.., b.1, b.3, b.5]] as
            case md-fst-reg'/i:
            { g : md-fst-reg-ctx,
              P : ( |- purity),
              F : (g |- sttp),
              M1 : (g |- module'),
              M2 : (g, a68 : con, m4 : module' |- module'),
              S3 : (g, a : con |- sg),
              C2 : (g |- con),
              C4 : (g, a : con |- con),
              S1 : (g |- sg),
              K : (g |- kind),
              Dof : (g |- md-of pure F M1 S1),
              Dfst : (g |- sg-fst S1 K),
              Dfst1 : (g |- md-fst M1 C2),
              Dof1 :
                (g, a : con, z675 : cn-of a (K[..]), m : module',
                 u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
                 y676 : md-fst m a |-
                   md-of P[] (F[..]) (M2[.., a, m]) (S3[.., a])),
              Dfst2 : (g |- md-fst M1 C2),
              Dfst3 :
                (g, a : con, m : module', z689 : md-fst m a |-
                   md-fst (M2[.., a, m]) (C4[.., a])),
              K1 : (g |- kind),
              Dfst4 : (g |- sg-fst S1 K1),
              Dof2 : (g |- cn-of C2 K1),
              K2 : (g, a69 : con |- kind),
              Dfst5 : (g, a69 : con |- sg-fst S3 K2),
              K3 : (g, a : con |- kind),
              Dfst6 : (g, a : con |- sg-fst S3 K3),
              Dof3 :
                (g, a : con, da : cn-of a (K[..]) |-
                   cn-of (C4[.., a]) (K3[.., a]))
            | x :
                [g |-
                   md-of P[] F (md/letp M1 (\x565. \z565. M2)) (S3[.., C2])],
              fst :
                [g |- md-fst (md/letp M1 (\x565. \z565. M2)) (C4[.., C2])]
            ; by [g |- Dfst5[.., C2]] as Dfst' unboxed;
              by [g |- Dof3[.., C2, _]] as Dof' unboxed;
              split
              sg-fst-fun [g, a69 : con |- Dfst5] [g, a69 : con |- Dfst6] as
              case kind-eq/i:
              { g : md-fst-reg-ctx,
                P : ( |- purity),
                F : (g |- sttp),
                M1 : (g |- module'),
                M2 : (g, a68 : con, m4 : module' |- module'),
                S3 : (g, a : con |- sg),
                C2 : (g |- con),
                C4 : (g, a : con |- con),
                S1 : (g |- sg),
                K : (g |- kind),
                Dof : (g |- md-of pure F M1 S1),
                Dfst : (g |- sg-fst S1 K),
                Dfst1 : (g |- md-fst M1 C2),
                Dof1 :
                  (g, a : con, z675 : cn-of a (K[..]), m : module',
                   u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
                   y676 : md-fst m a |-
                     md-of P[] (F[..]) (M2[.., a, m]) (S3[.., a])),
                Dfst2 : (g |- md-fst M1 C2),
                Dfst3 :
                  (g, a : con, m : module', z689 : md-fst m a |-
                     md-fst (M2[.., a, m]) (C4[.., a])),
                K1 : (g |- kind),
                Dfst4 : (g |- sg-fst S1 K1),
                Dof2 : (g |- cn-of C2 K1),
                K3 : (g, a : con |- kind),
                Dfst5 : (g, a69 : con |- sg-fst S3 K3),
                Dfst6 : (g, a : con |- sg-fst S3 K3),
                Dof3 :
                  (g, a : con, da : cn-of a (K[..]) |-
                     cn-of (C4[.., a]) (K3[.., a])),
                Dfst' : (g |- sg-fst (S3[.., C2]) (K3[.., C2])),
                Dof' : (g |- cn-of (C4[.., C2]) (K3[.., C2]))
              | x :
                  [g |-
                     md-of P[] F (md/letp M1 (\x565. \z565. M2)) (S3[.., C2])],
                fst :
                  [g |- md-fst (md/letp M1 (\x565. \z565. M2)) (C4[.., C2])]
              ; solve [g |- md-fst-reg'/i _ Dfst' Dof']
              }
            }
          }
        }
      }
    }
  }
  case md-of/let:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a67 : con, m3 : module' |- module'),
    S : (g |- sg),
    C : (g |- con),
    P1 : ( |- purity),
    S1 : (g |- sg),
    K : (g |- kind),
    P2 : ( |- purity),
    Dof : (g |- md-of P1[] F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dof1 :
      (g, a : con, z673 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       y674 : md-fst m a |- md-of P2[] (F[..]) (M2[.., a, m]) (S[..]))
  | x : [g |- md-of impure F (md/let M1 (\z558. \y559. M2) S) S],
    fst : [g |- md-fst (md/let M1 (\z558. \y559. M2) S) C]
  ; impossible fst
  }
  case md-of/out:
  { g : md-fst-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    C : (g |- con),
    L : ( |- name),
    Dof : (g |- md-of P[] F M1 (sg/named L[] S))
  | x : [g |- md-of P[] F (md/out M1) S], fst : [g |- md-fst (md/out M1) C]
  ; split fst as
    case md-fst/out:
    { g : md-fst-reg-ctx,
      P : ( |- purity),
      F : (g |- sttp),
      M1 : (g |- module'),
      S : (g |- sg),
      C : (g |- con),
      L : ( |- name),
      Dof : (g |- md-of P[] F M1 (sg/named L[] S)),
      Dfst : (g |- md-fst M1 C)
    | x : [g |- md-of P[] F (md/out M1) S], fst : [g |- md-fst (md/out M1) C]
    ; split md-fst-reg' [g |- Dof] [g |- Dfst] as
      case md-fst-reg'/i:
      { g : md-fst-reg-ctx,
        P : ( |- purity),
        F : (g |- sttp),
        M1 : (g |- module'),
        S : (g |- sg),
        C : (g |- con),
        L : ( |- name),
        Dof : (g |- md-of P[] F M1 (sg/named L[] S)),
        Dfst : (g |- md-fst M1 C),
        K : (g |- kind),
        Dfst1 : (g |- sg-fst (sg/named L[] S) K),
        Dof1 : (g |- cn-of C K)
      | x : [g |- md-of P[] F (md/out M1) S],
        fst : [g |- md-fst (md/out M1) C]
      ; split [g |- Dfst1] as
        case sg-fst/named:
        { g : md-fst-reg-ctx,
          P : ( |- purity),
          F : (g |- sttp),
          M1 : (g |- module'),
          S : (g |- sg),
          C : (g |- con),
          L : ( |- name),
          Dof : (g |- md-of P[] F M1 (sg/named L[] S)),
          Dfst : (g |- md-fst M1 C),
          K : (g |- kind),
          Dfst2 : (g |- sg-fst S K),
          Dof1 : (g |- cn-of C K)
        | x : [g |- md-of P[] F (md/out M1) S],
          fst : [g |- md-fst (md/out M1) C]
        ; solve [g |- md-fst-reg'/i _ Dfst2 Dof1]
        }
      }
    }
  }
  case md-of/in:
  { g : md-fst-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    L : ( |- name),
    M1 : (g |- module'),
    S1 : (g |- sg),
    C : (g |- con),
    Dof : (g |- md-of P[] F M1 S1)
  | x : [g |- md-of P[] F (md/in L[] M1) (sg/named L[] S1)],
    fst : [g |- md-fst (md/in L[] M1) C]
  ; split fst as
    case md-fst/in:
    { g : md-fst-reg-ctx,
      P : ( |- purity),
      F : (g |- sttp),
      L : ( |- name),
      M1 : (g |- module'),
      S1 : (g |- sg),
      C : (g |- con),
      Dof : (g |- md-of P[] F M1 S1),
      Dfst : (g |- md-fst M1 C)
    | x : [g |- md-of P[] F (md/in L[] M1) (sg/named L[] S1)],
      fst : [g |- md-fst (md/in L[] M1) C]
    ; split md-fst-reg' [g |- Dof] [g |- Dfst] as
      case md-fst-reg'/i:
      { g : md-fst-reg-ctx,
        P : ( |- purity),
        F : (g |- sttp),
        L : ( |- name),
        M1 : (g |- module'),
        S1 : (g |- sg),
        C : (g |- con),
        Dof : (g |- md-of P[] F M1 S1),
        Dfst : (g |- md-fst M1 C),
        K : (g |- kind),
        Dfst1 : (g |- sg-fst S1 K),
        Dof1 : (g |- cn-of C K)
      | x : [g |- md-of P[] F (md/in L[] M1) (sg/named L[] S1)],
        fst : [g |- md-fst (md/in L[] M1) C]
      ; solve [g |- md-fst-reg'/i _ (sg-fst/named Dfst1) Dof1]
      }
    }
  }
  case md-of/app:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g |- module'),
    S2 : (g, a66 : con |- sg),
    C1 : (g |- con),
    C : (g |- con),
    P1 : ( |- purity),
    S1 : (g |- sg),
    Dof : (g |- md-of P1[] F M1 (sg/pi S1 (\y531. S2))),
    Dof1 : (g |- md-of pure F M2 S1),
    Dfst : (g |- md-fst M2 C1)
  | x : [g |- md-of impure F (md/app M1 M2) (S2[.., C1])],
    fst : [g |- md-fst (md/app M1 M2) C]
  ; impossible fst
  }
  case md-of/lam:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    S1 : (g |- sg),
    M1 : (g, a64 : con, m2 : module' |- module'),
    S2 : (g, a65 : con |- sg),
    C : (g |- con),
    K : (g |- kind),
    P1 : ( |- purity),
    Dwf : (g |- sg-wf S1),
    Dfst : (g |- sg-fst S1 K),
    Dof :
      (g, a : con, x670 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       z670 : md-fst m a |- md-of P1[] (F[..]) (M1[.., a, m]) (S2[.., a]))
  | x :
      [g |-
         md-of pure F (md/lam S1 (\x555. \z555. M1)) (sg/pi S1 (\y531. S2))],
    fst : [g |- md-fst (md/lam S1 (\x555. \z555. M1)) C]
  ; split fst as
    case md-fst/lam:
    { g : md-fst-reg-ctx,
      F : (g |- sttp),
      S1 : (g |- sg),
      M1 : (g, a64 : con, m2 : module' |- module'),
      S2 : (g, a65 : con |- sg),
      K : (g |- kind),
      P1 : ( |- purity),
      Dwf : (g |- sg-wf S1),
      Dfst : (g |- sg-fst S1 K),
      Dof :
        (g, a : con, x670 : cn-of a (K[..]), m : module',
         u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
         z670 : md-fst m a |- md-of P1[] (F[..]) (M1[.., a, m]) (S2[.., a]))
    | x :
        [g |-
           md-of pure F (md/lam S1 (\z560. \y561. M1)) (sg/pi S1 (\x536. S2))],
      fst : [g |- md-fst (md/lam S1 (\z560. \y561. M1)) star]
    ; solve [g |- md-fst-reg'/i _ (sg-fst/pi ) cn-of/star]
    }
  }
  case md-of/pi2:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S2 : (g, a63 : con |- sg),
    C1 : (g |- con),
    C : (g |- con),
    S1 : (g |- sg),
    Dof : (g |- md-of pure F M1 (sg/sigma S1 (\y532. S2))),
    Dfst : (g |- md-fst M1 C1)
  | x : [g |- md-of pure F (md/pi2 M1) (S2[.., pi1 C1])],
    fst : [g |- md-fst (md/pi2 M1) C]
  ; split fst as
    case md-fst/pi2:
    { g : md-fst-reg-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      S2 : (g, a63 : con |- sg),
      C1 : (g |- con),
      C2 : (g |- con),
      S1 : (g |- sg),
      Dof : (g |- md-of pure F M1 (sg/sigma S1 (\y532. S2))),
      Dfst : (g |- md-fst M1 C1),
      Dfst1 : (g |- md-fst M1 C2)
    | x : [g |- md-of pure F (md/pi2 M1) (S2[.., pi1 C1])],
      fst : [g |- md-fst (md/pi2 M1) (pi2 C2)]
    ; split md-fst-reg' [g |- Dof] [g |- Dfst] as
      case md-fst-reg'/i:
      { g : md-fst-reg-ctx,
        F : (g |- sttp),
        M1 : (g |- module'),
        S2 : (g, a63 : con |- sg),
        C1 : (g |- con),
        C2 : (g |- con),
        S1 : (g |- sg),
        Dof : (g |- md-of pure F M1 (sg/sigma S1 (\y532. S2))),
        Dfst : (g |- md-fst M1 C1),
        Dfst1 : (g |- md-fst M1 C2),
        K : (g |- kind),
        Dfst2 : (g |- sg-fst (sg/sigma S1 (\y532. S2)) K),
        Dof1 : (g |- cn-of C1 K)
      | x : [g |- md-of pure F (md/pi2 M1) (S2[.., pi1 C1])],
        fst : [g |- md-fst (md/pi2 M1) (pi2 C2)]
      ; split [g |- Dfst2] as
        case sg-fst/sigma:
        { g : md-fst-reg-ctx,
          F : (g |- sttp),
          M1 : (g |- module'),
          S2 : (g, a63 : con |- sg),
          C1 : (g |- con),
          C2 : (g |- con),
          S1 : (g |- sg),
          Dof : (g |- md-of pure F M1 (sg/sigma S1 (\y532. S2))),
          Dfst : (g |- md-fst M1 C1),
          Dfst1 : (g |- md-fst M1 C2),
          K1 : (g |- kind),
          K2 : (g, a59 : con |- kind),
          Dfst3 : (g |- sg-fst S1 K1),
          Dfst4 : (g, a : con |- sg-fst S2 K2),
          Dof1 : (g |- cn-of C1 (sigma K1 (\z522. K2)))
        | x : [g |- md-of pure F (md/pi2 M1) (S2[.., pi1 C1])],
          fst : [g |- md-fst (md/pi2 M1) (pi2 C2)]
        ; split md-fst-fun [g |- Dfst] [g |- Dfst1] as
          case con-eq/i:
          { g : md-fst-reg-ctx,
            F : (g |- sttp),
            M1 : (g |- module'),
            S2 : (g, a63 : con |- sg),
            C2 : (g |- con),
            S1 : (g |- sg),
            Dof : (g |- md-of pure F M1 (sg/sigma S1 (\y532. S2))),
            Dfst : (g |- md-fst M1 C2),
            Dfst1 : (g |- md-fst M1 C2),
            K1 : (g |- kind),
            K2 : (g, a59 : con |- kind),
            Dfst3 : (g |- sg-fst S1 K1),
            Dfst4 : (g, a : con |- sg-fst S2 K2),
            Dof1 : (g |- cn-of C2 (sigma K1 (\z522. K2)))
          | x : [g |- md-of pure F (md/pi2 M1) (S2[.., pi1 C2])],
            fst : [g |- md-fst (md/pi2 M1) (pi2 C2)]
          ; solve [g |- md-fst-reg'/i _ (Dfst4[.., pi1 C2]) (cn-of/pi2 Dof1)]
          }
        }
      }
    }
  }
  case md-of/pi1:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    C : (g |- con),
    S2 : (g, a62 : con |- sg),
    Dof : (g |- md-of pure F M1 (sg/sigma S (\y532. S2)))
  | x : [g |- md-of pure F (md/pi1 M1) S], fst : [g |- md-fst (md/pi1 M1) C]
  ; split fst as
    case md-fst/pi1:
    { g : md-fst-reg-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      S : (g |- sg),
      C1 : (g |- con),
      S2 : (g, a62 : con |- sg),
      Dof : (g |- md-of pure F M1 (sg/sigma S (\y532. S2))),
      Dfst : (g |- md-fst M1 C1)
    | x : [g |- md-of pure F (md/pi1 M1) S],
      fst : [g |- md-fst (md/pi1 M1) (pi1 C1)]
    ; split md-fst-reg' [g |- Dof] [g |- Dfst] as
      case md-fst-reg'/i:
      { g : md-fst-reg-ctx,
        F : (g |- sttp),
        M1 : (g |- module'),
        S : (g |- sg),
        C1 : (g |- con),
        S2 : (g, a62 : con |- sg),
        Dof : (g |- md-of pure F M1 (sg/sigma S (\y532. S2))),
        Dfst : (g |- md-fst M1 C1),
        K : (g |- kind),
        Dfst1 : (g |- sg-fst (sg/sigma S (\y532. S2)) K),
        Dof1 : (g |- cn-of C1 K)
      | x : [g |- md-of pure F (md/pi1 M1) S],
        fst : [g |- md-fst (md/pi1 M1) (pi1 C1)]
      ; split [g |- Dfst1] as
        case sg-fst/sigma:
        { g : md-fst-reg-ctx,
          F : (g |- sttp),
          M1 : (g |- module'),
          S : (g |- sg),
          C1 : (g |- con),
          S2 : (g, a62 : con |- sg),
          Dof : (g |- md-of pure F M1 (sg/sigma S (\y532. S2))),
          Dfst : (g |- md-fst M1 C1),
          K1 : (g |- kind),
          K2 : (g, a59 : con |- kind),
          Dfst2 : (g |- sg-fst S K1),
          Dfst3 : (g, a : con |- sg-fst S2 K2),
          Dof1 : (g |- cn-of C1 (sigma K1 (\z522. K2)))
        | x : [g |- md-of pure F (md/pi1 M1) S],
          fst : [g |- md-fst (md/pi1 M1) (pi1 C1)]
        ; solve [g |- md-fst-reg'/i _ Dfst2 (cn-of/pi1 Dof1)]
        }
      }
    }
  }
  case md-of/dpair:
  { g : md-fst-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a60 : con, m1 : module' |- module'),
    S1 : (g |- sg),
    S2 : (g, a61 : con |- sg),
    C : (g |- con),
    K : (g |- kind),
    Dof : (g |- md-of P[] F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dof1 :
      (g, a : con, z667 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       y668 : md-fst m a |- md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a]))
  | x :
      [g |- md-of P[] F (md/dpair M1 (\a. \m. M2)) (sg/sigma S1 (\y532. S2))],
    fst : [g |- md-fst (md/dpair M1 (\a. \m. M2)) C]
  ; split fst as
    case md-fst/dpair:
    { g : md-fst-reg-ctx,
      P : ( |- purity),
      F : (g |- sttp),
      M1 : (g |- module'),
      M2 : (g, a60 : con, m1 : module' |- module'),
      S1 : (g |- sg),
      S2 : (g, a61 : con |- sg),
      C1 : (g |- con),
      C2 : (g, a71 : con |- con),
      K : (g |- kind),
      DofM1 : (g |- md-of P[] F M1 S1),
      DfstS1 : (g |- sg-fst S1 K),
      DofM2 :
        (g, a : con, z667 : cn-of a (K[..]), m : module',
         u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
         y668 : md-fst m a |- md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a])),
      Dfst : (g |- md-fst M1 C1),
      Dfst1 :
        (g, a : con, m : module', x687 : md-fst m a |-
           md-fst (M2[.., a, m]) (C2[.., a]))
    | x :
        [g |-
           md-of P[] F (md/dpair M1 (\a. \m. M2)) (sg/sigma S1 (\x537. S2))],
      fst : [g |- md-fst (md/dpair M1 (\a. \m. M2)) (pair C1 (C2[.., C1]))]
    ; split md-fst-reg' [g |- DofM1] [g |- Dfst] as
      case md-fst-reg'/i:
      { g : md-fst-reg-ctx,
        P : ( |- purity),
        F : (g |- sttp),
        M1 : (g |- module'),
        M2 : (g, a60 : con, m1 : module' |- module'),
        S1 : (g |- sg),
        S2 : (g, a61 : con |- sg),
        C1 : (g |- con),
        C2 : (g, a71 : con |- con),
        K : (g |- kind),
        DofM1 : (g |- md-of P[] F M1 S1),
        DfstS1 : (g |- sg-fst S1 K),
        DofM2 :
          (g, a : con, z667 : cn-of a (K[..]), m : module',
           u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
           y668 : md-fst m a |- md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a])),
        DfstM1 : (g |- md-fst M1 C1),
        DfstM2 :
          (g, a : con, m : module', x687 : md-fst m a |-
             md-fst (M2[.., a, m]) (C2[.., a])),
        K1 : (g |- kind),
        Dfst : (g |- sg-fst S1 K1),
        Dof : (g |- cn-of C1 K1)
      | x :
          [g |-
             md-of P[] F (md/dpair M1 (\a. \m. M2)) (sg/sigma S1 (\x537. S2))],
        fst : [g |- md-fst (md/dpair M1 (\a. \m. M2)) (pair C1 (C2[.., C1]))]
      ; split
        md-fst-reg'
          [g,
           b :
             block (
               a : con,
               da : cn-of a (K[..]),
               m : module',
               u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
               dfst : md-fst m a) |- DofM2[.., b.1, b.2, b.3, b.4, b.5]]
          [g,
           b :
             block (
               a : con,
               da : cn-of a (K[..]),
               m : module',
               u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
               dfst : md-fst m a) |- DfstM2[.., b.1, b.3, b.5]] as
        case md-fst-reg'/i:
        { g : md-fst-reg-ctx,
          P : ( |- purity),
          F : (g |- sttp),
          M1 : (g |- module'),
          M2 : (g, a60 : con, m1 : module' |- module'),
          S1 : (g |- sg),
          S3 : (g, a : con |- sg),
          C1 : (g |- con),
          C3 : (g, a : con |- con),
          K : (g |- kind),
          DofM1 : (g |- md-of P[] F M1 S1),
          DfstS1 : (g |- sg-fst S1 K),
          DofM2 :
            (g, a : con, z667 : cn-of a (K[..]), m : module',
             u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
             y668 : md-fst m a |-
               md-of P[] (F[..]) (M2[.., a, m]) (S3[.., a])),
          DfstM1 : (g |- md-fst M1 C1),
          DfstM2 :
            (g, a : con, m : module', x687 : md-fst m a |-
               md-fst (M2[.., a, m]) (C3[.., a])),
          K1 : (g |- kind),
          Dfst : (g |- sg-fst S1 K1),
          DofC1 : (g |- cn-of C1 K1),
          K2 : (g, a : con |- kind),
          Dfst1 : (g, a : con |- sg-fst S3 K2),
          Dof :
            (g, a : con, da : cn-of a (K[..]) |-
               cn-of (C3[.., a]) (K2[.., a]))
        | x :
            [g |-
               md-of
                 P[] F (md/dpair M1 (\a. \m. M2)) (sg/sigma S1 (\x537. S3))],
          fst :
            [g |- md-fst (md/dpair M1 (\a. \m. M2)) (pair C1 (C3[.., C1]))]
        ; by cn-of-reg
               [g, b : block (a : con, da : cn-of a (K[..])) |-
                  Dof[.., b.1, b.2]]
          as DwfK2 unboxed;
          by [g |- sg-fst/sigma Dfst (\a. Dfst1)] as Dfst' unboxed;
          by [g |- cn-of/pair DofC1 (Dof[.., C1, _]) (\a. \da. DwfK2[.., <a; _>])]
as Dof' unboxed;
          solve [g |- md-fst-reg'/i _ Dfst' Dof']
        }
      }
    }
  }
  case md-of/pair:
  { g : md-fst-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g |- module'),
    S1 : (g |- sg),
    S2 : (g |- sg),
    C : (g |- con),
    Dof : (g |- md-of P[] F M1 S1),
    Dof1 : (g |- md-of P[] F M2 S2)
  | x : [g |- md-of P[] F (md/pair M1 M2) (sg/sigma S1 (\x. S2[..]))],
    fst : [g |- md-fst (md/pair M1 M2) C]
  ; split fst as
    case md-fst/pair:
    { g : md-fst-reg-ctx,
      P : ( |- purity),
      F : (g |- sttp),
      M1 : (g |- module'),
      M2 : (g |- module'),
      S1 : (g |- sg),
      S2 : (g |- sg),
      C1 : (g |- con),
      C2 : (g |- con),
      Dof : (g |- md-of P[] F M1 S1),
      Dof1 : (g |- md-of P[] F M2 S2),
      Dfst : (g |- md-fst M1 C1),
      Dfst1 : (g |- md-fst M2 C2)
    | x : [g |- md-of P[] F (md/pair M1 M2) (sg/sigma S1 (\x. S2[..]))],
      fst : [g |- md-fst (md/pair M1 M2) (pair C1 C2)]
    ; split md-fst-reg' [g |- Dof] [g |- Dfst] as
      case md-fst-reg'/i:
      { g : md-fst-reg-ctx,
        P : ( |- purity),
        F : (g |- sttp),
        M1 : (g |- module'),
        M2 : (g |- module'),
        S1 : (g |- sg),
        S2 : (g |- sg),
        C1 : (g |- con),
        C2 : (g |- con),
        Dof : (g |- md-of P[] F M1 S1),
        Dof1 : (g |- md-of P[] F M2 S2),
        Dfst : (g |- md-fst M1 C1),
        Dfst1 : (g |- md-fst M2 C2),
        K : (g |- kind),
        Dfst2 : (g |- sg-fst S1 K),
        Dof2 : (g |- cn-of C1 K)
      | x : [g |- md-of P[] F (md/pair M1 M2) (sg/sigma S1 (\x. S2[..]))],
        fst : [g |- md-fst (md/pair M1 M2) (pair C1 C2)]
      ; split md-fst-reg' [g |- Dof1] [g |- Dfst1] as
        case md-fst-reg'/i:
        { g : md-fst-reg-ctx,
          P : ( |- purity),
          F : (g |- sttp),
          M1 : (g |- module'),
          M2 : (g |- module'),
          S1 : (g |- sg),
          S2 : (g |- sg),
          C1 : (g |- con),
          C2 : (g |- con),
          Dof : (g |- md-of P[] F M1 S1),
          Dof1 : (g |- md-of P[] F M2 S2),
          Dfst : (g |- md-fst M1 C1),
          Dfst1 : (g |- md-fst M2 C2),
          K : (g |- kind),
          Dfst2 : (g |- sg-fst S1 K),
          Dof2 : (g |- cn-of C1 K),
          K1 : (g |- kind),
          Dfst3 : (g |- sg-fst S2 K1),
          Dof3 : (g |- cn-of C2 K1)
        | x : [g |- md-of P[] F (md/pair M1 M2) (sg/sigma S1 (\x. S2[..]))],
          fst : [g |- md-fst (md/pair M1 M2) (pair C1 C2)]
        ; by cn-of-reg [g |- Dof3] as DwfK2 unboxed;
          by [g |- sg-fst/sigma Dfst2 (\a. Dfst3[..])] as Dfst' unboxed;
          by [g |- cn-of/pair Dof2 Dof3 (\a. \da. DwfK2[..])] as Dof' unboxed;
          solve [g |- md-fst-reg'/i _ Dfst' Dof']
        }
      }
    }
  }
  case md-of/datom:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    E : (g |- term),
    C1 : (g |- con),
    C : (g |- con),
    Dof : (g |- tm-of F E C1)
  | x : [g |- md-of pure F (md/datom E C1) (sg/datom C1)],
    fst : [g |- md-fst (md/datom E C1) C]
  ; split fst as
    case md-fst/datom:
    { g : md-fst-reg-ctx,
      F : (g |- sttp),
      E : (g |- term),
      C1 : (g |- con),
      Dof : (g |- tm-of F E C1)
    | x : [g |- md-of pure F (md/datom E C1) (sg/datom C1)],
      fst : [g |- md-fst (md/datom E C1) star]
    ; solve [g |- md-fst-reg'/i _ (sg-fst/datom ) cn-of/star]
    }
  }
  case md-of/sgatom:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    S1 : (g |- sg),
    C : (g |- con),
    Dwf : (g |- sg-wf S1)
  | x : [g |- md-of pure F (md/sgatom S1) (sg/sgatom S1)],
    fst : [g |- md-fst (md/sgatom S1) C]
  ; split fst as
    case md-fst/sgatom:
    { g : md-fst-reg-ctx,
      F : (g |- sttp),
      S1 : (g |- sg),
      Dwf : (g |- sg-wf S1)
    | x : [g |- md-of pure F (md/sgatom S1) (sg/sgatom S1)],
      fst : [g |- md-fst (md/sgatom S1) star]
    ; solve [g |- md-fst-reg'/i _ (sg-fst/sgatom ) cn-of/star]
    }
  }
  case md-of/satom:
  { g : md-fst-reg-ctx,
    F : (g |- sttp),
    C1 : (g |- con),
    K : (g |- kind),
    C : (g |- con),
    Dof : (g |- cn-of C1 K)
  | x : [g |- md-of pure F (md/satom C1) (sg/satom K)],
    fst : [g |- md-fst (md/satom C1) C]
  ; split fst as
    case md-fst/satom:
    { g : md-fst-reg-ctx,
      F : (g |- sttp),
      C : (g |- con),
      K : (g |- kind),
      Dof : (g |- cn-of C K)
    | x : [g |- md-of pure F (md/satom C) (sg/satom K)],
      fst : [g |- md-fst (md/satom C) C]
    ; solve [g |- md-fst-reg'/i _ (sg-fst/satom ) Dof]
    }
  }
  case md-of/unit:
  { g : md-fst-reg-ctx, F : (g |- sttp), C : (g |- con)
  | x : [g |- md-of pure F md/unit sg/one], fst : [g |- md-fst md/unit C]
  ; split fst as
    case md-fst/unit:
    { g : md-fst-reg-ctx, F : (g |- sttp)
    | x : [g |- md-of pure F md/unit sg/one],
      fst : [g |- md-fst md/unit star]
    ; solve [g |- md-fst-reg'/i _ sg-fst/one cn-of/star]
    }
  }
  %{ FIXME: Uncaught exception. Not_found
  case #.4:
  { g : md-fst-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    K1273 : (g |- kind),
    S : (g |- sg),
    #fst :
      #(g |-
          block (
            a : con,
            da : cn-of a (K1273[..]),
            m : module',
            dm : {P' : purity}  {F' : sttp}  md-of P' F' m (S[..]),
            dfst : md-fst m a)),
    C : (g |- con),
    Dwf204 : (g |- kd-wf K1273),
    Dwf63 : (g |- sg-wf S),
    Dfst67 : (g |- sg-fst S K1273)
  | x : [g |- md-of P[] F #fst.3 S], fst : [g |- md-fst #fst.3 C]
  ; ?
  }
  }%
}
;

proof md-fst-reg :
  (g : md-fst-reg-ctx)
  [g |- md-of P F M S] ->
  [g |- md-fst M C] ->
  [g |- sg-fst S K] ->
    [g |- cn-of C K] =
/ total /
intros
{ g : md-fst-reg-ctx,
  P : (g |- purity),
  F : (g |- sttp),
  M : (g |- module'),
  S : (g |- sg),
  C : (g |- con),
  K : (g |- kind)
| mof : [g |- md-of P F M S],
  fst : [g |- md-fst M C],
  fst1 : [g |- sg-fst S K]
; split md-fst-reg' mof fst as
  case md-fst-reg'/i:
  { g : md-fst-reg-ctx,
    P : (g |- purity),
    F : (g |- sttp),
    M : (g |- module'),
    S : (g |- sg),
    C : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dfst : (g |- sg-fst S K1),
    Dof : (g |- cn-of C K1)
  | mof : [g |- md-of P F M S],
    fst : [g |- md-fst M C],
    fst1 : [g |- sg-fst S K]
  ; split sg-fst-fun [_ |- Dfst] fst1 as
    case kind-eq/i:
    { g : md-fst-reg-ctx,
      P : (g |- purity),
      F : (g |- sttp),
      M : (g |- module'),
      S : (g |- sg),
      C : (g |- con),
      K : (g |- kind),
      Dfst : (g |- sg-fst S K),
      Dof : (g |- cn-of C K)
    | mof : [g |- md-of P F M S],
      fst : [g |- md-fst M C],
      fst1 : [g |- sg-fst S K]
    ; solve [_ |- Dof]
    }
  }
}
;

schema tm-of-reg-ctx =
  % conbind
  some [K : kind]
  block (a : con, da : cn-of a K) +
  % conbind-reg
  some [K : kind, wf : kd-wf K]
  block (a : con, da : cn-of a K) +
  % termbind-reg
  some [T : con, Dwf : cn-of T t]
  block (x : term, d : { F' : sttp } tm-of F' x T);

schema md-of-reg-ctx =
  % conbind
  some [K : kind]
  block (a : con, da : cn-of a K) +
  % conbind-reg
  some [K : kind, wf : kd-wf K]
  block (a : con, da : cn-of a K) +
  % termbind-reg
  some [T : con, Dwf : cn-of T t]
  block (x : term, d : { F' : sttp } tm-of F' x T) +
  % modbind-reg
  some [K : kind, S : sg, DwfK : kd-wf K, DwfS : sg-wf S, DfstS : sg-fst S K]
  block (
    a : con, da : cn-of a K,
    m : module', dm : { P' : purity } { F' : sttp } md-of P' F' m S,
    dfst : md-fst m a
  );

proof tm-of-reg :
  (g : tm-of-reg-ctx)
  [g |- tm-of F E T] ->
    [g |- cn-of T t] =
/ total 1 /
intros
{ g : tm-of-reg-ctx, F : (g |- sttp), E : (g |- term), T : (g |- con)
| x : [g |- tm-of F E T]
; split x as
  case tm-of/equiv:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E : (g |- term),
    T : (g |- con),
    C : (g |- con),
    Dof : (g |- tm-of F E C),
    Dequiv : (g |- cn-equiv C T t)
  | x : [g |- tm-of F E T]
  ; split cn-equiv-reg [g |- Dequiv] as
    case cn-equiv-reg/i:
    { g : tm-of-reg-ctx,
      F : (g |- sttp),
      E : (g |- term),
      T : (g |- con),
      C : (g |- con),
      Dof : (g |- tm-of F E C),
      Dequiv : (g |- cn-equiv C T t),
      Dof1 : (g |- cn-of C t),
      Dof2 : (g |- cn-of T t),
      Dwf : (g |- kd-wf t)
    | x : [g |- tm-of F E T]
    ; solve [g |- Dof2]
    }
  }
  case tm-of/snd:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    T : (g |- con),
    P : ( |- purity),
    Dof : (g |- md-of P[] F M (sg/datom T))
  | x : [g |- tm-of F (tm/snd M) T]
  ; split md-of-reg [g |- Dof] as
    case sg-wf/datom:
    { g : tm-of-reg-ctx,
      F : (g |- sttp),
      M : (g |- module'),
      T : (g |- con),
      P : ( |- purity),
      Dof : (g |- md-of P[] F M (sg/datom T)),
      Dof1 : (g |- cn-of T t)
    | x : [g |- tm-of F (tm/snd M) T]
    ; solve [g |- Dof1]
    }
  }
  case tm-of/lett:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g, x6 : term |- term),
    T : (g |- con),
    C : (g |- con),
    Dof : (g |- tm-of F E1 C),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         tm-of (F[..]) (E2[.., x]) (T[..]))
  | x : [g |- tm-of F (tm/lett E1 (\x. E2)) T]
  ; ?
  }
  case tm-of/try:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g, x5 : term |- term),
    T : (g |- con),
    Dof : (g |- tm-of F E1 T),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x tagged |-
         tm-of (F[..]) (E2[.., x]) (T[..]))
  | x : [g |- tm-of F (tm/try E1 (\x. E2)) T]
  ; solve tm-of-reg [g |- Dof]
  }
  case tm-of/raise:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    Dof : (g |- tm-of F E1 tagged),
    Dof1 : (g |- cn-of T t)
  | x : [g |- tm-of F (tm/raise E1 T) T]
  ; solve [_ |- Dof1]
  }
  case tm-of/out:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    X : ( |- label),
    Dof : (g |- tm-of F E1 (labeled X[] T))
  | x : [g |- tm-of F (tm/out E1) T]
  ; by tm-of-reg [g |- Dof] as Dwf unboxed;
    solve inversion-labeled [g |- Dwf]
  }
  case tm-of/in:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    X : ( |- label),
    E1 : (g |- term),
    C : (g |- con),
    Dof : (g |- tm-of F E1 C)
  | x : [g |- tm-of F (tm/in X[] E1) (labeled X[] C)]
  ; by tm-of-reg [g |- Dof] as Dwf unboxed;
    solve [g |- cn-of/labeled Dwf]
  }
  case tm-of/unroll:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    C : (g, a46 : con, a45 : con |- con),
    C1 : (g |- con),
    K : (g |- kind),
    Dof : (g |- tm-of F E1 (rec' K (\y478. \x478. C) C1))
  | x :
      [g |-
         tm-of
           F
           (tm/unroll E1)
           (C[.., lam K
              (\a. rec' (K[..]) (\y478. \x478. C[.., y478, x478]) a), C1])]
  ; ?
  }
  case tm-of/roll:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    K : (g |- kind),
    C : (g, a44 : con, a43 : con |- con),
    C1 : (g |- con),
    Dof :
      (g |-
         tm-of
           F
           E1
           (C[.., lam K
              (\a. rec' (K[..]) (\y478. \x478. C[.., y478, x478]) a), C1])),
    Dwf : (g |- kd-wf K),
    Dof1 :
      (g, a : con, y596 : cn-of a (pi (K[..]) (\l. t)), b : con,
       x596 : cn-of b (K[..]) |- cn-of (C[.., a, b]) t),
    Dof2 : (g |- cn-of C1 K)
  | x :
      [g |-
         tm-of
           F
           (tm/roll E1 K (\x499. \z499. C) C1) (rec' K (\y478. \x478. C) C1)]
  ; solve [g |- cn-of/rec Dwf (\a. \da. \b. \db. Dof1) Dof2]
  }
  case tm-of/iftag:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g |- term),
    E3 : (g, x4 : term |- term),
    E4 : (g |- term),
    T : (g |- con),
    C : (g |- con),
    Dof : (g |- tm-of F E1 tagged),
    Dof1 : (g |- tm-of F E2 (tag C)),
    Dof2 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         tm-of (F[..]) (E3[.., x]) (T[..])),
    Dof3 : (g |- tm-of F E4 T)
  | x : [g |- tm-of F (tm/iftag E1 E2 (\z497. E3) E4) T]
  ; solve tm-of-reg [g |- Dof3]
  }
  case tm-of/tag:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g |- term),
    C : (g |- con),
    Dof : (g |- tm-of F E1 (tag C)),
    Dof1 : (g |- tm-of F E2 C)
  | x : [g |- tm-of F (tm/tag E1 E2) tagged]
  ; solve [g |- cn-of/tagged]
  }
  case tm-of/newtag:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    C : (g |- con),
    Dof : (g |- cn-of C t)
  | x : [g |- tm-of F (tm/newtag C) (tag C)]
  ; solve [g |- cn-of/tag Dof]
  }
  case tm-of/tagloc:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    Dloc : ( |- location),
    C : (g |- con),
    Dlookup : (g |- st-lookup F Dloc[] (et/tag C)),
    Dof : (g |- cn-of C t)
  | x : [g |- tm-of F (tm/tagloc Dloc[]) (tag C)]
  ; solve [g |- cn-of/tag Dof]
  }
  case tm-of/assign:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g |- term),
    C : (g |- con),
    Dof : (g |- tm-of F E1 (ref C)),
    Dof1 : (g |- tm-of F E2 C)
  | x : [g |- tm-of F (tm/assign E1 E2) unit]
  ; solve [g |- cn-of/unit]
  }
  case tm-of/deref:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    Dof : (g |- tm-of F E1 (ref T))
  | x : [g |- tm-of F (tm/deref E1) T]
  ; by tm-of-reg [g |- Dof] as Dwf unboxed;
    solve inversion-ref [g |- Dwf]
  }
  case tm-of/ref:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    C : (g |- con),
    Dof : (g |- tm-of F E1 C)
  | x : [g |- tm-of F (tm/ref E1) (ref C)]
  ; by tm-of-reg [g |- Dof] as Dwf unboxed;
    solve [g |- cn-of/ref Dwf]
  }
  case tm-of/refloc:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    Dloc : ( |- location),
    C : (g |- con),
    Dlookup : (g |- st-lookup F Dloc[] (et/ref C)),
    Dof : (g |- cn-of C t)
  | x : [g |- tm-of F (tm/refloc Dloc[]) (ref C)]
  ; solve [g |- cn-of/ref Dof]
  }
  case tm-of/case:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g, x2 : term |- term),
    E3 : (g, x3 : term |- term),
    T : (g |- con),
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- tm-of F E1 (plus C C1)),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         tm-of (F[..]) (E2[.., x]) (T[..])),
    Dof2 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C1[..]) |-
         tm-of (F[..]) (E3[.., x]) (T[..]))
  | x : [g |- tm-of F (tm/case E1 (\y493. E2) (\z492. E3)) T]
  ; by tm-of-reg
     [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
        Dof1[.., b.1, b.2]]
as Dwf' unboxed;
    ?
  }
  case tm-of/in2:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    C1 : (g |- con),
    C : (g |- con),
    Dof : (g |- tm-of F E1 C),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- tm-of F (tm/in2 E1 C1) (plus C1 C)]
  ; by tm-of-reg [g |- Dof] as Dwf1 unboxed;
    solve [g |- cn-of/plus Dof1 Dwf1]
  }
  case tm-of/in1:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    C1 : (g |- con),
    C : (g |- con),
    Dof : (g |- tm-of F E1 C),
    Dof1 : (g |- cn-of C1 t)
  | x : [g |- tm-of F (tm/in1 E1 C1) (plus C C1)]
  ; by tm-of-reg [g |- Dof] as Dwf1 unboxed;
    solve [g |- cn-of/plus Dwf1 Dof1]
  }
  case tm-of/app:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g |- term),
    T : (g |- con),
    C : (g |- con),
    Dof : (g |- tm-of F E1 (arrow C T)),
    Dof1 : (g |- tm-of F E2 C)
  | x : [g |- tm-of F (tm/app E1 E2) T]
  ; by tm-of-reg [g |- Dof] as Dwf unboxed;
    split inversion-arrow [g |- Dwf] as
    case inversion-arrow/i:
    { g : tm-of-reg-ctx,
      F : (g |- sttp),
      E1 : (g |- term),
      E2 : (g |- term),
      T : (g |- con),
      C : (g |- con),
      Dof : (g |- tm-of F E1 (arrow C T)),
      Dof1 : (g |- tm-of F E2 C),
      Dwf : (g |- cn-of (arrow C T) t),
      Dof2 : (g |- cn-of C t),
      Dof3 : (g |- cn-of T t)
    | x : [g |- tm-of F (tm/app E1 E2) T]
    ; solve [g |- Dof3]
    }
  }
  case tm-of/lam:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    C : (g |- con),
    E1 : (g, x1 : term |- term),
    C1 : (g |- con),
    Dof : (g |- cn-of C t),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         tm-of (F[..]) (E1[.., x]) (C1[..]))
  | x : [g |- tm-of F (tm/lam C (\x. E1)) (arrow C C1)]
  ; by tm-of-reg
     [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
        Dof1[.., b.1, b.2]]
as Dwf2' unboxed;
    ?
  }
  case tm-of/pi2:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    C : (g |- con),
    Dof : (g |- tm-of F E1 (prod C T))
  | x : [g |- tm-of F (tm/pi2 E1) T]
  ; by tm-of-reg [g |- Dof] as Dwf unboxed;
    split inversion-prod [g |- Dwf] as
    case inversion-prod/i:
    { g : tm-of-reg-ctx,
      F : (g |- sttp),
      E1 : (g |- term),
      T : (g |- con),
      C : (g |- con),
      Dof : (g |- tm-of F E1 (prod C T)),
      Dwf : (g |- cn-of (prod C T) t),
      Dof1 : (g |- cn-of C t),
      Dof2 : (g |- cn-of T t)
    | x : [g |- tm-of F (tm/pi2 E1) T]
    ; solve [g |- Dof2]
    }
  }
  case tm-of/pi1:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    C1 : (g |- con),
    Dof : (g |- tm-of F E1 (prod T C1))
  | x : [g |- tm-of F (tm/pi1 E1) T]
  ; by tm-of-reg [g |- Dof] as Dwf unboxed;
    split inversion-prod [g |- Dwf] as
    case inversion-prod/i:
    { g : tm-of-reg-ctx,
      F : (g |- sttp),
      E1 : (g |- term),
      T : (g |- con),
      C1 : (g |- con),
      Dof : (g |- tm-of F E1 (prod T C1)),
      Dwf : (g |- cn-of (prod T C1) t),
      Dof1 : (g |- cn-of T t),
      Dof2 : (g |- cn-of C1 t)
    | x : [g |- tm-of F (tm/pi1 E1) T]
    ; solve [g |- Dof1]
    }
  }
  case tm-of/pair:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    E2 : (g |- term),
    C : (g |- con),
    C1 : (g |- con),
    Dof : (g |- tm-of F E1 C),
    Dof1 : (g |- tm-of F E2 C1)
  | x : [g |- tm-of F (tm/pair E1 E2) (prod C C1)]
  ; by tm-of-reg [g |- Dof] as Dwf1 unboxed;
    by tm-of-reg [g |- Dof1] as Dwf2 unboxed;
    solve [g |- cn-of/prod Dwf1 Dwf2]
  }
  case tm-of/abort:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    E1 : (g |- term),
    T : (g |- con),
    Dof : (g |- cn-of T t),
    Dof1 : (g |- tm-of F E1 void)
  | x : [g |- tm-of F (tm/abort E1 T) T]
  ; solve [_ |- Dof]
  }
  case tm-of/unit:
  { g : tm-of-reg-ctx, F : (g |- sttp)
  | x : [g |- tm-of F tm/unit unit]
  ; solve [g |- cn-of/unit]
  }
  %{ FIXME: Type-checking error.
      Ill-typed expression.
          Expected type:
            [?g[^0] |-
              tm-of (?F_497096[^0][..]) (?E_497097[^0][..]) (?T_497098[^0][..])]
          Inferred type:
            [?g[^0] |- cn-of (?#cof_497100.1[^0][..]) (?K419_497099[^0][..])]
  case #.2:
  { g : tm-of-reg-ctx,
    F : (g |- sttp),
    T : (g |- con),
    #tof : #(g |- block (x : term, d : {F' : sttp}  tm-of F' x (T[..]))),
    Dof325 : (g |- cn-of T t)
  | x : [g |- tm-of F #tof.1 T]
  ; solve [_ |- Dof325]
  }
  }%
}

and proof md-of-reg :
  (g : md-of-reg-ctx)
  [g |- md-of P F M S] ->
    [g |- sg-wf S] =
/ total 1 /
intros
{ g : md-of-reg-ctx,
  P : (g |- purity),
  F : (g |- sttp),
  M : (g |- module'),
  S : (g |- sg)
| x : [g |- md-of P F M S]
; split x as
  case md-of/subsume:
  { g : md-of-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M : (g |- module'),
    S : (g |- sg),
    S1 : (g |- sg),
    Dof : (g |- md-of P[] F M S1),
    Dsub : (g |- sg-sub S1 S)
  | x : [g |- md-of P[] F M S]
  ; split sg-sub-reg [_ |- Dsub] as
    case sg-sub-reg/i:
    { g : md-of-reg-ctx,
      P : ( |- purity),
      F : (g |- sttp),
      M : (g |- module'),
      S : (g |- sg),
      S1 : (g |- sg),
      Dof : (g |- md-of P[] F M S1),
      Dsub : (g |- sg-sub S1 S),
      Dwf : (g |- sg-wf S1),
      Dwf1 : (g |- sg-wf S)
    | x : [g |- md-of P[] F M S]
    ; solve [_ |- Dwf1]
    }
  }
  case md-of/forget:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    S : (g |- sg),
    Dof : (g |- md-of pure F M S)
  | x : [g |- md-of impure F M S]
  ; solve md-of-reg [_ |- Dof]
  }
  case md-of/extnamed:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    L : ( |- name),
    S2 : (g |- sg),
    S1 : (g |- sg),
    Dof : (g |- md-of pure F M (sg/named L[] S1)),
    Dof1 : (g |- md-of pure F (md/out M) S2)
  | x : [g |- md-of pure F M (sg/named L[] S2)]
  ; by md-of-reg [_ |- Dof1] as Dwf unboxed;
    solve [_ |- sg-wf/named Dwf]
  }
  case md-of/extsigma:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    S1 : (g |- sg),
    S2 : (g |- sg),
    Dof : (g |- md-of pure F (md/pi1 M) S1),
    Dof1 : (g |- md-of pure F (md/pi2 M) S2)
  | x : [g |- md-of pure F M (sg/sigma S1 (\x. S2[..]))]
  ; by md-of-reg [_ |- Dof] as Dwf1 unboxed;
    by md-of-reg [_ |- Dof1] as Dwf2 unboxed;
    split can-sg-fst [_ |- S1] as
    case can-sg-fst/i:
    { g : md-of-reg-ctx,
      F : (g |- sttp),
      M : (g |- module'),
      S1 : (g |- sg),
      S2 : (g |- sg),
      Dof : (g |- md-of pure F (md/pi1 M) S1),
      Dof1 : (g |- md-of pure F (md/pi2 M) S2),
      Dwf1 : (g |- sg-wf S1),
      Dwf2 : (g |- sg-wf S2),
      K : (g |- kind),
      Dfst : (g |- sg-fst S1 K)
    | x : [g |- md-of pure F M (sg/sigma S1 (\x. S2[..]))]
    ; solve [_ |- sg-wf/sigma Dwf1 Dfst (\a. \da. Dwf2[..])]
    }
  }
  case md-of/self:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    M : (g |- module'),
    K1 : (g |- kind),
    K : (g |- kind),
    C : (g |- con),
    Dof : (g |- md-of pure F M (sg/satom K)),
    Dfst : (g |- md-fst M C),
    Dof1 : (g |- cn-of C K1)
  | x : [g |- md-of pure F M (sg/satom K1)]
  ; by cn-of-reg [_ |- Dof1] as Dwf unboxed;
    solve [_ |- sg-wf/satom Dwf]
  }
  case md-of/seal:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    P1 : ( |- purity),
    Dof : (g |- md-of P1[] F M1 S)
  | x : [g |- md-of impure F (md/seal M1 S) S]
  ; solve md-of-reg [_ |- Dof]
  }
  case md-of/lete:
  { g : md-of-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    E : (g |- term),
    C : (g |- con),
    M1 : (g, x7 : term |- module'),
    S : (g |- sg),
    Dof : (g |- tm-of F E C),
    Dof1 :
      (g, x : term, u : {F' : sttp}  tm-of F' x (C[..]) |-
         md-of P[] (F[..]) (M1[.., x]) (S[..]))
  | x : [g |- md-of P[] F (md/lete E C (\x. M1)) S]
  ; by [_ |- Dof1[.., E, (\f. _)]] as Dof' unboxed;
    by md-of-reg
     [g, b : block (x : term, u : {F' : sttp}  tm-of F' x (C[..])) |-
        Dof1[.., b.1, b.2]]
as DwfS' unboxed;
    ?
  }
  case md-of/letp:
  { g : md-of-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a68 : con, m4 : module' |- module'),
    S2 : (g, a69 : con |- sg),
    C : (g |- con),
    S1 : (g |- sg),
    K : (g |- kind),
    Dof : (g |- md-of pure F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dfst1 : (g |- md-fst M1 C),
    Dof1 :
      (g, a : con, x629 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       z629 : md-fst m a |- md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a]))
  | x : [g |- md-of P[] F (md/letp M1 (\z513. \y514. M2)) (S2[.., C])]
  ; by md-of-reg
     [g,
      b :
        block (
          a : con,
          da : cn-of a (K[..]),
          m : module',
          u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
          dfst : md-fst m a) |- Dof1[.., b.1, b.2, b.3, b.4, b.5]]
as DwfS2' unboxed;
    by [g, b : block (a : con, da : cn-of a (K[..])) |-
          DwfS2'[.., <b.1; b.2; _; (\p. \f. _); _>]]
    as DwfS2 unboxed;
    ?
  }
  case md-of/let:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a67 : con, m3 : module' |- module'),
    S : (g |- sg),
    P1 : ( |- purity),
    S1 : (g |- sg),
    K : (g |- kind),
    P2 : ( |- purity),
    Dof : (g |- md-of P1[] F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dof1 :
      (g, a : con, x627 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       z627 : md-fst m a |- md-of P2[] (F[..]) (M2[.., a, m]) (S[..]))
  | x : [g |- md-of impure F (md/let M1 (\x512. \z512. M2) S) S]
  ; by md-of-reg
     [g,
      b :
        block (
          a : con,
          da : cn-of a (K[..]),
          m : module',
          u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
          dfst : md-fst m a) |- Dof1[.., b.1, b.2, b.3, b.4, b.5]]
as DwfS2 unboxed;
    by [g, b : block (a : con, da : cn-of a (K[..])) |-
          DwfS2[.., <b.1; b.2; _; (\p. \f. _); _>]]
    as DwfS2' unboxed;
    by md-of-reg [g |- Dof] as DwfS1 unboxed;
    by sg-fst-reg [g |- DwfS1] [g |- Dfst] as DwfK unboxed;
    split inhabitation [g |- DwfK] as
    case inhabitation/i:
    { g : md-of-reg-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      M2 : (g, a67 : con, m3 : module' |- module'),
      S : (g |- sg),
      P1 : ( |- purity),
      S1 : (g |- sg),
      K : (g |- kind),
      P2 : ( |- purity),
      Dof : (g |- md-of P1[] F M1 S1),
      Dfst : (g |- sg-fst S1 K),
      Dof1 :
        (g, a : con, x627 : cn-of a (K[..]), m : module',
         u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
         z627 : md-fst m a |- md-of P2[] (F[..]) (M2[.., a, m]) (S[..])),
      DwfS2 :
        (g,
         b :
           block (
             a : con,
             da : cn-of a (K[..]),
             m : module',
             u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
             dfst : md-fst m a) |- sg-wf (S[..])),
      DwfS2' :
        (g, b : block (a : con, da : cn-of a (K[..])) |- sg-wf (S[..])),
      DwfS1 : (g |- sg-wf S1),
      DwfK : (g |- kd-wf K),
      C : (g |- con),
      Dof2 : (g |- cn-of C K)
    | x : [g |- md-of impure F (md/let M1 (\x512. \z512. M2) S) S]
    ; solve [g |- DwfS2'[.., <C; Dof2>]]
    }
  }
  case md-of/out:
  { g : md-of-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    L : ( |- name),
    Dof : (g |- md-of P[] F M1 (sg/named L[] S))
  | x : [g |- md-of P[] F (md/out M1) S]
  ; split md-of-reg [g |- Dof] as
    case sg-wf/named:
    { g : md-of-reg-ctx,
      P : ( |- purity),
      F : (g |- sttp),
      M1 : (g |- module'),
      S : (g |- sg),
      L : ( |- name),
      Dof : (g |- md-of P[] F M1 (sg/named L[] S)),
      Dwf : (g |- sg-wf S)
    | x : [g |- md-of P[] F (md/out M1) S]
    ; solve [g |- Dwf]
    }
  }
  case md-of/in:
  { g : md-of-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    L : ( |- name),
    M1 : (g |- module'),
    S1 : (g |- sg),
    Dof : (g |- md-of P[] F M1 S1)
  | x : [g |- md-of P[] F (md/in L[] M1) (sg/named L[] S1)]
  ; by md-of-reg [g |- Dof] as Dwf unboxed;
    solve [g |- sg-wf/named Dwf]
  }
  case md-of/app:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g |- module'),
    S2 : (g, a66 : con |- sg),
    C : (g |- con),
    P1 : ( |- purity),
    S1 : (g |- sg),
    Dof : (g |- md-of P1[] F M1 (sg/pi S1 (\z484. S2))),
    Dof1 : (g |- md-of pure F M2 S1),
    Dfst : (g |- md-fst M2 C)
  | x : [g |- md-of impure F (md/app M1 M2) (S2[.., C])]
  ; ?
  }
  case md-of/lam:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    S1 : (g |- sg),
    M1 : (g, a64 : con, m2 : module' |- module'),
    S2 : (g, a65 : con |- sg),
    K : (g |- kind),
    P1 : ( |- purity),
    Dwf : (g |- sg-wf S1),
    Dfst : (g |- sg-fst S1 K),
    Dof :
      (g, a : con, y624 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       x624 : md-fst m a |- md-of P1[] (F[..]) (M1[.., a, m]) (S2[.., a]))
  | x :
      [g |-
         md-of pure F (md/lam S1 (\y509. \x509. M1)) (sg/pi S1 (\z484. S2))]
  ; by sg-fst-reg [g |- Dwf] [g |- Dfst] as DwfK unboxed;
    by md-of-reg
         [g,
          b :
            block (
              a : con,
              da : cn-of a (K[..]),
              m : module',
              u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
              dfst : md-fst m a) |- Dof[.., b.1, b.2, b.3, b.4, b.5]]
    as Dof' unboxed;
    by [g, b : block (a : con, da : cn-of a (K[..])) |-
          Dof'[.., <b.1; b.2; _; (\p. \f. _); _>]]
    as Dof'' unboxed;
    solve [g |- sg-wf/pi Dwf Dfst (\a. \da. Dof''[.., <a; da>])]
  }
  case md-of/pi2:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S2 : (g, a63 : con |- sg),
    C : (g |- con),
    S1 : (g |- sg),
    Dof : (g |- md-of pure F M1 (sg/sigma S1 (\z485. S2))),
    Dfst : (g |- md-fst M1 C)
  | x : [g |- md-of pure F (md/pi2 M1) (S2[.., pi1 C])]
  ; split md-of-reg [g |- Dof] as
    case sg-wf/sigma:
    { g : md-of-reg-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      S2 : (g, a63 : con |- sg),
      C : (g |- con),
      S1 : (g |- sg),
      Dof : (g |- md-of pure F M1 (sg/sigma S1 (\z485. S2))),
      Dfst : (g |- md-fst M1 C),
      K : (g |- kind),
      Dwf : (g |- sg-wf S1),
      Dfst1 : (g |- sg-fst S1 K),
      Dwf1 : (g, a : con, x605 : cn-of a (K[..]) |- sg-wf (S2[.., a]))
    | x : [g |- md-of pure F (md/pi2 M1) (S2[.., pi1 C])]
    ; ?
    }
  }
  case md-of/pi1:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    M1 : (g |- module'),
    S : (g |- sg),
    S2 : (g, a62 : con |- sg),
    Dof : (g |- md-of pure F M1 (sg/sigma S (\z485. S2)))
  | x : [g |- md-of pure F (md/pi1 M1) S]
  ; split md-of-reg [g |- Dof] as
    case sg-wf/sigma:
    { g : md-of-reg-ctx,
      F : (g |- sttp),
      M1 : (g |- module'),
      S : (g |- sg),
      S2 : (g, a62 : con |- sg),
      Dof : (g |- md-of pure F M1 (sg/sigma S (\z485. S2))),
      K : (g |- kind),
      Dwf : (g |- sg-wf S),
      Dfst : (g |- sg-fst S K),
      Dwf1 : (g, a : con, x605 : cn-of a (K[..]) |- sg-wf (S2[.., a]))
    | x : [g |- md-of pure F (md/pi1 M1) S]
    ; solve [g |- Dwf]
    }
  }
  case md-of/dpair:
  { g : md-of-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g, a60 : con, m1 : module' |- module'),
    S1 : (g |- sg),
    S2 : (g, a61 : con |- sg),
    K : (g |- kind),
    Dof : (g |- md-of P[] F M1 S1),
    Dfst : (g |- sg-fst S1 K),
    Dof1 :
      (g, a : con, x621 : cn-of a (K[..]), m : module',
       u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
       z621 : md-fst m a |- md-of P[] (F[..]) (M2[.., a, m]) (S2[.., a]))
  | x :
      [g |- md-of P[] F (md/dpair M1 (\a. \m. M2)) (sg/sigma S1 (\z485. S2))]
  ; by md-of-reg [g |- Dof] as DwfS1 unboxed;
    by md-of-reg
         [g,
          b :
            block (
              a : con,
              da : cn-of a (K[..]),
              m : module',
              u : {P' : purity}  {F' : sttp}  md-of P' F' m (S1[..]),
              dfst : md-fst m a) |- Dof1[.., b.1, b.2, b.3, b.4, b.5]]
    as DwfS2 unboxed;
    by [g, b : block (a : con, da : cn-of a (K[..])) |-
          DwfS2[.., <b.1; b.2; _; (\p. \f. _); _>]]
    as DwfS2' unboxed;
    solve [g |- sg-wf/sigma DwfS1 Dfst (\a. \da. DwfS2'[.., <a; da>])]
  }
  case md-of/pair:
  { g : md-of-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    M1 : (g |- module'),
    M2 : (g |- module'),
    S1 : (g |- sg),
    S2 : (g |- sg),
    Dof : (g |- md-of P[] F M1 S1),
    Dof1 : (g |- md-of P[] F M2 S2)
  | x : [g |- md-of P[] F (md/pair M1 M2) (sg/sigma S1 (\x. S2[..]))]
  ; by md-of-reg [g |- Dof] as Dwf1 unboxed;
    by md-of-reg [g |- Dof1] as Dwf2 unboxed;
    split can-sg-fst [g |- S1] as
    case can-sg-fst/i:
    { g : md-of-reg-ctx,
      P : ( |- purity),
      F : (g |- sttp),
      M1 : (g |- module'),
      M2 : (g |- module'),
      S1 : (g |- sg),
      S2 : (g |- sg),
      Dof : (g |- md-of P[] F M1 S1),
      Dof1 : (g |- md-of P[] F M2 S2),
      Dwf1 : (g |- sg-wf S1),
      Dwf2 : (g |- sg-wf S2),
      K : (g |- kind),
      Dfst : (g |- sg-fst S1 K)
    | x : [g |- md-of P[] F (md/pair M1 M2) (sg/sigma S1 (\x. S2[..]))]
    ; solve [g |- sg-wf/sigma Dwf1 Dfst (\a. \da. Dwf2[..])]
    }
  }
  case md-of/datom:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    E : (g |- term),
    C : (g |- con),
    Dof : (g |- tm-of F E C)
  | x : [g |- md-of pure F (md/datom E C) (sg/datom C)]
  ; by tm-of-reg [g |- Dof] as Dwf unboxed;
    solve [g |- sg-wf/datom Dwf]
  }
  case md-of/sgatom:
  { g : md-of-reg-ctx, F : (g |- sttp), S1 : (g |- sg), Dwf : (g |- sg-wf S1)
  | x : [g |- md-of pure F (md/sgatom S1) (sg/sgatom S1)]
  ; solve [g |- sg-wf/sgatom Dwf]
  }
  case md-of/satom:
  { g : md-of-reg-ctx,
    F : (g |- sttp),
    C : (g |- con),
    K : (g |- kind),
    Dof : (g |- cn-of C K)
  | x : [g |- md-of pure F (md/satom C) (sg/satom K)]
  ; by cn-of-reg [g |- Dof] as Dwf unboxed;
    solve [g |- sg-wf/satom Dwf]
  }
  case md-of/unit:
  { g : md-of-reg-ctx, F : (g |- sttp)
  | x : [g |- md-of pure F md/unit sg/one]
  ; solve [g |- sg-wf/one]
  }
  %{ FIXME: Uncaught exception: Not_found
  case #.4:
  { g : md-of-reg-ctx,
    P : ( |- purity),
    F : (g |- sttp),
    K1118 : (g |- kind),
    S : (g |- sg),
    #fst :
      #(g |-
          block (
            a : con,
            da : cn-of a (K1118[..]),
            m : module',
            dm : {P' : purity}  {F' : sttp}  md-of P' F' m (S[..]),
            dfst : md-fst m a)),
    Dwf188 : (g |- kd-wf K1118),
    Dwf51 : (g |- sg-wf S),
    Dfst56 : (g |- sg-fst S K1118)
  | x : [g |- md-of P[] F #fst.3 S]
  ; solve [_ |- Dwf51]
  }
  }%
}
;
