% Similarity

LF similar : con -> con -> type =
| similar/unit : similar unit unit
| similar/void : similar void void
| similar/prod : similar (prod _ _) (prod _ _)
| similar/arrow : similar (arrow _ _) (arrow _ _)
| similar/plus : similar (plus _ _) (plus _ _)
| similar/ref : similar (ref _) (ref _)
| similar/tag : similar (tag _) (tag _)
| similar/tagged : similar tagged tagged
| similar/rec : similar (rec' _ _ _) (rec' _ _ _)
| similar/labeled : similar (labeled _ _) (labeled _ _)
;

% Type Formation Inversion

LF typeish : kind -> type =
| typeish/t : typeish t
| typeish/sing : typeish (sing _)
;

proof typeish-equiv : [ |- kd-equiv K1 K2] ->
                        [ |- typeish K2] -> [ |- typeish K1] =
/ total 1 /
intros
{ K : ( |- kind), K1 : ( |- kind)
| x : [ |- kd-equiv K K1], x1 : [ |- typeish K1]
; split x as
  case kd-equiv/sigma:
  { K2 : ( |- kind),
    K3 : (a7 : con |- kind),
    K5 : ( |- kind),
    K4 : (a8 : con |- kind),
    X : (a : con, y134 : cn-of a K2[] |- kd-equiv (K3[a]) (K4[a])),
    X1 : ( |- kd-equiv K2 K5)
  | x : [ |- kd-equiv (sigma K2 (\z69. K3)) (sigma K5 (\z69. K4))],
    x1 : [ |- typeish (sigma K5 (\z69. K4))]
  ; impossible x1
  }
  case kd-equiv/pi:
  { K2 : ( |- kind),
    K3 : (a5 : con |- kind),
    K5 : ( |- kind),
    K4 : (a6 : con |- kind),
    X : (a : con, y133 : cn-of a K2[] |- kd-equiv (K3[a]) (K4[a])),
    X1 : ( |- kd-equiv K2 K5)
  | x : [ |- kd-equiv (pi K2 (\z68. K3)) (pi K5 (\z68. K4))],
    x1 : [ |- typeish (pi K5 (\z68. K4))]
  ; impossible x1
  }
  case kd-equiv/sing:
  { C : ( |- con), C1 : ( |- con), X : ( |- cn-equiv C C1 t)
  | x : [ |- kd-equiv (sing C) (sing C1)], x1 : [ |- typeish (sing C1)]
  ; solve [ |- typeish/sing ]
  }
  case kd-equiv/trans:
  { K : ( |- kind),
    K1 : ( |- kind),
    K3 : ( |- kind),
    X : ( |- kd-equiv K K3),
    X1 : ( |- kd-equiv K3 K1)
  | x : [ |- kd-equiv K K1], x1 : [ |- typeish K1]
  ; by typeish-equiv [ |- X1] x1 as l1;
    by typeish-equiv [ |- X] l1 as l2;
    solve l2
  }
  case kd-equiv/symm:
  { K : ( |- kind), K1 : ( |- kind), X : ( |- kd-equiv K1 K)
  | x : [ |- kd-equiv K K1], x1 : [ |- typeish K1]
  ; by typeish-equiv' [ |- X] x1 as l;
    solve l
  }
  case kd-equiv/refl:
  { K1 : ( |- kind), X : ( |- kd-wf K1)
  | x : [ |- kd-equiv K1 K1], x1 : [ |- typeish K1]
  ; solve x1
  }
}

and proof typeish-equiv' : [ |- kd-equiv K1 K2] ->
                        [ |- typeish K1] -> [ |- typeish K2] =
/ total 1 /
intros
{ K : ( |- kind), K1 : ( |- kind)
| x : [ |- kd-equiv K K1], x1 : [ |- typeish K]
; split x as
  case kd-equiv/sigma:
  { K2 : ( |- kind),
    K3 : (a7 : con |- kind),
    K5 : ( |- kind),
    K4 : (a8 : con |- kind),
    X : (a : con, y134 : cn-of a K2[] |- kd-equiv (K3[a]) (K4[a])),
    X1 : ( |- kd-equiv K2 K5)
  | x : [ |- kd-equiv (sigma K2 (\z69. K3)) (sigma K5 (\z69. K4))],
    x1 : [ |- typeish (sigma K2 (\z69. K3))]
  ; impossible x1
  }
  case kd-equiv/pi:
  { K2 : ( |- kind),
    K3 : (a5 : con |- kind),
    K5 : ( |- kind),
    K4 : (a6 : con |- kind),
    X : (a : con, y133 : cn-of a K2[] |- kd-equiv (K3[a]) (K4[a])),
    X1 : ( |- kd-equiv K2 K5)
  | x : [ |- kd-equiv (pi K2 (\z68. K3)) (pi K5 (\z68. K4))],
    x1 : [ |- typeish (pi K2 (\z68. K3))]
  ; impossible x1
  }
  case kd-equiv/sing:
  { C : ( |- con), C1 : ( |- con), X : ( |- cn-equiv C C1 t)
  | x : [ |- kd-equiv (sing C) (sing C1)], x1 : [ |- typeish (sing C)]
  ; solve [ |- typeish/sing ]
  }
  case kd-equiv/trans:
  { K : ( |- kind),
    K1 : ( |- kind),
    K3 : ( |- kind),
    X : ( |- kd-equiv K K3),
    X1 : ( |- kd-equiv K3 K1)
  | x : [ |- kd-equiv K K1], x1 : [ |- typeish K]
  ; by typeish-equiv' [ |- X] x1 as l1;
    by typeish-equiv' [ |- X1] l1 as l2;
    solve l2
  }
  case kd-equiv/symm:
  { K : ( |- kind), K1 : ( |- kind), X : ( |- kd-equiv K1 K)
  | x : [ |- kd-equiv K K1], x1 : [ |- typeish K]
  ; by typeish-equiv [ |- X] x1 as l1;
    solve l1
  }
  case kd-equiv/refl:
  { K1 : ( |- kind), X : ( |- kd-wf K1)
  | x : [ |- kd-equiv K1 K1], x1 : [ |- typeish K1]
  ; solve x1
  }
}
;

proof typeish-sub : [ |- kd-sub K1 K2] -> [ |- typeish K2] -> [ |- typeish K1] =
/ total 1 /
intros
{ K : ( |- kind), K1 : ( |- kind)
| x : [ |- kd-sub K K1], x1 : [ |- typeish K1]
; split x as
  case kd-sub/sigma:
  { K4 : ( |- kind),
    K5 : (a12 : con |- kind),
    K2 : ( |- kind),
    K3 : (a11 : con |- kind),
    C : ( |- con),
    X : (a : con, z138 : cn-of a K2[] |- kd-wf (K3[a])),
    X1 : (x138 : cn-of C K4 |- kd-sub (K5[C[]]) (K3[C[]])),
    X2 : ( |- kd-sub K2 K4)
  | x : [ |- kd-sub (sigma K4 (\z69. K5)) (sigma K2 (\z69. K3))],
    x1 : [ |- typeish (sigma K2 (\z69. K3))]
  ; impossible x1
  }
  case kd-sub/pi:
  { K2 : ( |- kind),
    K3 : (a9 : con |- kind),
    K4 : ( |- kind),
    K5 : (a10 : con |- kind),
    C : ( |- con),
    X : (a : con, y137 : cn-of a K2[] |- kd-wf (K3[a])),
    X1 : (z136 : cn-of C K4 |- kd-sub (K3[C[]]) (K5[C[]])),
    X2 : ( |- kd-sub K4 K2)
  | x : [ |- kd-sub (pi K2 (\z68. K3)) (pi K4 (\z68. K5))],
    x1 : [ |- typeish (pi K4 (\z68. K5))]
  ; impossible x1
  }
  case kd-sub/sing-t:
  { C : ( |- con), X : ( |- cn-of C t)
  | x : [ |- kd-sub (sing C) t], x1 : [ |- typeish t]
  ; solve [ |- typeish/sing ]
  }
  case kd-sub/trans:
  { K : ( |- kind),
    K1 : ( |- kind),
    K3 : ( |- kind),
    X : ( |- kd-sub K K3),
    X1 : ( |- kd-sub K3 K1)
  | x : [ |- kd-sub K K1], x1 : [ |- typeish K1]
  ; by typeish-sub [ |- X1] x1 as l1;
    by typeish-sub [ |- X] l1 as l2;
    solve l2
  }
  case kd-sub/refl:
  { K : ( |- kind), K1 : ( |- kind), X : ( |- kd-equiv K K1)
  | x : [ |- kd-sub K K1], x1 : [ |- typeish K1]
  ; solve typeish-equiv [ |- X] x1
  }
}
;

proof type-inversion : [ |- cn-of T K] ->
                         [ |- similar T T] ->
                           [ |- kd-sub K t] -> [ |- cn-of T t] =
/ total 1 /
intros
{ T : ( |- con), K : ( |- kind)
| x : [ |- cn-of T K], x1 : [ |- similar T T], x2 : [ |- kd-sub K t]
; split x as
  case cn-of/subsume:
  { T : ( |- con),
    K : ( |- kind),
    K1 : ( |- kind),
    X : ( |- kd-sub K1 K),
    X1 : ( |- cn-of T K1)
  | x : [ |- cn-of T K], x1 : [ |- similar T T], x2 : [ |- kd-sub K t]
  ; by x2 as X2 unboxed;
    by [ |- kd-sub/trans X X2] as l;
    by type-inversion [ |- X1] x1 l as q;
    solve q
  }
  case cn-of/extsigma:
  { T : ( |- con),
    K1 : ( |- kind),
    K2 : (a22 : con |- kind),
    X : (a : con, z149 : cn-of a K1[] |- kd-wf (K2[a])),
    X1 : ( |- cn-of (pi2 T) (K2[pi1 T])),
    X2 : ( |- cn-of (pi1 T) K1)
  | x : [ |- cn-of T (sigma K1 (\z69. K2))],
    x1 : [ |- similar T T],
    x2 : [ |- kd-sub (sigma K1 (\z69. K2)) t]
  ; impossible x1
  }
  case cn-of/extpi:
  { T : ( |- con),
    K1 : ( |- kind),
    K2 : (a21 : con |- kind),
    X : (a : con, x148 : cn-of a K1[] |- cn-of (app T[] a) (K2[a])),
    X1 : ( |- cn-of T (pi K1 (\z68. K2)))
  | x : [ |- cn-of T (pi K1 (\z68. K2))],
    x1 : [ |- similar T T],
    x2 : [ |- kd-sub (pi K1 (\z68. K2)) t]
  ; impossible x1
  }
  case cn-of/sing:
  { T : ( |- con), X : ( |- cn-of T t)
  | x : [ |- cn-of T (sing T)],
    x1 : [ |- similar T T],
    x2 : [ |- kd-sub (sing T) t]
  ; solve [ |- X]
  }
  case cn-of/labeled:
  { X : ( |- label), C : ( |- con), X1 : ( |- cn-of C t)
  | x : [ |- cn-of (labeled X C) t],
    x1 : [ |- similar (labeled X C) (labeled X C)],
    x2 : [ |- kd-sub t t]
  ; solve x
  }
  case cn-of/rec:
  { K1 : ( |- kind),
    C2 : (a20 : con, a19 : con |- con),
    C : ( |- con),
    C1 : ( |- con),
    X : ( |- cn-of C K1),
    X1 :
      (a : con, x146 : cn-of a (pi K1[] (\l. t)), z146 : cn-of C1[] K1[] |-
         cn-of (C2[a, C1[]]) t),
    X2 : ( |- kd-wf K1)
  | x : [ |- cn-of (rec' K1 (\z76. \y77. C2) C) t],
    x1 :
      [ |- similar (rec' K1 (\z76. \y77. C2) C) (rec' K1 (\z76. \y77. C2) C)],
    x2 : [ |- kd-sub t t]
  ; solve x
  }
  case cn-of/tagged:
  {
  | x : [ |- cn-of tagged t],
    x1 : [ |- similar tagged tagged],
    x2 : [ |- kd-sub t t]
  ; solve x
  }
  case cn-of/tag:
  { C : ( |- con), X : ( |- cn-of C t)
  | x : [ |- cn-of (tag C) t],
    x1 : [ |- similar (tag C) (tag C)],
    x2 : [ |- kd-sub t t]
  ; solve x
  }
  case cn-of/ref:
  { C : ( |- con), X : ( |- cn-of C t)
  | x : [ |- cn-of (ref C) t],
    x1 : [ |- similar (ref C) (ref C)],
    x2 : [ |- kd-sub t t]
  ; solve x
  }
  case cn-of/plus:
  { C : ( |- con), C1 : ( |- con), X : ( |- cn-of C t), X1 : ( |- cn-of C1 t)
  | x : [ |- cn-of (arrow C C1) t],
    x1 : [ |- similar (arrow C C1) (arrow C C1)],
    x2 : [ |- kd-sub t t]
  ; solve x
  }
  case cn-of/arrow:
  { C : ( |- con), C1 : ( |- con), X : ( |- cn-of C t), X1 : ( |- cn-of C1 t)
  | x : [ |- cn-of (arrow C C1) t],
    x1 : [ |- similar (arrow C C1) (arrow C C1)],
    x2 : [ |- kd-sub t t]
  ; solve x
  }
  case cn-of/prod:
  { C : ( |- con), C1 : ( |- con), X : ( |- cn-of C t), X1 : ( |- cn-of C1 t)
  | x : [ |- cn-of (prod C C1) t],
    x1 : [ |- similar (prod C C1) (prod C C1)],
    x2 : [ |- kd-sub t t]
  ; solve x
  }
  case cn-of/void:
  {
  | x : [ |- cn-of void t],
    x1 : [ |- similar void void],
    x2 : [ |- kd-sub t t]
  ; solve x
  }
  case cn-of/unit:
  {
  | x : [ |- cn-of unit t],
    x1 : [ |- similar unit unit],
    x2 : [ |- kd-sub t t]
  ; solve x
  }
  case cn-of/star:
  {
  | x : [ |- cn-of star one],
    x1 : [ |- similar star star],
    x2 : [ |- kd-sub one t]
  ; impossible x1
  }
  case cn-of/app:
  { C1 : ( |- con),
    C : ( |- con),
    K2 : (a18 : con |- kind),
    K1 : ( |- kind),
    X : ( |- cn-of C K1),
    X1 : ( |- cn-of C1 (pi K1 (\z68. K2)))
  | x : [ |- cn-of (app C1 C) (K2[C])],
    x1 : [ |- similar (app C1 C) (app C1 C)],
    x2 : [ |- kd-sub (K2[C]) t]
  ; impossible x1
  }
  case cn-of/lam:
  { K1 : ( |- kind),
    C : (a16 : con |- con),
    K2 : (a17 : con |- kind),
    X : (a : con, z141 : cn-of a K1[] |- cn-of (C[a]) (K2[a])),
    X1 : ( |- kd-wf K1)
  | x : [ |- cn-of (lam K1 (\y72. C)) (pi K1 (\z68. K2))],
    x1 : [ |- similar (lam K1 (\y72. C)) (lam K1 (\y72. C))],
    x2 : [ |- kd-sub (pi K1 (\z68. K2)) t]
  ; impossible x1
  }
  case cn-of/pi2:
  { C : ( |- con),
    K2 : (a15 : con |- kind),
    K1 : ( |- kind),
    X : ( |- cn-of C (sigma K1 (\z69. K2)))
  | x : [ |- cn-of (pi2 C) (K2[pi1 C])],
    x1 : [ |- similar (pi2 C) (pi2 C)],
    x2 : [ |- kd-sub (K2[pi1 C]) t]
  ; impossible x1
  }
  case cn-of/pi1:
  { C : ( |- con),
    K : ( |- kind),
    K2 : (a14 : con |- kind),
    X : ( |- cn-of C (sigma K (\z69. K2)))
  | x : [ |- cn-of (pi1 C) K],
    x1 : [ |- similar (pi1 C) (pi1 C)],
    x2 : [ |- kd-sub K t]
  ; impossible x1
  }
  case cn-of/pair:
  { C1 : ( |- con),
    C : ( |- con),
    K1 : ( |- kind),
    K2 : (a13 : con |- kind),
    X : (a : con, y140 : cn-of a K1[] |- kd-wf (K2[a])),
    X1 : ( |- cn-of C (K2[C1])),
    X2 : ( |- cn-of C1 K1)
  | x : [ |- cn-of (pair C1 C) (sigma K1 (\z69. K2))],
    x1 : [ |- similar (pair C1 C) (pair C1 C)],
    x2 : [ |- kd-sub (sigma K1 (\z69. K2)) t]
  ; impossible x1
  }
}
;
