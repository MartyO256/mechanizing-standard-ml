% Equalities

LF con-eq : con -> con -> type =
| con-eq/i : con-eq C C
;

LF entp-eq : entp -> entp -> type =
| entp-eq/i : entp-eq ET ET
;

LF entry-eq : entry -> entry -> type =
| entry-eq/i : entry-eq EN EN
;

LF kind-eq : kind -> kind -> type =
| kind-eq/i : kind-eq K K
;

LF module-eq : module' -> module' -> type =
| module-eq/i : module-eq M M
;

LF name-eq : name -> name -> type =
| name-eq/i : name-eq L L
;

LF purity-eq : purity -> purity -> type =
| purity-eq/i : purity-eq P P
;

LF sg-eq : sg -> sg -> type =
| sg-eq/i : sg-eq S S
;

LF store-eq : store -> store -> type =
| store-eq/i : store-eq ST ST
;

LF sttp-eq : sttp -> sttp -> type =
| sttp-eq/i : sttp-eq F F
;

LF term-eq : term -> term -> type =
| term-eq/i : term-eq E E
;

% Symmetry

proof con-eq-symm : [ |- con-eq C1 C2] -> [ |- con-eq C2 C1] =
/ total /
intros
{ C : ( |- con), C1 : ( |- con)
| x : [ |- con-eq C C1]
; split x as
  case con-eq/i:
  { C1 : ( |- con)
  | x : [ |- con-eq C1 C1]
  ; solve x
  }
}
;

proof kind-eq-symm : [ |- kind-eq K1 K2] -> [ |- kind-eq K2 K1] =
/ total /
intros
{ K : ( |- kind), K1 : ( |- kind)
| x : [ |- kind-eq K K1]
; split x as
  case kind-eq/i:
  { K1 : ( |- kind)
  | x : [ |- kind-eq K1 K1]
  ; solve x
  }
}
;

proof name-eq-symm : [ |- name-eq L1 L2] -> [ |- name-eq L2 L1] =
/ total /
intros
{ L : ( |- name), L1 : ( |- name)
| x : [ |- name-eq L L1]
; split x as
  case name-eq/i:
  { L1 : ( |- name)
  | x : [ |- name-eq L1 L1]
  ; solve x
  }
}
;

proof sg-eq-symm : [ |- sg-eq S1 S2] -> [ |- sg-eq S2 S1] =
/ total /
intros
{ S : ( |- sg), S1 : ( |- sg)
| x : [ |- sg-eq S S1]
; split x as
  case sg-eq/i:
  { S1 : ( |- sg)
  | x : [ |- sg-eq S1 S1]
  ; solve x
  }
}
;

proof term-eq-symm : [ |- term-eq E1 E2] -> [ |- term-eq E2 E1] =
/ total /
intros
{ E : ( |- term), E1 : ( |- term)
| x : [ |- term-eq E E1]
; split x as
  case term-eq/i:
  { E1 : ( |- term)
  | x : [ |- term-eq E1 E1]
  ; solve x
  }
}
;

proof module-eq-symm : [ |- module-eq M1 M2] -> [ |- module-eq M2 M1] =
/ total /
intros
{ M : ( |- module'), M1 : ( |- module')
| x : [ |- module-eq M M1]
; split x as
  case module-eq/i:
  { M1 : ( |- module')
  | x : [ |- module-eq M1 M1]
  ; solve x
  }
}
;

% Transitivity

proof con-eq-trans : [ |- con-eq C1 C2] ->
                       [ |- con-eq C2 C3] ->
                       [ |- con-eq C1 C3] =
/ total /
intros
{ C : ( |- con), C1 : ( |- con), C2 : ( |- con)
| x : [ |- con-eq C C1], x1 : [ |- con-eq C1 C2]
; split x as
  case con-eq/i:
  { C1 : ( |- con), C2 : ( |- con)
  | x : [ |- con-eq C1 C1], x1 : [ |- con-eq C1 C2]
  ; split x1 as
    case con-eq/i:
    { C2 : ( |- con)
    | x : [ |- con-eq C2 C2], x1 : [ |- con-eq C2 C2]
    ; solve x
    }
  }
}
;

proof module-eq-trans : [ |- module-eq M1 M2] ->
                          [ |- module-eq M2 M3] ->
                          [ |- module-eq M1 M3] =
/ total /
intros
{ M : ( |- module'), M1 : ( |- module'), M2 : ( |- module')
| x : [ |- module-eq M M1], x1 : [ |- module-eq M1 M2]
; split x as
  case module-eq/i:
  { M1 : ( |- module'), M2 : ( |- module')
  | x : [ |- module-eq M1 M1], x1 : [ |- module-eq M1 M2]
  ; split x1 as
    case module-eq/i:
    { M2 : ( |- module')
    | x : [ |- module-eq M2 M2], x1 : [ |- module-eq M2 M2]
    ; solve x
    }
  }
}
;

proof name-eq-trans : [ |- name-eq L1 L2] ->
                        [ |- name-eq L2 L3] ->
                        [ |- name-eq L1 L3] =
/ total /
intros
{ L : ( |- name), L1 : ( |- name), L2 : ( |- name)
| x : [ |- name-eq L L1], x1 : [ |- name-eq L1 L2]
; split x as
  case name-eq/i:
  { L1 : ( |- name), L2 : ( |- name)
  | x : [ |- name-eq L1 L1], x1 : [ |- name-eq L1 L2]
  ; split x1 as
    case name-eq/i:
    { L2 : ( |- name)
    | x : [ |- name-eq L2 L2], x1 : [ |- name-eq L2 L2]
    ; solve x
    }
  }
}
;

proof sg-eq-trans : [ |- sg-eq S1 S2] ->
                      [ |- sg-eq S2 S3] ->
                      [ |- sg-eq S1 S3] =
/ total /
intros
{ S : ( |- sg), S1 : ( |- sg), S2 : ( |- sg)
| x : [ |- sg-eq S S1], x1 : [ |- sg-eq S1 S2]
; split x as
  case sg-eq/i:
  { S1 : ( |- sg), S2 : ( |- sg)
  | x : [ |- sg-eq S1 S1], x1 : [ |- sg-eq S1 S2]
  ; split x1 as
    case sg-eq/i:
    { S2 : ( |- sg)
    | x : [ |- sg-eq S2 S2], x1 : [ |- sg-eq S2 S2]
    ; solve x
    }
  }
}
;
