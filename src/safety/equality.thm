% Equalities

LF con-eq : con -> con -> type =
| con-eq/i : con-eq C C
;
--name con-eq Deq.

LF entp-eq : entp -> entp -> type =
| entp-eq/i : entp-eq ET ET
;
--name entp-eq Deq.

LF entry-eq : entry -> entry -> type =
| entry-eq/i : entry-eq EN EN
;
--name entry-eq Deq.

LF kind-eq : kind -> kind -> type =
| kind-eq/i : kind-eq K K
;
--name kind-eq Deq.

LF module-eq : module' -> module' -> type =
| module-eq/i : module-eq M M
;
--name module-eq Deq.

LF name-eq : name -> name -> type =
| name-eq/i : name-eq L L
;
--name name-eq Deq.

LF purity-eq : purity -> purity -> type =
| purity-eq/i : purity-eq P P
;
--name purity-eq Deq.

LF sg-eq : sg -> sg -> type =
| sg-eq/i : sg-eq S S
;
--name sg-eq Deq.

LF store-eq : store -> store -> type =
| store-eq/i : store-eq ST ST
;
--name store-eq Deq.

LF sttp-eq : sttp -> sttp -> type =
| sttp-eq/i : sttp-eq F F
;
--name sttp-eq Deq.

LF term-eq : term -> term -> type =
| term-eq/i : term-eq E E
;
--name term-eq Deq.

% Symmetry

proof con-eq-symm : [ |- con-eq C1 C2] -> [ |- con-eq C2 C1] =
/ total /
?
;

proof kind-eq-symm : [ |- kind-eq K1 K2] -> [ |- kind-eq K2 K1] =
/ total /
?
;

proof name-eq-symm : [ |- name-eq L1 L2] -> [ |- name-eq L2 L1] =
/ total /
?
;

proof sg-eq-symm : [ |- sg-eq S1 S2] -> [ |- sg-eq S2 S1] =
/ total /
?
;

proof term-eq-symm : [ |- term-eq E1 E2] -> [ |- term-eq E2 E1] =
/ total /
?
;

proof module-eq-symm : [ |- module-eq M1 M2] -> [ |- module-eq M2 M1] =
/ total /
?
;

% Transitivity

proof con-eq-trans : [ |- con-eq C1 C2] ->
                       [ |- con-eq C2 C3] ->
                       [ |- con-eq C1 C3] =
/ total /
?
;

proof module-eq-trans : [ |- module-eq M1 M2] ->
                          [ |- module-eq M2 M3] ->
                          [ |- module-eq M1 M3] =
/ total /
?
;

proof name-eq-trans : [ |- name-eq L1 L2] ->
                        [ |- name-eq L2 L3] ->
                        [ |- name-eq L1 L3] =
/ total /
?
;

proof sg-eq-trans : [ |- sg-eq S1 S2] ->
                      [ |- sg-eq S2 S3] ->
                      [ |- sg-eq S1 S3] =
/ total /
?
;

% Cons Lemmas

proof con-resp-con : { C : [ c : con |- con] } [ |- con-eq C1 C1'] ->
                       [ |- con-eq (C[C1]) (C[C1'])] =
/ total /
?
;

proof con-resp-con2 : { C : [ c1 : con, c2: con |- con] } [ |- con-eq C1 C1'] ->
                        [ |- con-eq C2 C2'] ->
                          [ |- con-eq (C[C1, C2]) (C[C1', C2'])] =
/ total /
?
;

proof con-resp-kind : { C : [ k : kind |- con] } [ |- kind-eq K K'] ->
                        [ |- con-eq (C[K]) (C[K'])] =
/ total /
?
;

proof kind-resp-con : { K : [ c : con |- kind] } [ |- con-eq C C'] ->
                        [ |- kind-eq (K[C]) (K[C'])] =
/ total /
?
;

proof kind-resp-kind : { K : [ k : kind |- kind] } [ |- kind-eq K1 K1'] ->
                         [ |- kind-eq (K[K1]) (K[K1'])] =
/ total /
?
;

proof module-resp-con : { M : [ c : con |- module'] } [ |- con-eq C1 C2] ->
                          [ |- module-eq (M[C1]) (M[C2])] =
/ total /
?
;

proof module-resp-module : { M : [ m : module' |- module'] }
                           [ |- module-eq M1 M2] ->
                             [ |- module-eq (M[M1]) (M[M2])] =
/ total /
?
;

proof module-resp-term : { M : [ x : term |- module'] } [ |- term-eq E E'] ->
                           [ |- module-eq (M[E]) (M[E'])] =
/ total /
?
;

proof pair-resp : [ |- con-eq C1 C1'] ->
                    [ |- con-eq C2 C2'] ->
                      [ |- con-eq (pair C1 C2) (pair C1' C2')] =
/ total /
?
;

proof pi-resp : (g : conblock) [g |- kind-eq K1 K1'] ->
                  [g, a : con |- kind-eq (K2[a]) (K2'[a])] ->
                    [g |- kind-eq (pi K1 (\x. K2[x]))
                      (pi K1' (\x. K2'[x]))] =
/ total /
?
;

proof sg-resp-con : { S : [ c : con |- sg] } [ |- con-eq C C'] ->
                      [ |- sg-eq (S[C]) (S[C'])] =
/ total /
?
;

proof sg-resp-kind : { S : [ k : kind |- sg] } [ |- kind-eq K K'] ->
                       [ |- sg-eq (S[K]) (S[K'])] =
/ total /
?
;

proof sg-resp-name : { S : [ l : name |- sg] } [ |- name-eq L1 L2] ->
                       [ |- sg-eq (S[L1]) (S[L2])] =
/ total /
?
;

proof sg-resp-sg : { S : [ s : sg |- sg] } [ |- sg-eq S1 S2] ->
                     [ |- sg-eq (S[S1]) (S[S2])] =
/ total /
?
;

proof sigma-resp : (g : conblock) [g |- kind-eq K1 K1'] ->
                     [g, a : con |- kind-eq (K2[a]) (K2'[a])] ->
                       [g |- kind-eq (sigma K1 (\x. K2[x]))
                         (sigma K1' (\x. K2'[x]))] =
/ total /
?
;

proof store-resp-store : { ST : [ st : store |- store] }
                         [ |- store-eq ST1 ST1'] ->
                           [ |- store-eq (ST[ST1]) (ST[ST1'])] =
/ total /
?
;

proof term-resp-module : { E : [ m : module' |- term] } [ |- module-eq M M'] ->
                           [ |- term-eq (E[M]) (E[M'])] =
/ total /
?
;

proof term-resp-term : { E : [ x : term |- term] } [ |- term-eq E1 E1'] ->
                         [ |- term-eq (E[E1]) (E[E1'])] =
/ total /
?
;

% Cdr Lemmas

proof entp-eq-invert-tag : [ |- entp-eq (et/tag T) (et/tag T')] ->
                             [ |- con-eq T T'] =
/ total /
?
;

proof entry-eq-invert-ref : [ |- entry-eq (entry/ref E) (entry/ref E')] ->
                              [ |- term-eq E E'] =
/ total /
?
;

proof kind-eq-pi-invert/1 :
  (g : conblock)
  [g |- kind-eq (pi K1 (\x. K2[x])) (pi K1' (\x. K2'[x]))] ->
    [g |- kind-eq K1 K1'] =
/ total /
?
;

proof kind-eq-pi-invert/2 :
  (g : conblock)
  [g |- kind-eq (pi K1 (\x. K2[x])) (pi K1' (\x. K2'[x]))] ->
    [g, a : con |- kind-eq (K2[a]) (K2'[a])] =
/ total /
?
;

proof kind-eq-sigma-invert/1 :
  (g : conblock)
  [g |- kind-eq (sigma K1 (\x. K2[x])) (sigma K1' (\x. K2'[x]))] ->
    [g |- kind-eq K1 K1'] =
/ total /
?
;

proof kind-eq-sigma-invert/2 :
  (g : conblock)
  [g |- kind-eq (sigma K1 (\x. K2[x])) (sigma K1' (\x. K2'[x]))] ->
    [g, a : con |- kind-eq (K2[a]) (K2'[a]) ] =
/ total /
?
;

proof module-eq-pi1-invert : [ |- module-eq (md/pi1 M) (md/pi1 M')] ->
                               [ |- module-eq M M'] =
/ total /
?
;

proof module-eq-pi2-invert : [ |- module-eq (md/pi2 M) (md/pi2 M')] ->
                               [ |- module-eq M M'] =
/ total /
?
;

proof module-eq-out-invert : [ |- module-eq (md/out M) (md/out M')] ->
                               [ |- module-eq M M'] =
/ total /
?
;

proof sg-eq-named-invert/name-eq :
  [ |- sg-eq (sg/named L S) (sg/named L' S')] ->
    [ |- name-eq L L'] =
/ total /
?
;

proof sg-eq-named-invert/sg-eq :
  [ |- sg-eq (sg/named L S) (sg/named L' S')] ->
    [ |- sg-eq S S'] =
/ total /
?
;

proof sg-eq-pi-invert/1 :
  [ |- sg-eq (sg/pi S1 (\x. S2[x])) (sg/pi S1' (\x. S2'[x]))] ->
    [ |- sg-eq S1 S1'] =
/ total /
?
;

proof sg-eq-pi-invert/2 :
  [ |- sg-eq (sg/pi S1 (\x. S2[x])) (sg/pi S1' (\x. S2'[x]))] ->
    [ a : con |- sg-eq (S2[a]) (S2'[a])] =
/ total /
?
;

proof sg-eq-sigma-invert/1 :
  [ |- sg-eq (sg/sigma S1 (\x. S2[x])) (sg/sigma S1' (\x. S2'[x]))] ->
    [ |- sg-eq S1 S1'] =
/ total /
?
;

proof sg-eq-sigma-invert/2 :
  [ |- sg-eq (sg/sigma S1 (\x. S2[x])) (sg/sigma S1' (\x. S2'[x]))] ->
    [ a : con |- sg-eq (S2[a]) (S2'[a])] =
/ total /
?
;

% Contradiction

proof kind-eq-sigma-t : [ |- kind-eq (sigma K (\k. C[k])) t] -> [ |- false] =
/ total /
?
;

proof kind-eq-sigma-pi :
  [ |- kind-eq (sigma K (\k. C[k])) (pi K' (\k. C'[k]))] ->
    [ |- false] =
/ total /
?
;

proof kind-eq-t-sing : [ |- kind-eq t (sing C)] -> [ |- false] =
/ total /
?
;

% Respects Equality Lemmas

proof cn-equiv-resp :
  [ |- con-eq C1 C1'] ->
  [ |- con-eq C2 C2'] ->
  [ |- kind-eq K K'] ->
  [ |- cn-equiv C1 C2 K] ->
    [ |- cn-equiv C1' C2' K'] =
/ total /
?
;

proof cn-of-resp :
  [ |- con-eq C C'] ->
  [ |- kind-eq K K'] ->
  [ |- cn-of C K] ->
    [ |- cn-of C' K'] =
/ total /
?
;

proof kd-equiv-resp : [ |- kind-eq K1 K1'] ->
                        [ |- kind-eq K2 K2'] ->
                          [ |- kd-equiv K1 K2] -> [ |- kd-equiv K1' K2'] =
/ total /
?
;

proof kd-sub-resp :
  [ |- kind-eq K1 K1'] ->
  [ |- kind-eq K2 K2'] ->
  [ |- kd-sub K1 K2] ->
    [ |- kd-sub K1' K2'] =
/ total /
?
;

proof kd-wf-resp : [ |- kind-eq K K'] -> [ |- kd-wf K] -> [ |- kd-wf K'] =
/ total /
?
;

proof md-fst-resp :
  [ |- module-eq M1 M2] ->
  [ |- con-eq C1 C2] ->
  [ |- md-fst M1 C1] ->
    [ |- md-fst M2 C2] =
/ total /
?
;

proof md-of-resp :
  [ |- purity-eq P P'] ->
  [ |- sttp-eq F F'] ->
  [ |- module-eq M M'] ->
  [ |- sg-eq S S'] ->
  [ |- md-of P F M S] ->
    [ |- md-of P' F' M' S'] =
/ total /
?
;

proof sg-equiv-resp :
  [ |- sg-eq S1 S1'] ->
  [ |- sg-eq S2 S2'] ->
  [ |- sg-equiv S1 S2] ->
    [ |- sg-equiv S1' S2'] =
/ total /
?
;

proof sg-fst-resp :
  [ |- sg-eq S S'] ->
  [ |- kind-eq K K'] ->
  [ |- sg-fst S K] ->
    [ |- sg-fst S' K'] =
/ total /
?
;

proof sg-sub-resp :
  [ |- sg-eq S1 S1'] ->
  [ |- sg-eq S2 S2'] ->
  [ |- sg-sub S1 S2] ->
    [ |- sg-sub S1' S2'] =
/ total /
?
;

proof sg-wf-resp :
  [ |- sg-eq S S'] ->
  [ |- sg-wf S] ->
    [ |- sg-wf S'] =
/ total /
?
;

proof step-resp :
  [ |- store-eq ST1 ST1'] ->
  [ |- term-eq E1 E1'] ->
  [ |- store-eq ST2 ST2'] ->
  [ |- term-eq E2 E2'] ->
  [ |- step ST1 E1 ST2 E2] ->
    [ |- step ST1' E1' ST2' E2'] =
/ total /
?
;

proof step-md-resp :
  [ |- store-eq ST1 ST1'] ->
  [ |- module-eq M1 M1'] ->
  [ |- store-eq ST2 ST2'] ->
  [ |- module-eq M2 M2'] ->
  [ |- step-md ST1 M1 ST2 M2] ->
    [ |- step-md ST1' M1' ST2' M2'] =
/ total /
?
;

proof tm-of-resp :
  [ |- sttp-eq F F'] ->
  [ |- term-eq E E'] ->
  [ |- con-eq T T'] ->
  [ |- tm-of F E T] ->
    [ |- tm-of F' E' T'] =
/ total /
?
;

proof value-resp :
  [ |- term-eq E E'] ->
  [ |- value E] ->
    [ |- value E'] =
/ total /
?
;

proof value-md-resp :
  [ |- module-eq M M'] ->
  [ |- value-md M] ->
    [ |- value-md M'] =
/ total /
?
;
