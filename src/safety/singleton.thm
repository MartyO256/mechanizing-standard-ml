% Kind Lemmas

proof single-resp :
  (g : conblock)
  [g |- kind-eq K K'] ->
  [g, a : con |- kind-eq (Ks[.., a]) (Ks'[.., a])] ->
  [g |- single K (\x. Ks)] ->
    [g |- single K' (\x. Ks')] =
/ total /
?
;

LF can-single/existsKs : kind -> type =
| can-single/existsKs/i :
  { Ks : con -> kind } single K Ks -> can-single/existsKs K
;

proof can-single/existsKs/i :
  (g : conblock) { Ks : [g, a : con |- kind] } [g |- single K (\x. Ks)] ->
    [g |- can-single/existsKs K] =
/ total /
?
;

proof can-single :
  (g : conblock) { K : [g |- kind] } [g |- can-single/existsKs K] =
/ total 1 /
?
;

proof single-fun :
  (g : conblock)
  [g |- single K (\x. Ks)] ->
  [g |- single K (\x. Ks')] ->
    [g, a : con |- kind-eq (Ks[.., a]) (Ks'[.., a])] =
/ total 1 /
?
;

% Signature Lemmas

proof md-of-forget : [ |- md-of P F M S] -> [ |- md-of impure F M S] =
/ total /
?
;
