% Map into the singleton language

LF map : con -> eterm -> type =
| map/pair :
  map C1 M1 ->
  map C2 M2 ->
    map (pair C1 C2) (epair M1 M2)

| map/pi1 :
  map C M ->
    map (pi1 C) (epi1 M)

| map/pi2 :
  map C M ->
    map (pi2 C) (epi2 M)

| map/lam :
  tmap K A ->
  ({a : con} {x : eterm} map a x ->
   map (C a) (M x)) ->
    map (lam K C) (elam A M)

| map/app :
  map C1 M1 ->
  map C2 M2 ->
    map (app C1 C2) (eapp M1 M2)

| map/star : map star estar

| map/unit : map unit (econst const/unit)

| map/void : map void (econst const/void)

| map/prod :
  map C1 M1 ->
  map C2 M2 ->
    map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)

| map/arrow :
  map C1 M1 ->
  map C2 M2 ->
    map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)

| map/plus :
  map C1 M1 ->
  map C2 M2 ->
    map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)

| map/ref :
  map C M ->
    map (ref C) (eapp (econst const/ref) M)

| map/tag :
  map C M ->
    map (tag C) (eapp (econst const/tag) M)

| map/tagged : map tagged (econst const/tagged)

| map/rec :
  tmap K A ->
  ({a : con} {x : eterm} map a x ->
   {b : con} {y : eterm} map b y ->
   map (C1 a b) (M1 x y)) ->
  map C2 M2 ->
  flay A SK MA ->
    map (rec' K C1 C2)
      (eapp (econst (const/rec SK))
      (epair
        MA
        (epair (elam (epi A (\x. et))
        (\x. elam A (\y. M1 x y))) M2))
      )

| map/labeled :
  map C M ->
    map (labeled I C) (eapp (econst (const/labeled I)) M)

and tmap : kind -> etp -> type =
| tmap/t : tmap t et

| tmap/sing : map C M -> tmap (sing C) (esing M)

| tmap/pi :
  tmap K1 A1 ->
  ({a : con} {x : eterm} map a x -> tmap (K2 a) (A2 x)) ->
    tmap (pi K1 K2) (epi A1 A2)

| tmap/sigma :
  tmap K1 A1 ->
  ({a : con} {x : eterm} map a x -> tmap (K2 a) (A2 x)) ->
    tmap (sigma K1 K2) (esigma A1 A2)

| tmap/one : tmap one eone
;

% Map from the singleton language

LF unmap : eterm -> con -> type =
| unmap/app :
  unmap M1 C1 ->
  unmap M2 C2 ->
    unmap (eapp M1 M2) (app C1 C2)

| unmap/pi1 :
  unmap M C ->
    unmap (epi1 M) (pi1 C)

| unmap/pi2 :
  unmap M C ->
    unmap (epi2 M) (pi2 C)

| unmap/lam :
  tunmap A K ->
  ({x : eterm} {a : con} unmap x a -> unmap (M x) (C a)) ->
    unmap (elam A M) (lam K C)

| unmap/pair :
  unmap M1 C1 ->
  unmap M2 C2 ->
    unmap (epair M1 M2) (pair C1 C2)

| unmap/star : unmap estar star

| unmap/unit : unmap (econst const/unit) unit

| unmap/void : unmap (econst const/void) void

| unmap/prod : unmap (econst const/prod) (lam t (\a. lam t (\b. prod a b)))

| unmap/arrow : unmap (econst const/arrow) (lam t (\a. lam t (\b. arrow a b)))

| unmap/plus : unmap (econst const/plus) (lam t (\a. lam t (\b. plus a b)))

| unmap/ref : unmap (econst const/ref) (lam t (\a. ref a))

| unmap/tag : unmap (econst const/tag) (lam t (\a. tag a))

| unmap/tagged : unmap (econst const/tagged) tagged

| unmap/rec :
  skof-il SK K L ->
    unmap (econst (const/rec SK))
      (lam
        (sigma K
          (\a. sigma
            (pi (pi (L a) (\l. t)) (\k. (pi (L a) (\l. t))))
            (\l. (L a))
          )
        )
        (\b. rec'
          (L (pi1 b)) (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))
        )
      )

| unmap/labeled : unmap (econst (const/labeled I)) (lam t (\a. labeled I a))

and tunmap : etp -> kind -> type =
| tunmap/t : tunmap et t

| tunmap/sing : unmap M C -> tunmap (esing M) (sing C)

| tunmap/pi :
  tunmap A1 K1 ->
  ({x : eterm} {a : con} unmap x a ->
   tunmap (A2 x) (K2 a)) ->
    tunmap (epi A1 A2) (pi K1 K2)

| tunmap/sigma :
  tunmap A1 K1 ->
  ({x : eterm} {a : con} unmap x a ->
   tunmap (A2 x) (K2 a)) ->
    tunmap (esigma A1 A2) (sigma K1 K2)

| tunmap/one : tunmap eone one
;
--name map Dmap map.
--name tmap Dtmap tmap.
--name unmap Dunmap unmap.
--name tunmap Dtunmap tunmap.

schema unmap-block = some [a : con] block (x : eterm, xt : unmap x a);

schema conblock+unmap-block = block (a : con)
                            + some [a : con] block (x : eterm, xt : unmap x a);

proof unmap-resp :
  (g : conblock+unmap-block)
  [g |- eterm-eq M M'] ->
  [g |- con-eq C C'] ->
  [g |- unmap M C] ->
    [g |- unmap M' C'] =
/ total /
intros
{ g : conblock+unmap-block,
  M : (g |- eterm),
  M' : (g |- eterm),
  C : (g |- con),
  C' : (g |- con)
| eq : [g |- eterm-eq M M'],
  eq1 : [g |- con-eq C C'],
  unmap : [g |- unmap M C]
; split eq as
  case eterm-eq/i:
  { g : conblock+unmap-block,
    M' : (g |- eterm),
    C : (g |- con),
    C' : (g |- con)
  | eq : [g |- eterm-eq M' M'],
    eq1 : [g |- con-eq C C'],
    unmap : [g |- unmap M' C]
  ; split eq1 as
    case con-eq/i:
    { g : conblock+unmap-block, M' : (g |- eterm), C' : (g |- con)
    | eq : [g |- eterm-eq M' M'],
      eq1 : [g |- con-eq C' C'],
      unmap : [g |- unmap M' C']
    ; solve unmap
    }
  }
}
;

proof tunmap-resp :
  (g : conblock+unmap-block)
  [g |- etp-eq A A'] ->
  [g |- kind-eq K K'] ->
  [g |- tunmap A K] ->
    [g |- tunmap A' K'] =
/ total /
intros
{ g : conblock+unmap-block,
  A : (g |- etp),
  A' : (g |- etp),
  K : (g |- kind),
  K' : (g |- kind)
| eq : [g |- etp-eq A A'],
  eq1 : [g |- kind-eq K K'],
  tunmap : [g |- tunmap A K]
; split eq as
  case etp-eq/i:
  { g : conblock+unmap-block,
    A' : (g |- etp),
    K : (g |- kind),
    K' : (g |- kind)
  | eq : [g |- etp-eq A' A'],
    eq1 : [g |- kind-eq K K'],
    tunmap : [g |- tunmap A' K]
  ; split eq1 as
    case kind-eq/i:
    { g : conblock+unmap-block, A' : (g |- etp), K' : (g |- kind)
    | eq : [g |- etp-eq A' A'],
      eq1 : [g |- kind-eq K' K'],
      tunmap : [g |- tunmap A' K']
    ; solve tunmap
    }
  }
}
;

% Map Effectiveness

schema can-map-ctx =
  % evar
  block (ex : eterm) +
  % can-map-bind
  some [m : eterm]
  block (a : con, at : map a m) +
  % map-bind-for-can-map
  some [b : etp, k : kind]
  block (
    x : eterm, d : eof x b,
    a : con, e : cn-of a k,
    at : map a x
  ) +
  % invert-bind-for-can-map
  some [
    K : kind, K' : kind,
    B : etp,
    DmapK : tmap K B, DmapB : tunmap B K',
    DwfK : kd-wf K,
    DwfB : ewf B,
    DequivK : kd-equiv K K'
  ]
  block (
    a : con, da : cn-of a K,
    x : eterm, dx : eof x B,
    at : map a x, xt : unmap x a
  );

LF can-map/e : con -> type =
| can-map/i :
  { M : eterm }
  map C M ->
    can-map/e C
;

LF can-tmap/e : kind -> type =
| can-tmap/i :
  { A : etp }
  tmap K A ->
    can-tmap/e K
;

proof can-map :
  (g : can-map-ctx)
  { C : [g |- con] }
  [g |- can-map/e C] =
/ trust / % FIXME: See issue #4
intros
{ g : can-map-ctx,
  C : (g |- con)
|
; split [_ |- C] as
  case labeled:
  { g : can-map-ctx,
    X : ( |- label),
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      X : ( |- label),
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i _ (map/labeled Dmap)]
    }
  }
  case rec':
  { g : can-map-ctx,
    K : (g |- kind),
    C1 : (g, y180 : con, x180 : con |- con),
    C2 : (g |- con)
  |
  ; split can-tmap [g |- K] as
    case can-tmap/i:
    { g : can-map-ctx,
      K : (g |- kind),
      C1 : (g, y180 : con, x180 : con |- con),
      C2 : (g |- con),
      A : (g |- etp),
      Dtmap : (g |- tmap K A)
    |
    ; split
  can-map
  [g,
   b1 :
     block (
       x : eterm,
       d1 : eof x (A[..]),
       a : con,
       e1 : cn-of a (K[..]),
       at1 : map a x),
   b2 :
     block (
       y : eterm,
       d2 : eof y (A[..]),
       b : con,
       e1 : cn-of b (K[..]),
       at2 : map b y) |- C1[.., b1.3, b2.3]] as
      case can-map/i:
      { g : can-map-ctx,
        K : (g |- kind),
        C3 : (g, a : con, b : con |- con),
        C2 : (g |- con),
        A : (g |- etp),
        Dtmap : (g |- tmap K A),
        M : (g, x : eterm, y : eterm |- eterm),
        Dmap :
          (g, x : eterm, a : con, z1 : map a x, y : eterm, b : con,
           y2 : map b y |- map (C3[.., a, b]) (M[.., x, y]))
      |
      ; split can-map [g |- C2] as
        case can-map/i:
        { g : can-map-ctx,
          K : (g |- kind),
          C3 : (g, a : con, b : con |- con),
          C2 : (g |- con),
          A : (g |- etp),
          Dtmap : (g |- tmap K A),
          M : (g, x : eterm, y : eterm |- eterm),
          Dmap :
            (g, x : eterm, a : con, z1 : map a x, y : eterm, b : con,
             y2 : map b y |- map (C3[.., a, b]) (M[.., x, y])),
          M1 : (g |- eterm),
          Dmap1 : (g |- map C2 M1)
        |
        ; split can-flay [g |- A] as
          case can-flay/i:
          { g : can-map-ctx,
            K : (g |- kind),
            C3 : (g, a : con, b : con |- con),
            C2 : (g |- con),
            A : (g |- etp),
            Dtmap : (g |- tmap K A),
            M : (g, x : eterm, y : eterm |- eterm),
            Dmap :
              (g, x : eterm, a : con, z1 : map a x, y : eterm, b : con,
               y2 : map b y |- map (C3[.., a, b]) (M[.., x, y])),
            M1 : (g |- eterm),
            Dmap1 : (g |- map C2 M1),
            Dskel : ( |- skel),
            M2 : (g |- eterm),
            Dflay : (g |- flay A Dskel[] M2)
          |
          ; solve
              [g |-
                 can-map/i _
                 (map/rec Dtmap
                 (\a. \x. \at. \b. \y. \bt. Dmap[.., x, a, at, y, b, bt])
                 Dmap1 Dflay)]
          }
        }
      }
    }
  }
  case tagged:
  { g : can-map-ctx
  |
  ; solve [g |- can-map/i _ map/tagged]
  }
  case tag:
  { g : can-map-ctx,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i _ (map/tag Dmap)]
    }
  }
  case ref:
  { g : can-map-ctx,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i _ (map/ref Dmap)]
    }
  }
  case plus:
  { g : can-map-ctx,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : can-map-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i _ (map/plus Dmap Dmap1)]
      }
    }
  }
  case arrow:
  { g : can-map-ctx,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : can-map-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i _ (map/arrow Dmap Dmap1)]
      }
    }
  }
  case prod:
  { g : can-map-ctx,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : can-map-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve
          [g |-
             can-map/i (eapp (eapp (econst const/prod) M) M1)
             (map/prod Dmap Dmap1)]
      }
    }
  }
  case void:
  { g : can-map-ctx
  |
  ; solve [g |- can-map/i _ map/void]
  }
  case unit:
  { g : can-map-ctx
  |
  ; solve [g |- can-map/i _ map/unit]
  }
  case star:
  { g : can-map-ctx
  |
  ; solve [g |- can-map/i _ map/star]
  }
  case app:
  { g : can-map-ctx,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : can-map-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i (eapp M M1) (map/app Dmap Dmap1)]
      }
    }
  }
  case lam:
  { g : can-map-ctx,
    K : (g |- kind),
    C1 : (g, x175 : con |- con)
  |
  ; split can-tmap [g |- K] as
    case can-tmap/i:
    { g : can-map-ctx,
      K : (g |- kind),
      C1 : (g, x175 : con |- con),
      A : (g |- etp),
      Dtmap : (g |- tmap K A)
    |
    ; split
      can-map
        [g,
         b :
           block (
             x : eterm,
             d : eof x (A[..]),
             a : con,
             e : cn-of a (K[..]),
             at : map a x) |- C1[.., b.3]] as
      case can-map/i:
      { g : can-map-ctx,
        K : (g |- kind),
        C2 : (g, a : con |- con),
        A : (g |- etp),
        Dtmap : (g |- tmap K A),
        M : (g, x : eterm |- eterm),
        Dmap :
          (g, x : eterm, a : con, y1059 : map a x |-
             map (C2[.., a]) (M[.., x]))
      |
      ; by [g |- map/lam Dtmap (\a. \x. \at. Dmap[.., x, a, at])]
        as Dmap' unboxed;
        solve [g |- can-map/i _ Dmap']
      }
    }
  }
  case pi2:
  { g : can-map-ctx,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i (epi2 M) (map/pi2 Dmap)]
    }
  }
  case pi1:
  { g : can-map-ctx,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i (epi1 M) (map/pi1 Dmap)]
    }
  }
  case pair:
  { g : can-map-ctx,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : can-map-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i (epair M M1) (map/pair Dmap Dmap1)]
      }
    }
  }
  %{ FIXME: File "src/core/reconstruct.ml", line 2248, characters 11-16: Pattern matching failed
  case #.1:
  { g : can-map-ctx,
    K433 : (g |- kind),
    A20 : (g |- etp),
    #unmap :
      #(g |-
          block (
            a : con,
            da : cn-of a (K433[..]),
            x : eterm,
            dx : eof x (A20[..]),
            at : map a x,
            xt : unmap x a)),
    K434 : (g |- kind),
    Dtmap4 : (g |- tmap K433 A20),
    Dtunmap : (g |- tunmap A20 K434),
    Dwf61 : (g |- kd-wf K433),
    Y : (g |- ewf A20),
    Dequiv37 : (g |- kd-equiv K433 K434)
  |
  ; solve [_ |- can-map/i #unmap.3 #unmap.5]
  }
  case #.3:
  { g : can-map-ctx,
    A21 : (g |- etp),
    K435 : (g |- kind),
    #map :
      #(g |-
          block (
            x : eterm,
            d : eof x (A21[..]),
            a : con,
            e : cn-of a (K435[..]),
            at : map a x))
  |
  ; solve [_ |- can-map/i #map.1 #map.5]
  }
  case #.1:
  { g : can-map-ctx,
    M9 : (g |- eterm),
    #map : #(g |- block (a : con, at : map a (M9[..])))
  |
  ; solve [_ |- can-map/i _ #map.2]
  }
  }%
}

and proof can-tmap :
  (g : can-map-ctx)
  { K : [g |- kind] }
  [g |- can-tmap/e K] =
/ total 1 /
intros
{ g : can-map-ctx,
  K : (g |- kind)
|
; split [_ |- K] as
  case one:
  { g : can-map-ctx
  |
  ; solve [g |- can-tmap/i _ tmap/one]
  }
  case sigma:
  { g : can-map-ctx,
    K1 : (g |- kind),
    K2 : (g, y173 : con |- kind)
  |
  ; split can-tmap [g |- K1] as
    case can-tmap/i:
    { g : can-map-ctx,
      K1 : (g |- kind),
      K2 : (g, y173 : con |- kind),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A)
    |
    ; split
      can-tmap
        [g,
         b :
           block (
             x : eterm,
             d : eof x (A[..]),
             a : con,
             e : cn-of a (K1[..]),
             at : map a x) |- K2[.., b.3]] as
      case can-tmap/i:
      { g : can-map-ctx,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x1057 : map a x |-
             tmap (K3[.., a]) (A1[.., x]))
      |
      ; by [g |- tmap/sigma Dtmap (\a. \x. \xt. Dtmap1[.., x, a, xt])]
        as Dtmap' unboxed;
        solve [g |- can-tmap/i _ Dtmap']
      }
    }
  }
  case pi:
  { g : can-map-ctx,
    K1 : (g |- kind),
    K2 : (g, y172 : con |- kind)
  |
  ; split can-tmap [g |- K1] as
    case can-tmap/i:
    { g : can-map-ctx,
      K1 : (g |- kind),
      K2 : (g, y172 : con |- kind),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A)
    |
    ; split
      can-tmap
        [g,
         b :
           block (
             x : eterm,
             d : eof x (A[..]),
             a : con,
             e : cn-of a (K1[..]),
             at : map a x) |- K2[.., b.3]] as
      case can-tmap/i:
      { g : can-map-ctx,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x4 : map a x |-
             tmap (K3[.., a]) (A1[.., x]))
      |
      ; by [g |- tmap/pi Dtmap (\a. \x. \at. Dtmap1[.., x, a, at])] as Dtmap' unboxed;
        solve [g |- can-tmap/i _ Dtmap']
      }
    }
  }
  case sing:
  { g : can-map-ctx,
    C : (g |- con)
  |
  ; split can-map [g |- C] as
    case can-map/i:
    { g : can-map-ctx,
      C : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C M)
    |
    ; solve [g |- can-tmap/i _ (tmap/sing Dmap)]
    }
  }
  case t:
  { g : can-map-ctx
  |
  ; solve [g |- can-tmap/i _ tmap/t]
  }
}
;

% Map Functionality

schema map-fun-ctx =
  % evar
  block (ex : eterm) +
  % map-fun-bind
  some [x : eterm]
  block (a : con, at : map a x) +
  % map-bind-for-map-fun
  some [b : etp, k : kind]
  block (
    x : eterm, d : eof x b,
    a : con, e : cn-of a k,
    at : map a x
  ) +
  % invert-bind-for-map-fun
  some [K : kind, B : etp]
  block (
    a : con, da : cn-of a K,
    x : eterm, dx : eof x B,
    at : map a x
  );

proof map-fun :
  (g : map-fun-ctx)
  [g |- map C M] ->
  [g |- map C M'] ->
    [g |- eterm-eq M M'] =
/ total 1 /
intros
{ g : map-fun-ctx, C : (g |- con), M : (g |- eterm), M' : (g |- eterm)
| x : [g |- map C M], map : [g |- map C M']
; split x as
  case map/labeled:
  { g : map-fun-ctx,
    X : ( |- label),
    C1 : (g |- con),
    M1 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1)
  | x : [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)],
    map : [g |- map (labeled X[] C1) M']
  ; split map as
    case map/labeled:
    { g : map-fun-ctx,
      X : ( |- label),
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C1 M2)
    | x : [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)],
      map :
        [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M2)]
    ; split map-fun [g |- Dmap] [g |- Dmap1] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        X : ( |- label),
        C1 : (g |- con),
        M2 : (g |- eterm),
        Dmap : (g |- map C1 M2),
        Dmap1 : (g |- map C1 M2)
      | x :
          [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M2)],
        map :
          [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M2)]
      ; solve [g |- eterm-eq/i ]
      }
    }
  }
  case map/rec:
  { g : map-fun-ctx,
    K : (g |- kind),
    C1 : (g, a158 : con, a157 : con |- con),
    C2 : (g |- con),
    Dskel : ( |- skel),
    M3 : (g |- eterm),
    A : (g |- etp),
    M1 : (g, x923 : eterm, y923 : eterm |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dtmap : (g |- tmap K A),
    Dmap :
      (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
       z922 : map b y |- map (C1[.., a, b]) (M1[.., x, y])),
    Dmap1 : (g |- map C2 M2),
    Dflay : (g |- flay A Dskel[] M3)
  | x :
      [g |-
         map
           (rec' K (\z335. \y336. C1) C2)
           (eapp (econst (const/rec Dskel[]))
           (epair M3
           (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M1))) M2)))],
    map : [g |- map (rec' K (\z335. \y336. C1) C2) M']
  ; split map as
    case map/rec:
    { g : map-fun-ctx,
      K : (g |- kind),
      C1 : (g, a158 : con, a157 : con |- con),
      C2 : (g |- con),
      Dskel : ( |- skel),
      M3 : (g |- eterm),
      A : (g |- etp),
      M1 : (g, x923 : eterm, y923 : eterm |- eterm),
      M2 : (g |- eterm),
      Dskel1 : ( |- skel),
      M6 : (g |- eterm),
      A1 : (g |- etp),
      M4 : (g, x923 : eterm, y923 : eterm |- eterm),
      M5 : (g |- eterm),
      Dtmap : (g |- tmap K A),
      Dmap :
        (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
         z922 : map b y |- map (C1[.., a, b]) (M1[.., x, y])),
      Dmap1 : (g |- map C2 M2),
      Dflay : (g |- flay A Dskel[] M3),
      Dtmap1 : (g |- tmap K A1),
      Dmap2 :
        (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
         z922 : map b y |- map (C1[.., a, b]) (M4[.., x, y])),
      Dmap3 : (g |- map C2 M5),
      Dflay1 : (g |- flay A1 Dskel1[] M6)
    | x :
        [g |-
           map
             (rec' K (\z335. \y336. C1) C2)
             (eapp (econst (const/rec Dskel[]))
             (epair M3
             (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M1))) M2)))],
      map :
        [g |-
           map
             (rec' K (\z335. \y336. C1) C2)
             (eapp (econst (const/rec Dskel1[]))
             (epair M6
             (epair (elam (epi A1 (\x. et)) (\x. elam (A1[..]) (\y. M4))) M5)))]
    ; split map-fun [g |- Dmap1] [g |- Dmap3] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        K : (g |- kind),
        C1 : (g, a158 : con, a157 : con |- con),
        C2 : (g |- con),
        Dskel : ( |- skel),
        M3 : (g |- eterm),
        A : (g |- etp),
        M1 : (g, x923 : eterm, y923 : eterm |- eterm),
        M5 : (g |- eterm),
        Dskel1 : ( |- skel),
        M6 : (g |- eterm),
        A1 : (g |- etp),
        M4 : (g, x923 : eterm, y923 : eterm |- eterm),
        Dtmap : (g |- tmap K A),
        Dmap :
          (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
           z922 : map b y |- map (C1[.., a, b]) (M1[.., x, y])),
        Dmap1 : (g |- map C2 M5),
        Dflay : (g |- flay A Dskel[] M3),
        Dtmap1 : (g |- tmap K A1),
        Dmap2 :
          (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
           z922 : map b y |- map (C1[.., a, b]) (M4[.., x, y])),
        Dmap3 : (g |- map C2 M5),
        Dflay1 : (g |- flay A1 Dskel1[] M6)
      | x :
          [g |-
             map
               (rec' K (\z335. \y336. C1) C2)
               (eapp (econst (const/rec Dskel[]))
               (epair M3
               (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M1))) M5)))],
        map :
          [g |-
             map
               (rec' K (\z335. \y336. C1) C2)
               (eapp (econst (const/rec Dskel1[]))
               (epair M6
               (epair (elam (epi A1 (\x. et)) (\x. elam (A1[..]) (\y. M4)))
               M5)))]
      ; split
map-fun
  [g,
   b1 :
     block (
       x : eterm,
       d : eof x (A1[..]),
       a : con,
       e : cn-of a (K[..]),
       at : map a x),
   b2 :
     block (
       x : eterm,
       d : eof x (A1[..]),
       a : con,
       e : cn-of a (K[..]),
       at : map a x) |- Dmap[.., b1.3, b1.1, b1.5, b2.3, b2.1, b2.5]]
  [g,
   b1 :
     block (
       x : eterm,
       d : eof x (A1[..]),
       a : con,
       e : cn-of a (K[..]),
       at : map a x),
   b2 :
     block (
       x : eterm,
       d : eof x (A1[..]),
       a : con,
       e : cn-of a (K[..]),
       at : map a x) |- Dmap2[.., b1.3, b1.1, b1.5, b2.3, b2.1, b2.5]] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          K : (g |- kind),
          C1 : (g, a158 : con, a157 : con |- con),
          C2 : (g |- con),
          Dskel : ( |- skel),
          M3 : (g |- eterm),
          A : (g |- etp),
          M7 : (g, x : eterm, x : eterm |- eterm),
          M5 : (g |- eterm),
          Dskel1 : ( |- skel),
          M6 : (g |- eterm),
          A1 : (g |- etp),
          Dtmap : (g |- tmap K A),
          Dmap :
            (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
             z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
          Dmap1 : (g |- map C2 M5),
          Dflay : (g |- flay A Dskel[] M3),
          Dtmap1 : (g |- tmap K A1),
          Dmap2 :
            (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
             z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
          Dmap3 : (g |- map C2 M5),
          Dflay1 : (g |- flay A1 Dskel1[] M6)
        | x :
            [g |-
               map
                 (rec' K (\z335. \y336. C1) C2)
                 (eapp (econst (const/rec Dskel[]))
                 (epair M3
                 (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M7)))
                 M5)))],
          map :
            [g |-
               map
                 (rec' K (\z335. \y336. C1) C2)
                 (eapp (econst (const/rec Dskel1[]))
                 (epair M6
                 (epair (elam (epi A1 (\x. et)) (\x. elam (A1[..]) (\y. M7)))
                 M5)))]
        ; split tmap-fun [g |- Dtmap] [g |- Dtmap1] as
          case etp-eq/i:
          { g : map-fun-ctx,
            K : (g |- kind),
            C1 : (g, a158 : con, a157 : con |- con),
            C2 : (g |- con),
            Dskel : ( |- skel),
            M3 : (g |- eterm),
            A1 : (g |- etp),
            M7 : (g, x : eterm, x : eterm |- eterm),
            M5 : (g |- eterm),
            Dskel1 : ( |- skel),
            M6 : (g |- eterm),
            Dtmap : (g |- tmap K A1),
            Dmap :
              (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
               z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
            Dmap1 : (g |- map C2 M5),
            Dflay : (g |- flay A1 Dskel[] M3),
            Dtmap1 : (g |- tmap K A1),
            Dmap2 :
              (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
               z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
            Dmap3 : (g |- map C2 M5),
            Dflay1 : (g |- flay A1 Dskel1[] M6)
          | x :
              [g |-
                 map
                   (rec' K (\z529. \y530. C1) C2)
                   (eapp (econst (const/rec Dskel[]))
                   (epair M3
                   (epair (elam (epi A1 (\x. et))
                          (\x. elam (A1[..]) (\y. M7)))
                   M5)))],
            map :
              [g |-
                 map
                   (rec' K (\z529. \y530. C1) C2)
                   (eapp (econst (const/rec Dskel1[]))
                   (epair M6
                   (epair (elam (epi A1 (\x. et))
                          (\x. elam (A1[..]) (\y. M7)))
                   M5)))]
          ; split flay-fun [g |- Dflay] [g |- Dflay1] as
            case flay-fun/i:
            { g : map-fun-ctx,
              K : (g |- kind),
              C1 : (g, a158 : con, a157 : con |- con),
              C2 : (g |- con),
              Dskel : ( |- skel),
              M3 : (g |- eterm),
              A1 : (g |- etp),
              M7 : (g, x : eterm, x : eterm |- eterm),
              M5 : (g |- eterm),
              Dskel1 : ( |- skel),
              M6 : (g |- eterm),
              Dtmap : (g |- tmap K A1),
              Dmap :
                (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
                 z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
              Dmap1 : (g |- map C2 M5),
              Dflay : (g |- flay A1 Dskel[] M3),
              Dtmap1 : (g |- tmap K A1),
              Dmap2 :
                (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
                 z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
              Dmap3 : (g |- map C2 M5),
              Dflay1 : (g |- flay A1 Dskel1[] M6),
              Deq : ( |- skel-eq Dskel Dskel1),
              Deq1 : (g |- eterm-eq M3 M6)
            | x :
                [g |-
                   map
                     (rec' K (\z529. \y530. C1) C2)
                     (eapp (econst (const/rec Dskel[]))
                     (epair M3
                     (epair (elam (epi A1 (\x. et))
                            (\x. elam (A1[..]) (\y. M7)))
                     M5)))],
              map :
                [g |-
                   map
                     (rec' K (\z529. \y530. C1) C2)
                     (eapp (econst (const/rec Dskel1[]))
                     (epair M6
                     (epair (elam (epi A1 (\x. et))
                            (\x. elam (A1[..]) (\y. M7)))
                     M5)))]
            ; split [ |- Deq] as
              case skel-eq/i:
              { g : map-fun-ctx,
                K : (g |- kind),
                C1 : (g, a158 : con, a157 : con |- con),
                C2 : (g |- con),
                Dskel1 : ( |- skel),
                M3 : (g |- eterm),
                A1 : (g |- etp),
                M7 : (g, x : eterm, x : eterm |- eterm),
                M5 : (g |- eterm),
                M6 : (g |- eterm),
                Dtmap : (g |- tmap K A1),
                Dmap :
                  (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
                   z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
                Dmap1 : (g |- map C2 M5),
                Dflay : (g |- flay A1 Dskel1[] M3),
                Dtmap1 : (g |- tmap K A1),
                Dmap2 :
                  (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
                   z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
                Dmap3 : (g |- map C2 M5),
                Dflay1 : (g |- flay A1 Dskel1[] M6),
                Deq1 : (g |- eterm-eq M3 M6)
              | x :
                  [g |-
                     map
                       (rec' K (\z529. \y530. C1) C2)
                       (eapp (econst (const/rec Dskel1[]))
                       (epair M3
                       (epair (elam (epi A1 (\x. et))
                              (\x. elam (A1[..]) (\y. M7)))
                       M5)))],
                map :
                  [g |-
                     map
                       (rec' K (\z529. \y530. C1) C2)
                       (eapp (econst (const/rec Dskel1[]))
                       (epair M6
                       (epair (elam (epi A1 (\x. et))
                              (\x. elam (A1[..]) (\y. M7)))
                       M5)))]
              ; split [g |- Deq1] as
                case eterm-eq/i:
                { g : map-fun-ctx,
                  K : (g |- kind),
                  C1 : (g, a158 : con, a157 : con |- con),
                  C2 : (g |- con),
                  Dskel1 : ( |- skel),
                  M6 : (g |- eterm),
                  A1 : (g |- etp),
                  M7 : (g, x : eterm, x : eterm |- eterm),
                  M5 : (g |- eterm),
                  Dtmap : (g |- tmap K A1),
                  Dmap :
                    (g, a : con, x : eterm, x922 : map a x, b : con,
                     y : eterm,
                     z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
                  Dmap1 : (g |- map C2 M5),
                  Dflay : (g |- flay A1 Dskel1[] M6),
                  Dtmap1 : (g |- tmap K A1),
                  Dmap2 :
                    (g, a : con, x : eterm, x922 : map a x, b : con,
                     y : eterm,
                     z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
                  Dmap3 : (g |- map C2 M5),
                  Dflay1 : (g |- flay A1 Dskel1[] M6)
                | x :
                    [g |-
                       map
                         (rec' K (\z529. \y530. C1) C2)
                         (eapp (econst (const/rec Dskel1[]))
                         (epair M6
                         (epair (elam (epi A1 (\x. et))
                                (\x. elam (A1[..]) (\y. M7)))
                         M5)))],
                  map :
                    [g |-
                       map
                         (rec' K (\z529. \y530. C1) C2)
                         (eapp (econst (const/rec Dskel1[]))
                         (epair M6
                         (epair (elam (epi A1 (\x. et))
                                (\x. elam (A1[..]) (\y. M7)))
                         M5)))]
                ; solve [g |- eterm-eq/i ]
                }
              }
            }
          }
        }
      }
    }
  }
  case map/tagged:
  { g : map-fun-ctx, M' : (g |- eterm)
  | x : [g |- map tagged (econst const/tagged)], map : [g |- map tagged M']
  ; split map as
    case map/tagged:
    { g : map-fun-ctx
    | x : [g |- map tagged (econst const/tagged)],
      map : [g |- map tagged (econst const/tagged)]
    ; solve [g |- eterm-eq/i ]
    }
  }
  case map/tag:
  { g : map-fun-ctx,
    C1 : (g |- con),
    M1 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1)
  | x : [g |- map (tag C1) (eapp (econst const/tag) M1)],
    map : [g |- map (tag C1) M']
  ; split map as
    case map/tag:
    { g : map-fun-ctx,
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C1 M2)
    | x : [g |- map (tag C1) (eapp (econst const/tag) M1)],
      map : [g |- map (tag C1) (eapp (econst const/tag) M2)]
    ; split map-fun [g |- Dmap] [g |- Dmap1] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        M2 : (g |- eterm),
        Dmap : (g |- map C1 M2),
        Dmap1 : (g |- map C1 M2)
      | x : [g |- map (tag C1) (eapp (econst const/tag) M2)],
        map : [g |- map (tag C1) (eapp (econst const/tag) M2)]
      ; solve [g |- eterm-eq/i ]
      }
    }
  }
  case map/ref:
  { g : map-fun-ctx,
    C1 : (g |- con),
    M1 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1)
  | x : [g |- map (ref C1) (eapp (econst const/ref) M1)],
    map : [g |- map (ref C1) M']
  ; split map as
    case map/ref:
    { g : map-fun-ctx,
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C1 M2)
    | x : [g |- map (ref C1) (eapp (econst const/ref) M1)],
      map : [g |- map (ref C1) (eapp (econst const/ref) M2)]
    ; split map-fun [g |- Dmap] [g |- Dmap1] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        M2 : (g |- eterm),
        Dmap : (g |- map C1 M2),
        Dmap1 : (g |- map C1 M2)
      | x : [g |- map (ref C1) (eapp (econst const/ref) M2)],
        map : [g |- map (ref C1) (eapp (econst const/ref) M2)]
      ; solve [g |- eterm-eq/i ]
      }
    }
  }
  case map/plus:
  { g : map-fun-ctx,
    C1 : (g |- con),
    C2 : (g |- con),
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1),
    Dmap1 : (g |- map C2 M2)
  | x : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)],
    map : [g |- map (plus C1 C2) M']
  ; split map as
    case map/plus:
    { g : map-fun-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M4 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C2 M2),
      Dmap2 : (g |- map C1 M3),
      Dmap3 : (g |- map C2 M4)
    | x : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)],
      map : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M3) M4)]
    ; split map-fun [g |- Dmap] [g |- Dmap2] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M3 : (g |- eterm),
        M2 : (g |- eterm),
        M4 : (g |- eterm),
        Dmap : (g |- map C1 M3),
        Dmap1 : (g |- map C2 M2),
        Dmap2 : (g |- map C1 M3),
        Dmap3 : (g |- map C2 M4)
      | x : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M3) M2)],
        map : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M3) M4)]
      ; split map-fun [g |- Dmap1] [g |- Dmap3] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          C1 : (g |- con),
          C2 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dmap : (g |- map C1 M3),
          Dmap1 : (g |- map C2 M4),
          Dmap2 : (g |- map C1 M3),
          Dmap3 : (g |- map C2 M4)
        | x : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M3) M4)],
          map :
            [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M3) M4)]
        ; solve [g |- eterm-eq/i ]
        }
      }
    }
  }
  case map/arrow:
  { g : map-fun-ctx,
    C1 : (g |- con),
    C2 : (g |- con),
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1),
    Dmap1 : (g |- map C2 M2)
  | x : [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)],
    map : [g |- map (arrow C1 C2) M']
  ; split map as
    case map/arrow:
    { g : map-fun-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M4 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C2 M2),
      Dmap2 : (g |- map C1 M3),
      Dmap3 : (g |- map C2 M4)
    | x : [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)],
      map : [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M3) M4)]
    ; split map-fun [g |- Dmap] [g |- Dmap2] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M3 : (g |- eterm),
        M2 : (g |- eterm),
        M4 : (g |- eterm),
        Dmap : (g |- map C1 M3),
        Dmap1 : (g |- map C2 M2),
        Dmap2 : (g |- map C1 M3),
        Dmap3 : (g |- map C2 M4)
      | x : [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M3) M2)],
        map :
          [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M3) M4)]
      ; split map-fun [g |- Dmap1] [g |- Dmap3] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          C1 : (g |- con),
          C2 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dmap : (g |- map C1 M3),
          Dmap1 : (g |- map C2 M4),
          Dmap2 : (g |- map C1 M3),
          Dmap3 : (g |- map C2 M4)
        | x :
            [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M3) M4)],
          map :
            [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M3) M4)]
        ; solve [g |- eterm-eq/i ]
        }
      }
    }
  }
  case map/prod:
  { g : map-fun-ctx,
    C1 : (g |- con),
    C2 : (g |- con),
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1),
    Dmap1 : (g |- map C2 M2)
  | x : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)],
    map : [g |- map (prod C1 C2) M']
  ; split map as
    case map/prod:
    { g : map-fun-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M4 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C2 M2),
      Dmap2 : (g |- map C1 M3),
      Dmap3 : (g |- map C2 M4)
    | x : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)],
      map : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M3) M4)]
    ; split map-fun [g |- Dmap] [g |- Dmap2] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M3 : (g |- eterm),
        M2 : (g |- eterm),
        M4 : (g |- eterm),
        Dmap : (g |- map C1 M3),
        Dmap1 : (g |- map C2 M2),
        Dmap2 : (g |- map C1 M3),
        Dmap3 : (g |- map C2 M4)
      | x : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M3) M2)],
        map : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M3) M4)]
      ; split map-fun [g |- Dmap1] [g |- Dmap3] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          C1 : (g |- con),
          C2 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dmap : (g |- map C1 M3),
          Dmap1 : (g |- map C2 M4),
          Dmap2 : (g |- map C1 M3),
          Dmap3 : (g |- map C2 M4)
        | x : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M3) M4)],
          map :
            [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M3) M4)]
        ; solve [g |- eterm-eq/i ]
        }
      }
    }
  }
  case map/void:
  { g : map-fun-ctx, M' : (g |- eterm)
  | x : [g |- map void (econst const/void)], map : [g |- map void M']
  ; split map as
    case map/void:
    { g : map-fun-ctx
    | x : [g |- map void (econst const/void)],
      map : [g |- map void (econst const/void)]
    ; solve [g |- eterm-eq/i ]
    }
  }
  case map/unit:
  { g : map-fun-ctx, M' : (g |- eterm)
  | x : [g |- map unit (econst const/unit)], map : [g |- map unit M']
  ; split map as
    case map/unit:
    { g : map-fun-ctx
    | x : [g |- map unit (econst const/unit)],
      map : [g |- map unit (econst const/unit)]
    ; solve [g |- eterm-eq/i ]
    }
  }
  case map/star:
  { g : map-fun-ctx, M' : (g |- eterm)
  | x : [g |- map star estar], map : [g |- map star M']
  ; split map as
    case map/star:
    { g : map-fun-ctx
    | x : [g |- map star estar], map : [g |- map star estar]
    ; solve [g |- eterm-eq/i ]
    }
  }
  case map/app:
  { g : map-fun-ctx,
    C1 : (g |- con),
    C2 : (g |- con),
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1),
    Dmap1 : (g |- map C2 M2)
  | x : [g |- map (app C1 C2) (eapp M1 M2)], map : [g |- map (app C1 C2) M']
  ; split map as
    case map/app:
    { g : map-fun-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M4 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C2 M2),
      Dmap2 : (g |- map C1 M3),
      Dmap3 : (g |- map C2 M4)
    | x : [g |- map (app C1 C2) (eapp M1 M2)],
      map : [g |- map (app C1 C2) (eapp M3 M4)]
    ; split map-fun [g |- Dmap] [g |- Dmap2] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M3 : (g |- eterm),
        M2 : (g |- eterm),
        M4 : (g |- eterm),
        Dmap : (g |- map C1 M3),
        Dmap1 : (g |- map C2 M2),
        Dmap2 : (g |- map C1 M3),
        Dmap3 : (g |- map C2 M4)
      | x : [g |- map (app C1 C2) (eapp M3 M2)],
        map : [g |- map (app C1 C2) (eapp M3 M4)]
      ; split map-fun [g |- Dmap1] [g |- Dmap3] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          C1 : (g |- con),
          C2 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dmap : (g |- map C1 M3),
          Dmap1 : (g |- map C2 M4),
          Dmap2 : (g |- map C1 M3),
          Dmap3 : (g |- map C2 M4)
        | x : [g |- map (app C1 C2) (eapp M3 M4)],
          map : [g |- map (app C1 C2) (eapp M3 M4)]
        ; solve [g |- eterm-eq/i ]
        }
      }
    }
  }
  case map/lam:
  { g : map-fun-ctx,
    K : (g |- kind),
    C1 : (g, a156 : con |- con),
    A : (g |- etp),
    M1 : (g, x917 : eterm |- eterm),
    M' : (g |- eterm),
    Dtmap : (g |- tmap K A),
    Dmap :
      (g, a : con, x : eterm, y917 : map a x |- map (C1[.., a]) (M1[.., x]))
  | x : [g |- map (lam K (\y331. C1)) (elam A (\y146. M1))],
    map : [g |- map (lam K (\y331. C1)) M']
  ; split map as
    case map/lam:
    { g : map-fun-ctx,
      K : (g |- kind),
      C1 : (g, a156 : con |- con),
      A : (g |- etp),
      M1 : (g, x917 : eterm |- eterm),
      A1 : (g |- etp),
      M2 : (g, x917 : eterm |- eterm),
      Dtmap : (g |- tmap K A),
      Dmap :
        (g, a : con, x : eterm, y917 : map a x |- map (C1[.., a]) (M1[.., x])),
      Dtmap1 : (g |- tmap K A1),
      Dmap1 :
        (g, a : con, x : eterm, y917 : map a x |- map (C1[.., a]) (M2[.., x]))
    | x : [g |- map (lam K (\y331. C1)) (elam A (\y146. M1))],
      map : [g |- map (lam K (\y331. C1)) (elam A1 (\y146. M2))]
    ; split tmap-fun [g |- Dtmap] [g |- Dtmap1] as
      case etp-eq/i:
      { g : map-fun-ctx,
        K : (g |- kind),
        C1 : (g, a156 : con |- con),
        A1 : (g |- etp),
        M1 : (g, x917 : eterm |- eterm),
        M2 : (g, x917 : eterm |- eterm),
        Dtmap : (g |- tmap K A1),
        Dmap :
          (g, a : con, x : eterm, y917 : map a x |-
             map (C1[.., a]) (M1[.., x])),
        Dtmap1 : (g |- tmap K A1),
        Dmap1 :
          (g, a : con, x : eterm, y917 : map a x |-
             map (C1[.., a]) (M2[.., x]))
      | x : [g |- map (lam K (\y331. C1)) (elam A1 (\y146. M1))],
        map : [g |- map (lam K (\y331. C1)) (elam A1 (\y146. M2))]
      ; split
        map-fun
          [g,
           b :
             block (
               x : eterm,
               d : eof x (A1[..]),
               a : con,
               e : cn-of a (K[..]),
               at : map a x) |- Dmap[.., b.3, b.1, b.5]]
          [g,
           b :
             block (
               x : eterm,
               d : eof x (A1[..]),
               a : con,
               e : cn-of a (K[..]),
               at : map a x) |- Dmap1[.., b.3, b.1, b.5]] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          K : (g |- kind),
          C1 : (g, a156 : con |- con),
          A1 : (g |- etp),
          M3 : (g, x : eterm |- eterm),
          Dtmap : (g |- tmap K A1),
          Dmap :
            (g, a : con, x : eterm, y917 : map a x |-
               map (C1[.., a]) (M3[.., x])),
          Dtmap1 : (g |- tmap K A1),
          Dmap1 :
            (g, a : con, x : eterm, y917 : map a x |-
               map (C1[.., a]) (M3[.., x]))
        | x : [g |- map (lam K (\y331. C1)) (elam A1 (\y146. M3))],
          map : [g |- map (lam K (\y331. C1)) (elam A1 (\y146. M3))]
        ; solve [g |- eterm-eq/i ]
        }
      }
    }
  }
  case map/pi2:
  { g : map-fun-ctx,
    C1 : (g |- con),
    M1 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1)
  | x : [g |- map (pi2 C1) (epi2 M1)], map : [g |- map (pi2 C1) M']
  ; split map as
    case map/pi2:
    { g : map-fun-ctx,
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C1 M2)
    | x : [g |- map (pi2 C1) (epi2 M1)], map : [g |- map (pi2 C1) (epi2 M2)]
    ; by map-fun [g |- Dmap] [g |- Dmap1] as Deq1 unboxed;
      solve eterm-resp-eterm [x : eterm |- epi2 x] [g |- Deq1]
    }
  }
  case map/pi1:
  { g : map-fun-ctx,
    C1 : (g |- con),
    M1 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1)
  | x : [g |- map (pi1 C1) (epi1 M1)], map : [g |- map (pi1 C1) M']
  ; split map as
    case map/pi1:
    { g : map-fun-ctx,
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C1 M2)
    | x : [g |- map (pi1 C1) (epi1 M1)], map : [g |- map (pi1 C1) (epi1 M2)]
    ; by map-fun [g |- Dmap] [g |- Dmap1] as Deq1 unboxed;
      solve eterm-resp-eterm [x : eterm |- epi1 x] [g |- Deq1]
    }
  }
  case map/pair:
  { g : map-fun-ctx,
    C1 : (g |- con),
    C2 : (g |- con),
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1),
    Dmap1 : (g |- map C2 M2)
  | x : [g |- map (pair C1 C2) (epair M1 M2)],
    map : [g |- map (pair C1 C2) M']
  ; split map as
    case map/pair:
    { g : map-fun-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M4 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C2 M2),
      Dmap2 : (g |- map C1 M3),
      Dmap3 : (g |- map C2 M4)
    | x : [g |- map (pair C1 C2) (epair M1 M2)],
      map : [g |- map (pair C1 C2) (epair M3 M4)]
    ; by map-fun [g |- Dmap] [g |- Dmap2] as Deq1 unboxed;
      by map-fun [g |- Dmap1] [g |- Dmap3] as Deq2 unboxed;
      solve
        eterm-resp-eterm2 [x : eterm, y : eterm |- epair x y] [g |- Deq1]
          [g |- Deq2]
    }
  }
  %{ FIXME: File "src/core/reconstruct.ml", line 2248, characters 11-16: Pattern matching failed
  case #.5:
  { g : map-fun-ctx,
    K888 : (g |- kind),
    A157 : (g |- etp),
    #map :
      #(g |-
          block (
            a : con,
            da : cn-of a (K888[..]),
            x : eterm,
            dx : eof x (A157[..]),
            at : map a x)),
    M' : (g |- eterm)
  | x : [g |- map #map.1 #map.3], map : [g |- map #map.1 M']
  ; split map as
    case #.5:
    { g : map-fun-ctx,
      K888 : (g |- kind),
      A157 : (g |- etp),
      #map :
        #(g |-
            block (
              a : con,
              da : cn-of a (K888[..]),
              x : eterm,
              dx : eof x (A157[..]),
              at : map a x))
    | x : [g |- map #map.1 #map.3], map : [g |- map #map.1 #map.3]
    ; solve [_ |- eterm-eq/i ]
    }
  }
  case #.5:
  { g : map-fun-ctx,
    A158 : (g |- etp),
    K889 : (g |- kind),
    #map :
      #(g |-
          block (
            x : eterm,
            d : eof x (A158[..]),
            a : con,
            e : cn-of a (K889[..]),
            at : map a x)),
    M' : (g |- eterm)
  | x : [g |- map #map.3 #map.1], map : [g |- map #map.3 M']
  ; split map as
    case #.5:
    { g : map-fun-ctx,
      A158 : (g |- etp),
      K889 : (g |- kind),
      #map :
        #(g |-
            block (
              x : eterm,
              d : eof x (A158[..]),
              a : con,
              e : cn-of a (K889[..]),
              at : map a x))
    | x : [g |- map #map.3 #map.1], map : [g |- map #map.3 #map.1]
    ; solve [_ |- eterm-eq/i ]
    }
  }
  case #.2:
  { g : map-fun-ctx,
    M : (g |- eterm),
    #map : #(g |- block (a : con, at : map a (M[..]))),
    M' : (g |- eterm)
  | x : [g |- map #map.1 M], map : [g |- map #map.1 M']
  ; split map as
    case #.2:
    { g : map-fun-ctx,
      M' : (g |- eterm),
      #map : #(g |- block (a : con, at : map a (M'[..])))
    | x : [g |- map #map.1 M'], map : [g |- map #map.1 M']
    ; solve [_ |- eterm-eq/i ]
    }
  }
  }%
}

and proof tmap-fun :
  (g : map-fun-ctx)
  [g |- tmap K A] ->
  [g |- tmap K A'] ->
    [g |- etp-eq A A'] =
/ total 1 /
intros
{ g : map-fun-ctx, K : (g |- kind), A : (g |- etp), A' : (g |- etp)
| x : [g |- tmap K A], tmap : [g |- tmap K A']
; split x as
  case tmap/one:
  { g : map-fun-ctx, A' : (g |- etp)
  | x : [g |- tmap one eone], tmap : [g |- tmap one A']
  ; split tmap as
    case tmap/one:
    { g : map-fun-ctx
    | x : [g |- tmap one eone], tmap : [g |- tmap one eone]
    ; solve [_ |- etp-eq/i ]
    }
  }
  case tmap/sigma:
  { g : map-fun-ctx,
    K1 : (g |- kind),
    K2 : (g, a160 : con |- kind),
    A1 : (g |- etp),
    A2 : (g, z926 : eterm |- etp),
    A' : (g |- etp),
    Dtmap : (g |- tmap K1 A1),
    Dtmap1 :
      (g, a : con, x : eterm, x926 : map a x |- tmap (K2[.., a]) (A2[.., x]))
  | x : [g |- tmap (sigma K1 (\z328. K2)) (esigma A1 (\y143. A2))],
    tmap : [g |- tmap (sigma K1 (\z328. K2)) A']
  ; split tmap as
    case tmap/sigma:
    { g : map-fun-ctx,
      K1 : (g |- kind),
      K2 : (g, a160 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, z926 : eterm |- etp),
      A3 : (g |- etp),
      A4 : (g, z926 : eterm |- etp),
      Dtmap : (g |- tmap K1 A1),
      Dtmap1 :
        (g, a : con, x : eterm, x926 : map a x |-
           tmap (K2[.., a]) (A2[.., x])),
      Dtmap2 : (g |- tmap K1 A3),
      Dtmap3 :
        (g, a : con, x : eterm, x926 : map a x |-
           tmap (K2[.., a]) (A4[.., x]))
    | x : [g |- tmap (sigma K1 (\z328. K2)) (esigma A1 (\y143. A2))],
      tmap : [g |- tmap (sigma K1 (\z328. K2)) (esigma A3 (\y143. A4))]
    ; split tmap-fun [_ |- Dtmap] [_ |- Dtmap2] as
      case etp-eq/i:
      { g : map-fun-ctx,
        K1 : (g |- kind),
        K2 : (g, a160 : con |- kind),
        A3 : (g |- etp),
        A2 : (g, z926 : eterm |- etp),
        A4 : (g, z926 : eterm |- etp),
        Dtmap : (g |- tmap K1 A3),
        Dtmap1 :
          (g, a : con, x : eterm, x926 : map a x |-
             tmap (K2[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K1 A3),
        Dtmap3 :
          (g, a : con, x : eterm, x926 : map a x |-
             tmap (K2[.., a]) (A4[.., x]))
      | x : [g |- tmap (sigma K1 (\z328. K2)) (esigma A3 (\y143. A2))],
        tmap : [g |- tmap (sigma K1 (\z328. K2)) (esigma A3 (\y143. A4))]
      ; split
tmap-fun
  [g,
   b :
     block (
       x : eterm,
       d : eof x (A3[..]),
       a : con,
       e : cn-of a (K1[..]),
       at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
  [g,
   b :
     block (
       x : eterm,
       d : eof x (A3[..]),
       a : con,
       e : cn-of a (K1[..]),
       at : map a x) |- Dtmap3[.., b.3, b.1, b.5]] as
        case etp-eq/i:
        { g : map-fun-ctx,
          K1 : (g |- kind),
          K2 : (g, a160 : con |- kind),
          A3 : (g |- etp),
          A5 : (g, x : eterm |- etp),
          Dtmap : (g |- tmap K1 A3),
          Dtmap1 :
            (g, a : con, x : eterm, x926 : map a x |-
               tmap (K2[.., a]) (A5[.., x])),
          Dtmap2 : (g |- tmap K1 A3),
          Dtmap3 :
            (g, a : con, x : eterm, x926 : map a x |-
               tmap (K2[.., a]) (A5[.., x]))
        | x : [g |- tmap (sigma K1 (\z328. K2)) (esigma A3 (\y143. A5))],
          tmap : [g |- tmap (sigma K1 (\z328. K2)) (esigma A3 (\y143. A5))]
        ; solve [g |- etp-eq/i ]
        }
      }
    }
  }
  case tmap/pi:
  { g : map-fun-ctx,
    K1 : (g |- kind),
    K2 : (g, a159 : con |- kind),
    A1 : (g |- etp),
    A2 : (g, x925 : eterm |- etp),
    A' : (g |- etp),
    Dtmap : (g |- tmap K1 A1),
    Dtmap1 :
      (g, a : con, x : eterm, y925 : map a x |- tmap (K2[.., a]) (A2[.., x]))
  | x : [g |- tmap (pi K1 (\z327. K2)) (epi A1 (\y142. A2))],
    tmap : [g |- tmap (pi K1 (\z327. K2)) A']
  ; split tmap as
    case tmap/pi:
    { g : map-fun-ctx,
      K1 : (g |- kind),
      K2 : (g, a159 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, x925 : eterm |- etp),
      A3 : (g |- etp),
      A4 : (g, x925 : eterm |- etp),
      Dtmap : (g |- tmap K1 A1),
      Dtmap1 :
        (g, a : con, x : eterm, y925 : map a x |-
           tmap (K2[.., a]) (A2[.., x])),
      Dtmap2 : (g |- tmap K1 A3),
      Dtmap3 :
        (g, a : con, x : eterm, y925 : map a x |-
           tmap (K2[.., a]) (A4[.., x]))
    | x : [g |- tmap (pi K1 (\z327. K2)) (epi A1 (\y142. A2))],
      tmap : [g |- tmap (pi K1 (\z327. K2)) (epi A3 (\y142. A4))]
    ; split tmap-fun [_ |- Dtmap] [_ |- Dtmap2] as
      case etp-eq/i:
      { g : map-fun-ctx,
        K1 : (g |- kind),
        K2 : (g, a159 : con |- kind),
        A3 : (g |- etp),
        A2 : (g, x925 : eterm |- etp),
        A4 : (g, x925 : eterm |- etp),
        Dtmap : (g |- tmap K1 A3),
        Dtmap1 :
          (g, a : con, x : eterm, y925 : map a x |-
             tmap (K2[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K1 A3),
        Dtmap3 :
          (g, a : con, x : eterm, y925 : map a x |-
             tmap (K2[.., a]) (A4[.., x]))
      | x : [g |- tmap (pi K1 (\z327. K2)) (epi A3 (\y142. A2))],
        tmap : [g |- tmap (pi K1 (\z327. K2)) (epi A3 (\y142. A4))]
      ; split
tmap-fun
  [g,
   b :
     block (
       x : eterm,
       d : eof x (A3[..]),
       a : con,
       e : cn-of a (K1[..]),
       at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
  [g,
   b :
     block (
       x : eterm,
       d : eof x (A3[..]),
       a : con,
       e : cn-of a (K1[..]),
       at : map a x) |- Dtmap3[.., b.3, b.1, b.5]] as
        case etp-eq/i:
        { g : map-fun-ctx,
          K1 : (g |- kind),
          K2 : (g, a159 : con |- kind),
          A3 : (g |- etp),
          A5 : (g, x : eterm |- etp),
          Dtmap : (g |- tmap K1 A3),
          Dtmap1 :
            (g, a : con, x : eterm, y925 : map a x |-
               tmap (K2[.., a]) (A5[.., x])),
          Dtmap2 : (g |- tmap K1 A3),
          Dtmap3 :
            (g, a : con, x : eterm, y925 : map a x |-
               tmap (K2[.., a]) (A5[.., x]))
        | x : [g |- tmap (pi K1 (\z327. K2)) (epi A3 (\y142. A5))],
          tmap : [g |- tmap (pi K1 (\z327. K2)) (epi A3 (\y142. A5))]
        ; solve [g |- etp-eq/i ]
        }
      }
    }
  }
  case tmap/sing:
  { g : map-fun-ctx,
    C : (g |- con),
    M : (g |- eterm),
    A' : (g |- etp),
    Dmap : (g |- map C M)
  | x : [g |- tmap (sing C) (esing M)], tmap : [g |- tmap (sing C) A']
  ; split tmap as
    case tmap/sing:
    { g : map-fun-ctx,
      C : (g |- con),
      M : (g |- eterm),
      M1 : (g |- eterm),
      Dmap : (g |- map C M),
      Dmap1 : (g |- map C M1)
    | x : [g |- tmap (sing C) (esing M)],
      tmap : [g |- tmap (sing C) (esing M1)]
    ; split map-fun [_ |- Dmap] [_ |- Dmap1] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C : (g |- con),
        M1 : (g |- eterm),
        Dmap : (g |- map C M1),
        Dmap1 : (g |- map C M1)
      | x : [g |- tmap (sing C) (esing M1)],
        tmap : [g |- tmap (sing C) (esing M1)]
      ; solve [_ |- etp-eq/i ]
      }
    }
  }
  case tmap/t:
  { g : map-fun-ctx, A' : (g |- etp)
  | x : [g |- tmap t et], tmap : [g |- tmap t A']
  ; split tmap as
    case tmap/t:
    { g : map-fun-ctx
    | x : [g |- tmap t et], tmap : [g |- tmap t et]
    ; solve [_ |- etp-eq/i ]
    }
  }
}
;

% Map Preserves Typing

schema map-bind =
  % ebind
  some [ea : etp]
  block (ex : eterm, ed : eof ex ea) +
  % map-bind
  some [B : etp, K : kind, Dmap : tmap K B, Dwf : ewf B]
  block (
    x : eterm, dx : eof x B,
    a : con, da : cn-of a K,
    at : map a x
  );

LF map-of/e : kind -> eterm -> type =
| map-of/i :
  { A : etp }
  tmap K A ->
  eof M A ->
    map-of/e K M
;

LF map-of'/e : eterm -> etp -> type =
| map-of'/i : eof M A -> map-of'/e M A
;

LF map-wf/e : kind -> type =
| map-wf/i :
  { A : etp }
  tmap K A ->
  ewf A ->
    map-wf/e K
;

LF map-wf'/e : etp -> type =
| map-wf'/i : ewf A -> map-wf'/e A
;

LF map-subtp/e : etp -> etp -> type =
| map-subtp/i : subtp A B -> map-subtp/e A B
;

LF map-tequiv/e : etp -> etp -> type =
| map-tequiv/i : tequiv A B -> map-tequiv/e A B
;

LF map-equiv'/e : eterm -> eterm -> kind -> type =
| map-equiv'/i :
  { A : etp }
  tmap K A ->
  equiv M N A ->
    map-equiv'/e M N K
;

LF map-equiv''/e : eterm -> eterm -> etp -> type =
| map-equiv''/i : equiv M N A -> map-equiv''/e M N A
;

proof map-of :
  (g : map-bind)
  [g |- cn-of C K] ->
  [g |- map C M] ->
    [g |- map-of/e K M] =
/ total 1 /
intros
{ g : map-bind,
  C : (g |- con),
  K : (g |- kind),
  M : (g |- eterm)
| x : [g |- cn-of C K], map : [g |- map C M]
; by map as Dmap unboxed;
  split x as
  case cn-of/subsume:
  { g : map-bind,
    C : (g |- con),
    K : (g |- kind),
    M : (g |- eterm),
    Dmap : (g |- map C M),
    K1 : (g |- kind),
    Dof : (g |- cn-of C K1),
    Dsub : (g |- kd-sub K1 K)
  | x : [g |- cn-of C K], map : [g |- map C M]
  ; split map-of [_ |- Dof] [_ |- Dmap] as
    case map-of/i:
    { g : map-bind,
      C : (g |- con),
      K : (g |- kind),
      M : (g |- eterm),
      Dmap : (g |- map C M),
      K1 : (g |- kind),
      Dof : (g |- cn-of C K1),
      Dsub : (g |- kd-sub K1 K),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A),
      Dof1 : (g |- eof M A)
    | x : [g |- cn-of C K], map : [g |- map C M]
    ; split can-tmap [_ |- K] as
      case can-tmap/i:
      { g : map-bind,
        C : (g |- con),
        K : (g |- kind),
        M : (g |- eterm),
        Dmap : (g |- map C M),
        K1 : (g |- kind),
        Dof : (g |- cn-of C K1),
        Dsub : (g |- kd-sub K1 K),
        A : (g |- etp),
        DmapA : (g |- tmap K1 A),
        Dof' : (g |- eof M A),
        A1 : (g |- etp),
        Dtmap : (g |- tmap K A1)
      | x : [g |- cn-of C K], map : [g |- map C M]
      ; split map-subtp [g |- Dsub] [g |- DmapA] [g |- Dtmap] as
        case map-subtp/i:
        { g : map-bind,
          C : (g |- con),
          K : (g |- kind),
          M : (g |- eterm),
          Dmap : (g |- map C M),
          K1 : (g |- kind),
          Dof : (g |- cn-of C K1),
          Dsub : (g |- kd-sub K1 K),
          A : (g |- etp),
          DmapA : (g |- tmap K1 A),
          Dof' : (g |- eof M A),
          A1 : (g |- etp),
          DmapB : (g |- tmap K A1),
          Dsub1 : (g |- subtp A A1)
        | x : [g |- cn-of C K], map : [g |- map C M]
        ; solve [g |- map-of/i _ DmapB (eof/subsume Dof' Dsub1)]
        }
      }
    }
  }
  case cn-of/extsigma:
  { g : map-bind,
    C : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a23 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map C M),
    Dof : (g |- cn-of (pi1 C) K1),
    Dof1 : (g |- cn-of (pi2 C) (K2[.., pi1 C])),
    Dwf : (g, a : con, y328 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of C (sigma K1 (\x248. K2))], map : [g |- map C M]
  ; split map-of [g |- Dof] [g |- map/pi1 Dmap] as
    case map-of/i:
    { g : map-bind,
      C : (g |- con),
      K1 : (g |- kind),
      K2 : (g, a23 : con |- kind),
      M : (g |- eterm),
      Dmap : (g |- map C M),
      Dof : (g |- cn-of (pi1 C) K1),
      Dof1 : (g |- cn-of (pi2 C) (K2[.., pi1 C])),
      Dwf : (g, a : con, y328 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A),
      Dof2 : (g |- eof (epi1 M) A)
    | x : [g |- cn-of C (sigma K1 (\z328. K2))], map : [g |- map C M]
    ; split
      map-wf
        [g,
         b :
           block (
             x : eterm,
             dx : eof x (A[..]),
             a : con,
             da : cn-of a (K1[..]),
             at : map a x) |- Dwf[.., b.3, b.4]] as
      case map-wf/i:
      { g : map-bind,
        C : (g |- con),
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        M : (g |- eterm),
        Dmap : (g |- map C M),
        Dof : (g |- cn-of (pi1 C) K1),
        Dof1 : (g |- cn-of (pi2 C) (K3[.., pi1 C])),
        Dwf : (g, a : con, y328 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        Dof2 : (g |- eof (epi1 M) A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x1284 : map a x |-
             tmap (K3[.., a]) (A1[.., x])),
        Dwf1 : (g, x : eterm, dx : eof x (A[..]) |- ewf (A1[.., x]))
      | x : [g |- cn-of C (sigma K1 (\z328. K3))], map : [g |- map C M]
      ; split
map-of' [g |- Dof1] [g |- map/pi2 Dmap]
  [g |- Dtmap1[.., epi1 M, pi1 C, map/pi1 Dmap]] as
        case map-of'/i:
        { g : map-bind,
          C : (g |- con),
          K1 : (g |- kind),
          K3 : (g, a : con |- kind),
          M : (g |- eterm),
          Dmap : (g |- map C M),
          Dof : (g |- cn-of (pi1 C) K1),
          Dof1 : (g |- cn-of (pi2 C) (K3[.., pi1 C])),
          Dwf : (g, a : con, y328 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
          A : (g |- etp),
          Dtmap : (g |- tmap K1 A),
          Dof2 : (g |- eof (epi1 M) A),
          A1 : (g, x : eterm |- etp),
          Dtmap1 :
            (g, x : eterm, a : con, x1284 : map a x |-
               tmap (K3[.., a]) (A1[.., x])),
          Dwf1 : (g, x : eterm, dx : eof x (A[..]) |- ewf (A1[.., x])),
          Dof3 : (g |- eof (epi2 M) (A1[.., epi1 M]))
        | x : [g |- cn-of C (sigma K1 (\z522. K3))], map : [g |- map C M]
        ; solve
  [g |-
     map-of/i _
     (tmap/sigma Dtmap (\a. \x. \at. Dtmap1[.., x, a, at]))
     (eof/extsigma Dof2 Dof3 (\x. \dx. Dwf1))]
        }
      }
    }
  }
  case cn-of/extpi:
  { g : map-bind,
    C : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a22 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map C M),
    K2 : (g, a21 : con |- kind),
    Dof : (g |- cn-of C (pi K1 (\x247. K2))),
    Dof1 :
      (g, a : con, z326 : cn-of a (K1[..]) |-
         cn-of (app (C[..]) a) (K3[.., a]))
  | x : [g |- cn-of C (pi K1 (\x247. K3))], map : [g |- map C M]
  ; split map-of [g |- Dof] [g |- Dmap] as
    case map-of/i:
    { g : map-bind,
      C : (g |- con),
      K1 : (g |- kind),
      K3 : (g, a22 : con |- kind),
      M : (g |- eterm),
      Dmap : (g |- map C M),
      K2 : (g, a21 : con |- kind),
      DofPre : (g |- cn-of C (pi K1 (\x247. K2))),
      Dof :
        (g, a : con, z326 : cn-of a (K1[..]) |-
           cn-of (app (C[..]) a) (K3[.., a])),
      A : (g |- etp),
      Dtmap : (g |- tmap (pi K1 (\x247. K2)) A),
      Dof1 : (g |- eof M A)
    | x : [g |- cn-of C (pi K1 (\z521. K3))], map : [g |- map C M]
    ; split [g |- Dtmap] as
      case tmap/pi:
      { g : map-bind,
        C : (g |- con),
        K1 : (g |- kind),
        K3 : (g, a22 : con |- kind),
        M : (g |- eterm),
        Dmap : (g |- map C M),
        K2 : (g, a21 : con |- kind),
        DofPre : (g |- cn-of C (pi K1 (\x247. K2))),
        Dof :
          (g, a : con, z326 : cn-of a (K1[..]) |-
             cn-of (app (C[..]) a) (K3[.., a])),
        A1 : (g |- etp),
        A2 : (g, x1261 : eterm |- etp),
        Dtmap1 : (g |- tmap K1 A1),
        Dtmap2 :
          (g, a : con, x : eterm, y1261 : map a x |-
             tmap (K2[.., a]) (A2[.., x])),
        Dof1 : (g |- eof M (epi A1 (\z146. A2)))
      | x : [g |- cn-of C (pi K1 (\z521. K3))], map : [g |- map C M]
      ; split eof-reg [g |- Dof1] as
        case ewf/pi:
        { g : map-bind,
          C : (g |- con),
          K1 : (g |- kind),
          K3 : (g, a22 : con |- kind),
          M : (g |- eterm),
          Dmap : (g |- map C M),
          K2 : (g, a21 : con |- kind),
          DofPre : (g |- cn-of C (pi K1 (\x247. K2))),
          Dof :
            (g, a : con, z326 : cn-of a (K1[..]) |-
               cn-of (app (C[..]) a) (K3[.., a])),
          A1 : (g |- etp),
          A2 : (g, x1261 : eterm |- etp),
          Dtmap1 : (g |- tmap K1 A1),
          Dtmap2 :
            (g, a : con, x : eterm, y1261 : map a x |-
               tmap (K2[.., a]) (A2[.., x])),
          Dof1 : (g |- eof M (epi A1 (\z146. A2))),
          Dwf : (g |- ewf A1),
          Dwf1 : (g, x : eterm, z159 : eof x (A1[..]) |- ewf (A2[.., x]))
        | x : [g |- cn-of C (pi K1 (\z521. K3))], map : [g |- map C M]
        ; split
          map-of
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dof[.., b.3, b.4]]
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- map/app (Dmap[..]) b.5] as
          case map-of/i:
          { g : map-bind,
            C : (g |- con),
            K1 : (g |- kind),
            K4 : (g, a : con |- kind),
            M : (g |- eterm),
            Dmap : (g |- map C M),
            K2 : (g, a21 : con |- kind),
            DofPre : (g |- cn-of C (pi K1 (\x247. K2))),
            Dof :
              (g, a : con, z326 : cn-of a (K1[..]) |-
                 cn-of (app (C[..]) a) (K4[.., a])),
            A1 : (g |- etp),
            A2 : (g, x1261 : eterm |- etp),
            Dtmap1 : (g |- tmap K1 A1),
            Dtmap2 :
              (g, a : con, x : eterm, y1261 : map a x |-
                 tmap (K2[.., a]) (A2[.., x])),
            Dof1 : (g |- eof M (epi A1 (\z146. A2))),
            Dwf : (g |- ewf A1),
            Dwf1 : (g, x : eterm, z159 : eof x (A1[..]) |- ewf (A2[.., x])),
            A3 : (g, x : eterm |- etp),
            Dtmap3 :
              (g, x : eterm, a : con, y29 : map a x |-
                 tmap (K4[.., a]) (A3[.., x])),
            Dof2 :
              (g, x : eterm, dx : eof x (A1[..]) |-
                 eof (eapp (M[..]) x) (A3[.., x]))
          | x : [g |- cn-of C (pi K1 (\z521. K4))], map : [g |- map C M]
          ; solve
              [g |-
                 map-of/i _
                 (tmap/pi Dtmap1 (\a. \x. \at. Dtmap3[.., x, a, at]))
                 (eof/extpi Dof1 (\x. \dx. Dof2))]
          }
        }
      }
    }
  }
  case cn-of/sing:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map C M),
    Dof : (g |- cn-of C t)
  | x : [g |- cn-of C (sing C)], map : [g |- map C M]
  ; split map-of' [g |- Dof] [g |- Dmap] [g |- tmap/t] as
    case map-of'/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C M),
      Dof : (g |- cn-of C t),
      Dof1 : (g |- eof M et)
    | x : [g |- cn-of C (sing C)], map : [g |- map C M]
    ; solve [g |- map-of/i _ (tmap/sing Dmap) (eof/sing Dof1)]
    }
  }
  case cn-of/labeled:
  { g : map-bind,
    X : ( |- label),
    C1 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (labeled X[] C1) M),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (labeled X[] C1) t], map : [g |- map (labeled X[] C1) M]
  ; split map as
    case map/labeled:
    { g : map-bind,
      X : ( |- label),
      C1 : (g |- con),
      M1 : (g |- eterm),
      Dmap : (g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)),
      Dof : (g |- cn-of C1 t),
      Dmap1 : (g |- map C1 M1)
    | x : [g |- cn-of (labeled X[] C1) t],
      map : [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)]
    ; split map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as
      case map-of'/i:
      { g : map-bind,
        X : ( |- label),
        C1 : (g |- con),
        M1 : (g |- eterm),
        Dmap :
          (g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)),
        Dof : (g |- cn-of C1 t),
        Dmap1 : (g |- map C1 M1),
        Dof1 : (g |- eof M1 et)
      | x : [g |- cn-of (labeled X[] C1) t],
        map :
          [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)]
      ; solve
          [g |-
             map-of/i _
             tmap/t
             (eof/app (eof/const (ekof/i (ckof/labeled )
                                 (etopen/pi etopen/t
                                 etp-skel/t (\l1. \l2. \l3. etopen/t)))
                      (ewf/pi ewf/t (\l1. \l2. ewf/t)))
             Dof1)]
      }
    }
  }
  case cn-of/rec:
  { g : map-bind,
    K1 : (g |- kind),
    C1 : (g, a20 : con, a19 : con |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (rec' K1 (\x255. \z255. C1) C2) M),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, z324 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y325 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
    Dof1 : (g |- cn-of C2 K1)
  | x : [g |- cn-of (rec' K1 (\x255. \z255. C1) C2) t],
    map : [g |- map (rec' K1 (\x255. \z255. C1) C2) M]
  ; split map as
    case map/rec:
    { g : map-bind,
      K1 : (g |- kind),
      C1 : (g, a20 : con, a19 : con |- con),
      C2 : (g |- con),
      Dskel : ( |- skel),
      M3 : (g |- eterm),
      A : (g |- etp),
      M1 : (g, x923 : eterm, y923 : eterm |- eterm),
      M2 : (g |- eterm),
      Dmap :
        (g |-
           map
             (rec' K1 (\x255. \z255. C1) C2)
             (eapp (econst (const/rec Dskel[]))
             (epair M3
             (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M1))) M2)))),
      Dwf : (g |- kd-wf K1),
      Dof :
        (g, a : con, z324 : cn-of a (pi (K1[..]) (\l. t)), b : con,
         y325 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
      Dof1 : (g |- cn-of C2 K1),
      Dtmap : (g |- tmap K1 A),
      Dmap1 :
        (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
         z922 : map b y |- map (C1[.., a, b]) (M1[.., x, y])),
      Dmap2 : (g |- map C2 M2),
      Dflay : (g |- flay A Dskel[] M3)
    | x : [g |- cn-of (rec' K1 (\z335. \y336. C1) C2) t],
      map :
        [g |-
           map
             (rec' K1 (\z335. \y336. C1) C2)
             (eapp (econst (const/rec Dskel[]))
             (epair M3
             (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M1))) M2)))]
    ; split
map-of'
  [g,
   b1 :
     block (
       x : eterm,
       dx : eof x (epi (A[..]) (\l. et)),
       a : con,
       da : cn-of a (pi (K1[..]) (\l. t)),
       at : map a x),
   b2 :
     block (
       y : eterm,
       dy : eof y (A[..]),
       b : con,
       db : cn-of b (K1[..]),
       bt : map b y) |- Dof[.., b1.3, b1.4, b2.3, b2.4]]
  [g,
   b1 :
     block (
       x : eterm,
       dx : eof x (epi (A[..]) (\l. et)),
       a : con,
       da : cn-of a (pi (K1[..]) (\l. t)),
       at : map a x),
   b2 :
     block (
       y : eterm,
       dy : eof y (A[..]),
       b : con,
       db : cn-of b (K1[..]),
       bt : map b y) |- Dmap1[.., b1.3, b1.1, b1.5, b2.3, b2.1, b2.5]]
  [g,
   b1 :
     block (
       x : eterm,
       dx : eof x (epi (A[..]) (\l. et)),
       a : con,
       da : cn-of a (pi (K1[..]) (\l. t)),
       at : map a x),
   b2 :
     block (
       y : eterm,
       dy : eof y (A[..]),
       b : con,
       db : cn-of b (K1[..]),
       bt : map b y) |- tmap/t] as
      case map-of'/i:
      { g : map-bind,
        K1 : (g |- kind),
        C1 : (g, a20 : con, a19 : con |- con),
        C2 : (g |- con),
        Dskel : ( |- skel),
        M3 : (g |- eterm),
        A : (g |- etp),
        M4 : (g, x : eterm, y : eterm |- eterm),
        M2 : (g |- eterm),
        Dmap :
          (g |-
             map
               (rec' K1 (\x255. \z255. C1) C2)
               (eapp (econst (const/rec Dskel[]))
               (epair M3
               (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M4))) M2)))),
        Dwf : (g |- kd-wf K1),
        Dof :
          (g, a : con, z324 : cn-of a (pi (K1[..]) (\l. t)), b : con,
           y325 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
        Dof1 : (g |- cn-of C2 K1),
        Dtmap : (g |- tmap K1 A),
        Dmap1 :
          (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
           z922 : map b y |- map (C1[.., a, b]) (M4[.., x, y])),
        Dmap2 : (g |- map C2 M2),
        Dflay : (g |- flay A Dskel[] M3),
        Dof2 :
          (g, x : eterm, dx : eof x (epi (A[..]) (\l. et)), y : eterm,
           dy : eof y (A[..]) |- eof (M4[.., x, y]) et)
      | x : [g |- cn-of (rec' K1 (\y528. \x528. C1) C2) t],
        map :
          [g |-
             map
               (rec' K1 (\y528. \x528. C1) C2)
               (eapp (econst (const/rec Dskel[]))
               (epair M3
               (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M4))) M2)))]
      ; split map-of' [g |- Dof1] [g |- Dmap2] [g |- Dtmap] as
        case map-of'/i:
        { g : map-bind,
          K1 : (g |- kind),
          C1 : (g, a20 : con, a19 : con |- con),
          C2 : (g |- con),
          Dskel : ( |- skel),
          M3 : (g |- eterm),
          A : (g |- etp),
          M4 : (g, x : eterm, y : eterm |- eterm),
          M2 : (g |- eterm),
          Dmap :
            (g |-
               map
                 (rec' K1 (\x255. \z255. C1) C2)
                 (eapp (econst (const/rec Dskel[]))
                 (epair M3
                 (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M4)))
                 M2)))),
          Dwf : (g |- kd-wf K1),
          Dof :
            (g, a : con, z324 : cn-of a (pi (K1[..]) (\l. t)), b : con,
             y325 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
          Dof1 : (g |- cn-of C2 K1),
          Dtmap : (g |- tmap K1 A),
          Dmap1 :
            (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
             z922 : map b y |- map (C1[.., a, b]) (M4[.., x, y])),
          Dmap2 : (g |- map C2 M2),
          Dflay : (g |- flay A Dskel[] M3),
          Dof2 :
            (g, x : eterm, dx : eof x (epi (A[..]) (\l. et)), y : eterm,
             dy : eof y (A[..]) |- eof (M4[.., x, y]) et),
          Dof3 : (g |- eof M2 A)
        | x : [g |- cn-of (rec' K1 (\y528. \x528. C1) C2) t],
          map :
            [g |-
               map
                 (rec' K1 (\y528. \x528. C1) C2)
                 (eapp (econst (const/rec Dskel[]))
                 (epair M3
                 (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M4)))
                 M2)))]
        ; split can-skof [ |- Dskel] as
          case can-skof/i:
          { g : map-bind,
            K1 : (g |- kind),
            C1 : (g, a20 : con, a19 : con |- con),
            C2 : (g |- con),
            Dskel : ( |- skel),
            M3 : (g |- eterm),
            A : (g |- etp),
            M4 : (g, x : eterm, y : eterm |- eterm),
            M2 : (g |- eterm),
            Dmap :
              (g |-
                 map
                   (rec' K1 (\x255. \z255. C1) C2)
                   (eapp (econst (const/rec Dskel[]))
                   (epair M3
                   (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M4)))
                   M2)))),
            Dwf : (g |- kd-wf K1),
            Dof :
              (g, a : con, z324 : cn-of a (pi (K1[..]) (\l. t)), b : con,
               y325 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
            Dof1 : (g |- cn-of C2 K1),
            Dtmap : (g |- tmap K1 A),
            Dmap1 :
              (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
               z922 : map b y |- map (C1[.., a, b]) (M4[.., x, y])),
            Dmap2 : (g |- map C2 M2),
            Dflay : (g |- flay A Dskel[] M3),
            Dof2 :
              (g, x : eterm, dx : eof x (epi (A[..]) (\l. et)), y : eterm,
               dy : eof y (A[..]) |- eof (M4[.., x, y]) et),
            Dof3 : (g |- eof M2 A),
            A1 : ( |- etp),
            A2 : (x : eterm |- etp),
            Dskof : ( |- skof Dskel A1 (\z360. A2))
          | x : [g |- cn-of (rec' K1 (\y528. \x528. C1) C2) t],
            map :
              [g |-
                 map
                   (rec' K1 (\y528. \x528. C1) C2)
                   (eapp (econst (const/rec Dskel[]))
                   (epair M3
                   (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M4)))
                   M2)))]
          ; split map-wf' [g |- Dwf] [g |- Dtmap] as
            case map-wf'/i:
            { g : map-bind,
              K1 : (g |- kind),
              C1 : (g, a20 : con, a19 : con |- con),
              C2 : (g |- con),
              Dskel : ( |- skel),
              M3 : (g |- eterm),
              A : (g |- etp),
              M4 : (g, x : eterm, y : eterm |- eterm),
              M2 : (g |- eterm),
              Dmap :
                (g |-
                   map
                     (rec' K1 (\x255. \z255. C1) C2)
                     (eapp (econst (const/rec Dskel[]))
                     (epair M3
                     (epair (elam (epi A (\x. et))
                            (\x. elam (A[..]) (\y. M4)))
                     M2)))),
              Dwf : (g |- kd-wf K1),
              Dof :
                (g, a : con, z324 : cn-of a (pi (K1[..]) (\l. t)), b : con,
                 y325 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
              Dof1 : (g |- cn-of C2 K1),
              Dtmap : (g |- tmap K1 A),
              Dmap1 :
                (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
                 z922 : map b y |- map (C1[.., a, b]) (M4[.., x, y])),
              Dmap2 : (g |- map C2 M2),
              Dflay : (g |- flay A Dskel[] M3),
              Dof2 :
                (g, x : eterm, dx : eof x (epi (A[..]) (\l. et)), y : eterm,
                 dy : eof y (A[..]) |- eof (M4[.., x, y]) et),
              Dof3 : (g |- eof M2 A),
              A1 : ( |- etp),
              A2 : (x : eterm |- etp),
              Dskof : ( |- skof Dskel A1 (\z360. A2)),
              Dwf1 : (g |- ewf A)
            | x : [g |- cn-of (rec' K1 (\y528. \x528. C1) C2) t],
              map :
                [g |-
                   map
                     (rec' K1 (\y528. \x528. C1) C2)
                     (eapp (econst (const/rec Dskel[]))
                     (epair M3
                     (epair (elam (epi A (\x. et))
                            (\x. elam (A[..]) (\y. M4)))
                     M2)))]
            ; split flay-sound [g |- Dwf1] [g |- Dflay] [g |- Dskof[]] as
              case flay-sound/i:
              { g : map-bind,
                K1 : (g |- kind),
                C1 : (g, a20 : con, a19 : con |- con),
                C2 : (g |- con),
                Dskel : ( |- skel),
                M3 : (g |- eterm),
                A : (g |- etp),
                M4 : (g, x : eterm, y : eterm |- eterm),
                M2 : (g |- eterm),
                Dmap :
                  (g |-
                     map
                       (rec' K1 (\x255. \z255. C1) C2)
                       (eapp (econst (const/rec Dskel[]))
                       (epair M3
                       (epair (elam (epi A (\x. et))
                              (\x. elam (A[..]) (\y. M4)))
                       M2)))),
                Dwf : (g |- kd-wf K1),
                Dof :
                  (g, a : con, z324 : cn-of a (pi (K1[..]) (\l. t)), b : con,
                   y325 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
                Dof1 : (g |- cn-of C2 K1),
                Dtmap : (g |- tmap K1 A),
                Dmap1 :
                  (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
                   z922 : map b y |- map (C1[.., a, b]) (M4[.., x, y])),
                Dmap2 : (g |- map C2 M2),
                Dflay : (g |- flay A Dskel[] M3),
                Dof2 :
                  (g, x : eterm, dx : eof x (epi (A[..]) (\l. et)), y : eterm,
                   dy : eof y (A[..]) |- eof (M4[.., x, y]) et),
                Dof3 : (g |- eof M2 A),
                A1 : ( |- etp),
                A2 : (x : eterm |- etp),
                Dskof : ( |- skof Dskel A1 (\z360. A2[z360])),
                Dwf1 : (g |- ewf A),
                Dof4 : (g |- eof M3 A1[]),
                Dtequiv : (g |- tequiv A (A2[M3]))
              | x : [g |- cn-of (rec' K1 (\y528. \x528. C1) C2) t],
                map :
                  [g |-
                     map
                       (rec' K1 (\y528. \x528. C1) C2)
                       (eapp (econst (const/rec Dskel[]))
                       (epair M3
                       (epair (elam (epi A (\x. et))
                              (\x. elam (A[..]) (\y. M4)))
                       M2)))]
              ; split skof-reg [ |- Dskof] as
                case skof-reg/i:
                { g : map-bind,
                  K1 : (g |- kind),
                  C1 : (g, a20 : con, a19 : con |- con),
                  C2 : (g |- con),
                  Dskel : ( |- skel),
                  M3 : (g |- eterm),
                  A : (g |- etp),
                  M4 : (g, x : eterm, y : eterm |- eterm),
                  M2 : (g |- eterm),
                  Dmap :
                    (g |-
                       map
                         (rec' K1 (\x255. \z255. C1) C2)
                         (eapp (econst (const/rec Dskel[]))
                         (epair M3
                         (epair (elam (epi A (\x. et))
                                (\x. elam (A[..]) (\y. M4)))
                         M2)))),
                  Dwf : (g |- kd-wf K1),
                  Dof :
                    (g, a : con, z324 : cn-of a (pi (K1[..]) (\l. t)),
                     b : con,
                     y325 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
                  Dof1 : (g |- cn-of C2 K1),
                  Dtmap : (g |- tmap K1 A),
                  Dmap1 :
                    (g, a : con, x : eterm, x922 : map a x, b : con,
                     y : eterm,
                     z922 : map b y |- map (C1[.., a, b]) (M4[.., x, y])),
                  Dmap2 : (g |- map C2 M2),
                  Dflay : (g |- flay A Dskel[] M3),
                  Dof2 :
                    (g, x : eterm, dx : eof x (epi (A[..]) (\l. et)),
                     y : eterm,
                     dy : eof y (A[..]) |- eof (M4[.., x, y]) et),
                  Dof3 : (g |- eof M2 A),
                  A1 : ( |- etp),
                  A2 : (x : eterm |- etp),
                  Dskof : ( |- skof Dskel A1 (\z360. A2[z360])),
                  Dwf1 : (g |- ewf A),
                  Dof4 : (g |- eof M3 A1[]),
                  Dtequiv : (g |- tequiv A (A2[M3])),
                  Dwf2 : ( |- ewf A1),
                  Dwf3 : (x : eterm, x1 : eof x A1[] |- ewf (A2[x]))
                | x : [g |- cn-of (rec' K1 (\y528. \x528. C1) C2) t],
                  map :
                    [g |-
                       map
                         (rec' K1 (\y528. \x528. C1) C2)
                         (eapp (econst (const/rec Dskel[]))
                         (epair M3
                         (epair (elam (epi A (\x. et))
                                (\x. elam (A[..]) (\y. M4)))
                         M2)))]
                ; ?
                }
              }
            }
          }
        }
      }
    }
  }
  case cn-of/tagged:
  { g : map-bind,
    M : (g |- eterm),
    Dmap : (g |- map tagged M)
  | x : [g |- cn-of tagged t], map : [g |- map tagged M]
  ; split map as
    case map/tagged:
    { g : map-bind,
      Dmap : (g |- map tagged (econst const/tagged))
    | x : [g |- cn-of tagged t],
      map : [g |- map tagged (econst const/tagged)]
    ; solve
        [g |-
           map-of/i _ tmap/t (eof/const (ekof/i ckof/tagged etopen/t) ewf/t)]
    }
  }
  case cn-of/tag:
  { g : map-bind,
    C1 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (tag C1) M),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (tag C1) t], map : [g |- map (tag C1) M]
  ; split map as
    case map/tag:
    { g : map-bind,
      C1 : (g |- con),
      M1 : (g |- eterm),
      Dmap : (g |- map (tag C1) (eapp (econst const/tag) M1)),
      Dof : (g |- cn-of C1 t),
      Dmap1 : (g |- map C1 M1)
    | x : [g |- cn-of (tag C1) t],
      map : [g |- map (tag C1) (eapp (econst const/tag) M1)]
    ; split map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as
      case map-of'/i:
      { g : map-bind,
        C1 : (g |- con),
        M1 : (g |- eterm),
        Dmap : (g |- map (tag C1) (eapp (econst const/tag) M1)),
        Dof : (g |- cn-of C1 t),
        Dmap1 : (g |- map C1 M1),
        Dof1 : (g |- eof M1 et)
      | x : [g |- cn-of (tag C1) t],
        map : [g |- map (tag C1) (eapp (econst const/tag) M1)]
      ; solve
          [g |-
             map-of/i _
             tmap/t
             (eof/app (eof/const (ekof/i ckof/tag
                                 (etopen/pi etopen/t
                                 etp-skel/t (\l1. \l2. \l3. etopen/t)))
                      (ewf/pi ewf/t (\l1. \l2. ewf/t)))
             Dof1)]
      }
    }
  }
  case cn-of/ref:
  { g : map-bind,
    C1 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (ref C1) M),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (ref C1) t], map : [g |- map (ref C1) M]
  ; split map as
    case map/ref:
    { g : map-bind,
      C1 : (g |- con),
      M1 : (g |- eterm),
      Dmap : (g |- map (ref C1) (eapp (econst const/ref) M1)),
      Dof : (g |- cn-of C1 t),
      Dmap1 : (g |- map C1 M1)
    | x : [g |- cn-of (ref C1) t],
      map : [g |- map (ref C1) (eapp (econst const/ref) M1)]
    ; split map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as
      case map-of'/i:
      { g : map-bind,
        C1 : (g |- con),
        M1 : (g |- eterm),
        Dmap : (g |- map (ref C1) (eapp (econst const/ref) M1)),
        Dof : (g |- cn-of C1 t),
        Dmap1 : (g |- map C1 M1),
        Dof1 : (g |- eof M1 et)
      | x : [g |- cn-of (ref C1) t],
        map : [g |- map (ref C1) (eapp (econst const/ref) M1)]
      ; solve
          [g |-
             map-of/i _
             tmap/t
             (eof/app (eof/const (ekof/i ckof/ref
                                 (etopen/pi etopen/t
                                 etp-skel/t (\l1. \l2. \l3. etopen/t)))
                      (ewf/pi ewf/t (\l1. \l2. ewf/t)))
             Dof1)]
      }
    }
  }
  case cn-of/plus:
  { g : map-bind,
    C1 : (g |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (plus C1 C2) M),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (plus C1 C2) t], map : [g |- map (plus C1 C2) M]
  ; split map as
    case map/plus:
    { g : map-bind,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)),
      Dof : (g |- cn-of C1 t),
      Dof1 : (g |- cn-of C2 t),
      Dmap1 : (g |- map C1 M1),
      Dmap2 : (g |- map C2 M2)
    | x : [g |- cn-of (plus C1 C2) t],
      map : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)]
    ; split map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as
      case map-of'/i:
      { g : map-bind,
        C1 : (g |- con),
        C2 : (g |- con),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        Dmap :
          (g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)),
        Dof : (g |- cn-of C1 t),
        Dof1 : (g |- cn-of C2 t),
        Dmap1 : (g |- map C1 M1),
        Dmap2 : (g |- map C2 M2),
        Dof2 : (g |- eof M1 et)
      | x : [g |- cn-of (plus C1 C2) t],
        map : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)]
      ; split map-of' [g |- Dof1] [g |- Dmap2] [g |- tmap/t] as
        case map-of'/i:
        { g : map-bind,
          C1 : (g |- con),
          C2 : (g |- con),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          Dmap :
            (g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)),
          Dof : (g |- cn-of C1 t),
          Dof1 : (g |- cn-of C2 t),
          Dmap1 : (g |- map C1 M1),
          Dmap2 : (g |- map C2 M2),
          Dof2 : (g |- eof M1 et),
          Dof3 : (g |- eof M2 et)
        | x : [g |- cn-of (plus C1 C2) t],
          map :
            [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)]
        ; solve
            [g |-
               map-of/i _
               tmap/t
               (eof/app (eof/app (eof/const (ekof/i ckof/plus
                                            (etopen/pi etopen/t
                                            etp-skel/t
                                            (\l1.
                                               \l2.
                                                 \l3.
                                                   etopen/pi etopen/t
                                                   etp-skel/t
                                                   (\l4. \l5. \l6. etopen/t))))
                                 (ewf/pi ewf/t
                                 (\l1. \l2. ewf/pi ewf/t (\l3. \l4. ewf/t))))
                        Dof2)
               Dof3)]
        }
      }
    }
  }
  case cn-of/arrow:
  { g : map-bind,
    C1 : (g |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (arrow C1 C2) M),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (arrow C1 C2) t], map : [g |- map (arrow C1 C2) M]
  ; split map as
    case map/arrow:
    { g : map-bind,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap :
        (g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)),
      Dof : (g |- cn-of C1 t),
      Dof1 : (g |- cn-of C2 t),
      Dmap1 : (g |- map C1 M1),
      Dmap2 : (g |- map C2 M2)
    | x : [g |- cn-of (arrow C1 C2) t],
      map : [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)]
    ; split map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as
      case map-of'/i:
      { g : map-bind,
        C1 : (g |- con),
        C2 : (g |- con),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        Dmap :
          (g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)),
        Dof : (g |- cn-of C1 t),
        Dof1 : (g |- cn-of C2 t),
        Dmap1 : (g |- map C1 M1),
        Dmap2 : (g |- map C2 M2),
        Dof2 : (g |- eof M1 et)
      | x : [g |- cn-of (arrow C1 C2) t],
        map :
          [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)]
      ; split map-of' [g |- Dof1] [g |- Dmap2] [g |- tmap/t] as
        case map-of'/i:
        { g : map-bind,
          C1 : (g |- con),
          C2 : (g |- con),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          Dmap :
            (g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)),
          Dof : (g |- cn-of C1 t),
          Dof1 : (g |- cn-of C2 t),
          Dmap1 : (g |- map C1 M1),
          Dmap2 : (g |- map C2 M2),
          Dof2 : (g |- eof M1 et),
          Dof3 : (g |- eof M2 et)
        | x : [g |- cn-of (arrow C1 C2) t],
          map :
            [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)]
        ; solve
            [g |-
               map-of/i _
               tmap/t
               (eof/app (eof/app (eof/const (ekof/i ckof/arrow
                                            (etopen/pi etopen/t
                                            etp-skel/t
                                            (\l1.
                                               \l2.
                                                 \l3.
                                                   etopen/pi etopen/t
                                                   etp-skel/t
                                                   (\l4. \l5. \l6. etopen/t))))
                                 (ewf/pi ewf/t
                                 (\l1. \l2. ewf/pi ewf/t (\l3. \l4. ewf/t))))
                        Dof2)
               Dof3)]
        }
      }
    }
  }
  case cn-of/prod:
  { g : map-bind,
    C1 : (g |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (prod C1 C2) M),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (prod C1 C2) t], map : [g |- map (prod C1 C2) M]
  ; split map as
    case map/prod:
    { g : map-bind,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)),
      Dof : (g |- cn-of C1 t),
      Dof1 : (g |- cn-of C2 t),
      Dmap1 : (g |- map C1 M1),
      Dmap2 : (g |- map C2 M2)
    | x : [g |- cn-of (prod C1 C2) t],
      map : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)]
    ; split map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as
      case map-of'/i:
      { g : map-bind,
        C1 : (g |- con),
        C2 : (g |- con),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        Dmap :
          (g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)),
        Dof : (g |- cn-of C1 t),
        Dof1 : (g |- cn-of C2 t),
        Dmap1 : (g |- map C1 M1),
        Dmap2 : (g |- map C2 M2),
        Dof2 : (g |- eof M1 et)
      | x : [g |- cn-of (prod C1 C2) t],
        map : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)]
      ; split map-of' [g |- Dof1] [g |- Dmap2] [g |- tmap/t] as
        case map-of'/i:
        { g : map-bind,
          C1 : (g |- con),
          C2 : (g |- con),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          Dmap :
            (g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)),
          Dof : (g |- cn-of C1 t),
          Dof1 : (g |- cn-of C2 t),
          Dmap1 : (g |- map C1 M1),
          Dmap2 : (g |- map C2 M2),
          Dof2 : (g |- eof M1 et),
          Dof3 : (g |- eof M2 et)
        | x : [g |- cn-of (prod C1 C2) t],
          map :
            [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)]
        ; solve
            [g |-
               map-of/i _
               tmap/t
               (eof/app (eof/app (eof/const (ekof/i ckof/prod
                                            (etopen/pi etopen/t
                                            etp-skel/t
                                            (\l1.
                                               \l2.
                                                 \l3.
                                                   etopen/pi etopen/t
                                                   etp-skel/t
                                                   (\l4. \l5. \l6. etopen/t))))
                                 (ewf/pi ewf/t
                                 (\l1. \l2. ewf/pi ewf/t (\l3. \l4. ewf/t))))
                        Dof2)
               Dof3)]
        }
      }
    }
  }
  case cn-of/void:
  { g : map-bind,
    M : (g |- eterm),
    Dmap : (g |- map void M)
  | x : [g |- cn-of void t], map : [g |- map void M]
  ; split map as
    case map/void:
    { g : map-bind,
      Dmap : (g |- map void (econst const/void))
    | x : [g |- cn-of void t], map : [g |- map void (econst const/void)]
    ; solve
        [g |- map-of/i _ tmap/t (eof/const (ekof/i ckof/void etopen/t) ewf/t)]
    }
  }
  case cn-of/unit:
  { g : map-bind,
    M : (g |- eterm),
    Dmap : (g |- map unit M)
  | x : [g |- cn-of unit t], map : [g |- map unit M]
  ; split map as
    case map/unit:
    { g : map-bind,
      Dmap : (g |- map unit (econst const/unit))
    | x : [g |- cn-of unit t], map : [g |- map unit (econst const/unit)]
    ; solve
        [g |- map-of/i _ tmap/t (eof/const (ekof/i ckof/unit etopen/t) ewf/t)]
    }
  }
  case cn-of/star:
  { g : map-bind,
    M : (g |- eterm),
    Dmap : (g |- map star M)
  | x : [g |- cn-of star one], map : [g |- map star M]
  ; split map as
    case map/star:
    { g : map-bind, Dmap : (g |- map star estar)
    | x : [g |- cn-of star one], map : [g |- map star estar]
    ; solve [g |- map-of/i _ tmap/one eof/star]
    }
  }
  case cn-of/app:
  { g : map-bind,
    C2 : (g |- con),
    C1 : (g |- con),
    K2 : (g, a18 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map (app C2 C1) M),
    K1 : (g |- kind),
    Dof1 : (g |- cn-of C2 (pi K1 (\x247. K2))),
    Dof : (g |- cn-of C1 K1)
  | x : [g |- cn-of (app C2 C1) (K2[.., C1])], map : [g |- map (app C2 C1) M]
  ; split map as
    case map/app:
    { g : map-bind,
      C2 : (g |- con),
      C1 : (g |- con),
      K2 : (g, a18 : con |- kind),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map (app C2 C1) (eapp M1 M2)),
      K1 : (g |- kind),
      Dof1 : (g |- cn-of C2 (pi K1 (\x247. K2))),
      Dof : (g |- cn-of C1 K1),
      Dmap1 : (g |- map C2 M1),
      Dmap2 : (g |- map C1 M2)
    | x : [g |- cn-of (app C2 C1) (K2[.., C1])],
      map : [g |- map (app C2 C1) (eapp M1 M2)]
    ; split map-of [g |- Dof1] [g |- Dmap1] as
      case map-of/i:
      { g : map-bind,
        C2 : (g |- con),
        C1 : (g |- con),
        K2 : (g, a18 : con |- kind),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        Dmap : (g |- map (app C2 C1) (eapp M1 M2)),
        K1 : (g |- kind),
        Dof1 : (g |- cn-of C2 (pi K1 (\x247. K2))),
        Dof : (g |- cn-of C1 K1),
        Dmap1 : (g |- map C2 M1),
        Dmap2 : (g |- map C1 M2),
        A : (g |- etp),
        Dtmap : (g |- tmap (pi K1 (\x247. K2)) A),
        Dof2 : (g |- eof M1 A)
      | x : [g |- cn-of (app C2 C1) (K2[.., C1])],
        map : [g |- map (app C2 C1) (eapp M1 M2)]
      ; split [g |- Dtmap] as
        case tmap/pi:
        { g : map-bind,
          C2 : (g |- con),
          C1 : (g |- con),
          K2 : (g, a18 : con |- kind),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          Dmap : (g |- map (app C2 C1) (eapp M1 M2)),
          K1 : (g |- kind),
          Dof1 : (g |- cn-of C2 (pi K1 (\x247. K2))),
          Dof : (g |- cn-of C1 K1),
          Dmap1 : (g |- map C2 M1),
          Dmap2 : (g |- map C1 M2),
          A1 : (g |- etp),
          A2 : (g, x925 : eterm |- etp),
          Dtmap1 : (g |- tmap K1 A1),
          Dtmap2 :
            (g, a : con, x : eterm, y925 : map a x |-
               tmap (K2[.., a]) (A2[.., x])),
          Dof2 : (g |- eof M1 (epi A1 (\y142. A2)))
        | x : [g |- cn-of (app C2 C1) (K2[.., C1])],
          map : [g |- map (app C2 C1) (eapp M1 M2)]
        ; split map-of' [g |- Dof] [g |- Dmap2] [g |- Dtmap1] as
          case map-of'/i:
          { g : map-bind,
            C2 : (g |- con),
            C1 : (g |- con),
            K2 : (g, a18 : con |- kind),
            M1 : (g |- eterm),
            M2 : (g |- eterm),
            Dmap : (g |- map (app C2 C1) (eapp M1 M2)),
            K1 : (g |- kind),
            Dof1 : (g |- cn-of C2 (pi K1 (\x247. K2))),
            Dof : (g |- cn-of C1 K1),
            Dmap1 : (g |- map C2 M1),
            Dmap2 : (g |- map C1 M2),
            A1 : (g |- etp),
            A2 : (g, x925 : eterm |- etp),
            Dtmap1 : (g |- tmap K1 A1),
            Dtmap2 :
              (g, a : con, x : eterm, y925 : map a x |-
                 tmap (K2[.., a]) (A2[.., x])),
            Dof2 : (g |- eof M1 (epi A1 (\y142. A2))),
            Dof3 : (g |- eof M2 A1)
          | x : [g |- cn-of (app C2 C1) (K2[.., C1])],
            map : [g |- map (app C2 C1) (eapp M1 M2)]
          ; solve
              [g |-
                 map-of/i _ (Dtmap2[.., C1, M2, Dmap2]) (eof/app Dof2 Dof3)]
          }
        }
      }
    }
  }
  case cn-of/lam:
  { g : map-bind,
    K1 : (g |- kind),
    C1 : (g, a16 : con |- con),
    K2 : (g, a17 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map (lam K1 (\z250. C1)) M),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, y320 : cn-of a (K1[..]) |- cn-of (C1[.., a]) (K2[.., a]))
  | x : [g |- cn-of (lam K1 (\z250. C1)) (pi K1 (\x247. K2))],
    map : [g |- map (lam K1 (\z250. C1)) M]
  ; split map as
    case map/lam:
    { g : map-bind,
      K1 : (g |- kind),
      C1 : (g, a16 : con |- con),
      K2 : (g, a17 : con |- kind),
      A : (g |- etp),
      M1 : (g, x917 : eterm |- eterm),
      Dmap : (g |- map (lam K1 (\z250. C1)) (elam A (\y146. M1))),
      Dwf : (g |- kd-wf K1),
      Dof :
        (g, a : con, y320 : cn-of a (K1[..]) |- cn-of (C1[.., a]) (K2[.., a])),
      Dtmap : (g |- tmap K1 A),
      Dmap1 :
        (g, a : con, x : eterm, y917 : map a x |- map (C1[.., a]) (M1[.., x]))
    | x : [g |- cn-of (lam K1 (\y331. C1)) (pi K1 (\z327. K2))],
      map : [g |- map (lam K1 (\y331. C1)) (elam A (\y146. M1))]
    ; split
map-of
  [g,
   b :
     block (
       x : eterm,
       dx : eof x (A[..]),
       a : con,
       da : cn-of a (K1[..]),
       at : map a x) |- Dof[.., b.3, b.4]]
  [g,
   b :
     block (
       x : eterm,
       dx : eof x (A[..]),
       a : con,
       da : cn-of a (K1[..]),
       at : map a x) |- Dmap1[.., b.3, b.1, b.5]] as
      case map-of/i:
      { g : map-bind,
        K1 : (g |- kind),
        C1 : (g, a16 : con |- con),
        K3 : (g, a : con |- kind),
        A : (g |- etp),
        M2 : (g, x : eterm |- eterm),
        Dmap : (g |- map (lam K1 (\z250. C1)) (elam A (\y146. M2))),
        Dwf : (g |- kd-wf K1),
        Dof :
          (g, a : con, y320 : cn-of a (K1[..]) |-
             cn-of (C1[.., a]) (K3[.., a])),
        Dtmap : (g |- tmap K1 A),
        Dmap1 :
          (g, a : con, x : eterm, y917 : map a x |-
             map (C1[.., a]) (M2[.., x])),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x1291 : map a x |-
             tmap (K3[.., a]) (A1[.., x])),
        Dof1 :
          (g, x : eterm, dx : eof x (A[..]) |- eof (M2[.., x]) (A1[.., x]))
      | x : [g |- cn-of (lam K1 (\y331. C1)) (pi K1 (\z327. K3))],
        map : [g |- map (lam K1 (\y331. C1)) (elam A (\y146. M2))]
      ; split map-wf' [g |- Dwf] [g |- Dtmap] as
        case map-wf'/i:
        { g : map-bind,
          K1 : (g |- kind),
          C1 : (g, a16 : con |- con),
          K3 : (g, a : con |- kind),
          A : (g |- etp),
          M2 : (g, x : eterm |- eterm),
          Dmap : (g |- map (lam K1 (\z250. C1)) (elam A (\y146. M2))),
          Dwf : (g |- kd-wf K1),
          Dof :
            (g, a : con, y320 : cn-of a (K1[..]) |-
               cn-of (C1[.., a]) (K3[.., a])),
          Dtmap : (g |- tmap K1 A),
          Dmap1 :
            (g, a : con, x : eterm, y917 : map a x |-
               map (C1[.., a]) (M2[.., x])),
          A1 : (g, x : eterm |- etp),
          Dtmap1 :
            (g, x : eterm, a : con, x1291 : map a x |-
               tmap (K3[.., a]) (A1[.., x])),
          Dof1 :
            (g, x : eterm, dx : eof x (A[..]) |- eof (M2[.., x]) (A1[.., x])),
          Dwf1 : (g |- ewf A)
        | x : [g |- cn-of (lam K1 (\y525. C1)) (pi K1 (\z521. K3))],
          map : [g |- map (lam K1 (\y525. C1)) (elam A (\z150. M2))]
        ; solve
            [g |-
               map-of/i _
               (tmap/pi Dtmap (\a. \x. \at. Dtmap1[.., x, a, at]))
               (eof/lam Dwf1 (\x. \dx. Dof1))]
        }
      }
    }
  }
  case cn-of/pi2:
  { g : map-bind,
    C1 : (g |- con),
    K2 : (g, a15 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map (pi2 C1) M),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 (sigma K1 (\x248. K2)))
  | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])], map : [g |- map (pi2 C1) M]
  ; split map as
    case map/pi2:
    { g : map-bind,
      C1 : (g |- con),
      K2 : (g, a15 : con |- kind),
      M1 : (g |- eterm),
      Dmap : (g |- map (pi2 C1) (epi2 M1)),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 (sigma K1 (\x248. K2))),
      Dmap1 : (g |- map C1 M1)
    | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])],
      map : [g |- map (pi2 C1) (epi2 M1)]
    ; split map-of [g |- Dof] [g |- Dmap1] as
      case map-of/i:
      { g : map-bind,
        C1 : (g |- con),
        K2 : (g, a15 : con |- kind),
        M1 : (g |- eterm),
        Dmap : (g |- map (pi2 C1) (epi2 M1)),
        K1 : (g |- kind),
        Dof : (g |- cn-of C1 (sigma K1 (\x248. K2))),
        Dmap1 : (g |- map C1 M1),
        A : (g |- etp),
        Dtmap : (g |- tmap (sigma K1 (\x248. K2)) A),
        Dof1 : (g |- eof M1 A)
      | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])],
        map : [g |- map (pi2 C1) (epi2 M1)]
      ; split [g |- Dtmap] as
        case tmap/sigma:
        { g : map-bind,
          C1 : (g |- con),
          K2 : (g, a15 : con |- kind),
          M1 : (g |- eterm),
          Dmap : (g |- map (pi2 C1) (epi2 M1)),
          K1 : (g |- kind),
          Dof : (g |- cn-of C1 (sigma K1 (\x248. K2))),
          Dmap1 : (g |- map C1 M1),
          A1 : (g |- etp),
          A2 : (g, z926 : eterm |- etp),
          Dtmap1 : (g |- tmap K1 A1),
          Dtmap2 :
            (g, a : con, x : eterm, x926 : map a x |-
               tmap (K2[.., a]) (A2[.., x])),
          Dof1 : (g |- eof M1 (esigma A1 (\y143. A2)))
        | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])],
          map : [g |- map (pi2 C1) (epi2 M1)]
        ; solve
  [g |-
     map-of/i _ (Dtmap2[.., pi1 C1, epi1 M1, map/pi1 Dmap1]) (eof/pi2 Dof1)]
        }
      }
    }
  }
  case cn-of/pi1:
  { g : map-bind,
    C1 : (g |- con),
    K : (g |- kind),
    M : (g |- eterm),
    Dmap : (g |- map (pi1 C1) M),
    K2 : (g, a14 : con |- kind),
    Dof : (g |- cn-of C1 (sigma K (\x248. K2)))
  | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) M]
  ; split map as
    case map/pi1:
    { g : map-bind,
      C1 : (g |- con),
      K : (g |- kind),
      M1 : (g |- eterm),
      Dmap : (g |- map (pi1 C1) (epi1 M1)),
      K2 : (g, a14 : con |- kind),
      Dof : (g |- cn-of C1 (sigma K (\x248. K2))),
      Dmap1 : (g |- map C1 M1)
    | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) (epi1 M1)]
    ; split map-of [g |- Dof] [g |- Dmap1] as
      case map-of/i:
      { g : map-bind,
        C1 : (g |- con),
        K : (g |- kind),
        M1 : (g |- eterm),
        Dmap : (g |- map (pi1 C1) (epi1 M1)),
        K2 : (g, a14 : con |- kind),
        Dof : (g |- cn-of C1 (sigma K (\x248. K2))),
        Dmap1 : (g |- map C1 M1),
        A : (g |- etp),
        Dtmap : (g |- tmap (sigma K (\x248. K2)) A),
        Dof1 : (g |- eof M1 A)
      | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) (epi1 M1)]
      ; split [g |- Dtmap] as
        case tmap/sigma:
        { g : map-bind,
          C1 : (g |- con),
          K : (g |- kind),
          M1 : (g |- eterm),
          Dmap : (g |- map (pi1 C1) (epi1 M1)),
          K2 : (g, a14 : con |- kind),
          Dof : (g |- cn-of C1 (sigma K (\x248. K2))),
          Dmap1 : (g |- map C1 M1),
          A1 : (g |- etp),
          A2 : (g, z926 : eterm |- etp),
          Dtmap1 : (g |- tmap K A1),
          Dtmap2 :
            (g, a : con, x : eterm, x926 : map a x |-
               tmap (K2[.., a]) (A2[.., x])),
          Dof1 : (g |- eof M1 (esigma A1 (\y143. A2)))
        | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) (epi1 M1)]
        ; solve [g |- map-of/i _ Dtmap1 (eof/pi1 Dof1)]
        }
      }
    }
  }
  case cn-of/pair:
  { g : map-bind,
    C1 : (g |- con),
    C2 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a13 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map (pair C1 C2) M),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of C2 (K2[.., C1])),
    Dwf : (g, a : con, x318 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of (pair C1 C2) (sigma K1 (\x248. K2))],
    map : [g |- map (pair C1 C2) M]
  ; split map as
    case map/pair:
    { g : map-bind,
      C1 : (g |- con),
      C2 : (g |- con),
      K1 : (g |- kind),
      K2 : (g, a13 : con |- kind),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map (pair C1 C2) (epair M1 M2)),
      Dof : (g |- cn-of C1 K1),
      Dof1 : (g |- cn-of C2 (K2[.., C1])),
      Dwf : (g, a : con, x318 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      Dmap1 : (g |- map C1 M1),
      Dmap2 : (g |- map C2 M2)
    | x : [g |- cn-of (pair C1 C2) (sigma K1 (\z328. K2))],
      map : [g |- map (pair C1 C2) (epair M1 M2)]
    ; split map-of [g |- Dof] [g |- Dmap1] as
      case map-of/i:
      { g : map-bind,
        C1 : (g |- con),
        C2 : (g |- con),
        K1 : (g |- kind),
        K2 : (g, a13 : con |- kind),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        Dmap : (g |- map (pair C1 C2) (epair M1 M2)),
        Dof : (g |- cn-of C1 K1),
        Dof1 : (g |- cn-of C2 (K2[.., C1])),
        Dwf : (g, a : con, x318 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
        Dmap1 : (g |- map C1 M1),
        Dmap2 : (g |- map C2 M2),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        Dof2 : (g |- eof M1 A)
      | x : [g |- cn-of (pair C1 C2) (sigma K1 (\z328. K2))],
        map : [g |- map (pair C1 C2) (epair M1 M2)]
      ; split
        map-wf
          [g,
           b :
             block (
               x : eterm,
               dx : eof x (A[..]),
               a : con,
               da : cn-of a (K1[..]),
               at : map a x) |- Dwf[.., b.3, b.4]] as
        case map-wf/i:
        { g : map-bind,
          C1 : (g |- con),
          C2 : (g |- con),
          K1 : (g |- kind),
          K3 : (g, a : con |- kind),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          Dmap : (g |- map (pair C1 C2) (epair M1 M2)),
          Dof : (g |- cn-of C1 K1),
          Dof1 : (g |- cn-of C2 (K3[.., C1])),
          Dwf : (g, a : con, x318 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
          Dmap1 : (g |- map C1 M1),
          Dmap2 : (g |- map C2 M2),
          A : (g |- etp),
          Dtmap : (g |- tmap K1 A),
          Dof2 : (g |- eof M1 A),
          A1 : (g, x : eterm |- etp),
          Dtmap1 :
            (g, x : eterm, a : con, y5 : map a x |-
               tmap (K3[.., a]) (A1[.., x])),
          Dwf1 : (g, x : eterm, dx : eof x (A[..]) |- ewf (A1[.., x]))
        | x : [g |- cn-of (pair C1 C2) (sigma K1 (\z328. K3))],
          map : [g |- map (pair C1 C2) (epair M1 M2)]
        ; split map-of' [g |- Dof1] [g |- Dmap2] [g |- Dtmap1[.., M1, C1, Dmap1]] as
          case map-of'/i:
          { g : map-bind,
            C1 : (g |- con),
            C2 : (g |- con),
            K1 : (g |- kind),
            K3 : (g, a : con |- kind),
            M1 : (g |- eterm),
            M2 : (g |- eterm),
            Dmap : (g |- map (pair C1 C2) (epair M1 M2)),
            Dof : (g |- cn-of C1 K1),
            Dof1 : (g |- cn-of C2 (K3[.., C1])),
            Dwf : (g, a : con, x318 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
            Dmap1 : (g |- map C1 M1),
            Dmap2 : (g |- map C2 M2),
            A : (g |- etp),
            Dtmap : (g |- tmap K1 A),
            Dof2 : (g |- eof M1 A),
            A1 : (g, x : eterm |- etp),
            Dtmap1 :
              (g, x : eterm, a : con, y5 : map a x |-
                 tmap (K3[.., a]) (A1[.., x])),
            Dwf1 : (g, x : eterm, dx : eof x (A[..]) |- ewf (A1[.., x])),
            Dof3 : (g |- eof M2 (A1[.., M1]))
          | x : [g |- cn-of (pair C1 C2) (sigma K1 (\z522. K3))],
            map : [g |- map (pair C1 C2) (epair M1 M2)]
          ; solve
  [g |-
     map-of/i _
     (tmap/sigma Dtmap (\a. \x. \at. Dtmap1[.., x, a, at]))
     (eof/pair Dof2 Dof3 (\x. \dx. Dwf1))]
          }
        }
      }
    }
  }
  %{ FIXME: Type-checking error
  case #.2:
  { g : map-bind,
    K : (g |- kind),
    A57 : (g |- etp),
    #unmap :
      #(g |-
          block (
            a : con,
            da : cn-of a (K[..]),
            x : eterm,
            dx : eof x (A57[..]),
            at : map a x,
            xt : unmap x a)),
    M : (g |- eterm),
    Dmap : (g |- map #unmap.1 M),
    K452 : (g |- kind),
    Dtmap18 : (g |- tmap K A57),
    Dtunmap : (g |- tunmap A57 K452),
    Dwf61 : (g |- kd-wf K),
    Dwf : (g |- ewf A57),
    Dequiv37 : (g |- kd-equiv K K452)
  | x : [g |- cn-of #unmap.1 K], map : [g |- map #unmap.1 M]
  ; ?
  }
  case #.4:
  { g : map-bind,
    A58 : (g |- etp),
    K : (g |- kind),
    #map :
      #(g |-
          block (
            x : eterm,
            dx : eof x (A58[..]),
            a : con,
            da : cn-of a (K[..]),
            at : map a x)),
    M : (g |- eterm),
    Dmap : (g |- map #map.3 M),
    Dtmap19 : (g |- tmap K A58),
    Dwf1 : (g |- ewf A58)
  | x : [g |- cn-of #map.3 K], map : [g |- map #map.3 M]
  ; ?
  }
  }%
}

and proof map-of' :
  (g : map-bind)
  [g |- cn-of C K] ->
  [g |- map C M] ->
  [g |- tmap K A] ->
    [g |- map-of'/e M A] =
/ trust / % FIXME: See issue #4
intros
{ g : map-bind,
  C : (g |- con),
  K : (g |- kind),
  M : (g |- eterm),
  A : (g |- etp)
| x : [g |- cn-of C K], map : [g |- map C M], tmap : [g |- tmap K A]
; by x as Dof unboxed;
  by map as Dmap unboxed;
  by tmap as DmapA unboxed;
  split map-of [_ |- Dof] [_ |- Dmap] as
  case map-of/i:
  { g : map-bind,
    C : (g |- con),
    K : (g |- kind),
    M : (g |- eterm),
    A : (g |- etp),
    Dof : (g |- cn-of C K),
    Dmap : (g |- map C M),
    DmapA : (g |- tmap K A),
    A1 : (g |- etp),
    Dtmap : (g |- tmap K A1),
    Dof1 : (g |- eof M A1)
  | x : [g |- cn-of C K], map : [g |- map C M], tmap : [g |- tmap K A]
  ; split tmap-fun [_ |- Dtmap] [_ |- DmapA] as
    case etp-eq/i:
    { g : map-bind,
      C : (g |- con),
      K : (g |- kind),
      M : (g |- eterm),
      A : (g |- etp),
      Dof : (g |- cn-of C K),
      Dmap : (g |- map C M),
      DmapA : (g |- tmap K A),
      DmapA' : (g |- tmap K A),
      Dof' : (g |- eof M A)
    | x : [g |- cn-of C K], map : [g |- map C M], tmap : [g |- tmap K A]
    ; solve [_ |- map-of'/i Dof']
    }
  }
}

and proof map-wf :
  (g : map-bind)
  [g |- kd-wf K] ->
    [g |- map-wf/e K] =
/ total 1 /
intros
{ g : map-bind, K : (g |- kind)
| x : [g |- kd-wf K]
; split x as
  case kd-wf/one:
  { g : map-bind
  | x : [g |- kd-wf one]
  ; solve [_ |- map-wf/i _ tmap/one ewf/one]
  }
  case kd-wf/sigma:
  { g : map-bind,
    K1 : (g |- kind),
    K2 : (g, a4 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, y389 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (sigma K1 (\z328. K2))]
  ; split map-wf [g |- Dwf] as
    case map-wf/i:
    { g : map-bind,
      K1 : (g |- kind),
      K2 : (g, a4 : con |- kind),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, y389 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A),
      Dwf2 : (g |- ewf A)
    | x : [g |- kd-wf (sigma K1 (\z328. K2))]
    ; split
      map-wf
        [g,
         b :
           block (
             x : eterm,
             dx : eof x (A[..]),
             a : con,
             da : cn-of a (K1[..]),
             at : map a x) |- Dwf1[.., b.3, b.4]] as
      case map-wf/i:
      { g : map-bind,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g, a : con, y389 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        Dwf2 : (g |- ewf A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, z1268 : map a x |-
             tmap (K3[.., a]) (A1[.., x])),
        Dwf3 : (g, x : eterm, dx : eof x (A[..]) |- ewf (A1[.., x]))
      | x : [g |- kd-wf (sigma K1 (\z328. K3))]
      ; by [g |- tmap/sigma Dtmap (\a. \x. \at. Dtmap1[.., x, a, at])]
as Dtmap' unboxed;
        by [g |- ewf/sigma Dwf2 (\x. \dx. Dwf3)] as Dwf' unboxed;
        solve [g |- map-wf/i _ Dtmap' Dwf']
      }
    }
  }
  case kd-wf/pi:
  { g : map-bind,
    K1 : (g |- kind),
    K2 : (g, a3 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, y388 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (pi K1 (\z327. K2))]
  ; split map-wf [g |- Dwf] as
    case map-wf/i:
    { g : map-bind,
      K1 : (g |- kind),
      K2 : (g, a3 : con |- kind),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, y388 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A),
      Dwf2 : (g |- ewf A)
    | x : [g |- kd-wf (pi K1 (\x363. K2))]
    ; split
      map-wf
        [g,
         b :
           block (
             x : eterm,
             dx : eof x (A[..]),
             a : con,
             da : cn-of a (K1[..]),
             at : map a x) |- Dwf1[.., b.3, b.4]] as
      case map-wf/i:
      { g : map-bind,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g, a : con, y388 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        Dwf2 : (g |- ewf A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x1333 : map a x |-
             tmap (K3[.., a]) (A1[.., x])),
        Dwf3 : (g, x : eterm, dx : eof x (A[..]) |- ewf (A1[.., x]))
      | x : [g |- kd-wf (pi K1 (\x363. K3))]
      ; by [g |- tmap/pi Dtmap (\a. \x. \at. Dtmap1[.., x, a, at])]
        as Dtmap' unboxed;
        by [g |- ewf/pi Dwf2 (\x. \dx. Dwf3)] as Dwf' unboxed;
        solve [g |- map-wf/i _ Dtmap' Dwf']
      }
    }
  }
  case kd-wf/sing:
  { g : map-bind,
    C : (g |- con),
    Dof : (g |- cn-of C t)
  | x : [g |- kd-wf (sing C)]
  ; split can-map [g |- C] as
    case can-map/i:
    { g : map-bind,
      C : (g |- con),
      Dof : (g |- cn-of C t),
      M : (g |- eterm),
      Dmap : (g |- map C M)
    | x : [g |- kd-wf (sing C)]
    ; split map-of' [g |- Dof] [g |- Dmap] [g |- tmap/t] as
      case map-of'/i:
      { g : map-bind,
        C : (g |- con),
        Dof : (g |- cn-of C t),
        M : (g |- eterm),
        Dmap : (g |- map C M),
        Dof1 : (g |- eof M et)
      | x : [g |- kd-wf (sing C)]
      ; solve [g |- map-wf/i _ (tmap/sing Dmap) (ewf/sing Dof1)]
      }
    }
  }
  case kd-wf/t:
  { g : map-bind
  | x : [g |- kd-wf t]
  ; solve [g |- map-wf/i _ tmap/t ewf/t]
  }
}

and proof map-wf' :
  (g : map-bind)
  [g |- kd-wf K] ->
  [g |- tmap K A] ->
    [g |- map-wf'/e A] =
/ total 1 /
intros
{ g : map-bind, K : (g |- kind), A : (g |- etp)
| x : [g |- kd-wf K], tmap : [g |- tmap K A]
; by x as Dwf unboxed;
  by tmap as Dmap unboxed;
  split map-wf [_ |- Dwf] as
  case map-wf/i:
  { g : map-bind,
    K : (g |- kind),
    A : (g |- etp),
    Dwf : (g |- kd-wf K),
    Dmap : (g |- tmap K A),
    A1 : (g |- etp),
    Dtmap : (g |- tmap K A1),
    Dwf1 : (g |- ewf A1)
  | x : [g |- kd-wf K], tmap : [g |- tmap K A]
  ; split tmap-fun [_ |- Dmap] [_ |- Dtmap] as
    case etp-eq/i:
    { g : map-bind,
      K : (g |- kind),
      A' : (g |- etp),
      Dwf : (g |- kd-wf K),
      Dmap : (g |- tmap K A'),
      Dmap' : (g |- tmap K A'),
      Dwf' : (g |- ewf A')
    | x : [g |- kd-wf K], tmap : [g |- tmap K A']
    ; solve [_ |- map-wf'/i Dwf']
    }
  }
}

and proof map-subtp :
  (g : map-bind)
  [g |- kd-sub K L] ->
  [g |- tmap K A] ->
  [g |- tmap L B] ->
    [g |- map-subtp/e A B] =
/ trust / % FIXME: See issue #4
intros
{ g : map-bind,
  K : (g |- kind),
  L : (g |- kind),
  A : (g |- etp),
  B : (g |- etp)
| sub : [g |- kd-sub K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
; split sub as
  case kd-sub/sigma:
  { g : map-bind,
    K1 : (g |- kind),
    K3 : (g, a11 : con |- kind),
    K2 : (g |- kind),
    K4 : (g, a12 : con |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dsub : (g |- kd-sub K1 K2),
    Dsub1 :
      (g, a : con, y433 : cn-of a (K1[..]) |- kd-sub (K3[.., a]) (K4[.., a])),
    Dwf : (g, a : con, z432 : cn-of a (K2[..]) |- kd-wf (K4[.., a]))
  | sub : [g |- kd-sub (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
    tmap : [g |- tmap (sigma K1 (\x364. K3)) A],
    tmap1 : [g |- tmap (sigma K2 (\x364. K4)) B]
  ; split tmap as
    case tmap/sigma:
    { g : map-bind,
      K1 : (g |- kind),
      K3 : (g, a11 : con |- kind),
      K2 : (g |- kind),
      K4 : (g, a12 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, x962 : eterm |- etp),
      B : (g |- etp),
      Dsub : (g |- kd-sub K1 K2),
      Dsub1 :
        (g, a : con, y433 : cn-of a (K1[..]) |-
           kd-sub (K3[.., a]) (K4[.., a])),
      Dwf : (g, a : con, z432 : cn-of a (K2[..]) |- kd-wf (K4[.., a])),
      Dtmap : (g |- tmap K1 A1),
      Dtmap1 :
        (g, a : con, x : eterm, y962 : map a x |-
           tmap (K3[.., a]) (A2[.., x]))
    | sub : [g |- kd-sub (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
      tmap : [g |- tmap (sigma K1 (\x364. K3)) (esigma A1 (\y149. A2))],
      tmap1 : [g |- tmap (sigma K2 (\x364. K4)) B]
    ; split tmap1 as
      case tmap/sigma:
      { g : map-bind,
        K1 : (g |- kind),
        K3 : (g, a11 : con |- kind),
        K2 : (g |- kind),
        K4 : (g, a12 : con |- kind),
        A1 : (g |- etp),
        A2 : (g, x962 : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, x962 : eterm |- etp),
        Dsub : (g |- kd-sub K1 K2),
        Dsub1 :
          (g, a : con, y433 : cn-of a (K1[..]) |-
             kd-sub (K3[.., a]) (K4[.., a])),
        Dwf : (g, a : con, z432 : cn-of a (K2[..]) |- kd-wf (K4[.., a])),
        Dtmap : (g |- tmap K1 A1),
        Dtmap1 :
          (g, a : con, x : eterm, y962 : map a x |-
             tmap (K3[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K2 A3),
        Dtmap3 :
          (g, a : con, x : eterm, y962 : map a x |-
             tmap (K4[.., a]) (A4[.., x]))
      | sub : [g |- kd-sub (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
        tmap : [g |- tmap (sigma K1 (\x364. K3)) (esigma A1 (\y149. A2))],
        tmap1 : [g |- tmap (sigma K2 (\x364. K4)) (esigma A3 (\y149. A4))]
      ; split map-subtp [g |- Dsub] [g |- Dtmap] [g |- Dtmap2] as
        case map-subtp/i:
        { g : map-bind,
          K1 : (g |- kind),
          K3 : (g, a11 : con |- kind),
          K2 : (g |- kind),
          K4 : (g, a12 : con |- kind),
          A1 : (g |- etp),
          A2 : (g, x962 : eterm |- etp),
          A3 : (g |- etp),
          A4 : (g, x962 : eterm |- etp),
          Dsub : (g |- kd-sub K1 K2),
          Dsub1 :
            (g, a : con, y433 : cn-of a (K1[..]) |-
               kd-sub (K3[.., a]) (K4[.., a])),
          Dwf : (g, a : con, z432 : cn-of a (K2[..]) |- kd-wf (K4[.., a])),
          Dtmap : (g |- tmap K1 A1),
          Dtmap1 :
            (g, a : con, x : eterm, y962 : map a x |-
               tmap (K3[.., a]) (A2[.., x])),
          Dtmap2 : (g |- tmap K2 A3),
          Dtmap3 :
            (g, a : con, x : eterm, y962 : map a x |-
               tmap (K4[.., a]) (A4[.., x])),
          Dsub2 : (g |- subtp A1 A3)
        | sub : [g |- kd-sub (sigma K1 (\z522. K3)) (sigma K2 (\z522. K4))],
          tmap : [g |- tmap (sigma K1 (\z522. K3)) (esigma A1 (\z147. A2))],
          tmap1 : [g |- tmap (sigma K2 (\z522. K4)) (esigma A3 (\z147. A4))]
        ; split
          map-subtp
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dsub1[.., b.3, b.4]]
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dtmap3[.., b.3, b.1, b.5]] as
          case map-subtp/i:
          { g : map-bind,
            K1 : (g |- kind),
            K3 : (g, a11 : con |- kind),
            K2 : (g |- kind),
            K4 : (g, a12 : con |- kind),
            A1 : (g |- etp),
            A5 : (g, x : eterm |- etp),
            A3 : (g |- etp),
            A6 : (g, x : eterm |- etp),
            Dsub : (g |- kd-sub K1 K2),
            Dsub1 :
              (g, a : con, y433 : cn-of a (K1[..]) |-
                 kd-sub (K3[.., a]) (K4[.., a])),
            Dwf : (g, a : con, z432 : cn-of a (K2[..]) |- kd-wf (K4[.., a])),
            Dtmap : (g |- tmap K1 A1),
            Dtmap1 :
              (g, a : con, x : eterm, y962 : map a x |-
                 tmap (K3[.., a]) (A5[.., x])),
            Dtmap2 : (g |- tmap K2 A3),
            Dtmap3 :
              (g, a : con, x : eterm, y962 : map a x |-
                 tmap (K4[.., a]) (A6[.., x])),
            Dsub2 : (g |- subtp A1 A3),
            Dsub3 :
              (g, x : eterm, dx : eof x (A1[..]) |-
                 subtp (A5[.., x]) (A6[.., x]))
          | sub : [g |- kd-sub (sigma K1 (\z522. K3)) (sigma K2 (\z522. K4))],
            tmap : [g |- tmap (sigma K1 (\z522. K3)) (esigma A1 (\z147. A5))],
            tmap1 :
              [g |- tmap (sigma K2 (\z522. K4)) (esigma A3 (\z147. A6))]
          ; split
            map-wf'
              [g,
               b :
                 block (
                   x : eterm,
                   dx : eof x (A3[..]),
                   a : con,
                   da : cn-of a (K2[..]),
                   at : map a x) |- Dwf[.., b.3, b.4]]
              [g,
               b :
                 block (
                   x : eterm,
                   dx : eof x (A3[..]),
                   a : con,
                   da : cn-of a (K2[..]),
                   at : map a x) |- Dtmap3[.., b.3, b.1, b.5]] as
            case map-wf'/i:
            { g : map-bind,
              K1 : (g |- kind),
              K3 : (g, a11 : con |- kind),
              K2 : (g |- kind),
              K4 : (g, a12 : con |- kind),
              A1 : (g |- etp),
              A5 : (g, x : eterm |- etp),
              A3 : (g |- etp),
              A7 : (g, x : eterm |- etp),
              Dsub : (g |- kd-sub K1 K2),
              Dsub1 :
                (g, a : con, y433 : cn-of a (K1[..]) |-
                   kd-sub (K3[.., a]) (K4[.., a])),
              Dwf :
                (g, a : con, z432 : cn-of a (K2[..]) |- kd-wf (K4[.., a])),
              Dtmap : (g |- tmap K1 A1),
              Dtmap1 :
                (g, a : con, x : eterm, y962 : map a x |-
                   tmap (K3[.., a]) (A5[.., x])),
              Dtmap2 : (g |- tmap K2 A3),
              Dtmap3 :
                (g, a : con, x : eterm, y962 : map a x |-
                   tmap (K4[.., a]) (A7[.., x])),
              Dsub2 : (g |- subtp A1 A3),
              Dsub3 :
                (g, x : eterm, dx : eof x (A1[..]) |-
                   subtp (A5[.., x]) (A7[.., x])),
              Dwf1 : (g, x : eterm, dx : eof x (A3[..]) |- ewf (A7[.., x]))
            | sub :
                [g |- kd-sub (sigma K1 (\z522. K3)) (sigma K2 (\z522. K4))],
              tmap :
                [g |- tmap (sigma K1 (\z522. K3)) (esigma A1 (\z147. A5))],
              tmap1 :
                [g |- tmap (sigma K2 (\z522. K4)) (esigma A3 (\z147. A7))]
            ; solve
                [g |-
                   map-subtp/i (subtp/sigma Dsub2
                               (\x. \dx. Dsub3) (\x. \dx. Dwf1))]
            }
          }
        }
      }
    }
  }
  case kd-sub/pi:
  { g : map-bind,
    K2 : (g |- kind),
    K3 : (g, a9 : con |- kind),
    K1 : (g |- kind),
    K4 : (g, a10 : con |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dsub : (g |- kd-sub K1 K2),
    Dsub1 :
      (g, a : con, x431 : cn-of a (K1[..]) |- kd-sub (K3[.., a]) (K4[.., a])),
    Dwf : (g, a : con, y431 : cn-of a (K2[..]) |- kd-wf (K3[.., a]))
  | sub : [g |- kd-sub (pi K2 (\x363. K3)) (pi K1 (\x363. K4))],
    tmap : [g |- tmap (pi K2 (\x363. K3)) A],
    tmap1 : [g |- tmap (pi K1 (\x363. K4)) B]
  ; split tmap as
    case tmap/pi:
    { g : map-bind,
      K2 : (g |- kind),
      K3 : (g, a9 : con |- kind),
      K1 : (g |- kind),
      K4 : (g, a10 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, y961 : eterm |- etp),
      B : (g |- etp),
      Dsub : (g |- kd-sub K1 K2),
      Dsub1 :
        (g, a : con, x431 : cn-of a (K1[..]) |-
           kd-sub (K3[.., a]) (K4[.., a])),
      Dwf : (g, a : con, y431 : cn-of a (K2[..]) |- kd-wf (K3[.., a])),
      Dtmap : (g |- tmap K2 A1),
      Dtmap1 :
        (g, a : con, x : eterm, z960 : map a x |-
           tmap (K3[.., a]) (A2[.., x]))
    | sub : [g |- kd-sub (pi K2 (\x363. K3)) (pi K1 (\x363. K4))],
      tmap : [g |- tmap (pi K2 (\x363. K3)) (epi A1 (\y148. A2))],
      tmap1 : [g |- tmap (pi K1 (\x363. K4)) B]
    ; split tmap1 as
      case tmap/pi:
      { g : map-bind,
        K2 : (g |- kind),
        K3 : (g, a9 : con |- kind),
        K1 : (g |- kind),
        K4 : (g, a10 : con |- kind),
        A1 : (g |- etp),
        A2 : (g, y961 : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, y961 : eterm |- etp),
        Dsub : (g |- kd-sub K1 K2),
        Dsub1 :
          (g, a : con, x431 : cn-of a (K1[..]) |-
             kd-sub (K3[.., a]) (K4[.., a])),
        Dwf : (g, a : con, y431 : cn-of a (K2[..]) |- kd-wf (K3[.., a])),
        Dtmap : (g |- tmap K2 A1),
        Dtmap1 :
          (g, a : con, x : eterm, z960 : map a x |-
             tmap (K3[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K1 A3),
        Dtmap3 :
          (g, a : con, x : eterm, z960 : map a x |-
             tmap (K4[.., a]) (A4[.., x]))
      | sub : [g |- kd-sub (pi K2 (\x363. K3)) (pi K1 (\x363. K4))],
        tmap : [g |- tmap (pi K2 (\x363. K3)) (epi A1 (\y148. A2))],
        tmap1 : [g |- tmap (pi K1 (\x363. K4)) (epi A3 (\y148. A4))]
      ; split map-subtp [g |- Dsub] [g |- Dtmap2] [g |- Dtmap] as
        case map-subtp/i:
        { g : map-bind,
          K2 : (g |- kind),
          K3 : (g, a9 : con |- kind),
          K1 : (g |- kind),
          K4 : (g, a10 : con |- kind),
          A1 : (g |- etp),
          A2 : (g, y961 : eterm |- etp),
          A3 : (g |- etp),
          A4 : (g, y961 : eterm |- etp),
          Dsub : (g |- kd-sub K1 K2),
          Dsub1 :
            (g, a : con, x431 : cn-of a (K1[..]) |-
               kd-sub (K3[.., a]) (K4[.., a])),
          Dwf : (g, a : con, y431 : cn-of a (K2[..]) |- kd-wf (K3[.., a])),
          Dtmap : (g |- tmap K2 A1),
          Dtmap1 :
            (g, a : con, x : eterm, z960 : map a x |-
               tmap (K3[.., a]) (A2[.., x])),
          Dtmap2 : (g |- tmap K1 A3),
          Dtmap3 :
            (g, a : con, x : eterm, z960 : map a x |-
               tmap (K4[.., a]) (A4[.., x])),
          Dsub2 : (g |- subtp A3 A1)
        | sub : [g |- kd-sub (pi K2 (\z521. K3)) (pi K1 (\z521. K4))],
          tmap : [g |- tmap (pi K2 (\z521. K3)) (epi A1 (\z146. A2))],
          tmap1 : [g |- tmap (pi K1 (\z521. K4)) (epi A3 (\z146. A4))]
        ; split
          map-subtp
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A3[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dsub1[.., b.3, b.4]]
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A3[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A3[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dtmap3[.., b.3, b.1, b.5]] as
          case map-subtp/i:
          { g : map-bind,
            K2 : (g |- kind),
            K3 : (g, a9 : con |- kind),
            K1 : (g |- kind),
            K4 : (g, a10 : con |- kind),
            A1 : (g |- etp),
            A5 : (g, x : eterm |- etp),
            A3 : (g |- etp),
            A6 : (g, x : eterm |- etp),
            Dsub : (g |- kd-sub K1 K2),
            Dsub1 :
              (g, a : con, x431 : cn-of a (K1[..]) |-
                 kd-sub (K3[.., a]) (K4[.., a])),
            Dwf : (g, a : con, y431 : cn-of a (K2[..]) |- kd-wf (K3[.., a])),
            Dtmap : (g |- tmap K2 A1),
            Dtmap1 :
              (g, a : con, x : eterm, z960 : map a x |-
                 tmap (K3[.., a]) (A5[.., x])),
            Dtmap2 : (g |- tmap K1 A3),
            Dtmap3 :
              (g, a : con, x : eterm, z960 : map a x |-
                 tmap (K4[.., a]) (A6[.., x])),
            Dsub2 : (g |- subtp A3 A1),
            Dsub3 :
              (g, x : eterm, dx : eof x (A3[..]) |-
                 subtp (A5[.., x]) (A6[.., x]))
          | sub : [g |- kd-sub (pi K2 (\z521. K3)) (pi K1 (\z521. K4))],
            tmap : [g |- tmap (pi K2 (\z521. K3)) (epi A1 (\z146. A5))],
            tmap1 : [g |- tmap (pi K1 (\z521. K4)) (epi A3 (\z146. A6))]
          ; split
            map-wf'
              [g,
               b :
                 block (
                   x : eterm,
                   dx : eof x (A1[..]),
                   a : con,
                   da : cn-of a (K2[..]),
                   at : map a x) |- Dwf[.., b.3, b.4]]
              [g,
               b :
                 block (
                   x : eterm,
                   dx : eof x (A1[..]),
                   a : con,
                   da : cn-of a (K2[..]),
                   at : map a x) |- Dtmap1[.., b.3, b.1, b.5]] as
            case map-wf'/i:
            { g : map-bind,
              K2 : (g |- kind),
              K3 : (g, a9 : con |- kind),
              K1 : (g |- kind),
              K4 : (g, a10 : con |- kind),
              A1 : (g |- etp),
              A7 : (g, x : eterm |- etp),
              A3 : (g |- etp),
              A6 : (g, x : eterm |- etp),
              Dsub : (g |- kd-sub K1 K2),
              Dsub1 :
                (g, a : con, x431 : cn-of a (K1[..]) |-
                   kd-sub (K3[.., a]) (K4[.., a])),
              Dwf :
                (g, a : con, y431 : cn-of a (K2[..]) |- kd-wf (K3[.., a])),
              Dtmap : (g |- tmap K2 A1),
              Dtmap1 :
                (g, a : con, x : eterm, z960 : map a x |-
                   tmap (K3[.., a]) (A7[.., x])),
              Dtmap2 : (g |- tmap K1 A3),
              Dtmap3 :
                (g, a : con, x : eterm, z960 : map a x |-
                   tmap (K4[.., a]) (A6[.., x])),
              Dsub2 : (g |- subtp A3 A1),
              Dsub3 :
                (g, x : eterm, dx : eof x (A3[..]) |-
                   subtp (A7[.., x]) (A6[.., x])),
              Dwf1 : (g, x : eterm, dx : eof x (A1[..]) |- ewf (A7[.., x]))
            | sub : [g |- kd-sub (pi K2 (\z521. K3)) (pi K1 (\z521. K4))],
              tmap : [g |- tmap (pi K2 (\z521. K3)) (epi A1 (\z146. A7))],
              tmap1 : [g |- tmap (pi K1 (\z521. K4)) (epi A3 (\z146. A6))]
            ; solve
                [g |-
                   map-subtp/i (subtp/pi Dsub2
                               (\x. \dx. Dsub3) (\x. \dx. Dwf1))]
            }
          }
        }
      }
    }
  }
  case kd-sub/sing-t:
  { g : map-bind,
    C : (g |- con),
    A : (g |- etp),
    B : (g |- etp),
    Dof : (g |- cn-of C t)
  | sub : [g |- kd-sub (sing C) t],
    tmap : [g |- tmap (sing C) A],
    tmap1 : [g |- tmap t B]
  ; split tmap as
    case tmap/sing:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      B : (g |- etp),
      Dof : (g |- cn-of C t),
      Dmap : (g |- map C M)
    | sub : [g |- kd-sub (sing C) t],
      tmap : [g |- tmap (sing C) (esing M)],
      tmap1 : [g |- tmap t B]
    ; split tmap1 as
      case tmap/t:
      { g : map-bind,
        C : (g |- con),
        M : (g |- eterm),
        Dof : (g |- cn-of C t),
        Dmap : (g |- map C M)
      | sub : [g |- kd-sub (sing C) t],
        tmap : [g |- tmap (sing C) (esing M)],
        tmap1 : [g |- tmap t et]
      ; split map-of' [g |- Dof] [g |- Dmap] [g |- tmap/t] as
        case map-of'/i:
        { g : map-bind,
          C : (g |- con),
          M : (g |- eterm),
          Dof : (g |- cn-of C t),
          Dmap : (g |- map C M),
          Dof1 : (g |- eof M et)
        | sub : [g |- kd-sub (sing C) t],
          tmap : [g |- tmap (sing C) (esing M)],
          tmap1 : [g |- tmap t et]
        ; solve [g |- map-subtp/i (subtp/sing_t Dof1)]
        }
      }
    }
  }
  case kd-sub/trans:
  { g : map-bind,
    K : (g |- kind),
    L : (g |- kind),
    A : (g |- etp),
    B : (g |- etp),
    K2 : (g |- kind),
    Dsub : (g |- kd-sub K K2),
    Dsub1 : (g |- kd-sub K2 L)
  | sub : [g |- kd-sub K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
  ; by tmap as DmapA unboxed;
    by tmap1 as DmapC unboxed;
    split can-tmap [g |- K2] as
    case can-tmap/i:
    { g : map-bind,
      K : (g |- kind),
      K'' : (g |- kind),
      A : (g |- etp),
      C : (g |- etp),
      K' : (g |- kind),
      DsubAB : (g |- kd-sub K K'),
      DsubBC : (g |- kd-sub K' K''),
      DmapA : (g |- tmap K A),
      DmapC : (g |- tmap K'' C),
      A1 : (g |- etp),
      Dtmap : (g |- tmap K' A1)
    | sub : [g |- kd-sub K K''],
      tmap : [g |- tmap K A],
      tmap1 : [g |- tmap K'' C]
    ; split map-subtp [g |- DsubAB] [g |- DmapA] [g |- Dtmap] as
      case map-subtp/i:
      { g : map-bind,
        K : (g |- kind),
        K'' : (g |- kind),
        A : (g |- etp),
        C : (g |- etp),
        K' : (g |- kind),
        DsubAB : (g |- kd-sub K K'),
        DsubBC : (g |- kd-sub K' K''),
        DmapA : (g |- tmap K A),
        DmapC : (g |- tmap K'' C),
        B : (g |- etp),
        DmapB : (g |- tmap K' B),
        Dsub : (g |- subtp A B)
      | sub : [g |- kd-sub K K''],
        tmap : [g |- tmap K A],
        tmap1 : [g |- tmap K'' C]
      ; split map-subtp [g |- DsubBC] [g |- DmapB] [g |- DmapC] as
        case map-subtp/i:
        { g : map-bind,
          K : (g |- kind),
          K'' : (g |- kind),
          A : (g |- etp),
          C : (g |- etp),
          K' : (g |- kind),
          DsubAB : (g |- kd-sub K K'),
          DsubBC : (g |- kd-sub K' K''),
          DmapA : (g |- tmap K A),
          DmapC : (g |- tmap K'' C),
          B : (g |- etp),
          DmapB : (g |- tmap K' B),
          Dsub : (g |- subtp A B),
          Dsub1 : (g |- subtp B C)
        | sub : [g |- kd-sub K K''],
          tmap : [g |- tmap K A],
          tmap1 : [g |- tmap K'' C]
        ; solve [g |- map-subtp/i (subtp/trans Dsub Dsub1)]
        }
      }
    }
  }
  case kd-sub/refl:
  { g : map-bind,
    K : (g |- kind),
    L : (g |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dequiv : (g |- kd-equiv K L)
  | sub : [g |- kd-sub K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
  ; by tmap as DmapA unboxed;
    by tmap1 as DmapB unboxed;
    split map-tequiv [g |- Dequiv] [g |- DmapA] [g |- DmapB] as
    case map-tequiv/i:
    { g : map-bind,
      K : (g |- kind),
      L : (g |- kind),
      A : (g |- etp),
      B : (g |- etp),
      Dequiv : (g |- kd-equiv K L),
      DmapA : (g |- tmap K A),
      DmapB : (g |- tmap L B),
      Dtequiv : (g |- tequiv A B)
    | sub : [g |- kd-sub K L],
      tmap : [g |- tmap K A],
      tmap1 : [g |- tmap L B]
    ; solve [g |- map-subtp/i (subtp/reflex Dtequiv)]
    }
  }
}

and proof map-tequiv :
  (g : map-bind)
  [g |- kd-equiv K L] ->
  [g |- tmap K A] ->
  [g |- tmap L B] ->
    [g |- map-tequiv/e A B] =
/ total 1 /
intros
{ g : map-bind,
  K : (g |- kind),
  L : (g |- kind),
  A : (g |- etp),
  B : (g |- etp)
| x : [g |- kd-equiv K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
; split x as
  case kd-equiv/sigma:
  { g : map-bind,
    K1 : (g |- kind),
    K3 : (g, a7 : con |- kind),
    K2 : (g |- kind),
    K4 : (g, a8 : con |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, x428 : cn-of a (K1[..]) |-
         kd-equiv (K3[.., a]) (K4[.., a]))
  | x : [g |- kd-equiv (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
    tmap : [g |- tmap (sigma K1 (\x364. K3)) A],
    tmap1 : [g |- tmap (sigma K2 (\x364. K4)) B]
  ; split tmap as
    case tmap/sigma:
    { g : map-bind,
      K1 : (g |- kind),
      K3 : (g, a7 : con |- kind),
      K2 : (g |- kind),
      K4 : (g, a8 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, x962 : eterm |- etp),
      B : (g |- etp),
      Dequiv : (g |- kd-equiv K1 K2),
      Dequiv1 :
        (g, a : con, x428 : cn-of a (K1[..]) |-
           kd-equiv (K3[.., a]) (K4[.., a])),
      Dtmap : (g |- tmap K1 A1),
      Dtmap1 :
        (g, a : con, x : eterm, y962 : map a x |-
           tmap (K3[.., a]) (A2[.., x]))
    | x : [g |- kd-equiv (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
      tmap : [g |- tmap (sigma K1 (\x364. K3)) (esigma A1 (\y149. A2))],
      tmap1 : [g |- tmap (sigma K2 (\x364. K4)) B]
    ; split tmap1 as
      case tmap/sigma:
      { g : map-bind,
        K1 : (g |- kind),
        K3 : (g, a7 : con |- kind),
        K2 : (g |- kind),
        K4 : (g, a8 : con |- kind),
        A1 : (g |- etp),
        A2 : (g, x962 : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, x962 : eterm |- etp),
        Dequiv : (g |- kd-equiv K1 K2),
        Dequiv1 :
          (g, a : con, x428 : cn-of a (K1[..]) |-
             kd-equiv (K3[.., a]) (K4[.., a])),
        Dtmap : (g |- tmap K1 A1),
        Dtmap1 :
          (g, a : con, x : eterm, y962 : map a x |-
             tmap (K3[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K2 A3),
        Dtmap3 :
          (g, a : con, x : eterm, y962 : map a x |-
             tmap (K4[.., a]) (A4[.., x]))
      | x : [g |- kd-equiv (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
        tmap : [g |- tmap (sigma K1 (\x364. K3)) (esigma A1 (\y149. A2))],
        tmap1 : [g |- tmap (sigma K2 (\x364. K4)) (esigma A3 (\y149. A4))]
      ; split map-tequiv [g |- Dequiv] [g |- Dtmap] [g |- Dtmap2] as
        case map-tequiv/i:
        { g : map-bind,
          K1 : (g |- kind),
          K3 : (g, a7 : con |- kind),
          K2 : (g |- kind),
          K4 : (g, a8 : con |- kind),
          A1 : (g |- etp),
          A2 : (g, x962 : eterm |- etp),
          A3 : (g |- etp),
          A4 : (g, x962 : eterm |- etp),
          Dequiv : (g |- kd-equiv K1 K2),
          Dequiv1 :
            (g, a : con, x428 : cn-of a (K1[..]) |-
               kd-equiv (K3[.., a]) (K4[.., a])),
          Dtmap : (g |- tmap K1 A1),
          Dtmap1 :
            (g, a : con, x : eterm, y962 : map a x |-
               tmap (K3[.., a]) (A2[.., x])),
          Dtmap2 : (g |- tmap K2 A3),
          Dtmap3 :
            (g, a : con, x : eterm, y962 : map a x |-
               tmap (K4[.., a]) (A4[.., x])),
          Dtequiv : (g |- tequiv A1 A3)
        | x : [g |- kd-equiv (sigma K1 (\y521. K3)) (sigma K2 (\y521. K4))],
          tmap : [g |- tmap (sigma K1 (\y521. K3)) (esigma A1 (\z147. A2))],
          tmap1 : [g |- tmap (sigma K2 (\y521. K4)) (esigma A3 (\z147. A4))]
        ; split
          map-tequiv
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dequiv1[.., b.3, b.4]]
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dtmap3[.., b.3, b.1, b.5]] as
          case map-tequiv/i:
          { g : map-bind,
            K1 : (g |- kind),
            K3 : (g, a7 : con |- kind),
            K2 : (g |- kind),
            K4 : (g, a8 : con |- kind),
            A1 : (g |- etp),
            A5 : (g, x : eterm |- etp),
            A3 : (g |- etp),
            A6 : (g, x : eterm |- etp),
            Dequiv : (g |- kd-equiv K1 K2),
            Dequiv1 :
              (g, a : con, x428 : cn-of a (K1[..]) |-
                 kd-equiv (K3[.., a]) (K4[.., a])),
            Dtmap : (g |- tmap K1 A1),
            Dtmap1 :
              (g, a : con, x : eterm, y962 : map a x |-
                 tmap (K3[.., a]) (A5[.., x])),
            Dtmap2 : (g |- tmap K2 A3),
            Dtmap3 :
              (g, a : con, x : eterm, y962 : map a x |-
                 tmap (K4[.., a]) (A6[.., x])),
            Dtequiv : (g |- tequiv A1 A3),
            Dtequiv1 :
              (g, x : eterm, dx : eof x (A1[..]) |-
                 tequiv (A5[.., x]) (A6[.., x]))
          | x : [g |- kd-equiv (sigma K1 (\y521. K3)) (sigma K2 (\y521. K4))],
            tmap : [g |- tmap (sigma K1 (\y521. K3)) (esigma A1 (\z147. A5))],
            tmap1 :
              [g |- tmap (sigma K2 (\y521. K4)) (esigma A3 (\z147. A6))]
          ; solve
              [g |- map-tequiv/i (tequiv/sigma Dtequiv (\x. \dx. Dtequiv1))]
          }
        }
      }
    }
  }
  case kd-equiv/pi:
  { g : map-bind,
    K1 : (g |- kind),
    K3 : (g, a5 : con |- kind),
    K2 : (g |- kind),
    K4 : (g, a6 : con |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, x427 : cn-of a (K1[..]) |-
         kd-equiv (K3[.., a]) (K4[.., a]))
  | x : [g |- kd-equiv (pi K1 (\x363. K3)) (pi K2 (\x363. K4))],
    tmap : [g |- tmap (pi K1 (\x363. K3)) A],
    tmap1 : [g |- tmap (pi K2 (\x363. K4)) B]
  ; split tmap as
    case tmap/pi:
    { g : map-bind,
      K1 : (g |- kind),
      K3 : (g, a5 : con |- kind),
      K2 : (g |- kind),
      K4 : (g, a6 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, y961 : eterm |- etp),
      B : (g |- etp),
      Dequiv : (g |- kd-equiv K1 K2),
      Dequiv1 :
        (g, a : con, x427 : cn-of a (K1[..]) |-
           kd-equiv (K3[.., a]) (K4[.., a])),
      Dtmap : (g |- tmap K1 A1),
      Dtmap1 :
        (g, a : con, x : eterm, z960 : map a x |-
           tmap (K3[.., a]) (A2[.., x]))
    | x : [g |- kd-equiv (pi K1 (\x363. K3)) (pi K2 (\x363. K4))],
      tmap : [g |- tmap (pi K1 (\x363. K3)) (epi A1 (\y148. A2))],
      tmap1 : [g |- tmap (pi K2 (\x363. K4)) B]
    ; split tmap1 as
      case tmap/pi:
      { g : map-bind,
        K1 : (g |- kind),
        K3 : (g, a5 : con |- kind),
        K2 : (g |- kind),
        K4 : (g, a6 : con |- kind),
        A1 : (g |- etp),
        A2 : (g, y961 : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, y961 : eterm |- etp),
        Dequiv : (g |- kd-equiv K1 K2),
        Dequiv1 :
          (g, a : con, x427 : cn-of a (K1[..]) |-
             kd-equiv (K3[.., a]) (K4[.., a])),
        Dtmap : (g |- tmap K1 A1),
        Dtmap1 :
          (g, a : con, x : eterm, z960 : map a x |-
             tmap (K3[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K2 A3),
        Dtmap3 :
          (g, a : con, x : eterm, z960 : map a x |-
             tmap (K4[.., a]) (A4[.., x]))
      | x : [g |- kd-equiv (pi K1 (\x363. K3)) (pi K2 (\x363. K4))],
        tmap : [g |- tmap (pi K1 (\x363. K3)) (epi A1 (\y148. A2))],
        tmap1 : [g |- tmap (pi K2 (\x363. K4)) (epi A3 (\y148. A4))]
      ; split map-tequiv [g |- Dequiv] [g |- Dtmap] [g |- Dtmap2] as
        case map-tequiv/i:
        { g : map-bind,
          K1 : (g |- kind),
          K3 : (g, a5 : con |- kind),
          K2 : (g |- kind),
          K4 : (g, a6 : con |- kind),
          A1 : (g |- etp),
          A2 : (g, y961 : eterm |- etp),
          A3 : (g |- etp),
          A4 : (g, y961 : eterm |- etp),
          Dequiv : (g |- kd-equiv K1 K2),
          Dequiv1 :
            (g, a : con, x427 : cn-of a (K1[..]) |-
               kd-equiv (K3[.., a]) (K4[.., a])),
          Dtmap : (g |- tmap K1 A1),
          Dtmap1 :
            (g, a : con, x : eterm, z960 : map a x |-
               tmap (K3[.., a]) (A2[.., x])),
          Dtmap2 : (g |- tmap K2 A3),
          Dtmap3 :
            (g, a : con, x : eterm, z960 : map a x |-
               tmap (K4[.., a]) (A4[.., x])),
          Dtequiv : (g |- tequiv A1 A3)
        | x : [g |- kd-equiv (pi K1 (\y520. K3)) (pi K2 (\y520. K4))],
          tmap : [g |- tmap (pi K1 (\y520. K3)) (epi A1 (\z146. A2))],
          tmap1 : [g |- tmap (pi K2 (\y520. K4)) (epi A3 (\z146. A4))]
        ; split
          map-tequiv
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dequiv1[.., b.3, b.4]]
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A1[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dtmap3[.., b.3, b.1, b.5]] as
          case map-tequiv/i:
          { g : map-bind,
            K1 : (g |- kind),
            K3 : (g, a5 : con |- kind),
            K2 : (g |- kind),
            K4 : (g, a6 : con |- kind),
            A1 : (g |- etp),
            A5 : (g, x : eterm |- etp),
            A3 : (g |- etp),
            A6 : (g, x : eterm |- etp),
            Dequiv : (g |- kd-equiv K1 K2),
            Dequiv1 :
              (g, a : con, x427 : cn-of a (K1[..]) |-
                 kd-equiv (K3[.., a]) (K4[.., a])),
            Dtmap : (g |- tmap K1 A1),
            Dtmap1 :
              (g, a : con, x : eterm, z960 : map a x |-
                 tmap (K3[.., a]) (A5[.., x])),
            Dtmap2 : (g |- tmap K2 A3),
            Dtmap3 :
              (g, a : con, x : eterm, z960 : map a x |-
                 tmap (K4[.., a]) (A6[.., x])),
            Dtequiv : (g |- tequiv A1 A3),
            Dtequiv1 :
              (g, x : eterm, dx : eof x (A1[..]) |-
                 tequiv (A5[.., x]) (A6[.., x]))
          | x : [g |- kd-equiv (pi K1 (\y520. K3)) (pi K2 (\y520. K4))],
            tmap : [g |- tmap (pi K1 (\y520. K3)) (epi A1 (\z146. A5))],
            tmap1 : [g |- tmap (pi K2 (\y520. K4)) (epi A3 (\z146. A6))]
          ; solve [g |- map-tequiv/i (tequiv/pi Dtequiv (\x. \dx. Dtequiv1))]
          }
        }
      }
    }
  }
  case kd-equiv/sing:
  { g : map-bind,
    C : (g |- con),
    C1 : (g |- con),
    A : (g |- etp),
    B : (g |- etp),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)],
    tmap : [g |- tmap (sing C) A],
    tmap1 : [g |- tmap (sing C1) B]
  ; split tmap as
    case tmap/sing:
    { g : map-bind,
      C : (g |- con),
      C1 : (g |- con),
      M : (g |- eterm),
      B : (g |- etp),
      Dequiv : (g |- cn-equiv C C1 t),
      Dmap : (g |- map C M)
    | x : [g |- kd-equiv (sing C) (sing C1)],
      tmap : [g |- tmap (sing C) (esing M)],
      tmap1 : [g |- tmap (sing C1) B]
    ; split tmap1 as
      case tmap/sing:
      { g : map-bind,
        C : (g |- con),
        C1 : (g |- con),
        M : (g |- eterm),
        M1 : (g |- eterm),
        Dequiv : (g |- cn-equiv C C1 t),
        Dmap : (g |- map C M),
        Dmap1 : (g |- map C1 M1)
      | x : [g |- kd-equiv (sing C) (sing C1)],
        tmap : [g |- tmap (sing C) (esing M)],
        tmap1 : [g |- tmap (sing C1) (esing M1)]
      ; split map-equiv'' [g |- Dmap] [g |- Dmap1] [g |- Dequiv] [g |- tmap/t] as
        case map-equiv''/i:
        { g : map-bind,
          C : (g |- con),
          C1 : (g |- con),
          M : (g |- eterm),
          M1 : (g |- eterm),
          Dequiv : (g |- cn-equiv C C1 t),
          Dmap : (g |- map C M),
          Dmap1 : (g |- map C1 M1),
          Dequiv1 : (g |- equiv M M1 et)
        | x : [g |- kd-equiv (sing C) (sing C1)],
          tmap : [g |- tmap (sing C) (esing M)],
          tmap1 : [g |- tmap (sing C1) (esing M1)]
        ; solve [g |- map-tequiv/i (tequiv/sing Dequiv1)]
        }
      }
    }
  }
  case kd-equiv/trans:
  { g : map-bind,
    K : (g |- kind),
    L : (g |- kind),
    A : (g |- etp),
    B : (g |- etp),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv K K2),
    Dequiv1 : (g |- kd-equiv K2 L)
  | x : [g |- kd-equiv K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
  ; by tmap as DmapA unboxed;
    by tmap1 as DmapC unboxed;
    split can-tmap [g |- K2] as
    case can-tmap/i:
    { g : map-bind,
      K : (g |- kind),
      K'' : (g |- kind),
      A : (g |- etp),
      C : (g |- etp),
      K' : (g |- kind),
      DequivAB : (g |- kd-equiv K K'),
      DequivBC : (g |- kd-equiv K' K''),
      DmapA : (g |- tmap K A),
      DmapC : (g |- tmap K'' C),
      A1 : (g |- etp),
      Dtmap : (g |- tmap K' A1)
    | x : [g |- kd-equiv K K''],
      tmap : [g |- tmap K A],
      tmap1 : [g |- tmap K'' C]
    ; split map-tequiv [g |- DequivAB] [g |- DmapA] [g |- Dtmap] as
      case map-tequiv/i:
      { g : map-bind,
        K : (g |- kind),
        K'' : (g |- kind),
        A : (g |- etp),
        C : (g |- etp),
        K' : (g |- kind),
        DequivAB : (g |- kd-equiv K K'),
        DequivBC : (g |- kd-equiv K' K''),
        DmapA : (g |- tmap K A),
        DmapC : (g |- tmap K'' C),
        A1 : (g |- etp),
        DmapB : (g |- tmap K' A1),
        Dtequiv : (g |- tequiv A A1)
      | x : [g |- kd-equiv K K''],
        tmap : [g |- tmap K A],
        tmap1 : [g |- tmap K'' C]
      ; split map-tequiv [g |- DequivBC] [g |- DmapB] [g |- DmapC] as
        case map-tequiv/i:
        { g : map-bind,
          K : (g |- kind),
          K'' : (g |- kind),
          A : (g |- etp),
          C : (g |- etp),
          K' : (g |- kind),
          DequivAB : (g |- kd-equiv K K'),
          DequivBC : (g |- kd-equiv K' K''),
          DmapA : (g |- tmap K A),
          DmapC : (g |- tmap K'' C),
          A1 : (g |- etp),
          DmapB : (g |- tmap K' A1),
          Dtequiv : (g |- tequiv A A1),
          Dtequiv1 : (g |- tequiv A1 C)
        | x : [g |- kd-equiv K K''],
          tmap : [g |- tmap K A],
          tmap1 : [g |- tmap K'' C]
        ; solve [g |- map-tequiv/i (tequiv/trans Dtequiv Dtequiv1)]
        }
      }
    }
  }
  case kd-equiv/symm:
  { g : map-bind,
    K : (g |- kind),
    L : (g |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dequiv : (g |- kd-equiv L K)
  | x : [g |- kd-equiv K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
  ; by tmap as Dmap unboxed;
    by tmap1 as Dmap' unboxed;
    split map-tequiv [g |- Dequiv] [g |- Dmap'] [g |- Dmap] as
    case map-tequiv/i:
    { g : map-bind,
      K : (g |- kind),
      L : (g |- kind),
      A : (g |- etp),
      B : (g |- etp),
      Dequiv : (g |- kd-equiv L K),
      Dmap : (g |- tmap K A),
      Dmap' : (g |- tmap L B),
      Dtequiv : (g |- tequiv B A)
    | x : [g |- kd-equiv K L],
      tmap : [g |- tmap K A],
      tmap1 : [g |- tmap L B]
    ; solve [g |- map-tequiv/i (tequiv/symm Dtequiv)]
    }
  }
  case kd-equiv/refl:
  { g : map-bind,
    L : (g |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dwf : (g |- kd-wf L)
  | x : [g |- kd-equiv L L], tmap : [g |- tmap L A], tmap1 : [g |- tmap L B]
  ; by tmap as Dmap unboxed;
    by tmap1 as Dmap' unboxed;
    split tmap-fun [g |- Dmap] [g |- Dmap'] as
    case etp-eq/i:
    { g : map-bind,
      L : (g |- kind),
      B : (g |- etp),
      Dwf : (g |- kd-wf L),
      Dmap : (g |- tmap L B),
      Dmap' : (g |- tmap L B)
    | x : [g |- kd-equiv L L],
      tmap : [g |- tmap L B],
      tmap1 : [g |- tmap L B]
    ; split map-wf' [g |- Dwf] [g |- Dmap] as
      case map-wf'/i:
      { g : map-bind,
        L : (g |- kind),
        B : (g |- etp),
        Dwf : (g |- kd-wf L),
        Dmap : (g |- tmap L B),
        Dmap' : (g |- tmap L B),
        Dwf1 : (g |- ewf B)
      | x : [g |- kd-equiv L L],
        tmap : [g |- tmap L B],
        tmap1 : [g |- tmap L B]
      ; solve [g |- map-tequiv/i (tequiv/reflex Dwf1)]
      }
    }
  }
}

and proof map-equiv' :
  (g : map-bind)
  [g |- map C M] ->
  [g |- map D N] ->
  [g |- cn-equiv C D K] ->
    [g |- map-equiv'/e M N K] =
/ total 1 /
intros
{ g : map-bind,
  C : (g |- con),
  M : (g |- eterm),
  D : (g |- con),
  N : (g |- eterm),
  K : (g |- kind)
| map : [g |- map C M], map1 : [g |- map D N], equiv : [g |- cn-equiv C D K]
; split equiv as
  case cn-equiv/beta2:
  { g : map-bind,
    C1 : (g |- con),
    D : (g |- con),
    M : (g |- eterm),
    N : (g |- eterm),
    K : (g |- kind),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of D K)
  | map : [g |- map (pi2 (pair C1 D)) M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv (pi2 (pair C1 D)) D K]
  ; split map as
    case map/pi2:
    { g : map-bind,
      C1 : (g |- con),
      D : (g |- con),
      M1 : (g |- eterm),
      N : (g |- eterm),
      K : (g |- kind),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 K1),
      Dof1 : (g |- cn-of D K),
      Dmap : (g |- map (pair C1 D) M1)
    | map : [g |- map (pi2 (pair C1 D)) (epi2 M1)],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv (pi2 (pair C1 D)) D K]
    ; split [_ |- Dmap] as
      case map/pair:
      { g : map-bind,
        C1 : (g |- con),
        D : (g |- con),
        M2 : (g |- eterm),
        M3 : (g |- eterm),
        N : (g |- eterm),
        K : (g |- kind),
        K1 : (g |- kind),
        Dof : (g |- cn-of C1 K1),
        Dof1 : (g |- cn-of D K),
        Dmap1 : (g |- map C1 M2),
        Dmap2 : (g |- map D M3)
      | map : [g |- map (pi2 (pair C1 D)) (epi2 (epair M2 M3))],
        map1 : [g |- map D N],
        equiv : [g |- cn-equiv (pi2 (pair C1 D)) D K]
      ; split map-of [_ |- Dof] [_ |- Dmap1] as
        case map-of/i:
        { g : map-bind,
          C1 : (g |- con),
          D : (g |- con),
          M2 : (g |- eterm),
          M3 : (g |- eterm),
          N : (g |- eterm),
          K : (g |- kind),
          K1 : (g |- kind),
          Dof : (g |- cn-of C1 K1),
          Dof1 : (g |- cn-of D K),
          Dmap1 : (g |- map C1 M2),
          Dmap2 : (g |- map D M3),
          A : (g |- etp),
          Dtmap : (g |- tmap K1 A),
          Dof2 : (g |- eof M2 A)
        | map : [g |- map (pi2 (pair C1 D)) (epi2 (epair M2 M3))],
          map1 : [g |- map D N],
          equiv : [g |- cn-equiv (pi2 (pair C1 D)) D K]
        ; split map-of [_ |- Dof1] [_ |- Dmap2] as
          case map-of/i:
          { g : map-bind,
            C1 : (g |- con),
            D : (g |- con),
            M2 : (g |- eterm),
            M3 : (g |- eterm),
            N : (g |- eterm),
            K : (g |- kind),
            K1 : (g |- kind),
            Dof : (g |- cn-of C1 K1),
            Dof1 : (g |- cn-of D K),
            Dmap1 : (g |- map C1 M2),
            Dmap2 : (g |- map D M3),
            A : (g |- etp),
            Dtmap : (g |- tmap K1 A),
            Dof2 : (g |- eof M2 A),
            A1 : (g |- etp),
            Dtmap1 : (g |- tmap K A1),
            Dof3 : (g |- eof M3 A1)
          | map : [g |- map (pi2 (pair C1 D)) (epi2 (epair M2 M3))],
            map1 : [g |- map D N],
            equiv : [g |- cn-equiv (pi2 (pair C1 D)) D K]
          ; split map-fun map1 [_ |- Dmap2] as
            case eterm-eq/i:
            { g : map-bind,
              C1 : (g |- con),
              D : (g |- con),
              M2 : (g |- eterm),
              M3 : (g |- eterm),
              K : (g |- kind),
              K1 : (g |- kind),
              Dof : (g |- cn-of C1 K1),
              Dof1 : (g |- cn-of D K),
              Dmap1 : (g |- map C1 M2),
              Dmap2 : (g |- map D M3),
              A : (g |- etp),
              Dtmap : (g |- tmap K1 A),
              Dof2 : (g |- eof M2 A),
              A1 : (g |- etp),
              Dtmap1 : (g |- tmap K A1),
              Dof3 : (g |- eof M3 A1)
            | map : [g |- map (pi2 (pair C1 D)) (epi2 (epair M2 M3))],
              map1 : [g |- map D M3],
              equiv : [g |- cn-equiv (pi2 (pair C1 D)) D K]
            ; by [_ |- equiv/beta2 Dof2 Dof3] as Dequiv' unboxed;
              solve [_ |- map-equiv'/i _ Dtmap1 Dequiv']
            }
          }
        }
      }
    }
  }
  case cn-equiv/beta1:
  { g : map-bind,
    D : (g |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    N : (g |- eterm),
    K : (g |- kind),
    K2 : (g |- kind),
    Dof : (g |- cn-of D K),
    Dof1 : (g |- cn-of C2 K2)
  | map : [g |- map (pi1 (pair D C2)) M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv (pi1 (pair D C2)) D K]
  ; split map as
    case map/pi1:
    { g : map-bind,
      D : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      N : (g |- eterm),
      K : (g |- kind),
      K2 : (g |- kind),
      Dof : (g |- cn-of D K),
      Dof1 : (g |- cn-of C2 K2),
      Dmap : (g |- map (pair D C2) M1)
    | map : [g |- map (pi1 (pair D C2)) (epi1 M1)],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv (pi1 (pair D C2)) D K]
    ; split [g |- Dmap] as
      case map/pair:
      { g : map-bind,
        D : (g |- con),
        C2 : (g |- con),
        M2 : (g |- eterm),
        M3 : (g |- eterm),
        N : (g |- eterm),
        K : (g |- kind),
        K2 : (g |- kind),
        Dof : (g |- cn-of D K),
        Dof1 : (g |- cn-of C2 K2),
        Dmap1 : (g |- map D M2),
        Dmap2 : (g |- map C2 M3)
      | map : [g |- map (pi1 (pair D C2)) (epi1 (epair M2 M3))],
        map1 : [g |- map D N],
        equiv : [g |- cn-equiv (pi1 (pair D C2)) D K]
      ; split map-of [g |- Dof] [g |- Dmap1] as
        case map-of/i:
        { g : map-bind,
          D : (g |- con),
          C2 : (g |- con),
          M2 : (g |- eterm),
          M3 : (g |- eterm),
          N : (g |- eterm),
          K : (g |- kind),
          K2 : (g |- kind),
          Dof : (g |- cn-of D K),
          Dof1 : (g |- cn-of C2 K2),
          Dmap1 : (g |- map D M2),
          Dmap2 : (g |- map C2 M3),
          A : (g |- etp),
          Dtmap : (g |- tmap K A),
          Dof2 : (g |- eof M2 A)
        | map : [g |- map (pi1 (pair D C2)) (epi1 (epair M2 M3))],
          map1 : [g |- map D N],
          equiv : [g |- cn-equiv (pi1 (pair D C2)) D K]
        ; split map-of [g |- Dof1] [g |- Dmap2] as
          case map-of/i:
          { g : map-bind,
            D : (g |- con),
            C2 : (g |- con),
            M2 : (g |- eterm),
            M3 : (g |- eterm),
            N : (g |- eterm),
            K : (g |- kind),
            K2 : (g |- kind),
            Dof : (g |- cn-of D K),
            Dof1 : (g |- cn-of C2 K2),
            Dmap1 : (g |- map D M2),
            Dmap2 : (g |- map C2 M3),
            A : (g |- etp),
            Dtmap : (g |- tmap K A),
            Dof2 : (g |- eof M2 A),
            A1 : (g |- etp),
            Dtmap1 : (g |- tmap K2 A1),
            Dof3 : (g |- eof M3 A1)
          | map : [g |- map (pi1 (pair D C2)) (epi1 (epair M2 M3))],
            map1 : [g |- map D N],
            equiv : [g |- cn-equiv (pi1 (pair D C2)) D K]
          ; split map-fun map1 [g |- Dmap1] as
            case eterm-eq/i:
            { g : map-bind,
              D : (g |- con),
              C2 : (g |- con),
              M2 : (g |- eterm),
              M3 : (g |- eterm),
              K : (g |- kind),
              K2 : (g |- kind),
              Dof : (g |- cn-of D K),
              Dof1 : (g |- cn-of C2 K2),
              Dmap1 : (g |- map D M2),
              Dmap2 : (g |- map C2 M3),
              A : (g |- etp),
              Dtmap : (g |- tmap K A),
              Dof2 : (g |- eof M2 A),
              A1 : (g |- etp),
              Dtmap1 : (g |- tmap K2 A1),
              Dof3 : (g |- eof M3 A1)
            | map : [g |- map (pi1 (pair D C2)) (epi1 (epair M2 M3))],
              map1 : [g |- map D M2],
              equiv : [g |- cn-equiv (pi1 (pair D C2)) D K]
            ; by [g |- equiv/beta1 Dof2 Dof3] as Dequiv' unboxed;
              solve [g |- map-equiv'/i _ Dtmap Dequiv']
            }
          }
        }
      }
    }
  }
  case cn-equiv/beta:
  { g : map-bind,
    K1 : (g |- kind),
    C2 : (g, a41 : con |- con),
    C1 : (g |- con),
    M : (g |- eterm),
    N : (g |- eterm),
    K2 : (g, a42 : con |- kind),
    Dof1 :
      (g, a : con, y461 : cn-of a (K1[..]) |- cn-of (C2[.., a]) (K2[.., a])),
    Dof : (g |- cn-of C1 K1)
  | map : [g |- map (app (lam K1 (\z366. C2)) C1) M],
    map1 : [g |- map (C2[.., C1]) N],
    equiv :
      [g |- cn-equiv (app (lam K1 (\z366. C2)) C1) (C2[.., C1]) (K2[.., C1])]
  ; split map as
    case map/app:
    { g : map-bind,
      K1 : (g |- kind),
      C2 : (g, a41 : con |- con),
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      N : (g |- eterm),
      K2 : (g, a42 : con |- kind),
      Dof1 :
        (g, a : con, y461 : cn-of a (K1[..]) |- cn-of (C2[.., a]) (K2[.., a])),
      Dof : (g |- cn-of C1 K1),
      Dmap : (g |- map (lam K1 (\z366. C2)) M1),
      Dmap1 : (g |- map C1 M2)
    | map : [g |- map (app (lam K1 (\z366. C2)) C1) (eapp M1 M2)],
      map1 : [g |- map (C2[.., C1]) N],
      equiv :
        [g |-
           cn-equiv (app (lam K1 (\z366. C2)) C1) (C2[.., C1]) (K2[.., C1])]
    ; split [g |- Dmap] as
      case map/lam:
      { g : map-bind,
        K1 : (g |- kind),
        C2 : (g, a41 : con |- con),
        C1 : (g |- con),
        A : (g |- etp),
        M3 : (g, y953 : eterm |- eterm),
        M2 : (g |- eterm),
        N : (g |- eterm),
        K2 : (g, a42 : con |- kind),
        Dof1 :
          (g, a : con, y461 : cn-of a (K1[..]) |-
             cn-of (C2[.., a]) (K2[.., a])),
        Dof : (g |- cn-of C1 K1),
        Dtmap : (g |- tmap K1 A),
        Dmap2 :
          (g, a : con, x : eterm, z952 : map a x |-
             map (C2[.., a]) (M3[.., x])),
        Dmap1 : (g |- map C1 M2)
      | map :
          [g |-
             map (app (lam K1 (\z366. C2)) C1) (eapp (elam A (\y152. M3)) M2)],
        map1 : [g |- map (C2[.., C1]) N],
        equiv :
          [g |-
             cn-equiv (app (lam K1 (\z366. C2)) C1) (C2[.., C1]) (K2[.., C1])]
      ; by map1 as DmapMN unboxed;
        split
        map-of
          [g,
           b :
             block (
               x : eterm,
               dx : eof x (A[..]),
               a : con,
               da : cn-of a (K1[..]),
               at : map a x) |- Dof1[.., b.3, b.4]]
          [g,
           b :
             block (
               x : eterm,
               dx : eof x (A[..]),
               a : con,
               da : cn-of a (K1[..]),
               at : map a x) |- Dmap2[.., b.3, b.1, b.5]] as
        case map-of/i:
        { g : map-bind,
          K1 : (g |- kind),
          C2 : (g, a41 : con |- con),
          C1 : (g |- con),
          A : (g |- etp),
          M4 : (g, x : eterm |- eterm),
          M2 : (g |- eterm),
          N : (g |- eterm),
          K3 : (g, a : con |- kind),
          DofM :
            (g, a : con, y461 : cn-of a (K1[..]) |-
               cn-of (C2[.., a]) (K3[.., a])),
          DofN : (g |- cn-of C1 K1),
          DmapN : (g |- tmap K1 A),
          DmapM :
            (g, a : con, x : eterm, z952 : map a x |-
               map (C2[.., a]) (M4[.., x])),
          DmapA : (g |- map C1 M2),
          DmapMN : (g |- map (C2[.., C1]) N),
          A1 : (g, x : eterm |- etp),
          Dtmap :
            (g, x : eterm, a : con, y1389 : map a x |-
               tmap (K3[.., a]) (A1[.., x])),
          Dof :
            (g, x : eterm, dx : eof x (A[..]) |- eof (M4[.., x]) (A1[.., x]))
        | map :
            [g |-
               map
                 (app (lam K1 (\z366. C2)) C1) (eapp (elam A (\y152. M4)) M2)],
          map1 : [g |- map (C2[.., C1]) N],
          equiv :
            [g |-
               cn-equiv
                 (app (lam K1 (\z366. C2)) C1) (C2[.., C1]) (K3[.., C1])]
        ; split map-fun [g |- DmapM[.., C1, M2, DmapA]] [g |- DmapMN] as
          case eterm-eq/i:
          { g : map-bind,
            K1 : (g |- kind),
            C2 : (g, a41 : con |- con),
            C1 : (g |- con),
            A : (g |- etp),
            M4 : (g, x : eterm |- eterm),
            M2 : (g |- eterm),
            K3 : (g, a : con |- kind),
            DofM :
              (g, a : con, y461 : cn-of a (K1[..]) |-
                 cn-of (C2[.., a]) (K3[.., a])),
            DofN : (g |- cn-of C1 K1),
            DmapA : (g |- tmap K1 A),
            DmapM :
              (g, a : con, x : eterm, z952 : map a x |-
                 map (C2[.., a]) (M4[.., x])),
            DmapN : (g |- map C1 M2),
            DmapMN : (g |- map (C2[.., C1]) (M4[.., M2])),
            A1 : (g, x : eterm |- etp),
            DmapB :
              (g, x : eterm, a : con, y1389 : map a x |-
                 tmap (K3[.., a]) (A1[.., x])),
            DofM' :
              (g, x : eterm, dx : eof x (A[..]) |-
                 eof (M4[.., x]) (A1[.., x]))
          | map :
              [g |-
                 map
                   (app (lam K1 (\z366. C2)) C1)
                   (eapp (elam A (\y152. M4)) M2)],
            map1 : [g |- map (C2[.., C1]) (M4[.., M2])],
            equiv :
              [g |-
                 cn-equiv
                   (app (lam K1 (\z366. C2)) C1) (C2[.., C1]) (K3[.., C1])]
          ; split map-of' [g |- DofN] [g |- DmapN] [g |- DmapA] as
            case map-of'/i:
            { g : map-bind,
              K1 : (g |- kind),
              C2 : (g, a41 : con |- con),
              C1 : (g |- con),
              A : (g |- etp),
              M4 : (g, x : eterm |- eterm),
              M2 : (g |- eterm),
              K3 : (g, a : con |- kind),
              DofM :
                (g, a : con, y461 : cn-of a (K1[..]) |-
                   cn-of (C2[.., a]) (K3[.., a])),
              DofN : (g |- cn-of C1 K1),
              DmapA : (g |- tmap K1 A),
              DmapM :
                (g, a : con, x : eterm, z952 : map a x |-
                   map (C2[.., a]) (M4[.., x])),
              DmapN : (g |- map C1 M2),
              DmapMN : (g |- map (C2[.., C1]) (M4[.., M2])),
              A1 : (g, x : eterm |- etp),
              DmapB :
                (g, x : eterm, a : con, y1389 : map a x |-
                   tmap (K3[.., a]) (A1[.., x])),
              DofM' :
                (g, x : eterm, dx : eof x (A[..]) |-
                   eof (M4[.., x]) (A1[.., x])),
              Dof : (g |- eof M2 A)
            | map :
                [g |-
                   map
                     (app (lam K1 (\y525. C2)) C1)
                     (eapp (elam A (\z150. M4)) M2)],
              map1 : [g |- map (C2[.., C1]) (M4[.., M2])],
              equiv :
                [g |-
                   cn-equiv
                     (app (lam K1 (\y525. C2)) C1) (C2[.., C1]) (K3[.., C1])]
            ; solve
                [g |-
                   map-equiv'/i _
                   (DmapB[.., M2, C1, DmapN])
                   (equiv/beta (\x. \dx. DofM') Dof)]
            }
          }
        }
      }
    }
  }
  case cn-equiv/subsume:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    K : (g |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C D K1),
    Dsub : (g |- kd-sub K1 K)
  | map : [g |- map C M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv C D K]
  ; by map as Dmap unboxed;
    by map1 as Dmap' unboxed;
    split map-equiv' [g |- Dmap] [g |- Dmap'] [g |- Dequiv] as
    case map-equiv'/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      K : (g |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- cn-equiv C D K1),
      Dsub : (g |- kd-sub K1 K),
      Dmap : (g |- map C M),
      Dmap' : (g |- map D N),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A),
      Dequiv1 : (g |- equiv M N A)
    | map : [g |- map C M],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv C D K]
    ; split can-tmap [g |- K] as
      case can-tmap/i:
      { g : map-bind,
        C : (g |- con),
        M : (g |- eterm),
        D : (g |- con),
        N : (g |- eterm),
        K : (g |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- cn-equiv C D K1),
        Dsub : (g |- kd-sub K1 K),
        Dmap : (g |- map C M),
        Dmap' : (g |- map D N),
        A : (g |- etp),
        DmapA : (g |- tmap K1 A),
        Dequiv' : (g |- equiv M N A),
        A1 : (g |- etp),
        Dtmap : (g |- tmap K A1)
      | map : [g |- map C M],
        map1 : [g |- map D N],
        equiv : [g |- cn-equiv C D K]
      ; split map-subtp [g |- Dsub] [g |- DmapA] [g |- Dtmap] as
        case map-subtp/i:
        { g : map-bind,
          C : (g |- con),
          M : (g |- eterm),
          D : (g |- con),
          N : (g |- eterm),
          K : (g |- kind),
          K1 : (g |- kind),
          Dequiv : (g |- cn-equiv C D K1),
          Dsub : (g |- kd-sub K1 K),
          Dmap : (g |- map C M),
          Dmap' : (g |- map D N),
          A : (g |- etp),
          DmapA : (g |- tmap K1 A),
          Dequiv' : (g |- equiv M N A),
          A1 : (g |- etp),
          DmapB : (g |- tmap K A1),
          Dsub1 : (g |- subtp A A1)
        | map : [g |- map C M],
          map1 : [g |- map D N],
          equiv : [g |- cn-equiv C D K]
        ; solve [g |- map-equiv'/i _ DmapB (equiv/subsume Dequiv' Dsub1)]
        }
      }
    }
  }
  case cn-equiv/one:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    Dof : (g |- cn-of C one),
    Dof1 : (g |- cn-of D one)
  | map : [g |- map C M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv C D one]
  ; by map as Dmap1 unboxed;
    by map1 as Dmap2 unboxed;
    split map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/one] as
    case map-of'/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      Dof : (g |- cn-of C one),
      Dof1 : (g |- cn-of D one),
      Dmap1 : (g |- map C M),
      Dmap2 : (g |- map D N),
      Dof2 : (g |- eof M eone)
    | map : [g |- map C M],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv C D one]
    ; split map-of' [g |- Dof1] [g |- Dmap2] [g |- tmap/one] as
      case map-of'/i:
      { g : map-bind,
        C : (g |- con),
        M : (g |- eterm),
        D : (g |- con),
        N : (g |- eterm),
        Dof : (g |- cn-of C one),
        Dof1 : (g |- cn-of D one),
        Dmap1 : (g |- map C M),
        Dmap2 : (g |- map D N),
        Dof2 : (g |- eof M eone),
        Dof3 : (g |- eof N eone)
      | map : [g |- map C M],
        map1 : [g |- map D N],
        equiv : [g |- cn-equiv C D one]
      ; solve [g |- map-equiv'/i _ tmap/one (equiv/one Dof2 Dof3)]
      }
    }
  }
  case cn-equiv/extsigma:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    K1 : (g |- kind),
    K2 : (g, a40 : con |- kind),
    Dequiv : (g |- cn-equiv (pi1 C) (pi1 D) K1),
    Dequiv1 : (g |- cn-equiv (pi2 C) (pi2 D) (K2[.., pi1 C])),
    Dwf : (g, a : con, z458 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | map : [g |- map C M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv C D (sigma K1 (\x364. K2))]
  ; by map as Dmap unboxed;
    by map1 as Dmap' unboxed;
    split
    map-equiv' [g |- map/pi1 Dmap] [g |- map/pi1 Dmap'] [g |- Dequiv] as
    case map-equiv'/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      K1 : (g |- kind),
      K2 : (g, a40 : con |- kind),
      Dequiv1 : (g |- cn-equiv (pi1 C) (pi1 D) K1),
      Dequiv2 : (g |- cn-equiv (pi2 C) (pi2 D) (K2[.., pi1 C])),
      Dwf2 : (g, a : con, z458 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      Dmap : (g |- map C M),
      Dmap' : (g |- map D N),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A),
      Dequiv3 : (g |- equiv (epi1 M) (epi1 N) A)
    | map : [g |- map C M],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv C D (sigma K1 (\x364. K2))]
    ; split
      map-wf
        [g,
         b :
           block (
             x : eterm,
             dx : eof x (A[..]),
             a : con,
             da : cn-of a (K1[..]),
             at : map a x) |- Dwf2[.., b.3, b.4]] as
      case map-wf/i:
      { g : map-bind,
        C : (g |- con),
        M : (g |- eterm),
        D : (g |- con),
        N : (g |- eterm),
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        Dequiv1 : (g |- cn-equiv (pi1 C) (pi1 D) K1),
        Dequiv2 : (g |- cn-equiv (pi2 C) (pi2 D) (K3[.., pi1 C])),
        Dwf2 : (g, a : con, z458 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
        Dmap : (g |- map C M),
        Dmap' : (g |- map D N),
        A : (g |- etp),
        DmapA : (g |- tmap K1 A),
        Dequiv1' : (g |- equiv (epi1 M) (epi1 N) A),
        A1 : (g, x : eterm |- etp),
        Dtmap :
          (g, x : eterm, a : con, y1391 : map a x |-
             tmap (K3[.., a]) (A1[.., x])),
        Dwf3 : (g, x : eterm, dx : eof x (A[..]) |- ewf (A1[.., x]))
      | map : [g |- map C M],
        map1 : [g |- map D N],
        equiv : [g |- cn-equiv C D (sigma K1 (\x364. K3))]
      ; split
map-equiv'' [g |- map/pi2 Dmap] [g |- map/pi2 Dmap'] [g |- Dequiv2]
  [g |- Dtmap[.., epi1 M, pi1 C, map/pi1 Dmap]] as
        case map-equiv''/i:
        { g : map-bind,
          C : (g |- con),
          M : (g |- eterm),
          D : (g |- con),
          N : (g |- eterm),
          K1 : (g |- kind),
          K3 : (g, a : con |- kind),
          Dequiv1 : (g |- cn-equiv (pi1 C) (pi1 D) K1),
          Dequiv2 : (g |- cn-equiv (pi2 C) (pi2 D) (K3[.., pi1 C])),
          Dwf2 : (g, a : con, z458 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
          Dmap : (g |- map C M),
          Dmap' : (g |- map D N),
          A : (g |- etp),
          DmapA : (g |- tmap K1 A),
          Dequiv1' : (g |- equiv (epi1 M) (epi1 N) A),
          A1 : (g, x : eterm |- etp),
          Dtmap :
            (g, x : eterm, a : con, y1391 : map a x |-
               tmap (K3[.., a]) (A1[.., x])),
          Dwf3 : (g, x : eterm, dx : eof x (A[..]) |- ewf (A1[.., x])),
          Dequiv3 : (g |- equiv (epi2 M) (epi2 N) (A1[.., epi1 M]))
        | map : [g |- map C M],
          map1 : [g |- map D N],
          equiv : [g |- cn-equiv C D (sigma K1 (\z522. K3))]
        ; solve
            [g |-
               map-equiv'/i _
               (tmap/sigma DmapA (\a. \x. \at. Dtmap[.., x, a, at]))
               (equiv/extsigma Dequiv1' Dequiv3 (\x. \dx. Dwf3))]
        }
      }
    }
  }
  case cn-equiv/extpiw:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    K1 : (g |- kind),
    K3 : (g, a39 : con |- kind),
    K2 : (g, a38 : con |- kind),
    DequivPre : (g |- cn-equiv C D (pi K1 (\x363. K2))),
    Dequiv :
      (g, a : con, x457 : cn-of a (K1[..]) |-
         cn-equiv (app (C[..]) a) (app (D[..]) a) (K3[.., a]))
  | map : [g |- map C M],
    map' : [g |- map D N],
    equiv : [g |- cn-equiv C D (pi K1 (\x363. K3))]
  ; by map as Dmap unboxed;
    by map' as Dmap' unboxed;
    split map-equiv' [g |- Dmap] [g |- Dmap'] [g |- DequivPre] as
    case map-equiv'/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      K1 : (g |- kind),
      K3 : (g, a39 : con |- kind),
      K2 : (g, a38 : con |- kind),
      DequivPre : (g |- cn-equiv C D (pi K1 (\x363. K2))),
      Dequiv :
        (g, a : con, x457 : cn-of a (K1[..]) |-
           cn-equiv (app (C[..]) a) (app (D[..]) a) (K3[.., a])),
      Dmap : (g |- map C M),
      Dmap' : (g |- map D N),
      A : (g |- etp),
      Dtmap : (g |- tmap (pi K1 (\x363. K2)) A),
      DequivPre' : (g |- equiv M N A)
    | map : [g |- map C M],
      map' : [g |- map D N],
      equiv : [g |- cn-equiv C D (pi K1 (\z521. K3))]
    ; split [g |- Dtmap] as
      case tmap/pi:
      { g : map-bind,
        C : (g |- con),
        M : (g |- eterm),
        D : (g |- con),
        N : (g |- eterm),
        K1 : (g |- kind),
        K3 : (g, a39 : con |- kind),
        K2 : (g, a38 : con |- kind),
        DequivPre : (g |- cn-equiv C D (pi K1 (\x363. K2))),
        Dequiv :
          (g, a : con, x457 : cn-of a (K1[..]) |-
             cn-equiv (app (C[..]) a) (app (D[..]) a) (K3[.., a])),
        Dmap : (g |- map C M),
        Dmap' : (g |- map D N),
        A1 : (g |- etp),
        A2 : (g, y1264 : eterm |- etp),
        DmapA : (g |- tmap K1 A1),
        DmapA' :
          (g, a : con, x : eterm, z1263 : map a x |-
             tmap (K2[.., a]) (A2[.., x])),
        DequivPre' : (g |- equiv M N (epi A1 (\z146. A2)))
      | map : [g |- map C M],
        map' : [g |- map D N],
        equiv : [g |- cn-equiv C D (pi K1 (\z521. K3))]
      ; split
map-equiv'
  [g,
   b :
     block (
       x : eterm,
       dx : eof x (A1[..]),
       a : con,
       da : cn-of a (K1[..]),
       at : map a x) |- map/app (Dmap[..]) b.5]
  [g,
   b :
     block (
       x : eterm,
       dx : eof x (A1[..]),
       a : con,
       da : cn-of a (K1[..]),
       at : map a x) |- map/app (Dmap'[..]) b.5]
  [g,
   b :
     block (
       x : eterm,
       dx : eof x (A1[..]),
       a : con,
       da : cn-of a (K1[..]),
       at : map a x) |- Dequiv[.., b.3, b.4]] as
        case map-equiv'/i:
        { g : map-bind,
          C : (g |- con),
          M : (g |- eterm),
          D : (g |- con),
          N : (g |- eterm),
          K1 : (g |- kind),
          K4 : (g, a : con |- kind),
          K2 : (g, a38 : con |- kind),
          DequivPre : (g |- cn-equiv C D (pi K1 (\x363. K2))),
          Dequiv :
            (g, a : con, x457 : cn-of a (K1[..]) |-
               cn-equiv (app (C[..]) a) (app (D[..]) a) (K4[.., a])),
          Dmap : (g |- map C M),
          Dmap' : (g |- map D N),
          A1 : (g |- etp),
          A2 : (g, y1264 : eterm |- etp),
          DmapA : (g |- tmap K1 A1),
          DmapA' :
            (g, a : con, x : eterm, z1263 : map a x |-
               tmap (K2[.., a]) (A2[.., x])),
          DequivPre' : (g |- equiv M N (epi A1 (\z146. A2))),
          A3 : (g, x : eterm |- etp),
          DmapB :
            (g, x : eterm, a : con, y53 : map a x |-
               tmap (K4[.., a]) (A3[.., x])),
          Dequiv' :
            (g, x : eterm, dx : eof x (A1[..]) |-
               equiv (eapp (M[..]) x) (eapp (N[..]) x) (A3[.., x]))
        | map : [g |- map C M],
          map' : [g |- map D N],
          equiv : [g |- cn-equiv C D (pi K1 (\z521. K4))]
        ; solve
  [g |-
     map-equiv'/i _
     (tmap/pi DmapA (\a. \x. \at. DmapB[.., x, a, at]))
     (equiv/extpiw DequivPre' (\x. \dx. Dequiv'))]
        }
      }
    }
  }
  case cn-equiv/extpi:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    K1 : (g |- kind),
    K4 : (g, a37 : con |- kind),
    K2 : (g, a35 : con |- kind),
    K3 : (g, a36 : con |- kind),
    Dof : (g |- cn-of C (pi K1 (\x363. K2))),
    Dof1 : (g |- cn-of D (pi K1 (\x363. K3))),
    Dequiv :
      (g, a : con, x456 : cn-of a (K1[..]) |-
         cn-equiv (app (C[..]) a) (app (D[..]) a) (K4[.., a]))
  | map : [g |- map C M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv C D (pi K1 (\x363. K4))]
  ; by map as Dmap1 unboxed;
    by map1 as Dmap2 unboxed;
    split map-of [g |- Dof] [g |- Dmap1] as
    case map-of/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      K1 : (g |- kind),
      K4 : (g, a37 : con |- kind),
      K2 : (g, a35 : con |- kind),
      K3 : (g, a36 : con |- kind),
      DofPre1 : (g |- cn-of C (pi K1 (\x363. K2))),
      DofPre2 : (g |- cn-of D (pi K1 (\x363. K3))),
      Dequiv :
        (g, a : con, x456 : cn-of a (K1[..]) |-
           cn-equiv (app (C[..]) a) (app (D[..]) a) (K4[.., a])),
      Dmap : (g |- map C M),
      Dmap' : (g |- map D N),
      A : (g |- etp),
      Dtmap : (g |- tmap (pi K1 (\x363. K2)) A),
      Dof : (g |- eof M A)
    | map : [g |- map C M],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv C D (pi K1 (\x363. K4))]
    ; split [g |- Dtmap] as
      case tmap/pi:
      { g : map-bind,
        C : (g |- con),
        M : (g |- eterm),
        D : (g |- con),
        N : (g |- eterm),
        K1 : (g |- kind),
        K4 : (g, a37 : con |- kind),
        K2 : (g, a35 : con |- kind),
        K3 : (g, a36 : con |- kind),
        DofPre1 : (g |- cn-of C (pi K1 (\x363. K2))),
        DofPre2 : (g |- cn-of D (pi K1 (\x363. K3))),
        Dequiv :
          (g, a : con, x456 : cn-of a (K1[..]) |-
             cn-equiv (app (C[..]) a) (app (D[..]) a) (K4[.., a])),
        Dmap : (g |- map C M),
        Dmap' : (g |- map D N),
        A1 : (g |- etp),
        A2 : (g, y961 : eterm |- etp),
        Dtmap1 : (g |- tmap K1 A1),
        Dtmap2 :
          (g, a : con, x : eterm, z960 : map a x |-
             tmap (K2[.., a]) (A2[.., x])),
        Dof : (g |- eof M (epi A1 (\y148. A2)))
      | map : [g |- map C M],
        map1 : [g |- map D N],
        equiv : [g |- cn-equiv C D (pi K1 (\x363. K4))]
      ; split
        can-tmap
          [g,
           b :
             block (
               x : eterm,
               dx : eof x (A1[..]),
               a : con,
               da : cn-of a (K1[..]),
               at : map a x) |- K3[.., b.3]] as
        case can-tmap/i:
        { g : map-bind,
          C : (g |- con),
          M : (g |- eterm),
          D : (g |- con),
          N : (g |- eterm),
          K1 : (g |- kind),
          K4 : (g, a37 : con |- kind),
          K2 : (g, a35 : con |- kind),
          K5 : (g, a : con |- kind),
          DofPre1 : (g |- cn-of C (pi K1 (\x363. K2))),
          DofPre2 : (g |- cn-of D (pi K1 (\x363. K5))),
          Dequiv :
            (g, a : con, x456 : cn-of a (K1[..]) |-
               cn-equiv (app (C[..]) a) (app (D[..]) a) (K4[.., a])),
          Dmap : (g |- map C M),
          Dmap' : (g |- map D N),
          A1 : (g |- etp),
          A2 : (g, y961 : eterm |- etp),
          DmapA : (g |- tmap K1 A1),
          Dtmap2 :
            (g, a : con, x : eterm, z960 : map a x |-
               tmap (K2[.., a]) (A2[.., x])),
          DofPre1' : (g |- eof M (epi A1 (\y148. A2))),
          A3 : (g, x : eterm |- etp),
          Dtmap3 :
            (g, x : eterm, a : con, z1369 : map a x |-
               tmap (K5[.., a]) (A3[.., x]))
        | map : [g |- map C M],
          map1 : [g |- map D N],
          equiv : [g |- cn-equiv C D (pi K1 (\x363. K4))]
        ; split
map-of' [g |- DofPre2] [g |- Dmap']
  [g |- tmap/pi DmapA (\x. \a. \at. Dtmap3[.., a, x, at])] as
          case map-of'/i:
          { g : map-bind,
            C : (g |- con),
            M : (g |- eterm),
            D : (g |- con),
            N : (g |- eterm),
            K1 : (g |- kind),
            K4 : (g, a37 : con |- kind),
            K2 : (g, a35 : con |- kind),
            K5 : (g, a : con |- kind),
            DofPre1 : (g |- cn-of C (pi K1 (\x363. K2))),
            DofPre2 : (g |- cn-of D (pi K1 (\x363. K5))),
            Dequiv :
              (g, a : con, x456 : cn-of a (K1[..]) |-
                 cn-equiv (app (C[..]) a) (app (D[..]) a) (K4[.., a])),
            Dmap : (g |- map C M),
            Dmap' : (g |- map D N),
            A1 : (g |- etp),
            A2 : (g, y961 : eterm |- etp),
            DmapA : (g |- tmap K1 A1),
            Dtmap2 :
              (g, a : con, x : eterm, z960 : map a x |-
                 tmap (K2[.., a]) (A2[.., x])),
            DofPre1' : (g |- eof M (epi A1 (\y148. A2))),
            A3 : (g, x : eterm |- etp),
            Dtmap3 :
              (g, x : eterm, a : con, z1369 : map a x |-
                 tmap (K5[.., a]) (A3[.., x])),
            Dof : (g |- eof N (epi A1 (\z146. A3)))
          | map : [g |- map C M],
            map1 : [g |- map D N],
            equiv : [g |- cn-equiv C D (pi K1 (\z521. K4))]
          ; split
            map-equiv'
              [g,
               b :
                 block (
                   x : eterm,
                   dx : eof x (A1[..]),
                   a : con,
                   da : cn-of a (K1[..]),
                   at : map a x) |- map/app (Dmap[..]) b.5]
              [g,
               b :
                 block (
                   x : eterm,
                   dx : eof x (A1[..]),
                   a : con,
                   da : cn-of a (K1[..]),
                   at : map a x) |- map/app (Dmap'[..]) b.5]
              [g,
               b :
                 block (
                   x : eterm,
                   dx : eof x (A1[..]),
                   a : con,
                   da : cn-of a (K1[..]),
                   at : map a x) |- Dequiv[.., b.3, b.4]] as
            case map-equiv'/i:
            { g : map-bind,
              C : (g |- con),
              M : (g |- eterm),
              D : (g |- con),
              N : (g |- eterm),
              K1 : (g |- kind),
              K6 : (g, a : con |- kind),
              K2 : (g, a35 : con |- kind),
              K5 : (g, a : con |- kind),
              DofPre1 : (g |- cn-of C (pi K1 (\x363. K2))),
              DofPre2 : (g |- cn-of D (pi K1 (\x363. K5))),
              Dequiv :
                (g, a : con, x456 : cn-of a (K1[..]) |-
                   cn-equiv (app (C[..]) a) (app (D[..]) a) (K6[.., a])),
              Dmap : (g |- map C M),
              Dmap' : (g |- map D N),
              A1 : (g |- etp),
              A2 : (g, y961 : eterm |- etp),
              DmapA : (g |- tmap K1 A1),
              Dtmap2 :
                (g, a : con, x : eterm, z960 : map a x |-
                   tmap (K2[.., a]) (A2[.., x])),
              DofPre1' : (g |- eof M (epi A1 (\y148. A2))),
              A3 : (g, x : eterm |- etp),
              Dtmap3 :
                (g, x : eterm, a : con, z1369 : map a x |-
                   tmap (K5[.., a]) (A3[.., x])),
              DofPre2' : (g |- eof N (epi A1 (\z146. A3))),
              A4 : (g, x : eterm |- etp),
              Dtmap4 :
                (g, x : eterm, a : con, z1461 : map a x |-
                   tmap (K6[.., a]) (A4[.., x])),
              Dequiv1 :
                (g, x : eterm, dx : eof x (A1[..]) |-
                   equiv (eapp (M[..]) x) (eapp (N[..]) x) (A4[.., x]))
            | map : [g |- map C M],
              map1 : [g |- map D N],
              equiv : [g |- cn-equiv C D (pi K1 (\z521. K6))]
            ; solve
  [g |-
     map-equiv'/i _
     (tmap/pi DmapA (\a. \x. \at. Dtmap4[.., x, a, at]))
     (equiv/extpi DofPre1' DofPre2' (\x. \dx. Dequiv1))]
            }
          }
        }
      }
    }
  }
  case cn-equiv/singelim:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    Dof : (g |- cn-of C (sing D))
  | map : [g |- map C M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv C D t]
  ; by map as Dmap1 unboxed;
    by map1 as Dmap2 unboxed;
    split map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/sing Dmap2] as
    case map-of'/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      Dof : (g |- cn-of C (sing D)),
      Dmap1 : (g |- map C M),
      Dmap2 : (g |- map D N),
      Dof1 : (g |- eof M (esing N))
    | map : [g |- map C M],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv C D t]
    ; solve [g |- map-equiv'/i _ tmap/t (equiv/singelim Dof1)]
    }
  }
  case cn-equiv/sing:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    Dequiv : (g |- cn-equiv C D t)
  | map : [g |- map C M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv C D (sing C)]
  ; by map as Dmap1 unboxed;
    by map1 as Dmap2 unboxed;
    split map-equiv'' [g |- Dmap1] [g |- Dmap2] [g |- Dequiv] [g |- tmap/t] as
    case map-equiv''/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      Dequiv : (g |- cn-equiv C D t),
      Dmap1 : (g |- map C M),
      Dmap2 : (g |- map D N),
      Dequiv1 : (g |- equiv M N et)
    | map : [g |- map C M],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv C D (sing C)]
    ; solve [g |- map-equiv'/i _ (tmap/sing Dmap1) (equiv/sing Dequiv1)]
    }
  }
  case cn-equiv/labeled:
  { g : map-bind,
    X : ( |- label),
    C1 : (g |- con),
    M : (g |- eterm),
    C2 : (g |- con),
    N : (g |- eterm),
    Dequiv : (g |- cn-equiv C1 C2 t)
  | map : [g |- map (labeled X[] C1) M],
    map1 : [g |- map (labeled X[] C2) N],
    equiv : [g |- cn-equiv (labeled X[] C1) (labeled X[] C2) t]
  ; split map as
    case map/labeled:
    { g : map-bind,
      X : ( |- label),
      C1 : (g |- con),
      M1 : (g |- eterm),
      C2 : (g |- con),
      N : (g |- eterm),
      Dequiv : (g |- cn-equiv C1 C2 t),
      Dmap : (g |- map C1 M1)
    | map :
        [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)],
      map1 : [g |- map (labeled X[] C2) N],
      equiv : [g |- cn-equiv (labeled X[] C1) (labeled X[] C2) t]
    ; split map1 as
      case map/labeled:
      { g : map-bind,
        X : ( |- label),
        C1 : (g |- con),
        M1 : (g |- eterm),
        C2 : (g |- con),
        M2 : (g |- eterm),
        Dequiv : (g |- cn-equiv C1 C2 t),
        Dmap : (g |- map C1 M1),
        Dmap1 : (g |- map C2 M2)
      | map :
          [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)],
        map1 :
          [g |- map (labeled X[] C2) (eapp (econst (const/labeled X[])) M2)],
        equiv : [g |- cn-equiv (labeled X[] C1) (labeled X[] C2) t]
      ; split map-equiv'' [g |- Dmap] [g |- Dmap1] [g |- Dequiv] [g |- tmap/t] as
        case map-equiv''/i:
        { g : map-bind,
          X : ( |- label),
          C1 : (g |- con),
          M1 : (g |- eterm),
          C2 : (g |- con),
          M2 : (g |- eterm),
          Dequiv : (g |- cn-equiv C1 C2 t),
          Dmap : (g |- map C1 M1),
          Dmap1 : (g |- map C2 M2),
          Dequiv1 : (g |- equiv M1 M2 et)
        | map :
            [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)],
          map1 :
            [g |- map (labeled X[] C2) (eapp (econst (const/labeled X[])) M2)],
          equiv : [g |- cn-equiv (labeled X[] C1) (labeled X[] C2) t]
        ; solve
            [g |-
               map-equiv'/i _
               tmap/t
               (equiv/app (equiv/reflex (eof/const (ekof/i (ckof/labeled )
                                                   (etopen/pi etopen/t
                                                   etp-skel/t
                                                   (\l1. \l2. \l3. etopen/t)))
                                        (ewf/pi ewf/t (\l1. \l2. ewf/t))))
               Dequiv1)]
        }
      }
    }
  }
  case cn-equiv/rec:
  { g : map-bind,
    K1 : (g |- kind),
    C1 : (g, a32 : con, a31 : con |- con),
    C3 : (g |- con),
    M : (g |- eterm),
    K2 : (g |- kind),
    C2 : (g, a34 : con, a33 : con |- con),
    C4 : (g |- con),
    N : (g |- eterm),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, z453 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y454 : cn-of b (K1[..]) |- cn-equiv (C1[.., a, b]) (C2[.., a, b]) t),
    Dequiv2 : (g |- cn-equiv C3 C4 K1)
  | map : [g |- map (rec' K1 (\x371. \z371. C1) C3) M],
    map1 : [g |- map (rec' K2 (\x371. \z371. C2) C4) N],
    equiv :
      [g |-
         cn-equiv
           (rec' K1 (\x371. \z371. C1) C3) (rec' K2 (\x371. \z371. C2) C4) t]
  ; ?
  }
  case cn-equiv/tag:
  { g : map-bind,
    C1 : (g |- con),
    M : (g |- eterm),
    C2 : (g |- con),
    N : (g |- eterm),
    Dequiv : (g |- cn-equiv C1 C2 t)
  | map : [g |- map (tag C1) M],
    map1 : [g |- map (tag C2) N],
    equiv : [g |- cn-equiv (tag C1) (tag C2) t]
  ; split map as
    case map/tag:
    { g : map-bind,
      C1 : (g |- con),
      M1 : (g |- eterm),
      C2 : (g |- con),
      N : (g |- eterm),
      Dequiv : (g |- cn-equiv C1 C2 t),
      Dmap : (g |- map C1 M1)
    | map : [g |- map (tag C1) (eapp (econst const/tag) M1)],
      map1 : [g |- map (tag C2) N],
      equiv : [g |- cn-equiv (tag C1) (tag C2) t]
    ; split map1 as
      case map/tag:
      { g : map-bind,
        C1 : (g |- con),
        M1 : (g |- eterm),
        C2 : (g |- con),
        M2 : (g |- eterm),
        Dequiv : (g |- cn-equiv C1 C2 t),
        Dmap : (g |- map C1 M1),
        Dmap1 : (g |- map C2 M2)
      | map : [g |- map (tag C1) (eapp (econst const/tag) M1)],
        map1 : [g |- map (tag C2) (eapp (econst const/tag) M2)],
        equiv : [g |- cn-equiv (tag C1) (tag C2) t]
      ; split map-equiv'' [g |- Dmap] [g |- Dmap1] [g |- Dequiv] [g |- tmap/t] as
        case map-equiv''/i:
        { g : map-bind,
          C1 : (g |- con),
          M1 : (g |- eterm),
          C2 : (g |- con),
          M2 : (g |- eterm),
          Dequiv : (g |- cn-equiv C1 C2 t),
          Dmap : (g |- map C1 M1),
          Dmap1 : (g |- map C2 M2),
          Dequiv1 : (g |- equiv M1 M2 et)
        | map : [g |- map (tag C1) (eapp (econst const/tag) M1)],
          map1 : [g |- map (tag C2) (eapp (econst const/tag) M2)],
          equiv : [g |- cn-equiv (tag C1) (tag C2) t]
        ; solve
            [g |-
               map-equiv'/i _
               tmap/t
               (equiv/app (equiv/reflex (eof/const (ekof/i ckof/tag
                                                   (etopen/pi etopen/t
                                                   etp-skel/t
                                                   (\l1. \l2. \l3. etopen/t)))
                                        (ewf/pi ewf/t (\l1. \l2. ewf/t))))
               Dequiv1)]
        }
      }
    }
  }
  case cn-equiv/ref:
  { g : map-bind,
    C1 : (g |- con),
    M : (g |- eterm),
    C2 : (g |- con),
    N : (g |- eterm),
    Dequiv : (g |- cn-equiv C1 C2 t)
  | map : [g |- map (ref C1) M],
    map1 : [g |- map (ref C2) N],
    equiv : [g |- cn-equiv (ref C1) (ref C2) t]
  ; split map as
    case map/ref:
    { g : map-bind,
      C1 : (g |- con),
      M1 : (g |- eterm),
      C2 : (g |- con),
      N : (g |- eterm),
      Dequiv : (g |- cn-equiv C1 C2 t),
      Dmap : (g |- map C1 M1)
    | map : [g |- map (ref C1) (eapp (econst const/ref) M1)],
      map1 : [g |- map (ref C2) N],
      equiv : [g |- cn-equiv (ref C1) (ref C2) t]
    ; split map1 as
      case map/ref:
      { g : map-bind,
        C1 : (g |- con),
        M1 : (g |- eterm),
        C2 : (g |- con),
        M2 : (g |- eterm),
        Dequiv : (g |- cn-equiv C1 C2 t),
        Dmap : (g |- map C1 M1),
        Dmap1 : (g |- map C2 M2)
      | map : [g |- map (ref C1) (eapp (econst const/ref) M1)],
        map1 : [g |- map (ref C2) (eapp (econst const/ref) M2)],
        equiv : [g |- cn-equiv (ref C1) (ref C2) t]
      ; split map-equiv'' [g |- Dmap] [g |- Dmap1] [g |- Dequiv] [g |- tmap/t] as
        case map-equiv''/i:
        { g : map-bind,
          C1 : (g |- con),
          M1 : (g |- eterm),
          C2 : (g |- con),
          M2 : (g |- eterm),
          Dequiv : (g |- cn-equiv C1 C2 t),
          Dmap : (g |- map C1 M1),
          Dmap1 : (g |- map C2 M2),
          Dequiv1 : (g |- equiv M1 M2 et)
        | map : [g |- map (ref C1) (eapp (econst const/ref) M1)],
          map1 : [g |- map (ref C2) (eapp (econst const/ref) M2)],
          equiv : [g |- cn-equiv (ref C1) (ref C2) t]
        ; solve
            [g |-
               map-equiv'/i _
               tmap/t
               (equiv/app (equiv/reflex (eof/const (ekof/i ckof/ref
                                                   (etopen/pi etopen/t
                                                   etp-skel/t
                                                   (\l1. \l2. \l3. etopen/t)))
                                        (ewf/pi ewf/t (\l1. \l2. ewf/t))))
               Dequiv1)]
        }
      }
    }
  }
  case cn-equiv/plus:
  { g : map-bind,
    C1 : (g |- con),
    C3 : (g |- con),
    M : (g |- eterm),
    C2 : (g |- con),
    C4 : (g |- con),
    N : (g |- eterm),
    Dequiv : (g |- cn-equiv C1 C2 t),
    Dequiv1 : (g |- cn-equiv C3 C4 t)
  | map : [g |- map (plus C1 C3) M],
    map1 : [g |- map (plus C2 C4) N],
    equiv : [g |- cn-equiv (plus C1 C3) (plus C2 C4) t]
  ; split map as
    case map/plus:
    { g : map-bind,
      C1 : (g |- con),
      C3 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      C2 : (g |- con),
      C4 : (g |- con),
      N : (g |- eterm),
      Dequiv : (g |- cn-equiv C1 C2 t),
      Dequiv1 : (g |- cn-equiv C3 C4 t),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C3 M2)
    | map : [g |- map (plus C1 C3) (eapp (eapp (econst const/plus) M1) M2)],
      map1 : [g |- map (plus C2 C4) N],
      equiv : [g |- cn-equiv (plus C1 C3) (plus C2 C4) t]
    ; split map1 as
      case map/plus:
      { g : map-bind,
        C1 : (g |- con),
        C3 : (g |- con),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        C2 : (g |- con),
        C4 : (g |- con),
        M3 : (g |- eterm),
        M4 : (g |- eterm),
        Dequiv : (g |- cn-equiv C1 C2 t),
        Dequiv1 : (g |- cn-equiv C3 C4 t),
        Dmap : (g |- map C1 M1),
        Dmap1 : (g |- map C3 M2),
        Dmap2 : (g |- map C2 M3),
        Dmap3 : (g |- map C4 M4)
      | map : [g |- map (plus C1 C3) (eapp (eapp (econst const/plus) M1) M2)],
        map1 :
          [g |- map (plus C2 C4) (eapp (eapp (econst const/plus) M3) M4)],
        equiv : [g |- cn-equiv (plus C1 C3) (plus C2 C4) t]
      ; split map-equiv'' [g |- Dmap] [g |- Dmap2] [g |- Dequiv] [g |- tmap/t] as
        case map-equiv''/i:
        { g : map-bind,
          C1 : (g |- con),
          C3 : (g |- con),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          C2 : (g |- con),
          C4 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dequiv : (g |- cn-equiv C1 C2 t),
          Dequiv1 : (g |- cn-equiv C3 C4 t),
          Dmap : (g |- map C1 M1),
          Dmap1 : (g |- map C3 M2),
          Dmap2 : (g |- map C2 M3),
          Dmap3 : (g |- map C4 M4),
          Dequiv2 : (g |- equiv M1 M3 et)
        | map :
            [g |- map (plus C1 C3) (eapp (eapp (econst const/plus) M1) M2)],
          map1 :
            [g |- map (plus C2 C4) (eapp (eapp (econst const/plus) M3) M4)],
          equiv : [g |- cn-equiv (plus C1 C3) (plus C2 C4) t]
        ; split
          map-equiv'' [g |- Dmap1] [g |- Dmap3] [g |- Dequiv1] [g |- tmap/t] as
          case map-equiv''/i:
          { g : map-bind,
            C1 : (g |- con),
            C3 : (g |- con),
            M1 : (g |- eterm),
            M2 : (g |- eterm),
            C2 : (g |- con),
            C4 : (g |- con),
            M3 : (g |- eterm),
            M4 : (g |- eterm),
            Dequiv : (g |- cn-equiv C1 C2 t),
            Dequiv1 : (g |- cn-equiv C3 C4 t),
            Dmap : (g |- map C1 M1),
            Dmap1 : (g |- map C3 M2),
            Dmap2 : (g |- map C2 M3),
            Dmap3 : (g |- map C4 M4),
            Dequiv2 : (g |- equiv M1 M3 et),
            Dequiv3 : (g |- equiv M2 M4 et)
          | map :
              [g |- map (plus C1 C3) (eapp (eapp (econst const/plus) M1) M2)],
            map1 :
              [g |- map (plus C2 C4) (eapp (eapp (econst const/plus) M3) M4)],
            equiv : [g |- cn-equiv (plus C1 C3) (plus C2 C4) t]
          ; solve
              [g |-
                 map-equiv'/i _
                 tmap/t
                 (equiv/app (equiv/app (equiv/reflex (eof/const (ekof/i
                                                                ckof/plus
                                                                (etopen/pi
                                                                etopen/t
                                                                etp-skel/t
                                                                (\l1.
                                                                   \l2.
                                                                    \l3.
                                                                    etopen/pi
                                                                    etopen/t
                                                                    etp-skel/t
                                                                    (
                                                                    \l4.
                                                                    \l5.
                                                                    \l6.
                                                                    etopen/t))))
                                                     (ewf/pi ewf/t
                                                     (\l1.
                                                        \l2.
                                                          ewf/pi ewf/t
                                                          (\l3. \l4. ewf/t)))))
                            Dequiv2)
                 Dequiv3)]
          }
        }
      }
    }
  }
  case cn-equiv/arrow:
  { g : map-bind,
    C1 : (g |- con),
    C3 : (g |- con),
    M : (g |- eterm),
    C2 : (g |- con),
    C4 : (g |- con),
    N : (g |- eterm),
    Dequiv : (g |- cn-equiv C1 C2 t),
    Dequiv1 : (g |- cn-equiv C3 C4 t)
  | map : [g |- map (arrow C1 C3) M],
    map1 : [g |- map (arrow C2 C4) N],
    equiv : [g |- cn-equiv (arrow C1 C3) (arrow C2 C4) t]
  ; split map as
    case map/arrow:
    { g : map-bind,
      C1 : (g |- con),
      C3 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      C2 : (g |- con),
      C4 : (g |- con),
      N : (g |- eterm),
      Dequiv : (g |- cn-equiv C1 C2 t),
      Dequiv1 : (g |- cn-equiv C3 C4 t),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C3 M2)
    | map : [g |- map (arrow C1 C3) (eapp (eapp (econst const/arrow) M1) M2)],
      map1 : [g |- map (arrow C2 C4) N],
      equiv : [g |- cn-equiv (arrow C1 C3) (arrow C2 C4) t]
    ; split map1 as
      case map/arrow:
      { g : map-bind,
        C1 : (g |- con),
        C3 : (g |- con),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        C2 : (g |- con),
        C4 : (g |- con),
        M3 : (g |- eterm),
        M4 : (g |- eterm),
        Dequiv : (g |- cn-equiv C1 C2 t),
        Dequiv1 : (g |- cn-equiv C3 C4 t),
        Dmap : (g |- map C1 M1),
        Dmap1 : (g |- map C3 M2),
        Dmap2 : (g |- map C2 M3),
        Dmap3 : (g |- map C4 M4)
      | map :
          [g |- map (arrow C1 C3) (eapp (eapp (econst const/arrow) M1) M2)],
        map1 :
          [g |- map (arrow C2 C4) (eapp (eapp (econst const/arrow) M3) M4)],
        equiv : [g |- cn-equiv (arrow C1 C3) (arrow C2 C4) t]
      ; split map-equiv'' [g |- Dmap] [g |- Dmap2] [g |- Dequiv] [g |- tmap/t] as
        case map-equiv''/i:
        { g : map-bind,
          C1 : (g |- con),
          C3 : (g |- con),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          C2 : (g |- con),
          C4 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dequiv : (g |- cn-equiv C1 C2 t),
          Dequiv1 : (g |- cn-equiv C3 C4 t),
          Dmap : (g |- map C1 M1),
          Dmap1 : (g |- map C3 M2),
          Dmap2 : (g |- map C2 M3),
          Dmap3 : (g |- map C4 M4),
          Dequiv2 : (g |- equiv M1 M3 et)
        | map :
            [g |- map (arrow C1 C3) (eapp (eapp (econst const/arrow) M1) M2)],
          map1 :
            [g |- map (arrow C2 C4) (eapp (eapp (econst const/arrow) M3) M4)],
          equiv : [g |- cn-equiv (arrow C1 C3) (arrow C2 C4) t]
        ; split
          map-equiv'' [g |- Dmap1] [g |- Dmap3] [g |- Dequiv1] [g |- tmap/t] as
          case map-equiv''/i:
          { g : map-bind,
            C1 : (g |- con),
            C3 : (g |- con),
            M1 : (g |- eterm),
            M2 : (g |- eterm),
            C2 : (g |- con),
            C4 : (g |- con),
            M3 : (g |- eterm),
            M4 : (g |- eterm),
            Dequiv : (g |- cn-equiv C1 C2 t),
            Dequiv1 : (g |- cn-equiv C3 C4 t),
            Dmap : (g |- map C1 M1),
            Dmap1 : (g |- map C3 M2),
            Dmap2 : (g |- map C2 M3),
            Dmap3 : (g |- map C4 M4),
            Dequiv2 : (g |- equiv M1 M3 et),
            Dequiv3 : (g |- equiv M2 M4 et)
          | map :
              [g |-
                 map (arrow C1 C3) (eapp (eapp (econst const/arrow) M1) M2)],
            map1 :
              [g |-
                 map (arrow C2 C4) (eapp (eapp (econst const/arrow) M3) M4)],
            equiv : [g |- cn-equiv (arrow C1 C3) (arrow C2 C4) t]
          ; solve
              [g |-
                 map-equiv'/i _
                 tmap/t
                 (equiv/app (equiv/app (equiv/reflex (eof/const (ekof/i
                                                                ckof/arrow
                                                                (etopen/pi
                                                                etopen/t
                                                                etp-skel/t
                                                                (\l1.
                                                                   \l2.
                                                                    \l3.
                                                                    etopen/pi
                                                                    etopen/t
                                                                    etp-skel/t
                                                                    (
                                                                    \l4.
                                                                    \l5.
                                                                    \l6.
                                                                    etopen/t))))
                                                     (ewf/pi ewf/t
                                                     (\l1.
                                                        \l2.
                                                          ewf/pi ewf/t
                                                          (\l3. \l4. ewf/t)))))
                            Dequiv2)
                 Dequiv3)]
          }
        }
      }
    }
  }
  case cn-equiv/prod:
  { g : map-bind,
    C1 : (g |- con),
    C3 : (g |- con),
    M : (g |- eterm),
    C2 : (g |- con),
    C4 : (g |- con),
    N : (g |- eterm),
    Dequiv : (g |- cn-equiv C1 C2 t),
    Dequiv1 : (g |- cn-equiv C3 C4 t)
  | map : [g |- map (prod C1 C3) M],
    map1 : [g |- map (prod C2 C4) N],
    equiv : [g |- cn-equiv (prod C1 C3) (prod C2 C4) t]
  ; split map as
    case map/prod:
    { g : map-bind,
      C1 : (g |- con),
      C3 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      C2 : (g |- con),
      C4 : (g |- con),
      N : (g |- eterm),
      Dequiv : (g |- cn-equiv C1 C2 t),
      Dequiv1 : (g |- cn-equiv C3 C4 t),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C3 M2)
    | map : [g |- map (prod C1 C3) (eapp (eapp (econst const/prod) M1) M2)],
      map1 : [g |- map (prod C2 C4) N],
      equiv : [g |- cn-equiv (prod C1 C3) (prod C2 C4) t]
    ; split map1 as
      case map/prod:
      { g : map-bind,
        C1 : (g |- con),
        C3 : (g |- con),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        C2 : (g |- con),
        C4 : (g |- con),
        M3 : (g |- eterm),
        M4 : (g |- eterm),
        Dequiv : (g |- cn-equiv C1 C2 t),
        Dequiv1 : (g |- cn-equiv C3 C4 t),
        Dmap : (g |- map C1 M1),
        Dmap1 : (g |- map C3 M2),
        Dmap2 : (g |- map C2 M3),
        Dmap3 : (g |- map C4 M4)
      | map : [g |- map (prod C1 C3) (eapp (eapp (econst const/prod) M1) M2)],
        map1 :
          [g |- map (prod C2 C4) (eapp (eapp (econst const/prod) M3) M4)],
        equiv : [g |- cn-equiv (prod C1 C3) (prod C2 C4) t]
      ; split map-equiv'' [g |- Dmap] [g |- Dmap2] [g |- Dequiv] [g |- tmap/t] as
        case map-equiv''/i:
        { g : map-bind,
          C1 : (g |- con),
          C3 : (g |- con),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          C2 : (g |- con),
          C4 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dequiv : (g |- cn-equiv C1 C2 t),
          Dequiv1 : (g |- cn-equiv C3 C4 t),
          Dmap : (g |- map C1 M1),
          Dmap1 : (g |- map C3 M2),
          Dmap2 : (g |- map C2 M3),
          Dmap3 : (g |- map C4 M4),
          Dequiv2 : (g |- equiv M1 M3 et)
        | map :
            [g |- map (prod C1 C3) (eapp (eapp (econst const/prod) M1) M2)],
          map1 :
            [g |- map (prod C2 C4) (eapp (eapp (econst const/prod) M3) M4)],
          equiv : [g |- cn-equiv (prod C1 C3) (prod C2 C4) t]
        ; split
          map-equiv'' [g |- Dmap1] [g |- Dmap3] [g |- Dequiv1] [g |- tmap/t] as
          case map-equiv''/i:
          { g : map-bind,
            C1 : (g |- con),
            C3 : (g |- con),
            M1 : (g |- eterm),
            M2 : (g |- eterm),
            C2 : (g |- con),
            C4 : (g |- con),
            M3 : (g |- eterm),
            M4 : (g |- eterm),
            Dequiv : (g |- cn-equiv C1 C2 t),
            Dequiv1 : (g |- cn-equiv C3 C4 t),
            Dmap : (g |- map C1 M1),
            Dmap1 : (g |- map C3 M2),
            Dmap2 : (g |- map C2 M3),
            Dmap3 : (g |- map C4 M4),
            Dequiv2 : (g |- equiv M1 M3 et),
            Dequiv3 : (g |- equiv M2 M4 et)
          | map :
              [g |- map (prod C1 C3) (eapp (eapp (econst const/prod) M1) M2)],
            map1 :
              [g |- map (prod C2 C4) (eapp (eapp (econst const/prod) M3) M4)],
            equiv : [g |- cn-equiv (prod C1 C3) (prod C2 C4) t]
          ; solve
              [g |-
                 map-equiv'/i _
                 tmap/t
                 (equiv/app (equiv/app (equiv/reflex (eof/const (ekof/i
                                                                ckof/prod
                                                                (etopen/pi
                                                                etopen/t
                                                                etp-skel/t
                                                                (\l1.
                                                                   \l2.
                                                                    \l3.
                                                                    etopen/pi
                                                                    etopen/t
                                                                    etp-skel/t
                                                                    (
                                                                    \l4.
                                                                    \l5.
                                                                    \l6.
                                                                    etopen/t))))
                                                     (ewf/pi ewf/t
                                                     (\l1.
                                                        \l2.
                                                          ewf/pi ewf/t
                                                          (\l3. \l4. ewf/t)))))
                            Dequiv2)
                 Dequiv3)]
          }
        }
      }
    }
  }
  case cn-equiv/app:
  { g : map-bind,
    C1 : (g |- con),
    C3 : (g |- con),
    M : (g |- eterm),
    C2 : (g |- con),
    C4 : (g |- con),
    N : (g |- eterm),
    K2 : (g, a30 : con |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C1 C2 (pi K1 (\x363. K2))),
    Dequiv1 : (g |- cn-equiv C3 C4 K1)
  | map : [g |- map (app C1 C3) M],
    map1 : [g |- map (app C2 C4) N],
    equiv : [g |- cn-equiv (app C1 C3) (app C2 C4) (K2[.., C3])]
  ; split map as
    case map/app:
    { g : map-bind,
      C1 : (g |- con),
      C3 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      C2 : (g |- con),
      C4 : (g |- con),
      N : (g |- eterm),
      K2 : (g, a30 : con |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- cn-equiv C1 C2 (pi K1 (\x363. K2))),
      Dequiv1 : (g |- cn-equiv C3 C4 K1),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C3 M2)
    | map : [g |- map (app C1 C3) (eapp M1 M2)],
      map1 : [g |- map (app C2 C4) N],
      equiv : [g |- cn-equiv (app C1 C3) (app C2 C4) (K2[.., C3])]
    ; split map1 as
      case map/app:
      { g : map-bind,
        C1 : (g |- con),
        C3 : (g |- con),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        C2 : (g |- con),
        C4 : (g |- con),
        M3 : (g |- eterm),
        M4 : (g |- eterm),
        K2 : (g, a30 : con |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- cn-equiv C1 C2 (pi K1 (\x363. K2))),
        Dequiv1 : (g |- cn-equiv C3 C4 K1),
        Dmap : (g |- map C1 M1),
        Dmap1 : (g |- map C3 M2),
        Dmap2 : (g |- map C2 M3),
        Dmap3 : (g |- map C4 M4)
      | map : [g |- map (app C1 C3) (eapp M1 M2)],
        map1 : [g |- map (app C2 C4) (eapp M3 M4)],
        equiv : [g |- cn-equiv (app C1 C3) (app C2 C4) (K2[.., C3])]
      ; split map-equiv' [g |- Dmap] [g |- Dmap2] [g |- Dequiv] as
        case map-equiv'/i:
        { g : map-bind,
          C1 : (g |- con),
          C3 : (g |- con),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          C2 : (g |- con),
          C4 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          K2 : (g, a30 : con |- kind),
          K1 : (g |- kind),
          Dequiv : (g |- cn-equiv C1 C2 (pi K1 (\x363. K2))),
          Dequiv1 : (g |- cn-equiv C3 C4 K1),
          Dmap : (g |- map C1 M1),
          Dmap1 : (g |- map C3 M2),
          Dmap2 : (g |- map C2 M3),
          Dmap3 : (g |- map C4 M4),
          A : (g |- etp),
          Dtmap : (g |- tmap (pi K1 (\x363. K2)) A),
          Dequiv2 : (g |- equiv M1 M3 A)
        | map : [g |- map (app C1 C3) (eapp M1 M2)],
          map1 : [g |- map (app C2 C4) (eapp M3 M4)],
          equiv : [g |- cn-equiv (app C1 C3) (app C2 C4) (K2[.., C3])]
        ; split [g |- Dtmap] as
          case tmap/pi:
          { g : map-bind,
            C1 : (g |- con),
            C3 : (g |- con),
            M1 : (g |- eterm),
            M2 : (g |- eterm),
            C2 : (g |- con),
            C4 : (g |- con),
            M3 : (g |- eterm),
            M4 : (g |- eterm),
            K2 : (g, a30 : con |- kind),
            K1 : (g |- kind),
            Dequiv : (g |- cn-equiv C1 C2 (pi K1 (\x363. K2))),
            Dequiv1 : (g |- cn-equiv C3 C4 K1),
            Dmap : (g |- map C1 M1),
            Dmap1 : (g |- map C3 M2),
            Dmap2 : (g |- map C2 M3),
            Dmap3 : (g |- map C4 M4),
            A1 : (g |- etp),
            A2 : (g, y961 : eterm |- etp),
            Dtmap1 : (g |- tmap K1 A1),
            Dtmap2 :
              (g, a : con, x : eterm, z960 : map a x |-
                 tmap (K2[.., a]) (A2[.., x])),
            Dequiv2 : (g |- equiv M1 M3 (epi A1 (\y148. A2)))
          | map : [g |- map (app C1 C3) (eapp M1 M2)],
            map1 : [g |- map (app C2 C4) (eapp M3 M4)],
            equiv : [g |- cn-equiv (app C1 C3) (app C2 C4) (K2[.., C3])]
          ; split map-equiv'' [g |- Dmap1] [g |- Dmap3] [g |- Dequiv1] [g |- Dtmap1] as
            case map-equiv''/i:
            { g : map-bind,
              C1 : (g |- con),
              C3 : (g |- con),
              M1 : (g |- eterm),
              M2 : (g |- eterm),
              C2 : (g |- con),
              C4 : (g |- con),
              M3 : (g |- eterm),
              M4 : (g |- eterm),
              K2 : (g, a30 : con |- kind),
              K1 : (g |- kind),
              Dequiv : (g |- cn-equiv C1 C2 (pi K1 (\x363. K2))),
              Dequiv1 : (g |- cn-equiv C3 C4 K1),
              Dmap : (g |- map C1 M1),
              Dmap1 : (g |- map C3 M2),
              Dmap2 : (g |- map C2 M3),
              Dmap3 : (g |- map C4 M4),
              A1 : (g |- etp),
              A2 : (g, y961 : eterm |- etp),
              Dtmap1 : (g |- tmap K1 A1),
              Dtmap2 :
                (g, a : con, x : eterm, z960 : map a x |-
                   tmap (K2[.., a]) (A2[.., x])),
              Dequiv2 : (g |- equiv M1 M3 (epi A1 (\y148. A2))),
              Dequiv3 : (g |- equiv M2 M4 A1)
            | map : [g |- map (app C1 C3) (eapp M1 M2)],
              map1 : [g |- map (app C2 C4) (eapp M3 M4)],
              equiv : [g |- cn-equiv (app C1 C3) (app C2 C4) (K2[.., C3])]
            ; solve
                [g |-
                   map-equiv'/i _
                   (Dtmap2[.., C3, M2, Dmap1]) (equiv/app Dequiv2 Dequiv3)]
            }
          }
        }
      }
    }
  }
  case cn-equiv/lam:
  { g : map-bind,
    K1 : (g |- kind),
    C1 : (g, a27 : con |- con),
    M : (g |- eterm),
    K2 : (g |- kind),
    C2 : (g, a28 : con |- con),
    N : (g |- eterm),
    K3 : (g, a29 : con |- kind),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, y449 : cn-of a (K1[..]) |-
         cn-equiv (C1[.., a]) (C2[.., a]) (K3[.., a]))
  | map : [g |- map (lam K1 (\z366. C1)) M],
    map1 : [g |- map (lam K2 (\z366. C2)) N],
    equiv :
      [g |-
         cn-equiv
           (lam K1 (\z366. C1)) (lam K2 (\z366. C2)) (pi K1 (\x363. K3))]
  ; split map as
    case map/lam:
    { g : map-bind,
      K1 : (g |- kind),
      C1 : (g, a27 : con |- con),
      A : (g |- etp),
      M1 : (g, y1256 : eterm |- eterm),
      K2 : (g |- kind),
      C2 : (g, a28 : con |- con),
      N : (g |- eterm),
      K3 : (g, a29 : con |- kind),
      Dequiv : (g |- kd-equiv K1 K2),
      Dequiv1 :
        (g, a : con, y449 : cn-of a (K1[..]) |-
           cn-equiv (C1[.., a]) (C2[.., a]) (K3[.., a])),
      Dtmap : (g |- tmap K1 A),
      Dmap :
        (g, a : con, x : eterm, z1255 : map a x |-
           map (C1[.., a]) (M1[.., x]))
    | map : [g |- map (lam K1 (\y525. C1)) (elam A (\z150. M1))],
      map1 : [g |- map (lam K2 (\y525. C2)) N],
      equiv :
        [g |-
           cn-equiv
             (lam K1 (\y525. C1)) (lam K2 (\y525. C2)) (pi K1 (\z521. K3))]
    ; split map1 as
      case map/lam:
      { g : map-bind,
        K1 : (g |- kind),
        C1 : (g, a27 : con |- con),
        A : (g |- etp),
        M1 : (g, y1256 : eterm |- eterm),
        K2 : (g |- kind),
        C2 : (g, a28 : con |- con),
        A1 : (g |- etp),
        M2 : (g, y1256 : eterm |- eterm),
        K3 : (g, a29 : con |- kind),
        Dequiv : (g |- kd-equiv K1 K2),
        Dequiv1 :
          (g, a : con, y449 : cn-of a (K1[..]) |-
             cn-equiv (C1[.., a]) (C2[.., a]) (K3[.., a])),
        Dtmap : (g |- tmap K1 A),
        Dmap :
          (g, a : con, x : eterm, z1255 : map a x |-
             map (C1[.., a]) (M1[.., x])),
        Dtmap1 : (g |- tmap K2 A1),
        Dmap1 :
          (g, a : con, x : eterm, z1255 : map a x |-
             map (C2[.., a]) (M2[.., x]))
      | map : [g |- map (lam K1 (\y525. C1)) (elam A (\z150. M1))],
        map1 : [g |- map (lam K2 (\y525. C2)) (elam A1 (\z150. M2))],
        equiv :
          [g |-
             cn-equiv
               (lam K1 (\y525. C1)) (lam K2 (\y525. C2)) (pi K1 (\z521. K3))]
      ; split map-tequiv [g |- Dequiv] [g |- Dtmap] [g |- Dtmap1] as
        case map-tequiv/i:
        { g : map-bind,
          K1 : (g |- kind),
          C1 : (g, a27 : con |- con),
          A : (g |- etp),
          M1 : (g, y1256 : eterm |- eterm),
          K2 : (g |- kind),
          C2 : (g, a28 : con |- con),
          A1 : (g |- etp),
          M2 : (g, y1256 : eterm |- eterm),
          K3 : (g, a29 : con |- kind),
          Dequiv : (g |- kd-equiv K1 K2),
          Dequiv1 :
            (g, a : con, y449 : cn-of a (K1[..]) |-
               cn-equiv (C1[.., a]) (C2[.., a]) (K3[.., a])),
          Dtmap : (g |- tmap K1 A),
          Dmap :
            (g, a : con, x : eterm, z1255 : map a x |-
               map (C1[.., a]) (M1[.., x])),
          Dtmap1 : (g |- tmap K2 A1),
          Dmap1 :
            (g, a : con, x : eterm, z1255 : map a x |-
               map (C2[.., a]) (M2[.., x])),
          Dtequiv : (g |- tequiv A A1)
        | map : [g |- map (lam K1 (\y525. C1)) (elam A (\z150. M1))],
          map1 : [g |- map (lam K2 (\y525. C2)) (elam A1 (\z150. M2))],
          equiv :
            [g |-
               cn-equiv
                 (lam K1 (\y525. C1))
                 (lam K2 (\y525. C2)) (pi K1 (\z521. K3))]
        ; split
map-equiv'
  [g,
   b :
     block (
       x : eterm,
       dx : eof x (A[..]),
       a : con,
       da : cn-of a (K1[..]),
       at : map a x) |- Dmap[.., b.3, b.1, b.5]]
  [g,
   b :
     block (
       x : eterm,
       dx : eof x (A[..]),
       a : con,
       da : cn-of a (K1[..]),
       at : map a x) |- Dmap1[.., b.3, b.1, b.5]]
  [g,
   b :
     block (
       x : eterm,
       dx : eof x (A[..]),
       a : con,
       da : cn-of a (K1[..]),
       at : map a x) |- Dequiv1[.., b.3, b.4]] as
          case map-equiv'/i:
          { g : map-bind,
            K1 : (g |- kind),
            C1 : (g, a27 : con |- con),
            A : (g |- etp),
            M3 : (g, x : eterm |- eterm),
            K2 : (g |- kind),
            C2 : (g, a28 : con |- con),
            A1 : (g |- etp),
            M4 : (g, x : eterm |- eterm),
            K4 : (g, a : con |- kind),
            Dequiv : (g |- kd-equiv K1 K2),
            Dequiv1 :
              (g, a : con, y449 : cn-of a (K1[..]) |-
                 cn-equiv (C1[.., a]) (C2[.., a]) (K4[.., a])),
            Dtmap : (g |- tmap K1 A),
            Dmap :
              (g, a : con, x : eterm, z1255 : map a x |-
                 map (C1[.., a]) (M3[.., x])),
            Dtmap1 : (g |- tmap K2 A1),
            Dmap1 :
              (g, a : con, x : eterm, z1255 : map a x |-
                 map (C2[.., a]) (M4[.., x])),
            Dtequiv : (g |- tequiv A A1),
            A2 : (g, x : eterm |- etp),
            Dtmap2 :
              (g, x : eterm, a : con, z1441 : map a x |-
                 tmap (K4[.., a]) (A2[.., x])),
            Dequiv2 :
              (g, x : eterm, dx : eof x (A[..]) |-
                 equiv (M3[.., x]) (M4[.., x]) (A2[.., x]))
          | map : [g |- map (lam K1 (\y525. C1)) (elam A (\z150. M3))],
            map1 : [g |- map (lam K2 (\y525. C2)) (elam A1 (\z150. M4))],
            equiv :
              [g |-
                 cn-equiv
                   (lam K1 (\y525. C1))
                   (lam K2 (\y525. C2)) (pi K1 (\z521. K4))]
          ; solve
              [g |-
                 map-equiv'/i _
                 (tmap/pi Dtmap (\a. \x. \at. Dtmap2[.., x, a, at]))
                 (equiv/lam Dtequiv (\x. \dx. Dequiv2))]
          }
        }
      }
    }
  }
  case cn-equiv/pi2:
  { g : map-bind,
    C1 : (g |- con),
    M : (g |- eterm),
    C2 : (g |- con),
    N : (g |- eterm),
    K2 : (g, a26 : con |- kind),
    K1 : (g |- kind),
    Dequiv : (g |- cn-equiv C1 C2 (sigma K1 (\x364. K2)))
  | map : [g |- map (pi2 C1) M],
    map1 : [g |- map (pi2 C2) N],
    equiv : [g |- cn-equiv (pi2 C1) (pi2 C2) (K2[.., pi1 C1])]
  ; split map as
    case map/pi2:
    { g : map-bind,
      C1 : (g |- con),
      M1 : (g |- eterm),
      C2 : (g |- con),
      N : (g |- eterm),
      K2 : (g, a26 : con |- kind),
      K1 : (g |- kind),
      Dequiv : (g |- cn-equiv C1 C2 (sigma K1 (\x364. K2))),
      Dmap : (g |- map C1 M1)
    | map : [g |- map (pi2 C1) (epi2 M1)],
      map1 : [g |- map (pi2 C2) N],
      equiv : [g |- cn-equiv (pi2 C1) (pi2 C2) (K2[.., pi1 C1])]
    ; split map1 as
      case map/pi2:
      { g : map-bind,
        C1 : (g |- con),
        M1 : (g |- eterm),
        C2 : (g |- con),
        M2 : (g |- eterm),
        K2 : (g, a26 : con |- kind),
        K1 : (g |- kind),
        Dequiv : (g |- cn-equiv C1 C2 (sigma K1 (\x364. K2))),
        Dmap : (g |- map C1 M1),
        Dmap1 : (g |- map C2 M2)
      | map : [g |- map (pi2 C1) (epi2 M1)],
        map1 : [g |- map (pi2 C2) (epi2 M2)],
        equiv : [g |- cn-equiv (pi2 C1) (pi2 C2) (K2[.., pi1 C1])]
      ; split map-equiv' [g |- Dmap] [g |- Dmap1] [g |- Dequiv] as
        case map-equiv'/i:
        { g : map-bind,
          C1 : (g |- con),
          M1 : (g |- eterm),
          C2 : (g |- con),
          M2 : (g |- eterm),
          K2 : (g, a26 : con |- kind),
          K1 : (g |- kind),
          Dequiv : (g |- cn-equiv C1 C2 (sigma K1 (\x364. K2))),
          Dmap : (g |- map C1 M1),
          Dmap1 : (g |- map C2 M2),
          A : (g |- etp),
          Dtmap : (g |- tmap (sigma K1 (\x364. K2)) A),
          Dequiv1 : (g |- equiv M1 M2 A)
        | map : [g |- map (pi2 C1) (epi2 M1)],
          map1 : [g |- map (pi2 C2) (epi2 M2)],
          equiv : [g |- cn-equiv (pi2 C1) (pi2 C2) (K2[.., pi1 C1])]
        ; split [g |- Dtmap] as
          case tmap/sigma:
          { g : map-bind,
            C1 : (g |- con),
            M1 : (g |- eterm),
            C2 : (g |- con),
            M2 : (g |- eterm),
            K2 : (g, a26 : con |- kind),
            K1 : (g |- kind),
            Dequiv : (g |- cn-equiv C1 C2 (sigma K1 (\x364. K2))),
            Dmap : (g |- map C1 M1),
            Dmap1 : (g |- map C2 M2),
            A1 : (g |- etp),
            A2 : (g, x962 : eterm |- etp),
            Dtmap1 : (g |- tmap K1 A1),
            Dtmap2 :
              (g, a : con, x : eterm, y962 : map a x |-
                 tmap (K2[.., a]) (A2[.., x])),
            Dequiv1 : (g |- equiv M1 M2 (esigma A1 (\y149. A2)))
          | map : [g |- map (pi2 C1) (epi2 M1)],
            map1 : [g |- map (pi2 C2) (epi2 M2)],
            equiv : [g |- cn-equiv (pi2 C1) (pi2 C2) (K2[.., pi1 C1])]
          ; solve
              [g |-
                 map-equiv'/i _
                 (Dtmap2[.., pi1 C1, epi1 M1, map/pi1 Dmap]) (equiv/pi2 Dequiv1)]
          }
        }
      }
    }
  }
  case cn-equiv/pi1:
  { g : map-bind,
    C1 : (g |- con),
    M : (g |- eterm),
    C2 : (g |- con),
    N : (g |- eterm),
    K : (g |- kind),
    K2 : (g, a25 : con |- kind),
    Dequiv : (g |- cn-equiv C1 C2 (sigma K (\x364. K2)))
  | map : [g |- map (pi1 C1) M],
    map1 : [g |- map (pi1 C2) N],
    equiv : [g |- cn-equiv (pi1 C1) (pi1 C2) K]
  ; split map as
    case map/pi1:
    { g : map-bind,
      C1 : (g |- con),
      M1 : (g |- eterm),
      C2 : (g |- con),
      N : (g |- eterm),
      K : (g |- kind),
      K2 : (g, a25 : con |- kind),
      Dequiv : (g |- cn-equiv C1 C2 (sigma K (\x364. K2))),
      Dmap : (g |- map C1 M1)
    | map : [g |- map (pi1 C1) (epi1 M1)],
      map1 : [g |- map (pi1 C2) N],
      equiv : [g |- cn-equiv (pi1 C1) (pi1 C2) K]
    ; split map1 as
      case map/pi1:
      { g : map-bind,
        C1 : (g |- con),
        M1 : (g |- eterm),
        C2 : (g |- con),
        M2 : (g |- eterm),
        K : (g |- kind),
        K2 : (g, a25 : con |- kind),
        Dequiv : (g |- cn-equiv C1 C2 (sigma K (\x364. K2))),
        Dmap : (g |- map C1 M1),
        Dmap1 : (g |- map C2 M2)
      | map : [g |- map (pi1 C1) (epi1 M1)],
        map1 : [g |- map (pi1 C2) (epi1 M2)],
        equiv : [g |- cn-equiv (pi1 C1) (pi1 C2) K]
      ; split map-equiv' [g |- Dmap] [g |- Dmap1] [g |- Dequiv] as
        case map-equiv'/i:
        { g : map-bind,
          C1 : (g |- con),
          M1 : (g |- eterm),
          C2 : (g |- con),
          M2 : (g |- eterm),
          K : (g |- kind),
          K2 : (g, a25 : con |- kind),
          Dequiv : (g |- cn-equiv C1 C2 (sigma K (\x364. K2))),
          Dmap : (g |- map C1 M1),
          Dmap1 : (g |- map C2 M2),
          A : (g |- etp),
          Dtmap : (g |- tmap (sigma K (\x364. K2)) A),
          Dequiv1 : (g |- equiv M1 M2 A)
        | map : [g |- map (pi1 C1) (epi1 M1)],
          map1 : [g |- map (pi1 C2) (epi1 M2)],
          equiv : [g |- cn-equiv (pi1 C1) (pi1 C2) K]
        ; split [g |- Dtmap] as
          case tmap/sigma:
          { g : map-bind,
            C1 : (g |- con),
            M1 : (g |- eterm),
            C2 : (g |- con),
            M2 : (g |- eterm),
            K : (g |- kind),
            K2 : (g, a25 : con |- kind),
            Dequiv : (g |- cn-equiv C1 C2 (sigma K (\x364. K2))),
            Dmap : (g |- map C1 M1),
            Dmap1 : (g |- map C2 M2),
            A1 : (g |- etp),
            A2 : (g, x962 : eterm |- etp),
            Dtmap1 : (g |- tmap K A1),
            Dtmap2 :
              (g, a : con, x : eterm, y962 : map a x |-
                 tmap (K2[.., a]) (A2[.., x])),
            Dequiv1 : (g |- equiv M1 M2 (esigma A1 (\y149. A2)))
          | map : [g |- map (pi1 C1) (epi1 M1)],
            map1 : [g |- map (pi1 C2) (epi1 M2)],
            equiv : [g |- cn-equiv (pi1 C1) (pi1 C2) K]
          ; solve [g |- map-equiv'/i _ Dtmap1 (equiv/pi1 Dequiv1)]
          }
        }
      }
    }
  }
  case cn-equiv/pair:
  { g : map-bind,
    C1 : (g |- con),
    C3 : (g |- con),
    M : (g |- eterm),
    C2 : (g |- con),
    C4 : (g |- con),
    N : (g |- eterm),
    K1 : (g |- kind),
    K2 : (g, a24 : con |- kind),
    Dequiv : (g |- cn-equiv C1 C2 K1),
    Dequiv1 : (g |- cn-equiv C3 C4 (K2[.., C1])),
    Dwf : (g, a : con, x447 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | map : [g |- map (pair C1 C3) M],
    map1 : [g |- map (pair C2 C4) N],
    equiv : [g |- cn-equiv (pair C1 C3) (pair C2 C4) (sigma K1 (\x364. K2))]
  ; split map as
    case map/pair:
    { g : map-bind,
      C1 : (g |- con),
      C3 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      C2 : (g |- con),
      C4 : (g |- con),
      N : (g |- eterm),
      K1 : (g |- kind),
      K2 : (g, a24 : con |- kind),
      Dequiv : (g |- cn-equiv C1 C2 K1),
      Dequiv1 : (g |- cn-equiv C3 C4 (K2[.., C1])),
      Dwf : (g, a : con, x447 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C3 M2)
    | map : [g |- map (pair C1 C3) (epair M1 M2)],
      map1 : [g |- map (pair C2 C4) N],
      equiv :
        [g |- cn-equiv (pair C1 C3) (pair C2 C4) (sigma K1 (\x364. K2))]
    ; split map1 as
      case map/pair:
      { g : map-bind,
        C1 : (g |- con),
        C3 : (g |- con),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        C2 : (g |- con),
        C4 : (g |- con),
        M3 : (g |- eterm),
        M4 : (g |- eterm),
        K1 : (g |- kind),
        K2 : (g, a24 : con |- kind),
        Dequiv : (g |- cn-equiv C1 C2 K1),
        Dequiv1 : (g |- cn-equiv C3 C4 (K2[.., C1])),
        Dwf : (g, a : con, x447 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
        Dmap : (g |- map C1 M1),
        Dmap1 : (g |- map C3 M2),
        Dmap2 : (g |- map C2 M3),
        Dmap3 : (g |- map C4 M4)
      | map : [g |- map (pair C1 C3) (epair M1 M2)],
        map1 : [g |- map (pair C2 C4) (epair M3 M4)],
        equiv :
          [g |- cn-equiv (pair C1 C3) (pair C2 C4) (sigma K1 (\x364. K2))]
      ; split map-equiv' [g |- Dmap] [g |- Dmap2] [g |- Dequiv] as
        case map-equiv'/i:
        { g : map-bind,
          C1 : (g |- con),
          C3 : (g |- con),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          C2 : (g |- con),
          C4 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          K1 : (g |- kind),
          K2 : (g, a24 : con |- kind),
          Dequiv : (g |- cn-equiv C1 C2 K1),
          Dequiv1 : (g |- cn-equiv C3 C4 (K2[.., C1])),
          Dwf : (g, a : con, x447 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
          Dmap : (g |- map C1 M1),
          Dmap1 : (g |- map C3 M2),
          Dmap2 : (g |- map C2 M3),
          Dmap3 : (g |- map C4 M4),
          A : (g |- etp),
          Dtmap : (g |- tmap K1 A),
          Dequiv2 : (g |- equiv M1 M3 A)
        | map : [g |- map (pair C1 C3) (epair M1 M2)],
          map1 : [g |- map (pair C2 C4) (epair M3 M4)],
          equiv :
            [g |- cn-equiv (pair C1 C3) (pair C2 C4) (sigma K1 (\x364. K2))]
        ; split
          map-wf
            [g,
             b :
               block (
                 x : eterm,
                 dx : eof x (A[..]),
                 a : con,
                 da : cn-of a (K1[..]),
                 at : map a x) |- Dwf[.., b.3, b.4]] as
          case map-wf/i:
          { g : map-bind,
            C1 : (g |- con),
            C3 : (g |- con),
            M1 : (g |- eterm),
            M2 : (g |- eterm),
            C2 : (g |- con),
            C4 : (g |- con),
            M3 : (g |- eterm),
            M4 : (g |- eterm),
            K1 : (g |- kind),
            K3 : (g, a : con |- kind),
            Dequiv : (g |- cn-equiv C1 C2 K1),
            Dequiv1 : (g |- cn-equiv C3 C4 (K3[.., C1])),
            Dwf : (g, a : con, x447 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
            Dmap : (g |- map C1 M1),
            Dmap1 : (g |- map C3 M2),
            Dmap2 : (g |- map C2 M3),
            Dmap3 : (g |- map C4 M4),
            A : (g |- etp),
            Dtmap : (g |- tmap K1 A),
            Dequiv2 : (g |- equiv M1 M3 A),
            A1 : (g, x : eterm |- etp),
            Dtmap1 :
              (g, x : eterm, a : con, z5 : map a x |-
                 tmap (K3[.., a]) (A1[.., x])),
            Dwf1 : (g, x : eterm, dx : eof x (A[..]) |- ewf (A1[.., x]))
          | map : [g |- map (pair C1 C3) (epair M1 M2)],
            map1 : [g |- map (pair C2 C4) (epair M3 M4)],
            equiv :
              [g |- cn-equiv (pair C1 C3) (pair C2 C4) (sigma K1 (\x364. K3))]
          ; split
map-equiv'' [g |- Dmap1] [g |- Dmap3] [g |- Dequiv1]
  [g |- Dtmap1[.., M1, C1, Dmap]] as
            case map-equiv''/i:
            { g : map-bind,
              C1 : (g |- con),
              C3 : (g |- con),
              M1 : (g |- eterm),
              M2 : (g |- eterm),
              C2 : (g |- con),
              C4 : (g |- con),
              M3 : (g |- eterm),
              M4 : (g |- eterm),
              K1 : (g |- kind),
              K3 : (g, a : con |- kind),
              Dequiv : (g |- cn-equiv C1 C2 K1),
              Dequiv1 : (g |- cn-equiv C3 C4 (K3[.., C1])),
              Dwf :
                (g, a : con, x447 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
              Dmap : (g |- map C1 M1),
              Dmap1 : (g |- map C3 M2),
              Dmap2 : (g |- map C2 M3),
              Dmap3 : (g |- map C4 M4),
              A : (g |- etp),
              Dtmap : (g |- tmap K1 A),
              Dequiv2 : (g |- equiv M1 M3 A),
              A1 : (g, x : eterm |- etp),
              Dtmap1 :
                (g, x : eterm, a : con, z5 : map a x |-
                   tmap (K3[.., a]) (A1[.., x])),
              Dwf1 : (g, x : eterm, dx : eof x (A[..]) |- ewf (A1[.., x])),
              Dequiv3 : (g |- equiv M2 M4 (A1[.., M1]))
            | map : [g |- map (pair C1 C3) (epair M1 M2)],
              map1 : [g |- map (pair C2 C4) (epair M3 M4)],
              equiv :
                [g |-
                   cn-equiv (pair C1 C3) (pair C2 C4) (sigma K1 (\z522. K3))]
            ; solve
                [g |-
                   map-equiv'/i _
                   (tmap/sigma Dtmap (\a. \x. \at. Dtmap1[.., x, a, at]))
                   (equiv/pair Dequiv2 Dequiv3 (\x. \dx. Dwf1))]
            }
          }
        }
      }
    }
  }
  case cn-equiv/trans:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    K : (g |- kind),
    C2 : (g |- con),
    Dequiv : (g |- cn-equiv C C2 K),
    Dequiv1 : (g |- cn-equiv C2 D K)
  | map : [g |- map C M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv C D K]
  ; by map as Dmap1 unboxed;
    by map1 as Dmap3 unboxed;
    split can-map [g |- C2] as
    case can-map/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      K : (g |- kind),
      C2 : (g |- con),
      D12 : (g |- cn-equiv C C2 K),
      D23 : (g |- cn-equiv C2 D K),
      Dmap1 : (g |- map C M),
      Dmap3 : (g |- map D N),
      M1 : (g |- eterm),
      Dmap4 : (g |- map C2 M1)
    | map : [g |- map C M],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv C D K]
    ; split map-equiv' [g |- Dmap1] [g |- Dmap4] [g |- D12] as
      case map-equiv'/i:
      { g : map-bind,
        C : (g |- con),
        M : (g |- eterm),
        D : (g |- con),
        N : (g |- eterm),
        K : (g |- kind),
        C2 : (g |- con),
        D12 : (g |- cn-equiv C C2 K),
        D23 : (g |- cn-equiv C2 D K),
        Dmap1 : (g |- map C M),
        Dmap3 : (g |- map D N),
        M1 : (g |- eterm),
        Dmap2 : (g |- map C2 M1),
        A : (g |- etp),
        Dtmap : (g |- tmap K A),
        Dequiv : (g |- equiv M M1 A)
      | map : [g |- map C M],
        map1 : [g |- map D N],
        equiv : [g |- cn-equiv C D K]
      ; split map-equiv'' [g |- Dmap2] [g |- Dmap3] [g |- D23] [g |- Dtmap] as
        case map-equiv''/i:
        { g : map-bind,
          C : (g |- con),
          M : (g |- eterm),
          D : (g |- con),
          N : (g |- eterm),
          K : (g |- kind),
          C2 : (g |- con),
          D12 : (g |- cn-equiv C C2 K),
          D23 : (g |- cn-equiv C2 D K),
          Dmap1 : (g |- map C M),
          Dmap3 : (g |- map D N),
          M1 : (g |- eterm),
          Dmap2 : (g |- map C2 M1),
          A : (g |- etp),
          Dtmap : (g |- tmap K A),
          Dequiv : (g |- equiv M M1 A),
          Dequiv1 : (g |- equiv M1 N A)
        | map : [g |- map C M],
          map1 : [g |- map D N],
          equiv : [g |- cn-equiv C D K]
        ; solve [g |- map-equiv'/i _ Dtmap (equiv/trans Dequiv Dequiv1)]
        }
      }
    }
  }
  case cn-equiv/symm:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    K : (g |- kind),
    Dequiv : (g |- cn-equiv D C K)
  | map : [g |- map C M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv C D K]
  ; split map-equiv' map1 map [g |- Dequiv] as
    case map-equiv'/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      K : (g |- kind),
      Dequiv : (g |- cn-equiv D C K),
      A : (g |- etp),
      Dtmap : (g |- tmap K A),
      Dequiv1 : (g |- equiv N M A)
    | map : [g |- map C M],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv C D K]
    ; solve [g |- map-equiv'/i _ Dtmap (equiv/symm Dequiv1)]
    }
  }
  case cn-equiv/refl:
  { g : map-bind,
    D : (g |- con),
    M : (g |- eterm),
    N : (g |- eterm),
    K : (g |- kind),
    Dof : (g |- cn-of D K)
  | map : [g |- map D M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv D D K]
  ; split map-fun map map1 as
    case eterm-eq/i:
    { g : map-bind,
      D : (g |- con),
      N : (g |- eterm),
      K : (g |- kind),
      Dof : (g |- cn-of D K)
    | map : [g |- map D N],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv D D K]
    ; split map-of [g |- Dof] map as
      case map-of/i:
      { g : map-bind,
        D : (g |- con),
        N : (g |- eterm),
        K : (g |- kind),
        Dof : (g |- cn-of D K),
        A : (g |- etp),
        Dtmap : (g |- tmap K A),
        Dof1 : (g |- eof N A)
      | map : [g |- map D N],
        map1 : [g |- map D N],
        equiv : [g |- cn-equiv D D K]
      ; by [g |- equiv/reflex Dof1] as Dequiv' unboxed;
        solve [g |- map-equiv'/i _ Dtmap Dequiv']
      }
    }
  }
}

and proof map-equiv'' :
  (g : map-bind)
  [g |- map C M] ->
  [g |- map D N] ->
  [g |- cn-equiv C D K] ->
  [g |- tmap K A] ->
    [g |- map-equiv''/e M N A] =
/ trust / % FIXME: See issue #4
intros
{ g : map-bind,
  C : (g |- con),
  M : (g |- eterm),
  D : (g |- con),
  N : (g |- eterm),
  K : (g |- kind),
  A : (g |- etp)
| map : [g |- map C M],
  map1 : [g |- map D N],
  equiv : [g |- cn-equiv C D K],
  tmap : [g |- tmap K A]
; split map-equiv' map map1 equiv as
  case map-equiv'/i:
  { g : map-bind,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    K : (g |- kind),
    A : (g |- etp),
    A1 : (g |- etp),
    Dtmap : (g |- tmap K A1),
    Dequiv1 : (g |- equiv M N A1)
  | map : [g |- map C M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv C D K],
    tmap : [g |- tmap K A]
  ; split tmap-fun [_ |- Dtmap] tmap as
    case etp-eq/i:
    { g : map-bind,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      K : (g |- kind),
      A : (g |- etp),
      DmapA' : (g |- tmap K A),
      Dequiv' : (g |- equiv M N A)
    | map : [g |- map C M],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv C D K],
      tmap : [g |- tmap K A]
    ; solve [_ |- map-equiv''/i Dequiv']
    }
  }
}
;

LF map-equiv/e : con -> con -> kind -> type =
| map-equiv/i :
  { M : eterm } { N : eterm } { A : etp }
  map C M ->
  map D N ->
  tmap K A ->
  equiv M N A ->
    map-equiv/e C D K
;

proof map-equiv :
  (g : map-bind)
  { C : [g |- con] } { D : [g |- con] }
  [g |- cn-equiv C D K] ->
    [g |- map-equiv/e C D K] =
/ total 1 /
intros
{ g : map-bind, K : (g |- kind), C : (g |- con), D : (g |- con)
| equiv : [g |- cn-equiv C D K]
; split can-map [_ |- C] as
  case can-map/i:
  { g : map-bind,
    K : (g |- kind),
    C : (g |- con),
    D : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map C M)
  | equiv : [g |- cn-equiv C D K]
  ; split can-map [_ |- D] as
    case can-map/i:
    { g : map-bind,
      K : (g |- kind),
      C : (g |- con),
      D : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C M),
      M1 : (g |- eterm),
      Dmap1 : (g |- map D M1)
    | equiv : [g |- cn-equiv C D K]
    ; split map-equiv' [_ |- Dmap] [_ |- Dmap1] equiv as
      case map-equiv'/i:
      { g : map-bind,
        K : (g |- kind),
        C : (g |- con),
        D : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map D M1),
        A : (g |- etp),
        Dtmap : (g |- tmap K A),
        Dequiv : (g |- equiv M M1 A)
      | equiv : [g |- cn-equiv C D K]
      ; solve [_ |- map-equiv/i M M1 A Dmap Dmap1 Dtmap Dequiv]
      }
    }
  }
}
;

% Unmap Effectiveness

schema can-unmap-ctx =
  % conblock
  block (a : con) +
  % can-unmap-bind
  some [a : con]
  block (x : eterm, xt : unmap x a);

LF can-unmap/e : eterm -> type =
| can-unmap/i : { C : con } unmap M C -> can-unmap/e M
;

LF can-tunmap/e : etp -> type =
| can-tunmap/i : { K : kind } tunmap A K -> can-tunmap/e A
;

proof can-unmap :
  (g : can-unmap-ctx)
  { M : [g |- eterm] }
  [g |- can-unmap/e M] =
/ total 1 /
intros
{ g : can-unmap-ctx, M : (g |- eterm)
|
; split [_ |- M] as
  case estar:
  { g : can-unmap-ctx
  |
  ; solve [_ |- can-unmap/i _ unmap/star]
  }
  case epair:
  { g : can-unmap-ctx, M1 : (g |- eterm), M2 : (g |- eterm)
  |
  ; split can-unmap [_ |- M1] as
    case can-unmap/i:
    { g : can-unmap-ctx,
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      C : (g |- con),
      Dunmap : (g |- unmap M1 C)
    |
    ; split can-unmap [_ |- M2] as
      case can-unmap/i:
      { g : can-unmap-ctx,
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        C : (g |- con),
        Dunmap : (g |- unmap M1 C),
        C1 : (g |- con),
        Dunmap1 : (g |- unmap M2 C1)
      |
      ; solve [_ |- can-unmap/i _ (unmap/pair Dunmap Dunmap1)]
      }
    }
  }
  case elam:
  { g : can-unmap-ctx, A : (g |- etp), M1 : (g, y152 : eterm |- eterm)
  |
  ; split can-tunmap [_ |- A] as
    case can-tunmap/i:
    { g : can-unmap-ctx,
      A : (g |- etp),
      M1 : (g, y152 : eterm |- eterm),
      K : (g |- kind),
      Dtunmap : (g |- tunmap A K)
    |
    ; split
can-unmap
  [g, b1 : block (a : con), b2 : block (x : eterm, xt : unmap x b1.1) |-
     M1[.., b2.1]] as
      case can-unmap/i:
      { g : can-unmap-ctx,
        A : (g |- etp),
        M2 : (g, x : eterm |- eterm),
        K : (g |- kind),
        Dtunmap : (g |- tunmap A K),
        C : (g, y3 : con |- con),
        Dunmap :
          (g, z3 : con, x : eterm, y4 : unmap x z3 |-
             unmap (M2[.., x]) (C[.., z3]))
      |
      ; solve
          [g |-
             can-unmap/i _
             (unmap/lam Dtunmap (\x. \a. \at. Dunmap[.., a, x, at]))]
      }
    }
  }
  case epi2:
  { g : can-unmap-ctx, M1 : (g |- eterm)
  |
  ; split can-unmap [g |- M1] as
    case can-unmap/i:
    { g : can-unmap-ctx,
      M1 : (g |- eterm),
      C : (g |- con),
      Dunmap : (g |- unmap M1 C)
    |
    ; solve [g |- can-unmap/i _ (unmap/pi2 Dunmap)]
    }
  }
  case epi1:
  { g : can-unmap-ctx, M1 : (g |- eterm)
  |
  ; split can-unmap [g |- M1] as
    case can-unmap/i:
    { g : can-unmap-ctx,
      M1 : (g |- eterm),
      C : (g |- con),
      Dunmap : (g |- unmap M1 C)
    |
    ; solve [g |- can-unmap/i _ (unmap/pi1 Dunmap)]
    }
  }
  case eapp:
  { g : can-unmap-ctx, M1 : (g |- eterm), M2 : (g |- eterm)
  |
  ; split can-unmap [g |- M1] as
    case can-unmap/i:
    { g : can-unmap-ctx,
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      C : (g |- con),
      Dunmap : (g |- unmap M1 C)
    |
    ; split can-unmap [g |- M2] as
      case can-unmap/i:
      { g : can-unmap-ctx,
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        C : (g |- con),
        Dunmap : (g |- unmap M1 C),
        C1 : (g |- con),
        Dunmap1 : (g |- unmap M2 C1)
      |
      ; solve [g |- can-unmap/i _ (unmap/app Dunmap Dunmap1)]
      }
    }
  }
  case econst:
  { g : can-unmap-ctx, K : ( |- constant)
  |
  ; split [ |- K] as
    case const/labeled:
    { g : can-unmap-ctx, X : ( |- label)
    |
    ; solve [g |- can-unmap/i _ (unmap/labeled )]
    }
    case const/rec:
    { g : can-unmap-ctx, Dskel : ( |- skel)
    |
    ; split can-skof-il [ |- Dskel] as
      case can-skof-il/i:
      { g : can-unmap-ctx,
        Dskel : ( |- skel),
        K : ( |- kind),
        K1 : (z934 : con |- kind),
        Dskof-il : ( |- skof-il Dskel K (\z931. K1))
      |
      ; solve [g |- can-unmap/i _ (unmap/rec Dskof-il[])]
      }
    }
    case const/tagged:
    { g : can-unmap-ctx
    |
    ; solve [g |- can-unmap/i _ unmap/tagged]
    }
    case const/tag:
    { g : can-unmap-ctx
    |
    ; solve [g |- can-unmap/i _ unmap/tag]
    }
    case const/plus:
    { g : can-unmap-ctx
    |
    ; solve [g |- can-unmap/i _ unmap/plus]
    }
    case const/ref:
    { g : can-unmap-ctx
    |
    ; solve [g |- can-unmap/i _ unmap/ref]
    }
    case const/void:
    { g : can-unmap-ctx
    |
    ; solve [g |- can-unmap/i _ unmap/void]
    }
    case const/unit:
    { g : can-unmap-ctx
    |
    ; solve [g |- can-unmap/i _ unmap/unit]
    }
    case const/prod:
    { g : can-unmap-ctx
    |
    ; solve [g |- can-unmap/i _ unmap/prod]
    }
    case const/arrow:
    { g : can-unmap-ctx
    |
    ; solve [g |- can-unmap/i _ unmap/arrow]
    }
  }
  %{ FIXME: File "src/core/reconstruct.ml", line 2248, characters 11-16: Pattern matching failed
  case #.1:
  { g : can-unmap-ctx,
    C1048 : (g |- con),
    #unmap : #(g |- block (x : eterm, xt : unmap x (C1048[..])))
  |
  ; ?
  }
  }%
}

and proof can-tunmap :
  (g : can-unmap-ctx)
  { A : [g |- etp] }
  [g |- can-tunmap/e A] =
/ total 1 /
intros
{ g : can-unmap-ctx, A : (g |- etp)
|
; split [_ |- A] as
  case eone:
  { g : can-unmap-ctx
  |
  ; solve [_ |- can-tunmap/i _ tunmap/one]
  }
  case esing:
  { g : can-unmap-ctx, M : (g |- eterm)
  |
  ; split can-unmap [_ |- M] as
    case can-unmap/i:
    { g : can-unmap-ctx,
      M : (g |- eterm),
      C : (g |- con),
      Dunmap : (g |- unmap M C)
    |
    ; solve [_ |- can-tunmap/i _ (tunmap/sing Dunmap)]
    }
  }
  case esigma:
  { g : can-unmap-ctx, A1 : (g |- etp), A2 : (g, y149 : eterm |- etp)
  |
  ; split can-tunmap [_ |- A1] as
    case can-tunmap/i:
    { g : can-unmap-ctx,
      A1 : (g |- etp),
      A2 : (g, y149 : eterm |- etp),
      K : (g |- kind),
      Dtunmap : (g |- tunmap A1 K)
    |
    ; split
  can-tunmap
  [g, b1 : block (a : con), b2 : block (x : eterm, dx : unmap x b1.1) |-
     A2[.., b2.1]] as
      case can-tunmap/i:
      { g : can-unmap-ctx,
        A1 : (g |- etp),
        A3 : (g, x : eterm |- etp),
        K : (g |- kind),
        Dtunmap : (g |- tunmap A1 K),
        K1 : (g, y12 : con |- kind),
        Dtunmap1 :
          (g, z12 : con, x : eterm, y13 : unmap x z12 |-
             tunmap (A3[.., x]) (K1[.., z12]))
      |
      ; solve
          [g |-
             can-tunmap/i _
             (tunmap/sigma Dtunmap (\x. \a. \xt. Dtunmap1[.., a, x, xt]))]
      }
    }
  }
  case epi:
  { g : can-unmap-ctx, A1 : (g |- etp), A2 : (g, y148 : eterm |- etp)
  |
  ; split can-tunmap [_ |- A1] as
    case can-tunmap/i:
    { g : can-unmap-ctx,
      A1 : (g |- etp),
      A2 : (g, y148 : eterm |- etp),
      K : (g |- kind),
      Dtunmap : (g |- tunmap A1 K)
    |
    ; split
  can-tunmap
  [g, b1 : block (a : con), b2 : block (x : eterm, dx : unmap x b1.1) |-
     A2[.., b2.1]] as
      case can-tunmap/i:
      { g : can-unmap-ctx,
        A1 : (g |- etp),
        A3 : (g, x : eterm |- etp),
        K : (g |- kind),
        Dtunmap : (g |- tunmap A1 K),
        K1 : (g, y5 : con |- kind),
        Dtunmap1 :
          (g, z5 : con, x : eterm, y6 : unmap x z5 |-
             tunmap (A3[.., x]) (K1[.., z5]))
      |
      ; solve
          [g |-
             can-tunmap/i _
             (tunmap/pi Dtunmap (\x. \a. \xt. Dtunmap1[.., a, x, xt]))]
      }
    }
  }
  case et:
  { g : can-unmap-ctx
  |
  ; solve [_ |- can-tunmap/i _ tunmap/t]
  }
}
;

% Unmap Functionality

schema can-unmap-ctx =
  % conblock
  block (a : con) +
  % unmap-fun-bind
  some [a : con]
  block (x : eterm, xt : unmap x a);

proof unmap-fun :
  (g : can-unmap-ctx)
  [g |- unmap M C] ->
  [g |- unmap M C'] ->
    [g |- con-eq C C'] =
/ total 1 /
intros
{ g : can-unmap-ctx, M : (g |- eterm), C : (g |- con), C' : (g |- con)
| x : [g |- unmap M C], unmap : [g |- unmap M C']
; split x as
  case unmap/labeled:
  { g : can-unmap-ctx, L : ( |- label), C' : (g |- con)
  | x : [g |- unmap (econst (const/labeled L[])) (lam t (\a. labeled L[] a))],
    unmap : [g |- unmap (econst (const/labeled L[])) C']
  ; split unmap as
    case unmap/labeled:
    { g : can-unmap-ctx, L : ( |- label)
    | x :
        [g |- unmap (econst (const/labeled L[])) (lam t (\a. labeled L[] a))],
      unmap :
        [g |- unmap (econst (const/labeled L[])) (lam t (\a. labeled L[] a))]
    ; solve [_ |- con-eq/i ]
    }
  }
  case unmap/rec:
  { g : can-unmap-ctx,
    Dskel : ( |- skel),
    K : (g |- kind),
    K1 : (g, a167 : con |- kind),
    C' : (g |- con),
    Dskof-il : (g |- skof-il Dskel[] K (\x1003. K1))
  | x :
      [g |-
         unmap
           (econst (const/rec Dskel[]))
           (lam (sigma K
                (\a.
                   sigma (pi (pi K1 (\l. t)) (\k. pi (K1[.., a]) (\l. t)))
                   (\l. K1[.., a])))
           (\b.
              rec' (K1[.., pi1 b])
              (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))))],
    unmap : [g |- unmap (econst (const/rec Dskel[])) C']
  ; split unmap as
    case unmap/rec:
    { g : can-unmap-ctx,
      Dskel : ( |- skel),
      K : (g |- kind),
      K1 : (g, a167 : con |- kind),
      K2 : (g |- kind),
      K3 : (g, a167 : con |- kind),
      Dskof-il : (g |- skof-il Dskel[] K (\x1003. K1)),
      Dskof-il1 : (g |- skof-il Dskel[] K2 (\x1003. K3))
    | x :
        [g |-
           unmap
             (econst (const/rec Dskel[]))
             (lam (sigma K
                  (\a.
                     sigma (pi (pi K1 (\l. t)) (\k. pi (K1[.., a]) (\l. t)))
                     (\l. K1[.., a])))
             (\b.
                rec' (K1[.., pi1 b])
                (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))))],
      unmap :
        [g |-
           unmap
             (econst (const/rec Dskel[]))
             (lam (sigma K2
                  (\a.
                     sigma (pi (pi K3 (\l. t)) (\k. pi (K3[.., a]) (\l. t)))
                     (\l. K3[.., a])))
             (\b.
                rec' (K3[.., pi1 b])
                (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))))]
    ; split skof-il-fun [_ |- Dskof-il] [_ |- Dskof-il1] as
      case skof-il-fun/i:
      { g : can-unmap-ctx,
        Dskel : ( |- skel),
        K : (g |- kind),
        K1 : (g, a167 : con |- kind),
        K2 : (g |- kind),
        K3 : (g, a167 : con |- kind),
        Dskof-il : (g |- skof-il Dskel[] K (\x1003. K1)),
        Dskof-il1 : (g |- skof-il Dskel[] K2 (\x1003. K3)),
        Deq : (g |- kind-eq K K2),
        Deq1 : (g, x : con |- kind-eq K1 K3)
      | x :
          [g |-
             unmap
               (econst (const/rec Dskel[]))
               (lam (sigma K
                    (\a.
                       sigma (pi (pi K1 (\l. t))
                             (\k. pi (K1[.., a]) (\l. t)))
                       (\l. K1[.., a])))
               (\b.
                  rec' (K1[.., pi1 b])
                  (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))))],
        unmap :
          [g |-
             unmap
               (econst (const/rec Dskel[]))
               (lam (sigma K2
                    (\a.
                       sigma (pi (pi K3 (\l. t))
                             (\k. pi (K3[.., a]) (\l. t)))
                       (\l. K3[.., a])))
               (\b.
                  rec' (K3[.., pi1 b])
                  (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))))]
      ; split [_ |- Deq] as
        case kind-eq/i:
        { g : can-unmap-ctx,
          Dskel : ( |- skel),
          K2 : (g |- kind),
          K1 : (g, a167 : con |- kind),
          K3 : (g, a167 : con |- kind),
          Dskof-il : (g |- skof-il Dskel[] K2 (\x1003. K1)),
          Dskof-il1 : (g |- skof-il Dskel[] K2 (\x1003. K3)),
          Deq1 : (g, x : con |- kind-eq K1 K3)
        | x :
            [g |-
               unmap
                 (econst (const/rec Dskel[]))
                 (lam (sigma K2
                      (\a.
                         sigma (pi (pi K1 (\l. t))
                               (\k. pi (K1[.., a]) (\l. t)))
                         (\l. K1[.., a])))
                 (\b.
                    rec' (K1[.., pi1 b])
                    (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))))],
          unmap :
            [g |-
               unmap
                 (econst (const/rec Dskel[]))
                 (lam (sigma K2
                      (\a.
                         sigma (pi (pi K3 (\l. t))
                               (\k. pi (K3[.., a]) (\l. t)))
                         (\l. K3[.., a])))
                 (\b.
                    rec' (K3[.., pi1 b])
                    (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))))]
        ; split [_, x : con |- Deq1] as
          case kind-eq/i:
          { g : can-unmap-ctx,
            Dskel : ( |- skel),
            K2 : (g |- kind),
            K3 : (g, a167 : con |- kind),
            Dskof-il : (g |- skof-il Dskel[] K2 (\x1003. K3)),
            Dskof-il1 : (g |- skof-il Dskel[] K2 (\x1003. K3))
          | x :
              [g |-
                 unmap
                   (econst (const/rec Dskel[]))
                   (lam (sigma K2
                        (\a.
                           sigma (pi (pi K3 (\l. t))
                                 (\k. pi (K3[.., a]) (\l. t)))
                           (\l. K3[.., a])))
                   (\b.
                      rec' (K3[.., pi1 b])
                      (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))))],
            unmap :
              [g |-
                 unmap
                   (econst (const/rec Dskel[]))
                   (lam (sigma K2
                        (\a.
                           sigma (pi (pi K3 (\l. t))
                                 (\k. pi (K3[.., a]) (\l. t)))
                           (\l. K3[.., a])))
                   (\b.
                      rec' (K3[.., pi1 b])
                      (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))))]
          ; solve [_ |- con-eq/i ]
          }
        }
      }
    }
  }
  case unmap/tagged:
  { g : can-unmap-ctx, C' : (g |- con)
  | x : [g |- unmap (econst const/tagged) tagged],
    unmap : [g |- unmap (econst const/tagged) C']
  ; split unmap as
    case unmap/tagged:
    { g : can-unmap-ctx
    | x : [g |- unmap (econst const/tagged) tagged],
      unmap : [g |- unmap (econst const/tagged) tagged]
    ; solve [_ |- con-eq/i ]
    }
  }
  case unmap/tag:
  { g : can-unmap-ctx, C' : (g |- con)
  | x : [g |- unmap (econst const/tag) (lam t (\a. tag a))],
    unmap : [g |- unmap (econst const/tag) C']
  ; split unmap as
    case unmap/tag:
    { g : can-unmap-ctx
    | x : [g |- unmap (econst const/tag) (lam t (\a. tag a))],
      unmap : [g |- unmap (econst const/tag) (lam t (\a. tag a))]
    ; solve [_ |- con-eq/i ]
    }
  }
  case unmap/ref:
  { g : can-unmap-ctx, C' : (g |- con)
  | x : [g |- unmap (econst const/ref) (lam t (\a. ref a))],
    unmap : [g |- unmap (econst const/ref) C']
  ; split unmap as
    case unmap/ref:
    { g : can-unmap-ctx
    | x : [g |- unmap (econst const/ref) (lam t (\a. ref a))],
      unmap : [g |- unmap (econst const/ref) (lam t (\a. ref a))]
    ; solve [_ |- con-eq/i ]
    }
  }
  case unmap/plus:
  { g : can-unmap-ctx, C' : (g |- con)
  | x : [g |- unmap (econst const/plus) (lam t (\a. lam t (\b. plus a b)))],
    unmap : [g |- unmap (econst const/plus) C']
  ; split unmap as
    case unmap/plus:
    { g : can-unmap-ctx
    | x : [g |- unmap (econst const/plus) (lam t (\a. lam t (\b. plus a b)))],
      unmap :
        [g |- unmap (econst const/plus) (lam t (\a. lam t (\b. plus a b)))]
    ; solve [_ |- con-eq/i ]
    }
  }
  case unmap/arrow:
  { g : can-unmap-ctx, C' : (g |- con)
  | x : [g |- unmap (econst const/arrow) (lam t (\a. lam t (\b. arrow a b)))],
    unmap : [g |- unmap (econst const/arrow) C']
  ; split unmap as
    case unmap/arrow:
    { g : can-unmap-ctx
    | x :
        [g |- unmap (econst const/arrow) (lam t (\a. lam t (\b. arrow a b)))],
      unmap :
        [g |- unmap (econst const/arrow) (lam t (\a. lam t (\b. arrow a b)))]
    ; solve [_ |- con-eq/i ]
    }
  }
  case unmap/prod:
  { g : can-unmap-ctx, C' : (g |- con)
  | x : [g |- unmap (econst const/prod) (lam t (\a. lam t (\b. prod a b)))],
    unmap : [g |- unmap (econst const/prod) C']
  ; split unmap as
    case unmap/prod:
    { g : can-unmap-ctx
    | x : [g |- unmap (econst const/prod) (lam t (\a. lam t (\b. prod a b)))],
      unmap :
        [g |- unmap (econst const/prod) (lam t (\a. lam t (\b. prod a b)))]
    ; solve [_ |- con-eq/i ]
    }
  }
  case unmap/void:
  { g : can-unmap-ctx, C' : (g |- con)
  | x : [g |- unmap (econst const/void) void],
    unmap : [g |- unmap (econst const/void) C']
  ; split unmap as
    case unmap/void:
    { g : can-unmap-ctx
    | x : [g |- unmap (econst const/void) void],
      unmap : [g |- unmap (econst const/void) void]
    ; solve [_ |- con-eq/i ]
    }
  }
  case unmap/unit:
  { g : can-unmap-ctx, C' : (g |- con)
  | x : [g |- unmap (econst const/unit) unit],
    unmap : [g |- unmap (econst const/unit) C']
  ; split unmap as
    case unmap/unit:
    { g : can-unmap-ctx
    | x : [g |- unmap (econst const/unit) unit],
      unmap : [g |- unmap (econst const/unit) unit]
    ; solve [_ |- con-eq/i ]
    }
  }
  case unmap/star:
  { g : can-unmap-ctx, C' : (g |- con)
  | x : [g |- unmap estar star], unmap : [g |- unmap estar C']
  ; split unmap as
    case unmap/star:
    { g : can-unmap-ctx
    | x : [g |- unmap estar star], unmap : [g |- unmap estar star]
    ; solve [_ |- con-eq/i ]
    }
  }
  case unmap/pair:
  { g : can-unmap-ctx,
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    C1 : (g |- con),
    C2 : (g |- con),
    C' : (g |- con),
    Dunmap : (g |- unmap M1 C1),
    Dunmap1 : (g |- unmap M2 C2)
  | x : [g |- unmap (epair M1 M2) (pair C1 C2)],
    unmap : [g |- unmap (epair M1 M2) C']
  ; split unmap as
    case unmap/pair:
    { g : can-unmap-ctx,
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      C1 : (g |- con),
      C2 : (g |- con),
      C3 : (g |- con),
      C4 : (g |- con),
      Dunmap : (g |- unmap M1 C1),
      Dunmap1 : (g |- unmap M2 C2),
      Dunmap2 : (g |- unmap M1 C3),
      Dunmap3 : (g |- unmap M2 C4)
    | x : [g |- unmap (epair M1 M2) (pair C1 C2)],
      unmap : [g |- unmap (epair M1 M2) (pair C3 C4)]
    ; split unmap-fun [_ |- Dunmap] [_ |- Dunmap2] as
      case con-eq/i:
      { g : can-unmap-ctx,
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        C3 : (g |- con),
        C2 : (g |- con),
        C4 : (g |- con),
        Dunmap : (g |- unmap M1 C3),
        Dunmap1 : (g |- unmap M2 C2),
        Dunmap2 : (g |- unmap M1 C3),
        Dunmap3 : (g |- unmap M2 C4)
      | x : [g |- unmap (epair M1 M2) (pair C3 C2)],
        unmap : [g |- unmap (epair M1 M2) (pair C3 C4)]
      ; split unmap-fun [_ |- Dunmap1] [_ |- Dunmap3] as
        case con-eq/i:
        { g : can-unmap-ctx,
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          C3 : (g |- con),
          C4 : (g |- con),
          Dunmap : (g |- unmap M1 C3),
          Dunmap1 : (g |- unmap M2 C4),
          Dunmap2 : (g |- unmap M1 C3),
          Dunmap3 : (g |- unmap M2 C4)
        | x : [g |- unmap (epair M1 M2) (pair C3 C4)],
          unmap : [g |- unmap (epair M1 M2) (pair C3 C4)]
        ; solve [_ |- con-eq/i ]
        }
      }
    }
  }
  case unmap/lam:
  { g : can-unmap-ctx,
    A : (g |- etp),
    M1 : (g, y1212 : eterm |- eterm),
    K : (g |- kind),
    C1 : (g, a166 : con |- con),
    C' : (g |- con),
    Dtunmap : (g |- tunmap A K),
    Dunmap :
      (g, x : eterm, a : con, z1211 : unmap x a |-
         unmap (M1[.., x]) (C1[.., a]))
  | x : [g |- unmap (elam A (\y152. M1)) (lam K (\x473. C1))],
    unmap : [g |- unmap (elam A (\y152. M1)) C']
  ; split unmap as
    case unmap/lam:
    { g : can-unmap-ctx,
      A : (g |- etp),
      M1 : (g, y1212 : eterm |- eterm),
      K : (g |- kind),
      C1 : (g, a166 : con |- con),
      K1 : (g |- kind),
      C2 : (g, a166 : con |- con),
      Dtunmap : (g |- tunmap A K),
      Dunmap :
        (g, x : eterm, a : con, z1211 : unmap x a |-
           unmap (M1[.., x]) (C1[.., a])),
      Dtunmap1 : (g |- tunmap A K1),
      Dunmap1 :
        (g, x : eterm, a : con, z1211 : unmap x a |-
           unmap (M1[.., x]) (C2[.., a]))
    | x : [g |- unmap (elam A (\y152. M1)) (lam K (\x473. C1))],
      unmap : [g |- unmap (elam A (\y152. M1)) (lam K1 (\x473. C2))]
    ; split tunmap-fun [_ |- Dtunmap] [_ |- Dtunmap1] as
      case kind-eq/i:
      { g : can-unmap-ctx,
        A : (g |- etp),
        M1 : (g, y1212 : eterm |- eterm),
        K1 : (g |- kind),
        C1 : (g, a166 : con |- con),
        C2 : (g, a166 : con |- con),
        Dtunmap : (g |- tunmap A K1),
        Dunmap :
          (g, x : eterm, a : con, z1211 : unmap x a |-
             unmap (M1[.., x]) (C1[.., a])),
        Dtunmap1 : (g |- tunmap A K1),
        Dunmap1 :
          (g, x : eterm, a : con, z1211 : unmap x a |-
             unmap (M1[.., x]) (C2[.., a]))
      | x : [g |- unmap (elam A (\y152. M1)) (lam K1 (\x473. C1))],
        unmap : [g |- unmap (elam A (\y152. M1)) (lam K1 (\x473. C2))]
      ; split
        unmap-fun
          [_, a : con, b : block (x : eterm, xt : unmap x a) |-
             Dunmap[.., b.1, a, b.2]]
          [_, a : con, b : block (x : eterm, xt : unmap x a) |-
             Dunmap1[.., b.1, a, b.2]] as
        case con-eq/i:
        { g : can-unmap-ctx,
          A : (g |- etp),
          M1 : (g, y1212 : eterm |- eterm),
          K1 : (g |- kind),
          C2 : (g, a166 : con |- con),
          Dtunmap : (g |- tunmap A K1),
          Dunmap :
            (g, x : eterm, a : con, z1211 : unmap x a |-
               unmap (M1[.., x]) (C2[.., a])),
          Dtunmap1 : (g |- tunmap A K1),
          Dunmap1 :
            (g, x : eterm, a : con, z1211 : unmap x a |-
               unmap (M1[.., x]) (C2[.., a]))
        | x : [g |- unmap (elam A (\y152. M1)) (lam K1 (\x473. C2))],
          unmap : [g |- unmap (elam A (\y152. M1)) (lam K1 (\x473. C2))]
        ; solve [_ |- con-eq/i ]
        }
      }
    }
  }
  case unmap/pi2:
  { g : can-unmap-ctx,
    M1 : (g |- eterm),
    C1 : (g |- con),
    C' : (g |- con),
    Dunmap : (g |- unmap M1 C1)
  | x : [g |- unmap (epi2 M1) (pi2 C1)], unmap : [g |- unmap (epi2 M1) C']
  ; split unmap as
    case unmap/pi2:
    { g : can-unmap-ctx,
      M1 : (g |- eterm),
      C1 : (g |- con),
      C2 : (g |- con),
      Dunmap : (g |- unmap M1 C1),
      Dunmap1 : (g |- unmap M1 C2)
    | x : [g |- unmap (epi2 M1) (pi2 C1)],
      unmap : [g |- unmap (epi2 M1) (pi2 C2)]
    ; split unmap-fun [_ |- Dunmap] [_ |- Dunmap1] as
      case con-eq/i:
      { g : can-unmap-ctx,
        M1 : (g |- eterm),
        C2 : (g |- con),
        Dunmap : (g |- unmap M1 C2),
        Dunmap1 : (g |- unmap M1 C2)
      | x : [g |- unmap (epi2 M1) (pi2 C2)],
        unmap : [g |- unmap (epi2 M1) (pi2 C2)]
      ; solve [_ |- con-eq/i ]
      }
    }
  }
  case unmap/pi1:
  { g : can-unmap-ctx,
    M1 : (g |- eterm),
    C1 : (g |- con),
    C' : (g |- con),
    Dunmap : (g |- unmap M1 C1)
  | x : [g |- unmap (epi1 M1) (pi1 C1)], unmap : [g |- unmap (epi1 M1) C']
  ; split unmap as
    case unmap/pi1:
    { g : can-unmap-ctx,
      M1 : (g |- eterm),
      C1 : (g |- con),
      C2 : (g |- con),
      Dunmap : (g |- unmap M1 C1),
      Dunmap1 : (g |- unmap M1 C2)
    | x : [g |- unmap (epi1 M1) (pi1 C1)],
      unmap : [g |- unmap (epi1 M1) (pi1 C2)]
    ; split unmap-fun [_ |- Dunmap] [_ |- Dunmap1] as
      case con-eq/i:
      { g : can-unmap-ctx,
        M1 : (g |- eterm),
        C2 : (g |- con),
        Dunmap : (g |- unmap M1 C2),
        Dunmap1 : (g |- unmap M1 C2)
      | x : [g |- unmap (epi1 M1) (pi1 C2)],
        unmap : [g |- unmap (epi1 M1) (pi1 C2)]
      ; solve [_ |- con-eq/i ]
      }
    }
  }
  case unmap/app:
  { g : can-unmap-ctx,
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    C1 : (g |- con),
    C2 : (g |- con),
    C' : (g |- con),
    Dunmap : (g |- unmap M1 C1),
    Dunmap1 : (g |- unmap M2 C2)
  | x : [g |- unmap (eapp M1 M2) (app C1 C2)],
    unmap : [g |- unmap (eapp M1 M2) C']
  ; split unmap as
    case unmap/app:
    { g : can-unmap-ctx,
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      C1 : (g |- con),
      C2 : (g |- con),
      C3 : (g |- con),
      C4 : (g |- con),
      Dunmap : (g |- unmap M1 C1),
      Dunmap1 : (g |- unmap M2 C2),
      Dunmap2 : (g |- unmap M1 C3),
      Dunmap3 : (g |- unmap M2 C4)
    | x : [g |- unmap (eapp M1 M2) (app C1 C2)],
      unmap : [g |- unmap (eapp M1 M2) (app C3 C4)]
    ; split unmap-fun [_ |- Dunmap] [_ |- Dunmap2] as
      case con-eq/i:
      { g : can-unmap-ctx,
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        C3 : (g |- con),
        C2 : (g |- con),
        C4 : (g |- con),
        Dunmap : (g |- unmap M1 C3),
        Dunmap1 : (g |- unmap M2 C2),
        Dunmap2 : (g |- unmap M1 C3),
        Dunmap3 : (g |- unmap M2 C4)
      | x : [g |- unmap (eapp M1 M2) (app C3 C2)],
        unmap : [g |- unmap (eapp M1 M2) (app C3 C4)]
      ; split unmap-fun [_ |- Dunmap1] [_ |- Dunmap3] as
        case con-eq/i:
        { g : can-unmap-ctx,
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          C3 : (g |- con),
          C4 : (g |- con),
          Dunmap : (g |- unmap M1 C3),
          Dunmap1 : (g |- unmap M2 C4),
          Dunmap2 : (g |- unmap M1 C3),
          Dunmap3 : (g |- unmap M2 C4)
        | x : [g |- unmap (eapp M1 M2) (app C3 C4)],
          unmap : [g |- unmap (eapp M1 M2) (app C3 C4)]
        ; solve [_ |- con-eq/i ]
        }
      }
    }
  }
  %{ FIXME: File "src/core/reconstruct.ml", line 2248, characters 11-16: Pattern matching failed
  case #.2:
  { g : can-unmap-ctx,
    C : (g |- con),
    #unmap : #(g |- block (x : eterm, xt : unmap x (C[..]))),
    C' : (g |- con)
  | x : [g |- unmap #unmap.1 C], unmap : [g |- unmap #unmap.1 C']
  ; split unmap as
    case #.2:
    { g : can-unmap-ctx,
      C' : (g |- con),
      #unmap : #(g |- block (x : eterm, xt : unmap x (C'[..])))
    | x : [g |- unmap #unmap.1 C'], unmap : [g |- unmap #unmap.1 C']
    ; solve [_ |- con-eq/i ]
    }
  }
  }%
}

and proof tunmap-fun :
  (g : can-unmap-ctx)
  [g |- tunmap A K] ->
  [g |- tunmap A K'] ->
    [g |- kind-eq K K'] =
/ total 1 /
intros
{ g : can-unmap-ctx, A : (g |- etp), K : (g |- kind), K' : (g |- kind)
| x : [g |- tunmap A K], tunmap : [g |- tunmap A K']
; split x as
  case tunmap/one:
  { g : can-unmap-ctx, K' : (g |- kind)
  | x : [g |- tunmap eone one], tunmap : [g |- tunmap eone K']
  ; split tunmap as
    case tunmap/one:
    { g : can-unmap-ctx
    | x : [g |- tunmap eone one], tunmap : [g |- tunmap eone one]
    ; solve [_ |- kind-eq/i ]
    }
  }
  case tunmap/sigma:
  { g : can-unmap-ctx,
    A1 : (g |- etp),
    A2 : (g, y1216 : eterm |- etp),
    K1 : (g |- kind),
    K2 : (g, a169 : con |- kind),
    K' : (g |- kind),
    Dtunmap : (g |- tunmap A1 K1),
    Dtunmap1 :
      (g, x : eterm, a : con, z1215 : unmap x a |-
         tunmap (A2[.., x]) (K2[.., a]))
  | x : [g |- tunmap (esigma A1 (\y149. A2)) (sigma K1 (\y471. K2))],
    tunmap : [g |- tunmap (esigma A1 (\y149. A2)) K']
  ; split tunmap as
    case tunmap/sigma:
    { g : can-unmap-ctx,
      A1 : (g |- etp),
      A2 : (g, y1216 : eterm |- etp),
      K1 : (g |- kind),
      K2 : (g, a169 : con |- kind),
      K3 : (g |- kind),
      K4 : (g, a169 : con |- kind),
      Dtunmap : (g |- tunmap A1 K1),
      Dtunmap1 :
        (g, x : eterm, a : con, z1215 : unmap x a |-
           tunmap (A2[.., x]) (K2[.., a])),
      Dtunmap2 : (g |- tunmap A1 K3),
      Dtunmap3 :
        (g, x : eterm, a : con, z1215 : unmap x a |-
           tunmap (A2[.., x]) (K4[.., a]))
    | x : [g |- tunmap (esigma A1 (\y149. A2)) (sigma K1 (\y471. K2))],
      tunmap : [g |- tunmap (esigma A1 (\y149. A2)) (sigma K3 (\y471. K4))]
    ; split tunmap-fun [_ |- Dtunmap] [_ |- Dtunmap2] as
      case kind-eq/i:
      { g : can-unmap-ctx,
        A1 : (g |- etp),
        A2 : (g, y1216 : eterm |- etp),
        K3 : (g |- kind),
        K2 : (g, a169 : con |- kind),
        K4 : (g, a169 : con |- kind),
        Dtunmap : (g |- tunmap A1 K3),
        Dtunmap1 :
          (g, x : eterm, a : con, z1215 : unmap x a |-
             tunmap (A2[.., x]) (K2[.., a])),
        Dtunmap2 : (g |- tunmap A1 K3),
        Dtunmap3 :
          (g, x : eterm, a : con, z1215 : unmap x a |-
             tunmap (A2[.., x]) (K4[.., a]))
      | x : [g |- tunmap (esigma A1 (\y149. A2)) (sigma K3 (\y471. K2))],
        tunmap : [g |- tunmap (esigma A1 (\y149. A2)) (sigma K3 (\y471. K4))]
      ; split
        tunmap-fun
          [_, a : con, b : block (x : eterm, xt : unmap x a) |-
             Dtunmap1[.., b.1, a, b.2]]
          [_, a : con, b : block (x : eterm, xt : unmap x a) |-
             Dtunmap3[.., b.1, a, b.2]] as
        case kind-eq/i:
        { g : can-unmap-ctx,
          A1 : (g |- etp),
          A2 : (g, y1216 : eterm |- etp),
          K3 : (g |- kind),
          K4 : (g, a169 : con |- kind),
          Dtunmap : (g |- tunmap A1 K3),
          Dtunmap1 :
            (g, x : eterm, a : con, z1215 : unmap x a |-
               tunmap (A2[.., x]) (K4[.., a])),
          Dtunmap2 : (g |- tunmap A1 K3),
          Dtunmap3 :
            (g, x : eterm, a : con, z1215 : unmap x a |-
               tunmap (A2[.., x]) (K4[.., a]))
        | x : [g |- tunmap (esigma A1 (\y149. A2)) (sigma K3 (\y471. K4))],
          tunmap :
            [g |- tunmap (esigma A1 (\y149. A2)) (sigma K3 (\y471. K4))]
        ; solve [_ |- kind-eq/i ]
        }
      }
    }
  }
  case tunmap/pi:
  { g : can-unmap-ctx,
    A1 : (g |- etp),
    A2 : (g, z1214 : eterm |- etp),
    K1 : (g |- kind),
    K2 : (g, a168 : con |- kind),
    K' : (g |- kind),
    Dtunmap : (g |- tunmap A1 K1),
    Dtunmap1 :
      (g, x : eterm, a : con, x1214 : unmap x a |-
         tunmap (A2[.., x]) (K2[.., a]))
  | x : [g |- tunmap (epi A1 (\y148. A2)) (pi K1 (\y470. K2))],
    tunmap : [g |- tunmap (epi A1 (\y148. A2)) K']
  ; split tunmap as
    case tunmap/pi:
    { g : can-unmap-ctx,
      A1 : (g |- etp),
      A2 : (g, z1214 : eterm |- etp),
      K1 : (g |- kind),
      K2 : (g, a168 : con |- kind),
      K3 : (g |- kind),
      K4 : (g, a168 : con |- kind),
      Dtunmap : (g |- tunmap A1 K1),
      Dtunmap1 :
        (g, x : eterm, a : con, x1214 : unmap x a |-
           tunmap (A2[.., x]) (K2[.., a])),
      Dtunmap2 : (g |- tunmap A1 K3),
      Dtunmap3 :
        (g, x : eterm, a : con, x1214 : unmap x a |-
           tunmap (A2[.., x]) (K4[.., a]))
    | x : [g |- tunmap (epi A1 (\y148. A2)) (pi K1 (\y470. K2))],
      tunmap : [g |- tunmap (epi A1 (\y148. A2)) (pi K3 (\y470. K4))]
    ; split tunmap-fun [_ |- Dtunmap] [_ |- Dtunmap2] as
      case kind-eq/i:
      { g : can-unmap-ctx,
        A1 : (g |- etp),
        A2 : (g, z1214 : eterm |- etp),
        K3 : (g |- kind),
        K2 : (g, a168 : con |- kind),
        K4 : (g, a168 : con |- kind),
        Dtunmap : (g |- tunmap A1 K3),
        Dtunmap1 :
          (g, x : eterm, a : con, x1214 : unmap x a |-
             tunmap (A2[.., x]) (K2[.., a])),
        Dtunmap2 : (g |- tunmap A1 K3),
        Dtunmap3 :
          (g, x : eterm, a : con, x1214 : unmap x a |-
             tunmap (A2[.., x]) (K4[.., a]))
      | x : [g |- tunmap (epi A1 (\y148. A2)) (pi K3 (\y470. K2))],
        tunmap : [g |- tunmap (epi A1 (\y148. A2)) (pi K3 (\y470. K4))]
      ; split
        tunmap-fun
          [_, a : con, b : block (x : eterm, xt : unmap x a) |-
             Dtunmap1[.., b.1, a, b.2]]
          [_, a : con, b : block (x : eterm, xt : unmap x a) |-
             Dtunmap3[.., b.1, a, b.2]] as
        case kind-eq/i:
        { g : can-unmap-ctx,
          A1 : (g |- etp),
          A2 : (g, z1214 : eterm |- etp),
          K3 : (g |- kind),
          K4 : (g, a168 : con |- kind),
          Dtunmap : (g |- tunmap A1 K3),
          Dtunmap1 :
            (g, x : eterm, a : con, x1214 : unmap x a |-
               tunmap (A2[.., x]) (K4[.., a])),
          Dtunmap2 : (g |- tunmap A1 K3),
          Dtunmap3 :
            (g, x : eterm, a : con, x1214 : unmap x a |-
               tunmap (A2[.., x]) (K4[.., a]))
        | x : [g |- tunmap (epi A1 (\y148. A2)) (pi K3 (\y470. K4))],
          tunmap : [g |- tunmap (epi A1 (\y148. A2)) (pi K3 (\y470. K4))]
        ; solve [_ |- kind-eq/i ]
        }
      }
    }
  }
  case tunmap/sing:
  { g : can-unmap-ctx,
    M : (g |- eterm),
    C : (g |- con),
    K' : (g |- kind),
    Dunmap : (g |- unmap M C)
  | x : [g |- tunmap (esing M) (sing C)], tunmap : [g |- tunmap (esing M) K']
  ; split tunmap as
    case tunmap/sing:
    { g : can-unmap-ctx,
      M : (g |- eterm),
      C : (g |- con),
      C1 : (g |- con),
      Dunmap : (g |- unmap M C),
      Dunmap1 : (g |- unmap M C1)
    | x : [g |- tunmap (esing M) (sing C)],
      tunmap : [g |- tunmap (esing M) (sing C1)]
    ; split unmap-fun [_ |- Dunmap] [_ |- Dunmap1] as
      case con-eq/i:
      { g : can-unmap-ctx,
        M : (g |- eterm),
        C1 : (g |- con),
        Dunmap : (g |- unmap M C1),
        Dunmap1 : (g |- unmap M C1)
      | x : [g |- tunmap (esing M) (sing C1)],
        tunmap : [g |- tunmap (esing M) (sing C1)]
      ; solve [_ |- kind-eq/i ]
      }
    }
  }
  case tunmap/t:
  { g : can-unmap-ctx, K' : (g |- kind)
  | x : [g |- tunmap et t], tunmap : [g |- tunmap et K']
  ; split tunmap as
    case tunmap/t:
    { g : can-unmap-ctx
    | x : [g |- tunmap et t], tunmap : [g |- tunmap et t]
    ; solve [_ |- kind-eq/i ]
    }
  }
}
;

% Unmap Preserves Typing

LF unmap-expand/e : eterm -> con -> kind -> type =
| unmap-expand/i :
  { D : con }
  unmap M D ->
  expand-il C K D ->
    unmap-expand/e M C K
;

proof unmap-expand :
  (g : conblock+unmap-block)
  [g |- eexpand R A M] ->
  [g |- unmap R C] ->
  [g |- tunmap A K] ->
    [g |- unmap-expand/e M C K] =
/ total 1 /
intros
{ g : conblock+unmap-block,
  R : (g |- eterm),
  A : (g |- etp),
  M : (g |- eterm),
  C : (g |- con),
  K : (g |- kind)
| x : [g |- eexpand R A M],
  unmap : [g |- unmap R C],
  tunmap : [g |- tunmap A K]
; split x as
  case eexpand/one:
  { g : conblock+unmap-block,
    R : (g |- eterm),
    C : (g |- con),
    K : (g |- kind)
  | x : [g |- eexpand R eone estar],
    unmap : [g |- unmap R C],
    tunmap : [g |- tunmap eone K]
  ; split tunmap as
    case tunmap/one:
    { g : conblock+unmap-block, R : (g |- eterm), C : (g |- con)
    | x : [g |- eexpand R eone estar],
      unmap : [g |- unmap R C],
      tunmap : [g |- tunmap eone one]
    ; solve [_ |- unmap-expand/i _ unmap/star (expand-il/one )]
    }
  }
  case eexpand/sing:
  { g : conblock+unmap-block,
    R : (g |- eterm),
    M : (g |- eterm),
    C : (g |- con),
    K : (g |- kind)
  | x : [g |- eexpand R (esing M) M],
    unmap : [g |- unmap R C],
    tunmap : [g |- tunmap (esing M) K]
  ; split tunmap as
    case tunmap/sing:
    { g : conblock+unmap-block,
      R : (g |- eterm),
      M : (g |- eterm),
      C : (g |- con),
      C1 : (g |- con),
      Dunmap : (g |- unmap M C1)
    | x : [g |- eexpand R (esing M) M],
      unmap : [g |- unmap R C],
      tunmap : [g |- tunmap (esing M) (sing C1)]
    ; solve [_ |- unmap-expand/i _ Dunmap (expand-il/sing )]
    }
  }
  case eexpand/sigma:
  { g : conblock+unmap-block,
    R : (g |- eterm),
    A1 : (g |- etp),
    A2 : (g, x : eterm |- etp),
    M2 : (g |- eterm),
    M3 : (g |- eterm),
    C : (g |- con),
    K : (g |- kind),
    Dexpand : (g |- eexpand (epi1 R) A1 M2),
    Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3)
  | x : [g |- eexpand R (esigma A1 (\z147. A2)) (epair M2 M3)],
    unmap : [g |- unmap R C],
    tunmap : [g |- tunmap (esigma A1 (\z147. A2)) K]
  ; split tunmap as
    case tunmap/sigma:
    { g : conblock+unmap-block,
      R : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, x : eterm |- etp),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      C : (g |- con),
      K1 : (g |- kind),
      K2 : (g, a : con |- kind),
      Dexpand : (g |- eexpand (epi1 R) A1 M2),
      Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3),
      Dtunmap : (g |- tunmap A1 K1),
      Dtunmap1 :
        (g, x : eterm, a : con, z : unmap x a |-
           tunmap (A2[.., x]) (K2[.., a]))
    | x : [g |- eexpand R (esigma A1 (\z147. A2)) (epair M2 M3)],
      unmap : [g |- unmap R C],
      tunmap : [g |- tunmap (esigma A1 (\z147. A2)) (sigma K1 (\y498. K2))]
    ; by unmap as DmapR unboxed;
      split
      unmap-expand [_ |- Dexpand] [_ |- unmap/pi1 DmapR] [_ |- Dtunmap] as
      case unmap-expand/i:
      { g : conblock+unmap-block,
        R : (g |- eterm),
        A1 : (g |- etp),
        A2 : (g, x : eterm |- etp),
        M2 : (g |- eterm),
        M3 : (g |- eterm),
        C : (g |- con),
        K1 : (g |- kind),
        K2 : (g, a : con |- kind),
        Dexpand : (g |- eexpand (epi1 R) A1 M2),
        Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3),
        Dtunmap : (g |- tunmap A1 K1),
        Dtunmap1 :
          (g, x : eterm, a : con, z : unmap x a |-
             tunmap (A2[.., x]) (K2[.., a])),
        DmapR : (g |- unmap R C),
        C2 : (g |- con),
        Dunmap : (g |- unmap M2 C2),
        Dexpand-il : (g |- expand-il (pi1 C) K1 C2)
      | x : [g |- eexpand R (esigma A1 (\z147. A2)) (epair M2 M3)],
        unmap : [g |- unmap R C],
        tunmap : [g |- tunmap (esigma A1 (\z147. A2)) (sigma K1 (\y498. K2))]
      ; split
        unmap-expand [_ |- Dexpand1] [_ |- unmap/pi2 DmapR]
          [_ |- Dtunmap1[.., _, _, unmap/pi1 DmapR]] as
        case unmap-expand/i:
        { g : conblock+unmap-block,
          R : (g |- eterm),
          A1 : (g |- etp),
          A2 : (g, x : eterm |- etp),
          M2 : (g |- eterm),
          M3 : (g |- eterm),
          C : (g |- con),
          K1 : (g |- kind),
          K2 : (g, a : con |- kind),
          Dexpand : (g |- eexpand (epi1 R) A1 M2),
          Dexpand1 : (g |- eexpand (epi2 R) (A2[.., epi1 R]) M3),
          Dtunmap : (g |- tunmap A1 K1),
          Dtunmap1 :
            (g, x : eterm, a : con, z : unmap x a |-
               tunmap (A2[.., x]) (K2[.., a])),
          DmapR : (g |- unmap R C),
          C2 : (g |- con),
          Dunmap : (g |- unmap M2 C2),
          Dexpand-il : (g |- expand-il (pi1 C) K1 C2),
          C4 : (g |- con),
          Dunmap1 : (g |- unmap M3 C4),
          Dexpand-il1 : (g |- expand-il (pi2 C) (K2[.., pi1 C]) C4)
        | x : [g |- eexpand R (esigma A1 (\z147. A2)) (epair M2 M3)],
          unmap : [g |- unmap R C],
          tunmap :
            [g |- tunmap (esigma A1 (\z147. A2)) (sigma K1 (\y498. K2))]
        ; solve
            [_ |-
               unmap-expand/i _
               (unmap/pair Dunmap Dunmap1)
               (expand-il/sigma Dexpand-il Dexpand-il1)]
        }
      }
    }
  }
  case eexpand/pi:
  { g : conblock+unmap-block,
    R : (g |- eterm),
    A1 : (g |- etp),
    A2 : (g, y : eterm |- etp),
    M3 : (g, x : eterm |- eterm),
    C : (g |- con),
    K : (g |- kind),
    M1 : (g, z : eterm |- eterm),
    Dexpand : (g, x : eterm |- eexpand x (A1[..]) M1),
    Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M1) A2 M3)
  | x : [g |- eexpand R (epi A1 (\z146. A2)) (elam A1 (\z150. M3))],
    unmap : [g |- unmap R C],
    tunmap : [g |- tunmap (epi A1 (\z146. A2)) K]
  ; split tunmap as
    case tunmap/pi:
    { g : conblock+unmap-block,
      R : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, y : eterm |- etp),
      M3 : (g, x : eterm |- eterm),
      C : (g |- con),
      K1 : (g |- kind),
      K2 : (g, a : con |- kind),
      M1 : (g, z : eterm |- eterm),
      Dexpand : (g, x : eterm |- eexpand x (A1[..]) M1),
      Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M1) A2 M3),
      Dtunmap : (g |- tunmap A1 K1),
      Dtunmap1 :
        (g, x : eterm, a : con, x1 : unmap x a |-
           tunmap (A2[.., x]) (K2[.., a]))
    | x : [g |- eexpand R (epi A1 (\z146. A2)) (elam A1 (\z150. M3))],
      unmap : [g |- unmap R C],
      tunmap : [g |- tunmap (epi A1 (\z146. A2)) (pi K1 (\y497. K2))]
    ; by unmap as DmapR unboxed;
      split
      unmap-expand
        [_, a : con, b : block (x : eterm, xt : unmap x a) |-
           Dexpand[.., b.1]]
        [_, a : con, b : block (x : eterm, xt : unmap x a) |- b.2]
        [_, a : con, b : block (x : eterm, xt : unmap x a) |- Dtunmap[..]] as
      case unmap-expand/i:
      { g : conblock+unmap-block,
        R : (g |- eterm),
        A1 : (g |- etp),
        A2 : (g, y : eterm |- etp),
        M3 : (g, x : eterm |- eterm),
        C : (g |- con),
        K1 : (g |- kind),
        K2 : (g, a : con |- kind),
        M4 : (g, x : eterm |- eterm),
        Dexpand : (g, x : eterm |- eexpand x (A1[..]) M4),
        Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M4) A2 M3),
        Dtunmap : (g |- tunmap A1 K1),
        Dtunmap1 :
          (g, x : eterm, a : con, x1 : unmap x a |-
             tunmap (A2[.., x]) (K2[.., a])),
        DmapR : (g |- unmap R C),
        C2 : (g, a : con |- con),
        Dunmap :
          (g, a : con, x : eterm, z31 : unmap x a |-
             unmap (M4[.., x]) (C2[.., a])),
        Dexpand-il : (g, a : con |- expand-il a (K1[..]) C2)
      | x : [g |- eexpand R (epi A1 (\z146. A2)) (elam A1 (\z150. M3))],
        unmap : [g |- unmap R C],
        tunmap : [g |- tunmap (epi A1 (\z146. A2)) (pi K1 (\y497. K2))]
      ; split
        unmap-expand
          [_, a : con, b : block (x : eterm, xt : unmap x a) |-
             Dexpand1[.., b.1]]
          [_, a : con, b : block (x : eterm, xt : unmap x a) |-
             unmap/app (DmapR[..]) (Dunmap[.., a, b.1, b.2])]
          [_, a : con, b : block (x : eterm, xt : unmap x a) |-
             Dtunmap1[.., b.1, a, b.2]] as
        case unmap-expand/i:
        { g : conblock+unmap-block,
          R : (g |- eterm),
          A1 : (g |- etp),
          A2 : (g, y : eterm |- etp),
          M5 : (g, x : eterm |- eterm),
          C : (g |- con),
          K1 : (g |- kind),
          K2 : (g, a : con |- kind),
          M4 : (g, x : eterm |- eterm),
          Dexpand : (g, x : eterm |- eexpand x (A1[..]) M4),
          Dexpand1 : (g, x : eterm |- eexpand (eapp (R[..]) M4) A2 M5),
          Dtunmap : (g |- tunmap A1 K1),
          Dtunmap1 :
            (g, x : eterm, a : con, x1 : unmap x a |-
               tunmap (A2[.., x]) (K2[.., a])),
          DmapR : (g |- unmap R C),
          C2 : (g, a : con |- con),
          Dunmap :
            (g, a : con, x : eterm, z31 : unmap x a |-
               unmap (M4[.., x]) (C2[.., a])),
          Dexpand-il : (g, a : con |- expand-il a (K1[..]) C2),
          C4 : (g, a : con |- con),
          Dunmap1 :
            (g, a : con, x : eterm, y53 : unmap x a |-
               unmap (M5[.., x]) (C4[.., a])),
          Dexpand-il1 : (g, a : con |- expand-il (app (C[..]) C2) K2 C4)
        | x : [g |- eexpand R (epi A1 (\z146. A2)) (elam A1 (\z150. M5))],
          unmap : [g |- unmap R C],
          tunmap : [g |- tunmap (epi A1 (\z146. A2)) (pi K1 (\y497. K2))]
        ; solve
            [_ |-
               unmap-expand/i _
               (unmap/lam Dtunmap (\x. \a. \xt. Dunmap1[.., a, x, xt]))
               (expand-il/pi (\x. Dexpand-il) (\x. Dexpand-il1))]
        }
      }
    }
  }
  case eexpand/t:
  { g : conblock+unmap-block,
    M : (g |- eterm),
    C : (g |- con),
    K : (g |- kind)
  | x : [g |- eexpand M et M],
    unmap : [g |- unmap M C],
    tunmap : [g |- tunmap et K]
  ; split tunmap as
    case tunmap/t:
    { g : conblock+unmap-block, M : (g |- eterm), C : (g |- con)
    | x : [g |- eexpand M et M],
      unmap : [g |- unmap M C],
      tunmap : [g |- tunmap et t]
    ; by unmap as D unboxed;
      solve [_ |- unmap-expand/i _ D (expand-il/t )]
    }
  }
}
;

LF unmap-skof/e : skel -> etp -> (eterm -> etp) -> type =
| unmap-skof/i :
  { K : kind } { L : con -> kind }
  tunmap A K ->
  ({ x : eterm } { a : con } unmap x a -> tunmap (B x) (L a)) ->
  skof-il SK K L ->
    unmap-skof/e SK A B
;

proof unmap-skof :
  (g : conblock+unmap-block)
  [g |- skof SK A (\x. B)] ->
  [g |- unmap-skof/e SK A (\x. B)] =
/ total 1 /
intros
{ g : conblock+unmap-block,
  SK : (g |- skel),
  A : (g |- etp),
  B : (g, x344 : eterm |- etp)
| x : [g |- skof SK A (\x. B)]
; split x as
  case skof/one:
  { g : conblock+unmap-block
  | x : [g |- skof kone eone (\x. eone)]
  ; solve
      [_ |-
         unmap-skof/i _
         (\x. _) tunmap/one (\x. \a. \xt. tunmap/one) skof-il/one]
  }
  case skof/sing:
  { g : conblock+unmap-block
  | x : [g |- skof ksing et (\x. esing x)]
  ; solve
      [_ |-
         unmap-skof/i _
         (\x. _) tunmap/t (\x. \a. \xt. tunmap/sing xt) skof-il/sing]
  }
  case skof/sigma:
  { g : conblock+unmap-block,
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    A1 : (g |- etp),
    A2 : (g, y : eterm |- etp),
    A3 : (g |- etp),
    A4 : (g, x : eterm |- etp),
    M : (g, y : eterm, z : eterm |- eterm),
    Dskof : (g |- skof Dskel[] A1 (\y. A2)),
    Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
    Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M)
  | x :
      [g |-
         skof
           (ksigma Dskel[] Dskel1[])
           (esigma A1 (\y. epi A2 (\l. A3[..])))
           (\x.
              esigma (A2[.., epi1 x])
              (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
  ; split unmap-skof [_ |- Dskof] as
    case unmap-skof/i:
    { g : conblock+unmap-block,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      A1 : (g |- etp),
      A2 : (g, y : eterm |- etp),
      A3 : (g |- etp),
      A4 : (g, x : eterm |- etp),
      M : (g, y : eterm, z : eterm |- eterm),
      Dskof : (g |- skof Dskel[] A1 (\y. A2)),
      Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
      Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
      K : (g |- kind),
      K1 : (g, x : con |- kind),
      Dtunmap : (g |- tunmap A1 K),
      Dtunmap1 :
        (g, x : eterm, a : con, y : unmap x a |-
           tunmap (A2[.., x]) (K1[.., a])),
      Dskof-il : (g |- skof-il Dskel[] K (\y1049. K1))
    | x :
        [g |-
           skof
             (ksigma Dskel[] Dskel1[])
             (esigma A1 (\y. epi A2 (\l. A3[..])))
             (\x.
                esigma (A2[.., epi1 x])
                (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
    ; split unmap-skof [_ |- Dskof1] as
      case unmap-skof/i:
      { g : conblock+unmap-block,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        A1 : (g |- etp),
        A2 : (g, y : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, x : eterm |- etp),
        M : (g, y : eterm, z : eterm |- eterm),
        Dskof : (g |- skof Dskel[] A1 (\y. A2)),
        Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
        Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
        K : (g |- kind),
        K1 : (g, x : con |- kind),
        Dtunmap : (g |- tunmap A1 K),
        Dtunmap1 :
          (g, x : eterm, a : con, y : unmap x a |-
             tunmap (A2[.., x]) (K1[.., a])),
        Dskof-il : (g |- skof-il Dskel[] K (\y1049. K1)),
        K2 : (g |- kind),
        K3 : (g, x : con |- kind),
        Dtunmap2 : (g |- tunmap A3 K2),
        Dtunmap3 :
          (g, x : eterm, a : con, y : unmap x a |-
             tunmap (A4[.., x]) (K3[.., a])),
        Dskof-il1 : (g |- skof-il Dskel1[] K2 (\y1049. K3))
      | x :
          [g |-
             skof
               (ksigma Dskel[] Dskel1[])
               (esigma A1 (\y. epi A2 (\l. A3[..])))
               (\x.
                  esigma (A2[.., epi1 x])
                  (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
      ; split
unmap-expand
  [g, b : con, cb : block (y : eterm, yt : unmap y b), a : con,
   ca : block (x : eterm, xt : unmap x a) |- Dexpand[.., cb.1, ca.1]]
  [g, b : con, cb : block (y : eterm, yt : unmap y b), a : con,
   ca : block (x : eterm, xt : unmap x a) |- ca.2]
  [g, b : con, cb : block (y : eterm, yt : unmap y b), a : con,
   ca : block (x : eterm, xt : unmap x a) |- Dtunmap1[.., cb.1, b, cb.2]] as
        case unmap-expand/i:
        { g : conblock+unmap-block,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          A1 : (g |- etp),
          A2 : (g, y : eterm |- etp),
          A3 : (g |- etp),
          A4 : (g, x : eterm |- etp),
          M1 : (g, y : eterm, x : eterm |- eterm),
          Dskof : (g |- skof Dskel[] A1 (\y. A2)),
          Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
          Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M1),
          K : (g |- kind),
          K1 : (g, x : con |- kind),
          Dtunmap : (g |- tunmap A1 K),
          Dtunmap1 :
            (g, x : eterm, a : con, y : unmap x a |-
               tunmap (A2[.., x]) (K1[.., a])),
          Dskof-il : (g |- skof-il Dskel[] K (\y1049. K1)),
          K2 : (g |- kind),
          K3 : (g, x : con |- kind),
          Dtunmap2 : (g |- tunmap A3 K2),
          Dtunmap3 :
            (g, x : eterm, a : con, y : unmap x a |-
               tunmap (A4[.., x]) (K3[.., a])),
          Dskof-il1 : (g |- skof-il Dskel1[] K2 (\y1049. K3)),
          C1 : (g, b : con, a : con |- con),
          Dunmap :
            (g, b : con, y : eterm, z27 : unmap y b, a : con, x : eterm,
             y28 : unmap x a |- unmap (M1[.., y, x]) (C1[.., b, a])),
          Dexpand-il : (g, b : con, a : con |- expand-il a (K1[.., b]) C1)
        | x :
            [g |-
               skof
                 (ksigma Dskel[] Dskel1[])
                 (esigma A1 (\y. epi A2 (\l. A3[..])))
                 (\x.
                    esigma (A2[.., epi1 x])
                    (\x1. A4[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
        ; solve
            [g |-
               unmap-skof/i _
               (\x. _)
               (tunmap/sigma Dtunmap
               (\y. \b. \yt. tunmap/pi Dtunmap1 (\l1. \l2. \l3. Dtunmap2[..])))
               (\w.
                  \c.
                    \wt.
                      tunmap/sigma (Dtunmap1[.., _, _, unmap/pi1 wt])
                      (\x.
                         \a.
                           \xt.
                             Dtunmap3[.., _, _, unmap/app (unmap/pi2 wt)
                                      (Dunmap[.., _, _, unmap/pi1 wt, a, x,
                                              xt])]))
               (skof-il/sigma Dskof-il Dskof-il1 (\b. \a. Dexpand-il))]
        }
      }
    }
  }
  case skof/pi:
  { g : conblock+unmap-block,
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    A1 : (g |- etp),
    A2 : (g, z : eterm |- etp),
    A3 : (g |- etp),
    A4 : (g, y : eterm |- etp),
    M : (g, z : eterm, x : eterm |- eterm),
    Dskof : (g |- skof Dskel[] A1 (\y. A2)),
    Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
    Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M)
  | x :
      [g |-
         skof
           (kpi Dskel[] Dskel1[])
           (esigma A1 (\y. epi A2 (\l. A3[..])))
           (\x.
              epi (A2[.., epi1 x])
              (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
  ; split unmap-skof [g |- Dskof] as
    case unmap-skof/i:
    { g : conblock+unmap-block,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      A1 : (g |- etp),
      A2 : (g, z : eterm |- etp),
      A3 : (g |- etp),
      A4 : (g, y : eterm |- etp),
      M : (g, z : eterm, x : eterm |- eterm),
      Dskof : (g |- skof Dskel[] A1 (\y. A2)),
      Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
      Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
      K : (g |- kind),
      K1 : (g, x : con |- kind),
      Dtunmap : (g |- tunmap A1 K),
      Dtunmap1 :
        (g, x : eterm, a : con, y : unmap x a |-
           tunmap (A2[.., x]) (K1[.., a])),
      Dskof-il : (g |- skof-il Dskel[] K (\y1049. K1))
    | x :
        [g |-
           skof
             (kpi Dskel[] Dskel1[])
             (esigma A1 (\y. epi A2 (\l. A3[..])))
             (\x.
                epi (A2[.., epi1 x])
                (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
    ; split unmap-skof [g |- Dskof1] as
      case unmap-skof/i:
      { g : conblock+unmap-block,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        A1 : (g |- etp),
        A2 : (g, z : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, y : eterm |- etp),
        M : (g, z : eterm, x : eterm |- eterm),
        Dskof : (g |- skof Dskel[] A1 (\y. A2)),
        Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
        Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M),
        K : (g |- kind),
        K1 : (g, x : con |- kind),
        Dtunmap : (g |- tunmap A1 K),
        Dtunmap1 :
          (g, x : eterm, a : con, y : unmap x a |-
             tunmap (A2[.., x]) (K1[.., a])),
        Dskof-il : (g |- skof-il Dskel[] K (\y1049. K1)),
        K2 : (g |- kind),
        K3 : (g, x : con |- kind),
        Dtunmap2 : (g |- tunmap A3 K2),
        Dtunmap3 :
          (g, x : eterm, a : con, y : unmap x a |-
             tunmap (A4[.., x]) (K3[.., a])),
        Dskof-il1 : (g |- skof-il Dskel1[] K2 (\y1049. K3))
      | x :
          [g |-
             skof
               (kpi Dskel[] Dskel1[])
               (esigma A1 (\y. epi A2 (\l. A3[..])))
               (\x.
                  epi (A2[.., epi1 x])
                  (\x1. A4[.., eapp (epi2 x) (M[.., epi1 x, x1])]))]
      ; split
        unmap-expand
          [g, b : con, cb : block (y : eterm, yt : unmap y b), a : con,
           ca : block (x : eterm, xt : unmap x a) |- Dexpand[.., cb.1, ca.1]]
          [g, b : con, cb : block (y : eterm, yt : unmap y b), a : con,
           ca : block (x : eterm, xt : unmap x a) |- ca.2]
          [g, b : con, cb : block (y : eterm, yt : unmap y b), a : con,
           ca : block (x : eterm, xt : unmap x a) |-
             Dtunmap1[.., cb.1, b, cb.2]] as
        case unmap-expand/i:
        { g : conblock+unmap-block,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          A1 : (g |- etp),
          A2 : (g, z : eterm |- etp),
          A3 : (g |- etp),
          A4 : (g, y : eterm |- etp),
          M1 : (g, y : eterm, x : eterm |- eterm),
          Dskof : (g |- skof Dskel[] A1 (\y. A2)),
          Dskof1 : (g |- skof Dskel1[] A3 (\z. A4)),
          Dexpand : (g, y : eterm, x : eterm |- eexpand x (A2[.., y]) M1),
          K : (g |- kind),
          K1 : (g, x : con |- kind),
          Dtunmap : (g |- tunmap A1 K),
          Dtunmap1 :
            (g, x : eterm, a : con, y : unmap x a |-
               tunmap (A2[.., x]) (K1[.., a])),
          Dskof-il : (g |- skof-il Dskel[] K (\y1049. K1)),
          K2 : (g |- kind),
          K3 : (g, x : con |- kind),
          Dtunmap2 : (g |- tunmap A3 K2),
          Dtunmap3 :
            (g, x : eterm, a : con, y : unmap x a |-
               tunmap (A4[.., x]) (K3[.., a])),
          Dskof-il1 : (g |- skof-il Dskel1[] K2 (\y1049. K3)),
          C1 : (g, b : con, a : con |- con),
          Dunmap :
            (g, b : con, y : eterm, y1782 : unmap y b, a : con, x : eterm,
             x1782 : unmap x a |- unmap (M1[.., y, x]) (C1[.., b, a])),
          Dexpand-il : (g, b : con, a : con |- expand-il a (K1[.., b]) C1)
        | x :
            [g |-
               skof
                 (kpi Dskel[] Dskel1[])
                 (esigma A1 (\y. epi A2 (\l. A3[..])))
                 (\x.
                    epi (A2[.., epi1 x])
                    (\x1. A4[.., eapp (epi2 x) (M1[.., epi1 x, x1])]))]
        ; solve
            [g |-
               unmap-skof/i _
               (\x. _)
               (tunmap/sigma Dtunmap
               (\y. \b. \yt. tunmap/pi Dtunmap1 (\l1. \l2. \l3. Dtunmap2[..])))
               (\w.
                  \c.
                    \wt.
                      tunmap/pi (Dtunmap1[.., _, _, unmap/pi1 wt])
                      (\x.
                         \a.
                           \xt.
                             Dtunmap3[.., _, _, unmap/app (unmap/pi2 wt)
                                      (Dunmap[.., _, _, unmap/pi1 wt, a, x,
                                              xt])]))
               (skof-il/pi Dskof-il Dskof-il1 (\b. \a. Dexpand-il))]
        }
      }
    }
  }
  case skof/t:
  { g : conblock+unmap-block
  | x : [g |- skof kt eone (\x. et)]
  ; solve
  [g |- unmap-skof/i _ (\a. _) tunmap/one (\l1. \l2. \l3. tunmap/t) skof-il/t]
  }
}
;

schema unmap-bind =
  some [K : kind, B : etp, Dmap : tunmap B K, Dwf : kd-wf K]
  block (a : con, da : cn-of a K, x : eterm, dx : eof x B, xt : unmap x a);

LF unmap-of/e : etp -> con -> type =
| unmap-of/i :
  { K : kind }
  tunmap A K ->
  cn-of C K ->
    unmap-of/e A C
;

LF unmap-of'/e : con -> kind -> type =
| unmap-of'/i : cn-of C K -> unmap-of'/e C K
;

LF unmap-wf/e : etp -> type =
| unmap-wf/i :
  { K : kind }
  tunmap A K ->
  kd-wf K ->
    unmap-wf/e A
;

LF unmap-wf'/e : kind -> type =
| unmap-wf'/i : kd-wf K -> unmap-wf'/e K
;

LF unmap-subtp/e : kind -> kind -> type =
| unmap-subtp/i : kd-sub K L -> unmap-subtp/e K L
;

LF unmap-tequiv/e : kind -> kind -> type =
| unmap-tequiv/i : kd-equiv K L -> unmap-tequiv/e K L
;

LF unmap-equiv/e : etp -> con -> con -> type =
| unmap-equiv/i :
  { K : kind }
  tunmap A K ->
  cn-equiv C D K ->
    unmap-equiv/e A C D
;

LF unmap-equiv'/e : con -> con -> kind -> type =
| unmap-equiv'/i : cn-equiv C D K -> unmap-equiv'/e C D K
;

proof unmap-of :
  (g : unmap-bind)
  [g |- eof M A] ->
  [g |- unmap M C] ->
    [g |- unmap-of/e A C] =
/ total 1 /
intros
{ g : unmap-bind, M : (g |- eterm), A : (g |- etp), C : (g |- con)
| x : [g |- eof M A], unmap : [g |- unmap M C]
; split x as
  case eof/subsume:
  { g : unmap-bind,
    M : (g |- eterm),
    A : (g |- etp),
    C : (g |- con),
    A1 : (g |- etp),
    Dof : (g |- eof M A1),
    Dsub : (g |- subtp A1 A)
  | x : [g |- eof M A], unmap : [g |- unmap M C]
  ; split unmap-of [_ |- Dof] unmap as
    case unmap-of/i:
    { g : unmap-bind,
      M : (g |- eterm),
      A : (g |- etp),
      C : (g |- con),
      A1 : (g |- etp),
      Dof : (g |- eof M A1),
      Dsub : (g |- subtp A1 A),
      K : (g |- kind),
      Dtunmap : (g |- tunmap A1 K),
      Dof1 : (g |- cn-of C K)
    | x : [g |- eof M A], unmap : [g |- unmap M C]
    ; split can-tunmap [_ |- A] as
      case can-tunmap/i:
      { g : unmap-bind,
        M : (g |- eterm),
        A : (g |- etp),
        C : (g |- con),
        A1 : (g |- etp),
        Dof : (g |- eof M A1),
        Dsub : (g |- subtp A1 A),
        K : (g |- kind),
        Dtunmap : (g |- tunmap A1 K),
        Dof1 : (g |- cn-of C K),
        K1 : (g |- kind),
        Dtunmap1 : (g |- tunmap A K1)
      | x : [g |- eof M A], unmap : [g |- unmap M C]
      ; split unmap-subtp [_ |- Dsub] [_ |- Dtunmap] [_ |- Dtunmap1] as
        case unmap-subtp/i:
        { g : unmap-bind,
          M : (g |- eterm),
          A : (g |- etp),
          C : (g |- con),
          A1 : (g |- etp),
          Dof : (g |- eof M A1),
          Dsub : (g |- subtp A1 A),
          K : (g |- kind),
          Dtunmap : (g |- tunmap A1 K),
          Dof1 : (g |- cn-of C K),
          K1 : (g |- kind),
          Dtunmap1 : (g |- tunmap A K1),
          Dsub1 : (g |- kd-sub K K1)
        | x : [g |- eof M A], unmap : [g |- unmap M C]
        ; solve [_ |- unmap-of/i _ Dtunmap1 (cn-of/subsume Dof1 Dsub1)]
        }
      }
    }
  }
  case eof/extsigma:
  { g : unmap-bind,
    M : (g |- eterm),
    A1 : (g |- etp),
    A2 : (g, z : eterm |- etp),
    C : (g |- con),
    Dof : (g |- eof (epi1 M) A1),
    Dof1 : (g |- eof (epi2 M) (A2[.., epi1 M])),
    Dwf : (g, x : eterm, x1 : eof x (A1[..]) |- ewf (A2[.., x]))
  | x : [g |- eof M (esigma A1 (\z147. A2))], unmap : [g |- unmap M C]
  ; by unmap as Dmap unboxed;
    split unmap-of [_ |- Dof] [_ |- unmap/pi1 Dmap] as
    case unmap-of/i:
    { g : unmap-bind,
      M : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, z : eterm |- etp),
      C : (g |- con),
      Dof : (g |- eof (epi1 M) A1),
      Dof1 : (g |- eof (epi2 M) (A2[.., epi1 M])),
      Dwf : (g, x : eterm, x1 : eof x (A1[..]) |- ewf (A2[.., x])),
      Dmap : (g |- unmap M C),
      K : (g |- kind),
      Dtunmap : (g |- tunmap A1 K),
      Dof2 : (g |- cn-of (pi1 C) K)
    | x : [g |- eof M (esigma A1 (\z147. A2))], unmap : [g |- unmap M C]
    ; split
      unmap-wf
        [_,
         b :
           block (
             a : con,
             da : cn-of a (K[..]),
             x : eterm,
             dx : eof x (A1[..]),
             xt : unmap x a) |- Dwf[.., b.3, b.4]] as
      case unmap-wf/i:
      { g : unmap-bind,
        M : (g |- eterm),
        A1 : (g |- etp),
        A3 : (g, x : eterm |- etp),
        C : (g |- con),
        Dof : (g |- eof (epi1 M) A1),
        Dof1 : (g |- eof (epi2 M) (A3[.., epi1 M])),
        Dwf : (g, x : eterm, x1 : eof x (A1[..]) |- ewf (A3[.., x])),
        Dmap : (g |- unmap M C),
        K : (g |- kind),
        Dtunmap : (g |- tunmap A1 K),
        Dof2 : (g |- cn-of (pi1 C) K),
        K1 : (g, a : con |- kind),
        Dtunmap1 :
          (g, a : con, x : eterm, x5 : unmap x a |-
             tunmap (A3[.., x]) (K1[.., a])),
        Dwf1 : (g, a : con, da : cn-of a (K[..]) |- kd-wf (K1[.., a]))
      | x : [g |- eof M (esigma A1 (\z147. A3))], unmap : [g |- unmap M C]
      ; split
        unmap-of' [_ |- Dof1] [_ |- unmap/pi2 Dmap]
          [_ |- Dtunmap1[.., _, _, unmap/pi1 Dmap]] as
        case unmap-of'/i:
        { g : unmap-bind,
          M : (g |- eterm),
          A1 : (g |- etp),
          A3 : (g, x : eterm |- etp),
          C : (g |- con),
          Dof : (g |- eof (epi1 M) A1),
          Dof1 : (g |- eof (epi2 M) (A3[.., epi1 M])),
          Dwf : (g, x : eterm, x1 : eof x (A1[..]) |- ewf (A3[.., x])),
          Dmap : (g |- unmap M C),
          K : (g |- kind),
          Dtunmap : (g |- tunmap A1 K),
          Dof2 : (g |- cn-of (pi1 C) K),
          K1 : (g, a : con |- kind),
          Dtunmap1 :
            (g, a : con, x : eterm, x5 : unmap x a |-
               tunmap (A3[.., x]) (K1[.., a])),
          Dwf1 : (g, a : con, da : cn-of a (K[..]) |- kd-wf (K1[.., a])),
          Dof3 : (g |- cn-of (pi2 C) (K1[.., pi1 C]))
        | x : [g |- eof M (esigma A1 (\z147. A3))], unmap : [g |- unmap M C]
        ; solve
            [_ |-
               unmap-of/i _
               (tunmap/sigma Dtunmap (\x. \a. \xt. Dtunmap1[.., a, x, xt]))
               (cn-of/extsigma Dof2 Dof3 (\a. \da. Dwf1))]
        }
      }
    }
  }
  case eof/extpi:
  { g : unmap-bind,
    M : (g |- eterm),
    A1 : (g |- etp),
    A3 : (g, y : eterm |- etp),
    C : (g |- con),
    A2 : (g, z : eterm |- etp),
    Dof : (g |- eof M (epi A1 (\z146. A2))),
    Dof1 :
      (g, x : eterm, x1 : eof x (A1[..]) |- eof (eapp (M[..]) x) (A3[.., x]))
  | x : [g |- eof M (epi A1 (\z146. A3))], unmap : [g |- unmap M C]
  ; by unmap as Dmap unboxed;
    split unmap-of [g |- Dof] [g |- Dmap] as
    case unmap-of/i:
    { g : unmap-bind,
      M : (g |- eterm),
      A1 : (g |- etp),
      A3 : (g, y : eterm |- etp),
      C : (g |- con),
      A2 : (g, z : eterm |- etp),
      Dof : (g |- eof M (epi A1 (\z146. A2))),
      Dof1 :
        (g, x : eterm, x1 : eof x (A1[..]) |-
           eof (eapp (M[..]) x) (A3[.., x])),
      Dmap : (g |- unmap M C),
      K : (g |- kind),
      Dtunmap : (g |- tunmap (epi A1 (\z146. A2)) K),
      Dof2 : (g |- cn-of C K)
    | x : [g |- eof M (epi A1 (\z146. A3))], unmap : [g |- unmap M C]
    ; split [g |- Dtunmap] as
      case tunmap/pi:
      { g : unmap-bind,
        M : (g |- eterm),
        A1 : (g |- etp),
        A3 : (g, y : eterm |- etp),
        C : (g |- con),
        A2 : (g, z : eterm |- etp),
        Dof : (g |- eof M (epi A1 (\z146. A2))),
        Dof1 :
          (g, x : eterm, x1 : eof x (A1[..]) |-
             eof (eapp (M[..]) x) (A3[.., x])),
        Dmap : (g |- unmap M C),
        K1 : (g |- kind),
        K2 : (g, a : con |- kind),
        Dtunmap1 : (g |- tunmap A1 K1),
        Dtunmap2 :
          (g, x : eterm, a : con, y : unmap x a |-
             tunmap (A2[.., x]) (K2[.., a])),
        Dof2 : (g |- cn-of C (pi K1 (\z503. K2)))
      | x : [g |- eof M (epi A1 (\z146. A3))], unmap : [g |- unmap M C]
      ; split
        unmap-of
          [g,
           b :
             block (
               a : con,
               da : cn-of a (K1[..]),
               x : eterm,
               dx : eof x (A1[..]),
               xt : unmap x a) |- Dof1[.., b.3, b.4]]
          [g,
           b :
             block (
               a : con,
               da : cn-of a (K1[..]),
               x : eterm,
               dx : eof x (A1[..]),
               xt : unmap x a) |- unmap/app (Dmap[..]) b.5] as
        case unmap-of/i:
        { g : unmap-bind,
          M : (g |- eterm),
          A1 : (g |- etp),
          A4 : (g, x : eterm |- etp),
          C : (g |- con),
          A2 : (g, z : eterm |- etp),
          Dof : (g |- eof M (epi A1 (\z146. A2))),
          Dof1 :
            (g, x : eterm, x1 : eof x (A1[..]) |-
               eof (eapp (M[..]) x) (A4[.., x])),
          Dmap : (g |- unmap M C),
          K1 : (g |- kind),
          K2 : (g, a : con |- kind),
          Dtunmap1 : (g |- tunmap A1 K1),
          Dtunmap2 :
            (g, x : eterm, a : con, y : unmap x a |-
               tunmap (A2[.., x]) (K2[.., a])),
          Dof2 : (g |- cn-of C (pi K1 (\z503. K2))),
          K3 : (g, a : con |- kind),
          Dtunmap3 :
            (g, a : con, x : eterm, y1850 : unmap x a |-
               tunmap (A4[.., x]) (K3[.., a])),
          Dof3 :
            (g, a : con, da : cn-of a (K1[..]) |-
               cn-of (app (C[..]) a) (K3[.., a]))
        | x : [g |- eof M (epi A1 (\z146. A4))], unmap : [g |- unmap M C]
        ; solve
            [g |-
               unmap-of/i _
               (tunmap/pi Dtunmap1 (\x. \a. \xt. Dtunmap3[.., a, x, xt]))
               (cn-of/extpi Dof2 (\a. \da. Dof3))]
        }
      }
    }
  }
  case eof/star:
  { g : unmap-bind, C : (g |- con)
  | x : [g |- eof estar eone], unmap : [g |- unmap estar C]
  ; split unmap as
    case unmap/star:
    { g : unmap-bind
    | x : [g |- eof estar eone], unmap : [g |- unmap estar star]
    ; solve [g |- unmap-of/i _ tunmap/one cn-of/star]
    }
  }
  case eof/sing:
  { g : unmap-bind, M : (g |- eterm), C : (g |- con), Dof : (g |- eof M et)
  | x : [g |- eof M (esing M)], unmap : [g |- unmap M C]
  ; by unmap as Dmap unboxed;
    split unmap-of' [g |- Dof] [g |- Dmap] [g |- tunmap/t] as
    case unmap-of'/i:
    { g : unmap-bind,
      M : (g |- eterm),
      C : (g |- con),
      Dof : (g |- eof M et),
      Dmap : (g |- unmap M C),
      Dof1 : (g |- cn-of C t)
    | x : [g |- eof M (esing M)], unmap : [g |- unmap M C]
    ; solve [g |- unmap-of/i _ (tunmap/sing Dmap) (cn-of/sing Dof1)]
    }
  }
  case eof/pi2:
  { g : unmap-bind,
    M1 : (g |- eterm),
    A2 : (g, y : eterm |- etp),
    C : (g |- con),
    A1 : (g |- etp),
    Dof : (g |- eof M1 (esigma A1 (\z147. A2)))
  | x : [g |- eof (epi2 M1) (A2[.., epi1 M1])],
    unmap : [g |- unmap (epi2 M1) C]
  ; split unmap as
    case unmap/pi2:
    { g : unmap-bind,
      M1 : (g |- eterm),
      A2 : (g, y : eterm |- etp),
      C1 : (g |- con),
      A1 : (g |- etp),
      Dof : (g |- eof M1 (esigma A1 (\z147. A2))),
      Dunmap : (g |- unmap M1 C1)
    | x : [g |- eof (epi2 M1) (A2[.., epi1 M1])],
      unmap : [g |- unmap (epi2 M1) (pi2 C1)]
    ; split unmap-of [g |- Dof] [g |- Dunmap] as
      case unmap-of/i:
      { g : unmap-bind,
        M1 : (g |- eterm),
        A2 : (g, y : eterm |- etp),
        C1 : (g |- con),
        A1 : (g |- etp),
        Dof : (g |- eof M1 (esigma A1 (\z147. A2))),
        Dunmap : (g |- unmap M1 C1),
        K : (g |- kind),
        Dtunmap : (g |- tunmap (esigma A1 (\z147. A2)) K),
        Dof1 : (g |- cn-of C1 K)
      | x : [g |- eof (epi2 M1) (A2[.., epi1 M1])],
        unmap : [g |- unmap (epi2 M1) (pi2 C1)]
      ; split [g |- Dtunmap] as
        case tunmap/sigma:
        { g : unmap-bind,
          M1 : (g |- eterm),
          A2 : (g, y : eterm |- etp),
          C1 : (g |- con),
          A1 : (g |- etp),
          Dof : (g |- eof M1 (esigma A1 (\z147. A2))),
          Dunmap : (g |- unmap M1 C1),
          K1 : (g |- kind),
          K2 : (g, a : con |- kind),
          Dtunmap1 : (g |- tunmap A1 K1),
          Dtunmap2 :
            (g, x : eterm, a : con, x1 : unmap x a |-
               tunmap (A2[.., x]) (K2[.., a])),
          Dof1 : (g |- cn-of C1 (sigma K1 (\z504. K2)))
        | x : [g |- eof (epi2 M1) (A2[.., epi1 M1])],
          unmap : [g |- unmap (epi2 M1) (pi2 C1)]
        ; solve
            [g |-
               unmap-of/i _
               (Dtunmap2[.., _, _, unmap/pi1 Dunmap]) (cn-of/pi2 Dof1)]
        }
      }
    }
  }
  case eof/pi1:
  { g : unmap-bind,
    M1 : (g |- eterm),
    A : (g |- etp),
    C : (g |- con),
    A2 : (g, x : eterm |- etp),
    Dof : (g |- eof M1 (esigma A (\z147. A2)))
  | x : [g |- eof (epi1 M1) A], unmap : [g |- unmap (epi1 M1) C]
  ; split unmap as
    case unmap/pi1:
    { g : unmap-bind,
      M1 : (g |- eterm),
      A : (g |- etp),
      C1 : (g |- con),
      A2 : (g, x : eterm |- etp),
      Dof : (g |- eof M1 (esigma A (\z147. A2))),
      Dunmap : (g |- unmap M1 C1)
    | x : [g |- eof (epi1 M1) A], unmap : [g |- unmap (epi1 M1) (pi1 C1)]
    ; split unmap-of [g |- Dof] [g |- Dunmap] as
      case unmap-of/i:
      { g : unmap-bind,
        M1 : (g |- eterm),
        A : (g |- etp),
        C1 : (g |- con),
        A2 : (g, x : eterm |- etp),
        Dof : (g |- eof M1 (esigma A (\z147. A2))),
        Dunmap : (g |- unmap M1 C1),
        K : (g |- kind),
        Dtunmap : (g |- tunmap (esigma A (\z147. A2)) K),
        Dof1 : (g |- cn-of C1 K)
      | x : [g |- eof (epi1 M1) A], unmap : [g |- unmap (epi1 M1) (pi1 C1)]
      ; split [g |- Dtunmap] as
        case tunmap/sigma:
        { g : unmap-bind,
          M1 : (g |- eterm),
          A : (g |- etp),
          C1 : (g |- con),
          A2 : (g, x : eterm |- etp),
          Dof : (g |- eof M1 (esigma A (\z147. A2))),
          Dunmap : (g |- unmap M1 C1),
          K1 : (g |- kind),
          K2 : (g, a : con |- kind),
          Dtunmap1 : (g |- tunmap A K1),
          Dtunmap2 :
            (g, x : eterm, a : con, x1 : unmap x a |-
               tunmap (A2[.., x]) (K2[.., a])),
          Dof1 : (g |- cn-of C1 (sigma K1 (\z504. K2)))
        | x : [g |- eof (epi1 M1) A], unmap : [g |- unmap (epi1 M1) (pi1 C1)]
        ; solve [g |- unmap-of/i _ Dtunmap1 (cn-of/pi1 Dof1)]
        }
      }
    }
  }
  case eof/pair:
  { g : unmap-bind,
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    A1 : (g |- etp),
    A2 : (g, z : eterm |- etp),
    C : (g |- con),
    Dof : (g |- eof M1 A1),
    Dof1 : (g |- eof M2 (A2[.., M1])),
    Dwf : (g, x : eterm, x1 : eof x (A1[..]) |- ewf (A2[.., x]))
  | x : [g |- eof (epair M1 M2) (esigma A1 (\z147. A2))],
    unmap : [g |- unmap (epair M1 M2) C]
  ; split unmap as
    case unmap/pair:
    { g : unmap-bind,
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      A1 : (g |- etp),
      A2 : (g, z : eterm |- etp),
      C1 : (g |- con),
      C2 : (g |- con),
      Dof : (g |- eof M1 A1),
      Dof1 : (g |- eof M2 (A2[.., M1])),
      Dwf : (g, x : eterm, x1 : eof x (A1[..]) |- ewf (A2[.., x])),
      Dunmap : (g |- unmap M1 C1),
      Dunmap1 : (g |- unmap M2 C2)
    | x : [g |- eof (epair M1 M2) (esigma A1 (\z147. A2))],
      unmap : [g |- unmap (epair M1 M2) (pair C1 C2)]
    ; split unmap-of [g |- Dof] [g |- Dunmap] as
      case unmap-of/i:
      { g : unmap-bind,
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        A1 : (g |- etp),
        A2 : (g, z : eterm |- etp),
        C1 : (g |- con),
        C2 : (g |- con),
        Dof : (g |- eof M1 A1),
        Dof1 : (g |- eof M2 (A2[.., M1])),
        Dwf : (g, x : eterm, x1 : eof x (A1[..]) |- ewf (A2[.., x])),
        Dunmap : (g |- unmap M1 C1),
        Dunmap1 : (g |- unmap M2 C2),
        K : (g |- kind),
        Dtunmap : (g |- tunmap A1 K),
        Dof2 : (g |- cn-of C1 K)
      | x : [g |- eof (epair M1 M2) (esigma A1 (\z147. A2))],
        unmap : [g |- unmap (epair M1 M2) (pair C1 C2)]
      ; split
        unmap-wf
          [g,
           b :
             block (
               a : con,
               da : cn-of a (K[..]),
               x : eterm,
               dx : eof x (A1[..]),
               xt : unmap x a) |- Dwf[.., b.3, b.4]] as
        case unmap-wf/i:
        { g : unmap-bind,
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          A1 : (g |- etp),
          A3 : (g, x : eterm |- etp),
          C1 : (g |- con),
          C2 : (g |- con),
          Dof : (g |- eof M1 A1),
          Dof1 : (g |- eof M2 (A3[.., M1])),
          Dwf : (g, x : eterm, x1 : eof x (A1[..]) |- ewf (A3[.., x])),
          Dunmap : (g |- unmap M1 C1),
          Dunmap1 : (g |- unmap M2 C2),
          K : (g |- kind),
          Dtunmap : (g |- tunmap A1 K),
          Dof2 : (g |- cn-of C1 K),
          K1 : (g, a : con |- kind),
          Dtunmap1 :
            (g, a : con, x : eterm, z1822 : unmap x a |-
               tunmap (A3[.., x]) (K1[.., a])),
          Dwf1 : (g, a : con, da : cn-of a (K[..]) |- kd-wf (K1[.., a]))
        | x : [g |- eof (epair M1 M2) (esigma A1 (\z147. A3))],
          unmap : [g |- unmap (epair M1 M2) (pair C1 C2)]
        ; split
          unmap-of' [g |- Dof1] [g |- Dunmap1]
            [g |- Dtunmap1[.., _, _, Dunmap]] as
          case unmap-of'/i:
          { g : unmap-bind,
            M1 : (g |- eterm),
            M2 : (g |- eterm),
            A1 : (g |- etp),
            A3 : (g, x : eterm |- etp),
            C1 : (g |- con),
            C2 : (g |- con),
            Dof : (g |- eof M1 A1),
            Dof1 : (g |- eof M2 (A3[.., M1])),
            Dwf : (g, x : eterm, x1 : eof x (A1[..]) |- ewf (A3[.., x])),
            Dunmap : (g |- unmap M1 C1),
            Dunmap1 : (g |- unmap M2 C2),
            K : (g |- kind),
            Dtunmap : (g |- tunmap A1 K),
            Dof2 : (g |- cn-of C1 K),
            K1 : (g, a : con |- kind),
            Dtunmap1 :
              (g, a : con, x : eterm, z1822 : unmap x a |-
                 tunmap (A3[.., x]) (K1[.., a])),
            Dwf1 : (g, a : con, da : cn-of a (K[..]) |- kd-wf (K1[.., a])),
            Dof3 : (g |- cn-of C2 (K1[.., C1]))
          | x : [g |- eof (epair M1 M2) (esigma A1 (\z147. A3))],
            unmap : [g |- unmap (epair M1 M2) (pair C1 C2)]
          ; solve
              [g |-
                 unmap-of/i _
                 (tunmap/sigma Dtunmap (\x. \a. \xt. Dtunmap1[.., a, x, xt]))
                 (cn-of/pair Dof2 Dof3 (\a. \da. Dwf1))]
          }
        }
      }
    }
  }
  case eof/app:
  { g : unmap-bind,
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    A2 : (g, y : eterm |- etp),
    C : (g |- con),
    A1 : (g |- etp),
    Dof : (g |- eof M1 (epi A1 (\z146. A2))),
    Dof1 : (g |- eof M2 A1)
  | x : [g |- eof (eapp M1 M2) (A2[.., M2])],
    unmap : [g |- unmap (eapp M1 M2) C]
  ; split unmap as
    case unmap/app:
    { g : unmap-bind,
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      A2 : (g, y : eterm |- etp),
      C1 : (g |- con),
      C2 : (g |- con),
      A1 : (g |- etp),
      Dof : (g |- eof M1 (epi A1 (\z146. A2))),
      Dof1 : (g |- eof M2 A1),
      Dunmap : (g |- unmap M1 C1),
      Dunmap1 : (g |- unmap M2 C2)
    | x : [g |- eof (eapp M1 M2) (A2[.., M2])],
      unmap : [g |- unmap (eapp M1 M2) (app C1 C2)]
    ; split unmap-of [g |- Dof] [g |- Dunmap] as
      case unmap-of/i:
      { g : unmap-bind,
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        A2 : (g, y : eterm |- etp),
        C1 : (g |- con),
        C2 : (g |- con),
        A1 : (g |- etp),
        Dof : (g |- eof M1 (epi A1 (\z146. A2))),
        Dof1 : (g |- eof M2 A1),
        Dunmap : (g |- unmap M1 C1),
        Dunmap1 : (g |- unmap M2 C2),
        K : (g |- kind),
        Dtunmap : (g |- tunmap (epi A1 (\z146. A2)) K),
        Dof2 : (g |- cn-of C1 K)
      | x : [g |- eof (eapp M1 M2) (A2[.., M2])],
        unmap : [g |- unmap (eapp M1 M2) (app C1 C2)]
      ; split [g |- Dtunmap] as
        case tunmap/pi:
        { g : unmap-bind,
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          A2 : (g, y : eterm |- etp),
          C1 : (g |- con),
          C2 : (g |- con),
          A1 : (g |- etp),
          Dof : (g |- eof M1 (epi A1 (\z146. A2))),
          Dof1 : (g |- eof M2 A1),
          Dunmap : (g |- unmap M1 C1),
          Dunmap1 : (g |- unmap M2 C2),
          K1 : (g |- kind),
          K2 : (g, a : con |- kind),
          Dtunmap1 : (g |- tunmap A1 K1),
          Dtunmap2 :
            (g, x : eterm, a : con, y : unmap x a |-
               tunmap (A2[.., x]) (K2[.., a])),
          Dof2 : (g |- cn-of C1 (pi K1 (\z503. K2)))
        | x : [g |- eof (eapp M1 M2) (A2[.., M2])],
          unmap : [g |- unmap (eapp M1 M2) (app C1 C2)]
        ; split unmap-of' [g |- Dof1] [g |- Dunmap1] [g |- Dtunmap1] as
          case unmap-of'/i:
          { g : unmap-bind,
            M1 : (g |- eterm),
            M2 : (g |- eterm),
            A2 : (g, y : eterm |- etp),
            C1 : (g |- con),
            C2 : (g |- con),
            A1 : (g |- etp),
            Dof : (g |- eof M1 (epi A1 (\z146. A2))),
            Dof1 : (g |- eof M2 A1),
            Dunmap : (g |- unmap M1 C1),
            Dunmap1 : (g |- unmap M2 C2),
            K1 : (g |- kind),
            K2 : (g, a : con |- kind),
            Dtunmap1 : (g |- tunmap A1 K1),
            Dtunmap2 :
              (g, x : eterm, a : con, y : unmap x a |-
                 tunmap (A2[.., x]) (K2[.., a])),
            Dof2 : (g |- cn-of C1 (pi K1 (\z503. K2))),
            Dof3 : (g |- cn-of C2 K1)
          | x : [g |- eof (eapp M1 M2) (A2[.., M2])],
            unmap : [g |- unmap (eapp M1 M2) (app C1 C2)]
          ; solve
              [g |-
                 unmap-of/i _
                 (Dtunmap2[.., _, _, Dunmap1]) (cn-of/app Dof2 Dof3)]
          }
        }
      }
    }
  }
  case eof/lam:
  { g : unmap-bind,
    A1 : (g |- etp),
    M1 : (g, z : eterm |- eterm),
    A2 : (g, y : eterm |- etp),
    C : (g |- con),
    Dwf : (g |- ewf A1),
    Dof : (g, x : eterm, x1 : eof x (A1[..]) |- eof (M1[.., x]) (A2[.., x]))
  | x : [g |- eof (elam A1 (\z150. M1)) (epi A1 (\z146. A2))],
    unmap : [g |- unmap (elam A1 (\z150. M1)) C]
  ; split unmap as
    case unmap/lam:
    { g : unmap-bind,
      A1 : (g |- etp),
      M1 : (g, z : eterm |- eterm),
      A2 : (g, y : eterm |- etp),
      K : (g |- kind),
      C1 : (g, a : con |- con),
      Dwf : (g |- ewf A1),
      Dof :
        (g, x : eterm, x1 : eof x (A1[..]) |- eof (M1[.., x]) (A2[.., x])),
      Dtunmap : (g |- tunmap A1 K),
      Dunmap :
        (g, x : eterm, a : con, x1 : unmap x a |-
           unmap (M1[.., x]) (C1[.., a]))
    | x : [g |- eof (elam A1 (\z150. M1)) (epi A1 (\z146. A2))],
      unmap : [g |- unmap (elam A1 (\z150. M1)) (lam K (\y507. C1))]
    ; split unmap-wf' [g |- Dwf] [g |- Dtunmap] as
      case unmap-wf'/i:
      { g : unmap-bind,
        A1 : (g |- etp),
        M1 : (g, z : eterm |- eterm),
        A2 : (g, y : eterm |- etp),
        K : (g |- kind),
        C1 : (g, a : con |- con),
        Dwf : (g |- ewf A1),
        Dof :
          (g, x : eterm, x1 : eof x (A1[..]) |- eof (M1[.., x]) (A2[.., x])),
        Dtunmap : (g |- tunmap A1 K),
        Dunmap :
          (g, x : eterm, a : con, x1 : unmap x a |-
             unmap (M1[.., x]) (C1[.., a])),
        Dwf1 : (g |- kd-wf K)
      | x : [g |- eof (elam A1 (\z150. M1)) (epi A1 (\z146. A2))],
        unmap : [g |- unmap (elam A1 (\z150. M1)) (lam K (\y507. C1))]
      ; split
unmap-of
  [g,
   b :
     block (
       a : con,
       da : cn-of a (K[..]),
       x : eterm,
       dx : eof x (A1[..]),
       xt : unmap x a) |- Dof[.., b.3, b.4]]
  [g,
   b :
     block (
       a : con,
       da : cn-of a (K[..]),
       x : eterm,
       dx : eof x (A1[..]),
       xt : unmap x a) |- Dunmap[.., b.3, b.1, b.5]] as
        case unmap-of/i:
        { g : unmap-bind,
          A1 : (g |- etp),
          M1 : (g, z : eterm |- eterm),
          A3 : (g, x : eterm |- etp),
          K : (g |- kind),
          C2 : (g, a : con |- con),
          Dwf : (g |- ewf A1),
          Dof :
            (g, x : eterm, x1 : eof x (A1[..]) |- eof (M1[.., x]) (A3[.., x])),
          Dtunmap : (g |- tunmap A1 K),
          Dunmap :
            (g, x : eterm, a : con, x1 : unmap x a |-
               unmap (M1[.., x]) (C2[.., a])),
          Dwf1 : (g |- kd-wf K),
          K1 : (g, a : con |- kind),
          Dtunmap1 :
            (g, a : con, x : eterm, z1818 : unmap x a |-
               tunmap (A3[.., x]) (K1[.., a])),
          Dof1 :
            (g, a : con, da : cn-of a (K[..]) |-
               cn-of (C2[.., a]) (K1[.., a]))
        | x : [g |- eof (elam A1 (\z150. M1)) (epi A1 (\z146. A3))],
          unmap : [g |- unmap (elam A1 (\z150. M1)) (lam K (\y507. C2))]
        ; solve
            [g |-
               unmap-of/i _
               (tunmap/pi Dtunmap (\x. \a. \xt. Dtunmap1[.., a, x, xt]))
               (cn-of/lam Dwf1 (\a. \da. Dof1))]
        }
      }
    }
  }
  case eof/const:
  { g : unmap-bind,
    K : ( |- constant),
    A : (g |- etp),
    C : (g |- con),
    Dekof : (g |- ekof K[] A),
    Dwf : (g |- ewf A)
  | x : [g |- eof (econst K[]) A], unmap : [g |- unmap (econst K[]) C]
  ; split [ |- K] as
    case const/labeled:
    { g : unmap-bind,
      L : ( |- label),
      A : (g |- etp),
      C : (g |- con),
      Dekof : (g |- ekof (const/labeled L[]) A),
      Dwf : (g |- ewf A)
    | x : [g |- eof (econst (const/labeled L[])) A],
      unmap : [g |- unmap (econst (const/labeled L[])) C]
    ; split unmap as
      case unmap/labeled:
      { g : unmap-bind,
        L : ( |- label),
        A : (g |- etp),
        Dekof : (g |- ekof (const/labeled L[]) A),
        Dwf : (g |- ewf A)
      | x : [g |- eof (econst (const/labeled L[])) A],
        unmap :
          [g |-
             unmap (econst (const/labeled L[])) (lam t (\a. labeled L[] a))]
      ; split [g |- Dekof] as
        case ekof/i:
        { g : unmap-bind,
          L : ( |- label),
          A : (g |- etp),
          A1 : ( |- ctp),
          X : ( |- ckof (const/labeled L) A1),
          Detopen : (g |- etopen A1[] A),
          Dwf : (g |- ewf A)
        | x : [g |- eof (econst (const/labeled L[])) A],
          unmap :
            [g |-
               unmap (econst (const/labeled L[])) (lam t (\a. labeled L[] a))]
        ; split [ |- X] as
          case ckof/labeled:
          { g : unmap-bind,
            L : ( |- label),
            A : (g |- etp),
            Detopen : (g |- etopen (cpi ct (\l. ct)) A),
            Dwf : (g |- ewf A)
          | x : [g |- eof (econst (const/labeled L[])) A],
            unmap :
              [g |-
                 unmap
                   (econst (const/labeled L[])) (lam t (\a. labeled L[] a))]
          ; split [g |- Detopen] as
            case etopen/pi:
            { g : unmap-bind,
              L : ( |- label),
              A2 : (g |- etp),
              A4 : (g, x : eterm |- etp),
              Dskel : ( |- skel),
              Detopen1 : (g |- etopen ct A2),
              Dskel1 : (g |- etp-skel A2 Dskel[]),
              Detopen2 :
                (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   etopen ct (A4[.., x])),
              Dwf : (g |- ewf (epi A2 (\z146. A4)))
            | x :
                [g |- eof (econst (const/labeled L[])) (epi A2 (\z146. A4))],
              unmap :
                [g |-
                   unmap
                     (econst (const/labeled L[])) (lam t (\a. labeled L[] a))]
            ; split [g |- Detopen1] as
              case etopen/t:
              { g : unmap-bind,
                L : ( |- label),
                A4 : (g, x : eterm |- etp),
                Dskel : ( |- skel),
                Dskel1 : (g |- etp-skel et Dskel[]),
                Detopen2 :
                  (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                     etopen ct (A4[.., x])),
                Dwf : (g |- ewf (epi et (\z146. A4)))
              | x :
                  [g |- eof (econst (const/labeled L[])) (epi et (\z146. A4))],
                unmap :
                  [g |-
                     unmap
                       (econst (const/labeled L[]))
                       (lam t (\a. labeled L[] a))]
              ; split
                [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   Detopen2] as
                case etopen/t:
                { g : unmap-bind,
                  L : ( |- label),
                  Dskel : ( |- skel),
                  Dskel1 : (g |- etp-skel et Dskel[]),
                  Dwf : (g |- ewf (epi et (\z146. et)))
                | x :
                    [g |-
                       eof (econst (const/labeled L[])) (epi et (\z146. et))],
                  unmap :
                    [g |-
                       unmap
                         (econst (const/labeled L[]))
                         (lam t (\a. labeled L[] a))]
                ; solve
                    [g |-
                       unmap-of/i _
                       (tunmap/pi tunmap/t (\l1. \l2. \l3. tunmap/t))
                       (cn-of/lam kd-wf/t (\a. \da. cn-of/labeled da))]
                }
              }
            }
          }
        }
      }
    }
    case const/rec:
    { g : unmap-bind,
      Dskel : ( |- skel),
      A : (g |- etp),
      C : (g |- con),
      Dekof : (g |- ekof (const/rec Dskel[]) A),
      Dwf : (g |- ewf A)
    | x : [g |- eof (econst (const/rec Dskel[])) A],
      unmap : [g |- unmap (econst (const/rec Dskel[])) C]
    ; ?
    }
    case const/tagged:
    { g : unmap-bind,
      A : (g |- etp),
      C : (g |- con),
      Dekof : (g |- ekof const/tagged A),
      Dwf : (g |- ewf A)
    | x : [g |- eof (econst const/tagged) A],
      unmap : [g |- unmap (econst const/tagged) C]
    ; split unmap as
      case unmap/tagged:
      { g : unmap-bind,
        A : (g |- etp),
        Dekof : (g |- ekof const/tagged A),
        Dwf : (g |- ewf A)
      | x : [g |- eof (econst const/tagged) A],
        unmap : [g |- unmap (econst const/tagged) tagged]
      ; split [g |- Dekof] as
        case ekof/i:
        { g : unmap-bind,
          A : (g |- etp),
          A1 : ( |- ctp),
          X : ( |- ckof const/tagged A1),
          Detopen : (g |- etopen A1[] A),
          Dwf : (g |- ewf A)
        | x : [g |- eof (econst const/tagged) A],
          unmap : [g |- unmap (econst const/tagged) tagged]
        ; split [ |- X] as
          case ckof/tagged:
          { g : unmap-bind,
            A : (g |- etp),
            Detopen : (g |- etopen ct A),
            Dwf : (g |- ewf A)
          | x : [g |- eof (econst const/tagged) A],
            unmap : [g |- unmap (econst const/tagged) tagged]
          ; split [g |- Detopen] as
            case etopen/t:
            { g : unmap-bind, Dwf : (g |- ewf et)
            | x : [g |- eof (econst const/tagged) et],
              unmap : [g |- unmap (econst const/tagged) tagged]
            ; solve [g |- unmap-of/i _ tunmap/t cn-of/tagged]
            }
          }
        }
      }
    }
    case const/tag:
    { g : unmap-bind,
      A : (g |- etp),
      C : (g |- con),
      Dekof : (g |- ekof const/tag A),
      Dwf : (g |- ewf A)
    | x : [g |- eof (econst const/tag) A],
      unmap : [g |- unmap (econst const/tag) C]
    ; split unmap as
      case unmap/tag:
      { g : unmap-bind,
        A : (g |- etp),
        Dekof : (g |- ekof const/tag A),
        Dwf : (g |- ewf A)
      | x : [g |- eof (econst const/tag) A],
        unmap : [g |- unmap (econst const/tag) (lam t (\a. tag a))]
      ; split [g |- Dekof] as
        case ekof/i:
        { g : unmap-bind,
          A : (g |- etp),
          A1 : ( |- ctp),
          X : ( |- ckof const/tag A1),
          Detopen : (g |- etopen A1[] A),
          Dwf : (g |- ewf A)
        | x : [g |- eof (econst const/tag) A],
          unmap : [g |- unmap (econst const/tag) (lam t (\a. tag a))]
        ; split [ |- X] as
          case ckof/tag:
          { g : unmap-bind,
            A : (g |- etp),
            Detopen : (g |- etopen (cpi ct (\l. ct)) A),
            Dwf : (g |- ewf A)
          | x : [g |- eof (econst const/tag) A],
            unmap : [g |- unmap (econst const/tag) (lam t (\a. tag a))]
          ; split [g |- Detopen] as
            case etopen/pi:
            { g : unmap-bind,
              A2 : (g |- etp),
              A4 : (g, x : eterm |- etp),
              Dskel : ( |- skel),
              Detopen1 : (g |- etopen ct A2),
              Dskel1 : (g |- etp-skel A2 Dskel[]),
              Detopen2 :
                (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   etopen ct (A4[.., x])),
              Dwf : (g |- ewf (epi A2 (\z146. A4)))
            | x : [g |- eof (econst const/tag) (epi A2 (\z146. A4))],
              unmap : [g |- unmap (econst const/tag) (lam t (\a. tag a))]
            ; split [g |- Detopen1] as
              case etopen/t:
              { g : unmap-bind,
                A4 : (g, x : eterm |- etp),
                Dskel : ( |- skel),
                Dskel1 : (g |- etp-skel et Dskel[]),
                Detopen2 :
                  (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                     etopen ct (A4[.., x])),
                Dwf : (g |- ewf (epi et (\z146. A4)))
              | x : [g |- eof (econst const/tag) (epi et (\z146. A4))],
                unmap : [g |- unmap (econst const/tag) (lam t (\a. tag a))]
              ; split
                [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   Detopen2] as
                case etopen/t:
                { g : unmap-bind,
                  Dskel : ( |- skel),
                  Dskel1 : (g |- etp-skel et Dskel[]),
                  Dwf : (g |- ewf (epi et (\z146. et)))
                | x : [g |- eof (econst const/tag) (epi et (\z146. et))],
                  unmap : [g |- unmap (econst const/tag) (lam t (\a. tag a))]
                ; solve
                    [g |-
                       unmap-of/i _
                       (tunmap/pi tunmap/t (\l1. \l2. \l3. tunmap/t))
                       (cn-of/lam kd-wf/t (\a. \da. cn-of/tag da))]
                }
              }
            }
          }
        }
      }
    }
    case const/plus:
    { g : unmap-bind,
      A : (g |- etp),
      C : (g |- con),
      Dekof : (g |- ekof const/plus A),
      Dwf : (g |- ewf A)
    | x : [g |- eof (econst const/plus) A],
      unmap : [g |- unmap (econst const/plus) C]
    ; split unmap as
      case unmap/plus:
      { g : unmap-bind,
        A : (g |- etp),
        Dekof : (g |- ekof const/plus A),
        Dwf : (g |- ewf A)
      | x : [g |- eof (econst const/plus) A],
        unmap :
          [g |- unmap (econst const/plus) (lam t (\a. lam t (\b. plus a b)))]
      ; split [g |- Dekof] as
        case ekof/i:
        { g : unmap-bind,
          A : (g |- etp),
          A1 : ( |- ctp),
          X : ( |- ckof const/plus A1),
          Detopen : (g |- etopen A1[] A),
          Dwf : (g |- ewf A)
        | x : [g |- eof (econst const/plus) A],
          unmap :
            [g |-
               unmap (econst const/plus) (lam t (\a. lam t (\b. plus a b)))]
        ; split [ |- X] as
          case ckof/plus:
          { g : unmap-bind,
            A : (g |- etp),
            Detopen : (g |- etopen (cpi ct (\l1. cpi ct (\l2. ct))) A),
            Dwf : (g |- ewf A)
          | x : [g |- eof (econst const/plus) A],
            unmap :
              [g |-
                 unmap (econst const/plus) (lam t (\a. lam t (\b. plus a b)))]
          ; split [g |- Detopen] as
            case etopen/pi:
            { g : unmap-bind,
              A2 : (g |- etp),
              A4 : (g, x : eterm |- etp),
              Dskel : ( |- skel),
              Detopen1 : (g |- etopen ct A2),
              Dskel1 : (g |- etp-skel A2 Dskel[]),
              Detopen2 :
                (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   etopen (cpi ct (\l2. ct)) (A4[.., x])),
              Dwf : (g |- ewf (epi A2 (\z146. A4)))
            | x : [g |- eof (econst const/plus) (epi A2 (\z146. A4))],
              unmap :
                [g |-
                   unmap
                     (econst const/plus) (lam t (\a. lam t (\b. plus a b)))]
            ; split [g |- Detopen1] as
              case etopen/t:
              { g : unmap-bind,
                A4 : (g, x : eterm |- etp),
                Dskel : ( |- skel),
                Dskel1 : (g |- etp-skel et Dskel[]),
                Detopen2 :
                  (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                     etopen (cpi ct (\l2. ct)) (A4[.., x])),
                Dwf : (g |- ewf (epi et (\z146. A4)))
              | x : [g |- eof (econst const/plus) (epi et (\z146. A4))],
                unmap :
                  [g |-
                     unmap
                       (econst const/plus) (lam t (\a. lam t (\b. plus a b)))]
              ; split
                [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   Detopen2] as
                case etopen/pi:
                { g : unmap-bind,
                  A6 : (g, x : eterm |- etp),
                  A8 : (g, x : eterm, x1 : eterm |- etp),
                  Dskel : ( |- skel),
                  Dskel1 : (g |- etp-skel et Dskel[]),
                  Dskel2 : ( |- skel),
                  Detopen3 :
                    (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                       etopen ct (A6[.., x])),
                  Dskel3 : (g, x : eterm |- etp-skel A6 Dskel2[]),
                  Detopen4 :
                    (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x,
                     xc1 : catom, x1 : eterm,
                     z1 : etopenr xc1 Dskel2[] x1 |-
                       etopen ct (A8[.., x, x1])),
                  Dwf : (g |- ewf (epi et (\z146. epi A6 (\z147. A8))))
                | x :
                    [g |-
                       eof
                         (econst const/plus)
                         (epi et (\z146. epi A6 (\z147. A8)))],
                  unmap :
                    [g |-
                       unmap
                         (econst const/plus)
                         (lam t (\a. lam t (\b. plus a b)))]
                ; split
                  [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                     Detopen3] as
                  case etopen/t:
                  { g : unmap-bind,
                    A8 : (g, x : eterm, x1 : eterm |- etp),
                    Dskel : ( |- skel),
                    Dskel1 : (g |- etp-skel et Dskel[]),
                    Dskel2 : ( |- skel),
                    Dskel3 : (g, x : eterm |- etp-skel et Dskel2[]),
                    Detopen4 :
                      (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x,
                       xc1 : catom, x1 : eterm,
                       z1 : etopenr xc1 Dskel2[] x1 |-
                         etopen ct (A8[.., x, x1])),
                    Dwf : (g |- ewf (epi et (\z146. epi et (\z147. A8))))
                  | x :
                      [g |-
                         eof
                           (econst const/plus)
                           (epi et (\z146. epi et (\z147. A8)))],
                    unmap :
                      [g |-
                         unmap
                           (econst const/plus)
                           (lam t (\a. lam t (\b. plus a b)))]
                  ; split
                    [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x,
                     xc1 : catom, x1 : eterm,
                     z1 : etopenr xc1 Dskel2[] x1 |- Detopen4] as
                    case etopen/t:
                    { g : unmap-bind,
                      Dskel : ( |- skel),
                      Dskel1 : (g |- etp-skel et Dskel[]),
                      Dskel2 : ( |- skel),
                      Dskel3 : (g, x : eterm |- etp-skel et Dskel2[]),
                      Dwf : (g |- ewf (epi et (\z146. epi et (\z147. et))))
                    | x :
                        [g |-
                           eof
                             (econst const/plus)
                             (epi et (\z146. epi et (\z147. et)))],
                      unmap :
                        [g |-
                           unmap
                             (econst const/plus)
                             (lam t (\a. lam t (\b. plus a b)))]
                    ; solve
                        [g |-
                           unmap-of/i _
                           (tunmap/pi tunmap/t
                           (\l1.
                              \l2.
                                \l3.
                                  tunmap/pi tunmap/t
                                  (\l4. \l5. \l6. tunmap/t)))
                           (cn-of/lam kd-wf/t
                           (\a.
                              \da.
                                cn-of/lam kd-wf/t (\b. \db. cn-of/plus da db)))]
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    case const/ref:
    { g : unmap-bind,
      A : (g |- etp),
      C : (g |- con),
      Dekof : (g |- ekof const/ref A),
      Dwf : (g |- ewf A)
    | x : [g |- eof (econst const/ref) A],
      unmap : [g |- unmap (econst const/ref) C]
    ; split unmap as
      case unmap/ref:
      { g : unmap-bind,
        A : (g |- etp),
        Dekof : (g |- ekof const/ref A),
        Dwf : (g |- ewf A)
      | x : [g |- eof (econst const/ref) A],
        unmap : [g |- unmap (econst const/ref) (lam t (\a. ref a))]
      ; split [g |- Dekof] as
        case ekof/i:
        { g : unmap-bind,
          A : (g |- etp),
          A1 : ( |- ctp),
          X : ( |- ckof const/ref A1),
          Detopen : (g |- etopen A1[] A),
          Dwf : (g |- ewf A)
        | x : [g |- eof (econst const/ref) A],
          unmap : [g |- unmap (econst const/ref) (lam t (\a. ref a))]
        ; split [ |- X] as
          case ckof/ref:
          { g : unmap-bind,
            A : (g |- etp),
            Detopen : (g |- etopen (cpi ct (\l. ct)) A),
            Dwf : (g |- ewf A)
          | x : [g |- eof (econst const/ref) A],
            unmap : [g |- unmap (econst const/ref) (lam t (\a. ref a))]
          ; split [g |- Detopen] as
            case etopen/pi:
            { g : unmap-bind,
              A2 : (g |- etp),
              A4 : (g, x : eterm |- etp),
              Dskel : ( |- skel),
              Detopen1 : (g |- etopen ct A2),
              Dskel1 : (g |- etp-skel A2 Dskel[]),
              Detopen2 :
                (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   etopen ct (A4[.., x])),
              Dwf : (g |- ewf (epi A2 (\z146. A4)))
            | x : [g |- eof (econst const/ref) (epi A2 (\z146. A4))],
              unmap : [g |- unmap (econst const/ref) (lam t (\a. ref a))]
            ; split [g |- Detopen1] as
              case etopen/t:
              { g : unmap-bind,
                A4 : (g, x : eterm |- etp),
                Dskel : ( |- skel),
                Dskel1 : (g |- etp-skel et Dskel[]),
                Detopen2 :
                  (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                     etopen ct (A4[.., x])),
                Dwf : (g |- ewf (epi et (\z146. A4)))
              | x : [g |- eof (econst const/ref) (epi et (\z146. A4))],
                unmap : [g |- unmap (econst const/ref) (lam t (\a. ref a))]
              ; split
                [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   Detopen2] as
                case etopen/t:
                { g : unmap-bind,
                  Dskel : ( |- skel),
                  Dskel1 : (g |- etp-skel et Dskel[]),
                  Dwf : (g |- ewf (epi et (\z146. et)))
                | x : [g |- eof (econst const/ref) (epi et (\z146. et))],
                  unmap : [g |- unmap (econst const/ref) (lam t (\a. ref a))]
                ; solve
                    [g |-
                       unmap-of/i _
                       (tunmap/pi tunmap/t (\l1. \l2. \l3. tunmap/t))
                       (cn-of/lam kd-wf/t (\a. \da. cn-of/ref da))]
                }
              }
            }
          }
        }
      }
    }
    case const/void:
    { g : unmap-bind,
      A : (g |- etp),
      C : (g |- con),
      Dekof : (g |- ekof const/void A),
      Dwf : (g |- ewf A)
    | x : [g |- eof (econst const/void) A],
      unmap : [g |- unmap (econst const/void) C]
    ; split unmap as
      case unmap/void:
      { g : unmap-bind,
        A : (g |- etp),
        Dekof : (g |- ekof const/void A),
        Dwf : (g |- ewf A)
      | x : [g |- eof (econst const/void) A],
        unmap : [g |- unmap (econst const/void) void]
      ; split [g |- Dekof] as
        case ekof/i:
        { g : unmap-bind,
          A : (g |- etp),
          A1 : ( |- ctp),
          X : ( |- ckof const/void A1),
          Detopen : (g |- etopen A1[] A),
          Dwf : (g |- ewf A)
        | x : [g |- eof (econst const/void) A],
          unmap : [g |- unmap (econst const/void) void]
        ; split [ |- X] as
          case ckof/void:
          { g : unmap-bind,
            A : (g |- etp),
            Detopen : (g |- etopen ct A),
            Dwf : (g |- ewf A)
          | x : [g |- eof (econst const/void) A],
            unmap : [g |- unmap (econst const/void) void]
          ; split [g |- Detopen] as
            case etopen/t:
            { g : unmap-bind, Dwf : (g |- ewf et)
            | x : [g |- eof (econst const/void) et],
              unmap : [g |- unmap (econst const/void) void]
            ; solve [g |- unmap-of/i _ tunmap/t cn-of/void]
            }
          }
        }
      }
    }
    case const/unit:
    { g : unmap-bind,
      A : (g |- etp),
      C : (g |- con),
      Dekof : (g |- ekof const/unit A),
      Dwf : (g |- ewf A)
    | x : [g |- eof (econst const/unit) A],
      unmap : [g |- unmap (econst const/unit) C]
    ; split unmap as
      case unmap/unit:
      { g : unmap-bind,
        A : (g |- etp),
        Dekof : (g |- ekof const/unit A),
        Dwf : (g |- ewf A)
      | x : [g |- eof (econst const/unit) A],
        unmap : [g |- unmap (econst const/unit) unit]
      ; split [g |- Dekof] as
        case ekof/i:
        { g : unmap-bind,
          A : (g |- etp),
          A1 : ( |- ctp),
          X : ( |- ckof const/unit A1),
          Detopen : (g |- etopen A1[] A),
          Dwf : (g |- ewf A)
        | x : [g |- eof (econst const/unit) A],
          unmap : [g |- unmap (econst const/unit) unit]
        ; split [ |- X] as
          case ckof/unit:
          { g : unmap-bind,
            A : (g |- etp),
            Detopen : (g |- etopen ct A),
            Dwf : (g |- ewf A)
          | x : [g |- eof (econst const/unit) A],
            unmap : [g |- unmap (econst const/unit) unit]
          ; split [g |- Detopen] as
            case etopen/t:
            { g : unmap-bind, Dwf : (g |- ewf et)
            | x : [g |- eof (econst const/unit) et],
              unmap : [g |- unmap (econst const/unit) unit]
            ; solve [g |- unmap-of/i _ tunmap/t cn-of/unit]
            }
          }
        }
      }
    }
    case const/prod:
    { g : unmap-bind,
      A : (g |- etp),
      C : (g |- con),
      Dekof : (g |- ekof const/prod A),
      Dwf : (g |- ewf A)
    | x : [g |- eof (econst const/prod) A],
      unmap : [g |- unmap (econst const/prod) C]
    ; split unmap as
      case unmap/prod:
      { g : unmap-bind,
        A : (g |- etp),
        Dekof : (g |- ekof const/prod A),
        Dwf : (g |- ewf A)
      | x : [g |- eof (econst const/prod) A],
        unmap :
          [g |- unmap (econst const/prod) (lam t (\a. lam t (\b. prod a b)))]
      ; split [g |- Dekof] as
        case ekof/i:
        { g : unmap-bind,
          A : (g |- etp),
          A1 : ( |- ctp),
          X : ( |- ckof const/prod A1),
          Detopen : (g |- etopen A1[] A),
          Dwf : (g |- ewf A)
        | x : [g |- eof (econst const/prod) A],
          unmap :
            [g |-
               unmap (econst const/prod) (lam t (\a. lam t (\b. prod a b)))]
        ; split [ |- X] as
          case ckof/prod:
          { g : unmap-bind,
            A : (g |- etp),
            Detopen : (g |- etopen (cpi ct (\l1. cpi ct (\l2. ct))) A),
            Dwf : (g |- ewf A)
          | x : [g |- eof (econst const/prod) A],
            unmap :
              [g |-
                 unmap (econst const/prod) (lam t (\a. lam t (\b. prod a b)))]
          ; split [g |- Detopen] as
            case etopen/pi:
            { g : unmap-bind,
              A2 : (g |- etp),
              A4 : (g, x : eterm |- etp),
              Dskel : ( |- skel),
              Detopen1 : (g |- etopen ct A2),
              Dskel1 : (g |- etp-skel A2 Dskel[]),
              Detopen2 :
                (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   etopen (cpi ct (\l2. ct)) (A4[.., x])),
              Dwf : (g |- ewf (epi A2 (\z146. A4)))
            | x : [g |- eof (econst const/prod) (epi A2 (\z146. A4))],
              unmap :
                [g |-
                   unmap
                     (econst const/prod) (lam t (\a. lam t (\b. prod a b)))]
            ; split [g |- Detopen1] as
              case etopen/t:
              { g : unmap-bind,
                A4 : (g, x : eterm |- etp),
                Dskel : ( |- skel),
                Dskel1 : (g |- etp-skel et Dskel[]),
                Detopen2 :
                  (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                     etopen (cpi ct (\l2. ct)) (A4[.., x])),
                Dwf : (g |- ewf (epi et (\z146. A4)))
              | x : [g |- eof (econst const/prod) (epi et (\z146. A4))],
                unmap :
                  [g |-
                     unmap
                       (econst const/prod) (lam t (\a. lam t (\b. prod a b)))]
              ; split
                [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   Detopen2] as
                case etopen/pi:
                { g : unmap-bind,
                  A6 : (g, x : eterm |- etp),
                  A8 : (g, x : eterm, x1 : eterm |- etp),
                  Dskel : ( |- skel),
                  Dskel1 : (g |- etp-skel et Dskel[]),
                  Dskel2 : ( |- skel),
                  Detopen3 :
                    (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                       etopen ct (A6[.., x])),
                  Dskel3 : (g, x : eterm |- etp-skel A6 Dskel2[]),
                  Detopen4 :
                    (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x,
                     xc1 : catom, x1 : eterm,
                     z1 : etopenr xc1 Dskel2[] x1 |-
                       etopen ct (A8[.., x, x1])),
                  Dwf : (g |- ewf (epi et (\z146. epi A6 (\z147. A8))))
                | x :
                    [g |-
                       eof
                         (econst const/prod)
                         (epi et (\z146. epi A6 (\z147. A8)))],
                  unmap :
                    [g |-
                       unmap
                         (econst const/prod)
                         (lam t (\a. lam t (\b. prod a b)))]
                ; split
                  [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                     Detopen3] as
                  case etopen/t:
                  { g : unmap-bind,
                    A8 : (g, x : eterm, x1 : eterm |- etp),
                    Dskel : ( |- skel),
                    Dskel1 : (g |- etp-skel et Dskel[]),
                    Dskel2 : ( |- skel),
                    Dskel3 : (g, x : eterm |- etp-skel et Dskel2[]),
                    Detopen4 :
                      (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x,
                       xc1 : catom, x1 : eterm,
                       z1 : etopenr xc1 Dskel2[] x1 |-
                         etopen ct (A8[.., x, x1])),
                    Dwf : (g |- ewf (epi et (\z146. epi et (\z147. A8))))
                  | x :
                      [g |-
                         eof
                           (econst const/prod)
                           (epi et (\z146. epi et (\z147. A8)))],
                    unmap :
                      [g |-
                         unmap
                           (econst const/prod)
                           (lam t (\a. lam t (\b. prod a b)))]
                  ; split
                    [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x,
                     xc1 : catom, x1 : eterm,
                     z1 : etopenr xc1 Dskel2[] x1 |- Detopen4] as
                    case etopen/t:
                    { g : unmap-bind,
                      Dskel : ( |- skel),
                      Dskel1 : (g |- etp-skel et Dskel[]),
                      Dskel2 : ( |- skel),
                      Dskel3 : (g, x : eterm |- etp-skel et Dskel2[]),
                      Dwf : (g |- ewf (epi et (\z146. epi et (\z147. et))))
                    | x :
                        [g |-
                           eof
                             (econst const/prod)
                             (epi et (\z146. epi et (\z147. et)))],
                      unmap :
                        [g |-
                           unmap
                             (econst const/prod)
                             (lam t (\a. lam t (\b. prod a b)))]
                    ; solve
                        [g |-
                           unmap-of/i _
                           (tunmap/pi tunmap/t
                           (\l1.
                              \l2.
                                \l3.
                                  tunmap/pi tunmap/t
                                  (\l4. \l5. \l6. tunmap/t)))
                           (cn-of/lam kd-wf/t
                           (\a.
                              \da.
                                cn-of/lam kd-wf/t (\b. \db. cn-of/prod da db)))]
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    case const/arrow:
    { g : unmap-bind,
      A : (g |- etp),
      C : (g |- con),
      Dekof : (g |- ekof const/arrow A),
      Dwf : (g |- ewf A)
    | x : [g |- eof (econst const/arrow) A],
      unmap : [g |- unmap (econst const/arrow) C]
    ; split unmap as
      case unmap/arrow:
      { g : unmap-bind,
        A : (g |- etp),
        Dekof : (g |- ekof const/arrow A),
        Dwf : (g |- ewf A)
      | x : [g |- eof (econst const/arrow) A],
        unmap :
          [g |-
             unmap (econst const/arrow) (lam t (\a. lam t (\b. arrow a b)))]
      ; split [g |- Dekof] as
        case ekof/i:
        { g : unmap-bind,
          A : (g |- etp),
          A1 : ( |- ctp),
          X : ( |- ckof const/arrow A1),
          Detopen : (g |- etopen A1[] A),
          Dwf : (g |- ewf A)
        | x : [g |- eof (econst const/arrow) A],
          unmap :
            [g |-
               unmap (econst const/arrow) (lam t (\a. lam t (\b. arrow a b)))]
        ; split [ |- X] as
          case ckof/arrow:
          { g : unmap-bind,
            A : (g |- etp),
            Detopen : (g |- etopen (cpi ct (\l1. cpi ct (\l2. ct))) A),
            Dwf : (g |- ewf A)
          | x : [g |- eof (econst const/arrow) A],
            unmap :
              [g |-
                 unmap
                   (econst const/arrow) (lam t (\a. lam t (\b. arrow a b)))]
          ; split [g |- Detopen] as
            case etopen/pi:
            { g : unmap-bind,
              A2 : (g |- etp),
              A4 : (g, x : eterm |- etp),
              Dskel : ( |- skel),
              Detopen1 : (g |- etopen ct A2),
              Dskel1 : (g |- etp-skel A2 Dskel[]),
              Detopen2 :
                (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   etopen (cpi ct (\l2. ct)) (A4[.., x])),
              Dwf : (g |- ewf (epi A2 (\z146. A4)))
            | x : [g |- eof (econst const/arrow) (epi A2 (\z146. A4))],
              unmap :
                [g |-
                   unmap
                     (econst const/arrow) (lam t (\a. lam t (\b. arrow a b)))]
            ; split [g |- Detopen1] as
              case etopen/t:
              { g : unmap-bind,
                A4 : (g, x : eterm |- etp),
                Dskel : ( |- skel),
                Dskel1 : (g |- etp-skel et Dskel[]),
                Detopen2 :
                  (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                     etopen (cpi ct (\l2. ct)) (A4[.., x])),
                Dwf : (g |- ewf (epi et (\z146. A4)))
              | x : [g |- eof (econst const/arrow) (epi et (\z146. A4))],
                unmap :
                  [g |-
                     unmap
                       (econst const/arrow)
                       (lam t (\a. lam t (\b. arrow a b)))]
              ; split
                [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                   Detopen2] as
                case etopen/pi:
                { g : unmap-bind,
                  A6 : (g, x : eterm |- etp),
                  A8 : (g, x : eterm, x1 : eterm |- etp),
                  Dskel : ( |- skel),
                  Dskel1 : (g |- etp-skel et Dskel[]),
                  Dskel2 : ( |- skel),
                  Detopen3 :
                    (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                       etopen ct (A6[.., x])),
                  Dskel3 : (g, x : eterm |- etp-skel A6 Dskel2[]),
                  Detopen4 :
                    (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x,
                     xc1 : catom, x1 : eterm,
                     z1 : etopenr xc1 Dskel2[] x1 |-
                       etopen ct (A8[.., x, x1])),
                  Dwf : (g |- ewf (epi et (\z146. epi A6 (\z147. A8))))
                | x :
                    [g |-
                       eof
                         (econst const/arrow)
                         (epi et (\z146. epi A6 (\z147. A8)))],
                  unmap :
                    [g |-
                       unmap
                         (econst const/arrow)
                         (lam t (\a. lam t (\b. arrow a b)))]
                ; split
                  [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x |-
                     Detopen3] as
                  case etopen/t:
                  { g : unmap-bind,
                    A8 : (g, x : eterm, x1 : eterm |- etp),
                    Dskel : ( |- skel),
                    Dskel1 : (g |- etp-skel et Dskel[]),
                    Dskel2 : ( |- skel),
                    Dskel3 : (g, x : eterm |- etp-skel et Dskel2[]),
                    Detopen4 :
                      (g, xc : catom, x : eterm, z : etopenr xc Dskel[] x,
                       xc1 : catom, x1 : eterm,
                       z1 : etopenr xc1 Dskel2[] x1 |-
                         etopen ct (A8[.., x, x1])),
                    Dwf : (g |- ewf (epi et (\z146. epi et (\z147. A8))))
                  | x :
                      [g |-
                         eof
                           (econst const/arrow)
                           (epi et (\z146. epi et (\z147. A8)))],
                    unmap :
                      [g |-
                         unmap
                           (econst const/arrow)
                           (lam t (\a. lam t (\b. arrow a b)))]
                  ; split
                    [g, xc : catom, x : eterm, z : etopenr xc Dskel[] x,
                     xc1 : catom, x1 : eterm,
                     z1 : etopenr xc1 Dskel2[] x1 |- Detopen4] as
                    case etopen/t:
                    { g : unmap-bind,
                      Dskel : ( |- skel),
                      Dskel1 : (g |- etp-skel et Dskel[]),
                      Dskel2 : ( |- skel),
                      Dskel3 : (g, x : eterm |- etp-skel et Dskel2[]),
                      Dwf : (g |- ewf (epi et (\z146. epi et (\z147. et))))
                    | x :
                        [g |-
                           eof
                             (econst const/arrow)
                             (epi et (\z146. epi et (\z147. et)))],
                      unmap :
                        [g |-
                           unmap
                             (econst const/arrow)
                             (lam t (\a. lam t (\b. arrow a b)))]
                    ; solve
                        [g |-
                           unmap-of/i _
                           (tunmap/pi tunmap/t
                           (\l1.
                              \l2.
                                \l3.
                                  tunmap/pi tunmap/t
                                  (\l4. \l5. \l6. tunmap/t)))
                           (cn-of/lam kd-wf/t
                           (\a.
                              \da.
                                cn-of/lam kd-wf/t
                                (\b. \db. cn-of/arrow da db)))]
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  case #.4:
  { g : unmap-bind,
    K1348 : (g |- kind),
    A : (g |- etp),
    #unmap :
      #(g |-
          block (
            a : con,
            da : cn-of a (K1348[..]),
            x : eterm,
            dx : eof x (A[..]),
            xt : unmap x a)),
    C : (g |- con),
    Dtunmap27 : (g |- tunmap A K1348),
    Dwf201 : (g |- kd-wf K1348)
  | x : [g |- eof #unmap.3 A], unmap : [g |- unmap #unmap.3 C]
  ; split unmap as
    case #.5:
    { g : unmap-bind,
      K1348 : (g |- kind),
      A : (g |- etp),
      #unmap :
        #(g |-
            block (
              a : con,
              da : cn-of a (K1348[..]),
              x : eterm,
              dx : eof x (A[..]),
              xt : unmap x a)),
      Dtunmap27 : (g |- tunmap A K1348),
      Dwf201 : (g |- kd-wf K1348),
      Dtunmap32 : (g |- tunmap A K1348),
      Dwf203 : (g |- kd-wf K1348)
    | x : [g |- eof #unmap.3 A], unmap : [g |- unmap #unmap.3 #unmap.1]
    ; solve [g |- unmap-of/i _ Dtunmap27 #unmap.2]
    }
  }
}

and proof unmap-of' :
  (g : unmap-bind)
  [g |- eof M A] ->
  [g |- unmap M C] ->
  [g |- tunmap A K] ->
    [g |- unmap-of'/e C K] =
/ total 1 /
intros
{ g : unmap-bind,
  M : (g |- eterm),
  A : (g |- etp),
  C : (g |- con),
  K : (g |- kind)
| x : [g |- eof M A], unmap : [g |- unmap M C], tunmap : [g |- tunmap A K]
; split unmap-of x unmap as
  case unmap-of/i:
  { g : unmap-bind,
    M : (g |- eterm),
    A : (g |- etp),
    C : (g |- con),
    K : (g |- kind),
    K1 : (g |- kind),
    Dtunmap : (g |- tunmap A K1),
    Dof : (g |- cn-of C K1)
  | x : [g |- eof M A], unmap : [g |- unmap M C], tunmap : [g |- tunmap A K]
  ; split tunmap-fun tunmap [_ |- Dtunmap] as
    case kind-eq/i:
    { g : unmap-bind,
      M : (g |- eterm),
      A : (g |- etp),
      C : (g |- con),
      K1 : (g |- kind),
      Dtunmap : (g |- tunmap A K1),
      Dof : (g |- cn-of C K1)
    | x : [g |- eof M A],
      unmap : [g |- unmap M C],
      tunmap : [g |- tunmap A K1]
    ; solve [_ |- unmap-of'/i Dof]
    }
  }
}

and proof unmap-wf :
  (g : unmap-bind)
  [g |- ewf A] ->
    [g |- unmap-wf/e A] =
/ total 1 /
intros
{ g : unmap-bind, A : (g |- etp)
| x : [g |- ewf A]
; split x as
  case ewf/one:
  { g : unmap-bind
  | x : [g |- ewf eone]
  ; solve [_ |- unmap-wf/i _ tunmap/one kd-wf/one]
  }
  case ewf/sing:
  { g : unmap-bind, M : (g |- eterm), Dof : (g |- eof M et)
  | x : [g |- ewf (esing M)]
  ; split can-unmap [_ |- M] as
    case can-unmap/i:
    { g : unmap-bind,
      M : (g |- eterm),
      Dof : (g |- eof M et),
      C : (g |- con),
      Dunmap : (g |- unmap M C)
    | x : [g |- ewf (esing M)]
    ; split unmap-of [_ |- Dof] [_ |- Dunmap] as
      case unmap-of/i:
      { g : unmap-bind,
        M : (g |- eterm),
        Dof : (g |- eof M et),
        C : (g |- con),
        Dunmap : (g |- unmap M C),
        K : (g |- kind),
        Dtunmap : (g |- tunmap et K),
        Dof1 : (g |- cn-of C K)
      | x : [g |- ewf (esing M)]
      ; split [_ |- Dtunmap] as
        case tunmap/t:
        { g : unmap-bind,
          M : (g |- eterm),
          Dof : (g |- eof M et),
          C : (g |- con),
          Dunmap : (g |- unmap M C),
          Dof1 : (g |- cn-of C t)
        | x : [g |- ewf (esing M)]
        ; solve [_ |- unmap-wf/i _ (tunmap/sing Dunmap) (kd-wf/sing Dof1)]
        }
      }
    }
  }
  case ewf/sigma:
  { g : unmap-bind,
    A1 : (g |- etp),
    A2 : (g, x : eterm |- etp),
    Dwf : (g |- ewf A1),
    Dwf1 : (g, x : eterm, y : eof x (A1[..]) |- ewf (A2[.., x]))
  | x : [g |- ewf (esigma A1 (\z147. A2))]
  ; split unmap-wf [_ |- Dwf] as
    case unmap-wf/i:
    { g : unmap-bind,
      A1 : (g |- etp),
      A2 : (g, x : eterm |- etp),
      Dwf : (g |- ewf A1),
      Dwf1 : (g, x : eterm, y : eof x (A1[..]) |- ewf (A2[.., x])),
      K : (g |- kind),
      Dtunmap : (g |- tunmap A1 K),
      Dwf2 : (g |- kd-wf K)
    | x : [g |- ewf (esigma A1 (\z147. A2))]
    ; split
      unmap-wf
        [_,
         b :
           block (
             a : con,
             da : cn-of a (K[..]),
             x : eterm,
             dx : eof x (A1[..]),
             xt : unmap x a) |- Dwf1[.., b.3, b.4]] as
      case unmap-wf/i:
      { g : unmap-bind,
        A1 : (g |- etp),
        A3 : (g, x : eterm |- etp),
        Dwf : (g |- ewf A1),
        Dwf1 : (g, x : eterm, y : eof x (A1[..]) |- ewf (A3[.., x])),
        K : (g |- kind),
        Dtunmap : (g |- tunmap A1 K),
        Dwf2 : (g |- kd-wf K),
        K1 : (g, a : con |- kind),
        Dtunmap1 :
          (g, a : con, x : eterm, z7 : unmap x a |-
             tunmap (A3[.., x]) (K1[.., a])),
        Dwf3 : (g, a : con, da : cn-of a (K[..]) |- kd-wf (K1[.., a]))
      | x : [g |- ewf (esigma A1 (\z147. A3))]
      ; solve
          [_ |-
             unmap-wf/i _
             (tunmap/sigma Dtunmap (\x. \a. \xt. Dtunmap1[.., a, x, xt]))
             (kd-wf/sigma Dwf2 (\a. \da. Dwf3))]
      }
    }
  }
  case ewf/pi:
  { g : unmap-bind,
    A1 : (g |- etp),
    A2 : (g, y : eterm |- etp),
    Dwf : (g |- ewf A1),
    Dwf1 : (g, x : eterm, z : eof x (A1[..]) |- ewf (A2[.., x]))
  | x : [g |- ewf (epi A1 (\z146. A2))]
  ; split unmap-wf [_ |- Dwf] as
    case unmap-wf/i:
    { g : unmap-bind,
      A1 : (g |- etp),
      A2 : (g, y : eterm |- etp),
      Dwf : (g |- ewf A1),
      Dwf1 : (g, x : eterm, z : eof x (A1[..]) |- ewf (A2[.., x])),
      K : (g |- kind),
      Dtunmap : (g |- tunmap A1 K),
      Dwf2 : (g |- kd-wf K)
    | x : [g |- ewf (epi A1 (\z146. A2))]
    ; split
      unmap-wf
        [_,
         b :
           block (
             a : con,
             da : cn-of a (K[..]),
             x : eterm,
             dx : eof x (A1[..]),
             xt : unmap x a) |- Dwf1[.., b.3, b.4]] as
      case unmap-wf/i:
      { g : unmap-bind,
        A1 : (g |- etp),
        A3 : (g, x : eterm |- etp),
        Dwf : (g |- ewf A1),
        Dwf1 : (g, x : eterm, z : eof x (A1[..]) |- ewf (A3[.., x])),
        K : (g |- kind),
        Dtunmap : (g |- tunmap A1 K),
        Dwf2 : (g |- kd-wf K),
        K1 : (g, a : con |- kind),
        Dtunmap1 :
          (g, a : con, x : eterm, x13 : unmap x a |-
             tunmap (A3[.., x]) (K1[.., a])),
        Dwf3 : (g, a : con, da : cn-of a (K[..]) |- kd-wf (K1[.., a]))
      | x : [g |- ewf (epi A1 (\z146. A3))]
      ; solve
          [_ |-
             unmap-wf/i _
             (tunmap/pi Dtunmap (\x. \a. \xt. Dtunmap1[.., a, x, xt]))
             (kd-wf/pi Dwf2 (\a. \da. Dwf3))]
      }
    }
  }
  case ewf/t:
  { g : unmap-bind
  | x : [g |- ewf et]
  ; solve [_ |- unmap-wf/i _ tunmap/t kd-wf/t]
  }
}

and proof unmap-wf' :
  (g : unmap-bind)
  [g |- ewf A] ->
  [g |- tunmap A K] ->
    [g |- unmap-wf'/e K] =
/ total /
intros
{ g : unmap-bind, A : (g |- etp), K : (g |- kind)
| wf : [g |- ewf A], tunmap : [g |- tunmap A K]
; split unmap-wf wf as
  case unmap-wf/i:
  { g : unmap-bind,
    A : (g |- etp),
    K : (g |- kind),
    K1 : (g |- kind),
    Dtunmap : (g |- tunmap A K1),
    Dwf : (g |- kd-wf K1)
  | wf : [g |- ewf A], tunmap : [g |- tunmap A K]
  ; split tunmap-fun tunmap [_ |- Dtunmap] as
    case kind-eq/i:
    { g : unmap-bind,
      A : (g |- etp),
      K1 : (g |- kind),
      Dtunmap : (g |- tunmap A K1),
      Dwf : (g |- kd-wf K1)
    | wf : [g |- ewf A], tunmap : [g |- tunmap A K1]
    ; solve [_ |- unmap-wf'/i Dwf]
    }
  }
}

and proof unmap-subtp :
  (g : unmap-bind)
  [g |- subtp A B] ->
  [g |- tunmap A K] ->
  [g |- tunmap B L] ->
    [g |- unmap-subtp/e K L] =
/ total 1 /
intros
{ g : unmap-bind,
  A : (g |- etp),
  B : (g |- etp),
  K : (g |- kind),
  L : (g |- kind)
| x : [g |- subtp A B],
  tunmap : [g |- tunmap A K],
  tunmap1 : [g |- tunmap B L]
; split x as
  case subtp/sigma:
  { g : unmap-bind,
    A1 : (g |- etp),
    A3 : (g, y : eterm |- etp),
    A2 : (g |- etp),
    A4 : (g, x : eterm |- etp),
    K : (g |- kind),
    L : (g |- kind),
    Dsub : (g |- subtp A1 A2),
    Dsub1 :
      (g, x : eterm, z : eof x (A1[..]) |- subtp (A3[.., x]) (A4[.., x])),
    Dwf : (g, x : eterm, x1 : eof x (A2[..]) |- ewf (A4[.., x]))
  | x : [g |- subtp (esigma A1 (\z147. A3)) (esigma A2 (\z147. A4))],
    tunmap : [g |- tunmap (esigma A1 (\z147. A3)) K],
    tunmap1 : [g |- tunmap (esigma A2 (\z147. A4)) L]
  ; split tunmap as
    case tunmap/sigma:
    { g : unmap-bind,
      A1 : (g |- etp),
      A3 : (g, y : eterm |- etp),
      A2 : (g |- etp),
      A4 : (g, x : eterm |- etp),
      K1 : (g |- kind),
      K2 : (g, a : con |- kind),
      L : (g |- kind),
      Dsub : (g |- subtp A1 A2),
      Dsub1 :
        (g, x : eterm, z : eof x (A1[..]) |- subtp (A3[.., x]) (A4[.., x])),
      Dwf : (g, x : eterm, x1 : eof x (A2[..]) |- ewf (A4[.., x])),
      Dtunmap : (g |- tunmap A1 K1),
      Dtunmap1 :
        (g, x : eterm, a : con, x1 : unmap x a |-
           tunmap (A3[.., x]) (K2[.., a]))
    | x : [g |- subtp (esigma A1 (\z147. A3)) (esigma A2 (\z147. A4))],
      tunmap : [g |- tunmap (esigma A1 (\z147. A3)) (sigma K1 (\z504. K2))],
      tunmap1 : [g |- tunmap (esigma A2 (\z147. A4)) L]
    ; split tunmap1 as
      case tunmap/sigma:
      { g : unmap-bind,
        A1 : (g |- etp),
        A3 : (g, y : eterm |- etp),
        A2 : (g |- etp),
        A4 : (g, x : eterm |- etp),
        K1 : (g |- kind),
        K2 : (g, a : con |- kind),
        K3 : (g |- kind),
        K4 : (g, a : con |- kind),
        Dsub : (g |- subtp A1 A2),
        Dsub1 :
          (g, x : eterm, z : eof x (A1[..]) |- subtp (A3[.., x]) (A4[.., x])),
        Dwf : (g, x : eterm, x1 : eof x (A2[..]) |- ewf (A4[.., x])),
        Dtunmap : (g |- tunmap A1 K1),
        Dtunmap1 :
          (g, x : eterm, a : con, x1 : unmap x a |-
             tunmap (A3[.., x]) (K2[.., a])),
        Dtunmap2 : (g |- tunmap A2 K3),
        Dtunmap3 :
          (g, x : eterm, a : con, x1 : unmap x a |-
             tunmap (A4[.., x]) (K4[.., a]))
      | x : [g |- subtp (esigma A1 (\z147. A3)) (esigma A2 (\z147. A4))],
        tunmap : [g |- tunmap (esigma A1 (\z147. A3)) (sigma K1 (\z504. K2))],
        tunmap1 :
          [g |- tunmap (esigma A2 (\z147. A4)) (sigma K3 (\z504. K4))]
      ; split unmap-subtp [_ |- Dsub] [_ |- Dtunmap] [_ |- Dtunmap2] as
        case unmap-subtp/i:
        { g : unmap-bind,
          A1 : (g |- etp),
          A3 : (g, y : eterm |- etp),
          A2 : (g |- etp),
          A4 : (g, x : eterm |- etp),
          K1 : (g |- kind),
          K2 : (g, a : con |- kind),
          K3 : (g |- kind),
          K4 : (g, a : con |- kind),
          Dsub : (g |- subtp A1 A2),
          Dsub1 :
            (g, x : eterm, z : eof x (A1[..]) |-
               subtp (A3[.., x]) (A4[.., x])),
          Dwf : (g, x : eterm, x1 : eof x (A2[..]) |- ewf (A4[.., x])),
          Dtunmap : (g |- tunmap A1 K1),
          Dtunmap1 :
            (g, x : eterm, a : con, x1 : unmap x a |-
               tunmap (A3[.., x]) (K2[.., a])),
          Dtunmap2 : (g |- tunmap A2 K3),
          Dtunmap3 :
            (g, x : eterm, a : con, x1 : unmap x a |-
               tunmap (A4[.., x]) (K4[.., a])),
          Dsub2 : (g |- kd-sub K1 K3)
        | x : [g |- subtp (esigma A1 (\z147. A3)) (esigma A2 (\z147. A4))],
          tunmap :
            [g |- tunmap (esigma A1 (\z147. A3)) (sigma K1 (\z504. K2))],
          tunmap1 :
            [g |- tunmap (esigma A2 (\z147. A4)) (sigma K3 (\z504. K4))]
        ; split
          unmap-subtp
            [_,
             b :
               block (
                 a : con,
                 da : cn-of a (K1[..]),
                 x : eterm,
                 dx : eof x (A1[..]),
                 xt : unmap x a) |- Dsub1[.., b.3, b.4]]
            [_,
             b :
               block (
                 a : con,
                 da : cn-of a (K1[..]),
                 x : eterm,
                 dx : eof x (A1[..]),
                 xt : unmap x a) |- Dtunmap1[.., b.3, b.1, b.5]]
            [_,
             b :
               block (
                 a : con,
                 da : cn-of a (K1[..]),
                 x : eterm,
                 dx : eof x (A1[..]),
                 xt : unmap x a) |- Dtunmap3[.., b.3, b.1, b.5]] as
          case unmap-subtp/i:
          { g : unmap-bind,
            A1 : (g |- etp),
            A3 : (g, y : eterm |- etp),
            A2 : (g |- etp),
            A4 : (g, x : eterm |- etp),
            K1 : (g |- kind),
            K5 : (g, a : con |- kind),
            K3 : (g |- kind),
            K6 : (g, a : con |- kind),
            Dsub : (g |- subtp A1 A2),
            Dsub1 :
              (g, x : eterm, z : eof x (A1[..]) |-
                 subtp (A3[.., x]) (A4[.., x])),
            Dwf : (g, x : eterm, x1 : eof x (A2[..]) |- ewf (A4[.., x])),
            Dtunmap : (g |- tunmap A1 K1),
            Dtunmap1 :
              (g, x : eterm, a : con, x1 : unmap x a |-
                 tunmap (A3[.., x]) (K5[.., a])),
            Dtunmap2 : (g |- tunmap A2 K3),
            Dtunmap3 :
              (g, x : eterm, a : con, x1 : unmap x a |-
                 tunmap (A4[.., x]) (K6[.., a])),
            Dsub2 : (g |- kd-sub K1 K3),
            Dsub3 :
              (g, a : con, da : cn-of a (K1[..]) |-
                 kd-sub (K5[.., a]) (K6[.., a]))
          | x : [g |- subtp (esigma A1 (\z147. A3)) (esigma A2 (\z147. A4))],
            tunmap :
              [g |- tunmap (esigma A1 (\z147. A3)) (sigma K1 (\z504. K5))],
            tunmap1 :
              [g |- tunmap (esigma A2 (\z147. A4)) (sigma K3 (\z504. K6))]
          ; split
            unmap-wf'
              [_,
               b :
                 block (
                   a : con,
                   da : cn-of a (K3[..]),
                   x : eterm,
                   dx : eof x (A2[..]),
                   xt : unmap x a) |- Dwf[.., b.3, b.4]]
              [_,
               b :
                 block (
                   a : con,
                   da : cn-of a (K3[..]),
                   x : eterm,
                   dx : eof x (A2[..]),
                   xt : unmap x a) |- Dtunmap3[.., b.3, b.1, b.5]] as
            case unmap-wf'/i:
            { g : unmap-bind,
              A1 : (g |- etp),
              A3 : (g, y : eterm |- etp),
              A2 : (g |- etp),
              A4 : (g, x : eterm |- etp),
              K1 : (g |- kind),
              K5 : (g, a : con |- kind),
              K3 : (g |- kind),
              K7 : (g, a : con |- kind),
              Dsub : (g |- subtp A1 A2),
              Dsub1 :
                (g, x : eterm, z : eof x (A1[..]) |-
                   subtp (A3[.., x]) (A4[.., x])),
              Dwf : (g, x : eterm, x1 : eof x (A2[..]) |- ewf (A4[.., x])),
              Dtunmap : (g |- tunmap A1 K1),
              Dtunmap1 :
                (g, x : eterm, a : con, x1 : unmap x a |-
                   tunmap (A3[.., x]) (K5[.., a])),
              Dtunmap2 : (g |- tunmap A2 K3),
              Dtunmap3 :
                (g, x : eterm, a : con, x1 : unmap x a |-
                   tunmap (A4[.., x]) (K7[.., a])),
              Dsub2 : (g |- kd-sub K1 K3),
              Dsub3 :
                (g, a : con, da : cn-of a (K1[..]) |-
                   kd-sub (K5[.., a]) (K7[.., a])),
              Dwf1 : (g, a : con, da : cn-of a (K3[..]) |- kd-wf (K7[.., a]))
            | x :
                [g |- subtp (esigma A1 (\z147. A3)) (esigma A2 (\z147. A4))],
              tunmap :
                [g |- tunmap (esigma A1 (\z147. A3)) (sigma K1 (\z504. K5))],
              tunmap1 :
                [g |- tunmap (esigma A2 (\z147. A4)) (sigma K3 (\z504. K7))]
            ; solve
                [_ |-
                   unmap-subtp/i (kd-sub/sigma Dsub2
                                 (\a. \da. Dsub3) (\a. \da. Dwf1))]
            }
          }
        }
      }
    }
  }
  case subtp/pi:
  { g : unmap-bind,
    A2 : (g |- etp),
    A3 : (g, z : eterm |- etp),
    A1 : (g |- etp),
    A4 : (g, y : eterm |- etp),
    K : (g |- kind),
    L : (g |- kind),
    Dsub : (g |- subtp A1 A2),
    Dsub1 :
      (g, x : eterm, x1 : eof x (A1[..]) |- subtp (A3[.., x]) (A4[.., x])),
    Dwf : (g, x : eterm, y : eof x (A2[..]) |- ewf (A3[.., x]))
  | x : [g |- subtp (epi A2 (\z146. A3)) (epi A1 (\z146. A4))],
    tunmap : [g |- tunmap (epi A2 (\z146. A3)) K],
    tunmap1 : [g |- tunmap (epi A1 (\z146. A4)) L]
  ; split tunmap as
    case tunmap/pi:
    { g : unmap-bind,
      A2 : (g |- etp),
      A3 : (g, z : eterm |- etp),
      A1 : (g |- etp),
      A4 : (g, y : eterm |- etp),
      K1 : (g |- kind),
      K2 : (g, a : con |- kind),
      L : (g |- kind),
      Dsub : (g |- subtp A1 A2),
      Dsub1 :
        (g, x : eterm, x1 : eof x (A1[..]) |- subtp (A3[.., x]) (A4[.., x])),
      Dwf : (g, x : eterm, y : eof x (A2[..]) |- ewf (A3[.., x])),
      Dtunmap : (g |- tunmap A2 K1),
      Dtunmap1 :
        (g, x : eterm, a : con, y : unmap x a |-
           tunmap (A3[.., x]) (K2[.., a]))
    | x : [g |- subtp (epi A2 (\z146. A3)) (epi A1 (\z146. A4))],
      tunmap : [g |- tunmap (epi A2 (\z146. A3)) (pi K1 (\z503. K2))],
      tunmap1 : [g |- tunmap (epi A1 (\z146. A4)) L]
    ; split tunmap1 as
      case tunmap/pi:
      { g : unmap-bind,
        A2 : (g |- etp),
        A3 : (g, z : eterm |- etp),
        A1 : (g |- etp),
        A4 : (g, y : eterm |- etp),
        K1 : (g |- kind),
        K2 : (g, a : con |- kind),
        K3 : (g |- kind),
        K4 : (g, a : con |- kind),
        Dsub : (g |- subtp A1 A2),
        Dsub1 :
          (g, x : eterm, x1 : eof x (A1[..]) |- subtp (A3[.., x]) (A4[.., x])),
        Dwf : (g, x : eterm, y : eof x (A2[..]) |- ewf (A3[.., x])),
        Dtunmap : (g |- tunmap A2 K1),
        Dtunmap1 :
          (g, x : eterm, a : con, y : unmap x a |-
             tunmap (A3[.., x]) (K2[.., a])),
        Dtunmap2 : (g |- tunmap A1 K3),
        Dtunmap3 :
          (g, x : eterm, a : con, y : unmap x a |-
             tunmap (A4[.., x]) (K4[.., a]))
      | x : [g |- subtp (epi A2 (\z146. A3)) (epi A1 (\z146. A4))],
        tunmap : [g |- tunmap (epi A2 (\z146. A3)) (pi K1 (\z503. K2))],
        tunmap1 : [g |- tunmap (epi A1 (\z146. A4)) (pi K3 (\z503. K4))]
      ; split unmap-subtp [g |- Dsub] [g |- Dtunmap2] [g |- Dtunmap] as
        case unmap-subtp/i:
        { g : unmap-bind,
          A2 : (g |- etp),
          A3 : (g, z : eterm |- etp),
          A1 : (g |- etp),
          A4 : (g, y : eterm |- etp),
          K1 : (g |- kind),
          K2 : (g, a : con |- kind),
          K3 : (g |- kind),
          K4 : (g, a : con |- kind),
          Dsub : (g |- subtp A1 A2),
          Dsub1 :
            (g, x : eterm, x1 : eof x (A1[..]) |-
               subtp (A3[.., x]) (A4[.., x])),
          Dwf : (g, x : eterm, y : eof x (A2[..]) |- ewf (A3[.., x])),
          Dtunmap : (g |- tunmap A2 K1),
          Dtunmap1 :
            (g, x : eterm, a : con, y : unmap x a |-
               tunmap (A3[.., x]) (K2[.., a])),
          Dtunmap2 : (g |- tunmap A1 K3),
          Dtunmap3 :
            (g, x : eterm, a : con, y : unmap x a |-
               tunmap (A4[.., x]) (K4[.., a])),
          Dsub2 : (g |- kd-sub K3 K1)
        | x : [g |- subtp (epi A2 (\z146. A3)) (epi A1 (\z146. A4))],
          tunmap : [g |- tunmap (epi A2 (\z146. A3)) (pi K1 (\z503. K2))],
          tunmap1 : [g |- tunmap (epi A1 (\z146. A4)) (pi K3 (\z503. K4))]
        ; split
          unmap-subtp
            [g,
             b :
               block (
                 a : con,
                 da : cn-of a (K3[..]),
                 x : eterm,
                 dx : eof x (A1[..]),
                 xt : unmap x a) |- Dsub1[.., b.3, b.4]]
            [g,
             b :
               block (
                 a : con,
                 da : cn-of a (K3[..]),
                 x : eterm,
                 dx : eof x (A1[..]),
                 xt : unmap x a) |- Dtunmap1[.., b.3, b.1, b.5]]
            [g,
             b :
               block (
                 a : con,
                 da : cn-of a (K3[..]),
                 x : eterm,
                 dx : eof x (A1[..]),
                 xt : unmap x a) |- Dtunmap3[.., b.3, b.1, b.5]] as
          case unmap-subtp/i:
          { g : unmap-bind,
            A2 : (g |- etp),
            A3 : (g, z : eterm |- etp),
            A1 : (g |- etp),
            A4 : (g, y : eterm |- etp),
            K1 : (g |- kind),
            K5 : (g, a : con |- kind),
            K3 : (g |- kind),
            K6 : (g, a : con |- kind),
            Dsub : (g |- subtp A1 A2),
            Dsub1 :
              (g, x : eterm, x1 : eof x (A1[..]) |-
                 subtp (A3[.., x]) (A4[.., x])),
            Dwf : (g, x : eterm, y : eof x (A2[..]) |- ewf (A3[.., x])),
            Dtunmap : (g |- tunmap A2 K1),
            Dtunmap1 :
              (g, x : eterm, a : con, y : unmap x a |-
                 tunmap (A3[.., x]) (K5[.., a])),
            Dtunmap2 : (g |- tunmap A1 K3),
            Dtunmap3 :
              (g, x : eterm, a : con, y : unmap x a |-
                 tunmap (A4[.., x]) (K6[.., a])),
            Dsub2 : (g |- kd-sub K3 K1),
            Dsub3 :
              (g, a : con, da : cn-of a (K3[..]) |-
                 kd-sub (K5[.., a]) (K6[.., a]))
          | x : [g |- subtp (epi A2 (\z146. A3)) (epi A1 (\z146. A4))],
            tunmap : [g |- tunmap (epi A2 (\z146. A3)) (pi K1 (\z503. K5))],
            tunmap1 : [g |- tunmap (epi A1 (\z146. A4)) (pi K3 (\z503. K6))]
          ; split
            unmap-wf'
              [g,
               b :
                 block (
                   a : con,
                   da : cn-of a (K1[..]),
                   x : eterm,
                   dx : eof x (A2[..]),
                   xt : unmap x a) |- Dwf[.., b.3, b.4]]
              [g,
               b :
                 block (
                   a : con,
                   da : cn-of a (K1[..]),
                   x : eterm,
                   dx : eof x (A2[..]),
                   xt : unmap x a) |- Dtunmap1[.., b.3, b.1, b.5]] as
            case unmap-wf'/i:
            { g : unmap-bind,
              A2 : (g |- etp),
              A3 : (g, z : eterm |- etp),
              A1 : (g |- etp),
              A4 : (g, y : eterm |- etp),
              K1 : (g |- kind),
              K7 : (g, a : con |- kind),
              K3 : (g |- kind),
              K6 : (g, a : con |- kind),
              Dsub : (g |- subtp A1 A2),
              Dsub1 :
                (g, x : eterm, x1 : eof x (A1[..]) |-
                   subtp (A3[.., x]) (A4[.., x])),
              Dwf : (g, x : eterm, y : eof x (A2[..]) |- ewf (A3[.., x])),
              Dtunmap : (g |- tunmap A2 K1),
              Dtunmap1 :
                (g, x : eterm, a : con, y : unmap x a |-
                   tunmap (A3[.., x]) (K7[.., a])),
              Dtunmap2 : (g |- tunmap A1 K3),
              Dtunmap3 :
                (g, x : eterm, a : con, y : unmap x a |-
                   tunmap (A4[.., x]) (K6[.., a])),
              Dsub2 : (g |- kd-sub K3 K1),
              Dsub3 :
                (g, a : con, da : cn-of a (K3[..]) |-
                   kd-sub (K7[.., a]) (K6[.., a])),
              Dwf1 : (g, a : con, da : cn-of a (K1[..]) |- kd-wf (K7[.., a]))
            | x : [g |- subtp (epi A2 (\z146. A3)) (epi A1 (\z146. A4))],
              tunmap : [g |- tunmap (epi A2 (\z146. A3)) (pi K1 (\z503. K7))],
              tunmap1 :
                [g |- tunmap (epi A1 (\z146. A4)) (pi K3 (\z503. K6))]
            ; solve
                [g |-
                   unmap-subtp/i (kd-sub/pi Dsub2
                                 (\a. \da. Dsub3) (\a. \da. Dwf1))]
            }
          }
        }
      }
    }
  }
  case subtp/sing_t:
  { g : unmap-bind,
    M : (g |- eterm),
    K : (g |- kind),
    L : (g |- kind),
    Dof : (g |- eof M et)
  | x : [g |- subtp (esing M) et],
    tunmap : [g |- tunmap (esing M) K],
    tunmap1 : [g |- tunmap et L]
  ; split tunmap as
    case tunmap/sing:
    { g : unmap-bind,
      M : (g |- eterm),
      C : (g |- con),
      L : (g |- kind),
      Dof : (g |- eof M et),
      Dunmap : (g |- unmap M C)
    | x : [g |- subtp (esing M) et],
      tunmap : [g |- tunmap (esing M) (sing C)],
      tunmap1 : [g |- tunmap et L]
    ; split tunmap1 as
      case tunmap/t:
      { g : unmap-bind,
        M : (g |- eterm),
        C : (g |- con),
        Dof : (g |- eof M et),
        Dunmap : (g |- unmap M C)
      | x : [g |- subtp (esing M) et],
        tunmap : [g |- tunmap (esing M) (sing C)],
        tunmap1 : [g |- tunmap et t]
      ; split unmap-of' [g |- Dof] [g |- Dunmap] [g |- tunmap/t] as
        case unmap-of'/i:
        { g : unmap-bind,
          M : (g |- eterm),
          C : (g |- con),
          Dof : (g |- eof M et),
          Dunmap : (g |- unmap M C),
          Dof1 : (g |- cn-of C t)
        | x : [g |- subtp (esing M) et],
          tunmap : [g |- tunmap (esing M) (sing C)],
          tunmap1 : [g |- tunmap et t]
        ; solve [g |- unmap-subtp/i (kd-sub/sing-t Dof1)]
        }
      }
    }
  }
  case subtp/trans:
  { g : unmap-bind,
    A : (g |- etp),
    B : (g |- etp),
    K : (g |- kind),
    L : (g |- kind),
    A2 : (g |- etp),
    Dsub : (g |- subtp A A2),
    Dsub1 : (g |- subtp A2 B)
  | x : [g |- subtp A B],
    tunmap : [g |- tunmap A K],
    tunmap1 : [g |- tunmap B L]
  ; split can-tunmap [g |- A2] as
    case can-tunmap/i:
    { g : unmap-bind,
      A : (g |- etp),
      B : (g |- etp),
      K : (g |- kind),
      L : (g |- kind),
      A2 : (g |- etp),
      Dsub : (g |- subtp A A2),
      Dsub1 : (g |- subtp A2 B),
      K1 : (g |- kind),
      Dtunmap : (g |- tunmap A2 K1)
    | x : [g |- subtp A B],
      tunmap : [g |- tunmap A K],
      tunmap1 : [g |- tunmap B L]
    ; split unmap-subtp [g |- Dsub] tunmap [g |- Dtunmap] as
      case unmap-subtp/i:
      { g : unmap-bind,
        A : (g |- etp),
        B : (g |- etp),
        K : (g |- kind),
        L : (g |- kind),
        A2 : (g |- etp),
        Dsub : (g |- subtp A A2),
        Dsub1 : (g |- subtp A2 B),
        K1 : (g |- kind),
        Dtunmap : (g |- tunmap A2 K1),
        Dsub2 : (g |- kd-sub K K1)
      | x : [g |- subtp A B],
        tunmap : [g |- tunmap A K],
        tunmap1 : [g |- tunmap B L]
      ; split unmap-subtp [g |- Dsub1] [g |- Dtunmap] tunmap1 as
        case unmap-subtp/i:
        { g : unmap-bind,
          A : (g |- etp),
          B : (g |- etp),
          K : (g |- kind),
          L : (g |- kind),
          A2 : (g |- etp),
          Dsub : (g |- subtp A A2),
          Dsub1 : (g |- subtp A2 B),
          K1 : (g |- kind),
          Dtunmap : (g |- tunmap A2 K1),
          Dsub2 : (g |- kd-sub K K1),
          Dsub3 : (g |- kd-sub K1 L)
        | x : [g |- subtp A B],
          tunmap : [g |- tunmap A K],
          tunmap1 : [g |- tunmap B L]
        ; solve [g |- unmap-subtp/i (kd-sub/trans Dsub2 Dsub3)]
        }
      }
    }
  }
  case subtp/reflex:
  { g : unmap-bind,
    A : (g |- etp),
    B : (g |- etp),
    K : (g |- kind),
    L : (g |- kind),
    Dtequiv : (g |- tequiv A B)
  | x : [g |- subtp A B],
    tunmap : [g |- tunmap A K],
    tunmap1 : [g |- tunmap B L]
  ; split unmap-tequiv [g |- Dtequiv] tunmap tunmap1 as
    case unmap-tequiv/i:
    { g : unmap-bind,
      A : (g |- etp),
      B : (g |- etp),
      K : (g |- kind),
      L : (g |- kind),
      Dtequiv : (g |- tequiv A B),
      Dequiv : (g |- kd-equiv K L)
    | x : [g |- subtp A B],
      tunmap : [g |- tunmap A K],
      tunmap1 : [g |- tunmap B L]
    ; solve [g |- unmap-subtp/i (kd-sub/refl Dequiv)]
    }
  }
}

and proof unmap-tequiv :
  (g : unmap-bind)
  [g |- tequiv A B] ->
  [g |- tunmap A K] ->
  [g |- tunmap B L] ->
    [g |- unmap-tequiv/e K L] =
/ total 1 /
?

and proof unmap-equiv :
  (g : unmap-bind)
  [g |- unmap M C] ->
  [g |- unmap N D] ->
  [g |- equiv M N A] ->
    [g |- unmap-equiv/e A C D] =
/ total 1 /
?

and proof unmap-equiv' :
  (g : unmap-bind)
  [g |- unmap M C] ->
  [g |- unmap N D] ->
  [g |- equiv M N A] ->
  [g |- tunmap A K] ->
    [g |- unmap-equiv'/e C D K] =
/ total /
intros
{ g : unmap-bind,
  M : (g |- eterm),
  C : (g |- con),
  N : (g |- eterm),
  D : (g |- con),
  A : (g |- etp),
  K : (g |- kind)
| unmap1 : [g |- unmap M C],
  unmap2 : [g |- unmap N D],
  equiv : [g |- equiv M N A],
  tunmap : [g |- tunmap A K]
; split unmap-equiv unmap1 unmap2 equiv as
  case unmap-equiv/i:
  { g : unmap-bind,
    M : (g |- eterm),
    C : (g |- con),
    N : (g |- eterm),
    D : (g |- con),
    A : (g |- etp),
    K : (g |- kind),
    K1 : (g |- kind),
    Dtunmap : (g |- tunmap A K1),
    Dequiv : (g |- cn-equiv C D K1)
  | unmap1 : [g |- unmap M C],
    unmap2 : [g |- unmap N D],
    equiv : [g |- equiv M N A],
    tunmap : [g |- tunmap A K]
  ; split tunmap-fun tunmap [_ |- Dtunmap] as
    case kind-eq/i:
    { g : unmap-bind,
      M : (g |- eterm),
      C : (g |- con),
      N : (g |- eterm),
      D : (g |- con),
      A : (g |- etp),
      K1 : (g |- kind),
      Dtunmap : (g |- tunmap A K1),
      Dequiv : (g |- cn-equiv C D K1)
    | unmap1 : [g |- unmap M C],
      unmap2 : [g |- unmap N D],
      equiv : [g |- equiv M N A],
      tunmap : [g |- tunmap A K1]
    ; solve [_ |- unmap-equiv'/i Dequiv]
    }
  }
}
;


% Unmap Inverts Map

schema invert-bind =
  some [
    K : kind,
    K' : kind,
    B : etp,
    DmapK : tmap K B,
    DmapB : tunmap B K',
    DwfK : kd-wf K,
    DwfB : ewf B,
    DequivK : kd-equiv K K'
  ]
  block (
    a : con,
    da : cn-of a K,
    x : eterm,
    dx : eof x B,
    at : map a x,
    xt : unmap x a
  );

LF invert-map/e : con -> kind -> eterm -> type =
| invert-map/i :
  { C' : con }
  unmap M C' ->
  cn-equiv C C' K ->
    invert-map/e C K M
;

LF invert-tmap/e : kind -> etp -> type =
| invert-tmap/i :
  { K' : kind }
  tunmap A K' ->
  kd-equiv K K' ->
    invert-tmap/e K A
;

proof invert-map :
  (g : invert-bind)
  [g |- cn-of C K] ->
  [g |- map C M] ->
    [g |- invert-map/e C K M] =
/ total 1 /
intros
{ g : invert-bind, C : (g |- con), K : (g |- kind), M : (g |- eterm)
| x : [g |- cn-of C K], map : [g |- map C M]
; split x as
  case cn-of/subsume:
  { g : invert-bind,
    C : (g |- con),
    K : (g |- kind),
    M : (g |- eterm),
    K1 : (g |- kind),
    Dof : (g |- cn-of C K1),
    Dsub : (g |- kd-sub K1 K)
  | x : [g |- cn-of C K], map : [g |- map C M]
  ; split invert-map [_ |- Dof] map as
    case invert-map/i:
    { g : invert-bind,
      C : (g |- con),
      K : (g |- kind),
      M : (g |- eterm),
      K1 : (g |- kind),
      Dof : (g |- cn-of C K1),
      Dsub : (g |- kd-sub K1 K),
      C2 : (g |- con),
      Dunmap : (g |- unmap M C2),
      Dequiv : (g |- cn-equiv C C2 K1)
    | x : [g |- cn-of C K], map : [g |- map C M]
    ; solve [_ |- invert-map/i _ Dunmap (cn-equiv/subsume Dequiv Dsub)]
    }
  }
  case cn-of/extsigma:
  { g : invert-bind,
    C : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a : con |- kind),
    M : (g |- eterm),
    Dof : (g |- cn-of (pi1 C) K1),
    Dof1 : (g |- cn-of (pi2 C) (K2[.., pi1 C])),
    Dwf : (g, a : con, y : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of C (sigma K1 (\x709. K2))], map : [g |- map C M]
  ; ?
  }
  case cn-of/extpi:
  { g : invert-bind,
    C : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a : con |- kind),
    M : (g |- eterm),
    K2 : (g, a : con |- kind),
    Dof : (g |- cn-of C (pi K1 (\x708. K2))),
    Dof1 :
      (g, a : con, z : cn-of a (K1[..]) |- cn-of (app (C[..]) a) (K3[.., a]))
  | x : [g |- cn-of C (pi K1 (\x708. K3))], map : [g |- map C M]
  ; ?
  }
  case cn-of/sing:
  { g : invert-bind, C : (g |- con), M : (g |- eterm), Dof : (g |- cn-of C t)
  | x : [g |- cn-of C (sing C)], map : [g |- map C M]
  ; ?
  }
  case cn-of/labeled:
  { g : invert-bind,
    L : ( |- label),
    C1 : (g |- con),
    M : (g |- eterm),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (labeled L[] C1) t], map : [g |- map (labeled L[] C1) M]
  ; split map as
    case map/labeled:
    { g : invert-bind,
      L : ( |- label),
      C1 : (g |- con),
      M1 : (g |- eterm),
      Dof : (g |- cn-of C1 t),
      Dmap : (g |- map C1 M1)
    | x : [g |- cn-of (labeled L[] C1) t],
      map :
        [g |- map (labeled L[] C1) (eapp (econst (const/labeled L[])) M1)]
    ; split invert-map [_ |- Dof] [_ |- Dmap] as
      case invert-map/i:
      { g : invert-bind,
        L : ( |- label),
        C1 : (g |- con),
        M1 : (g |- eterm),
        Dof : (g |- cn-of C1 t),
        D : (g |- map C1 M1),
        C3 : (g |- con),
        Dunmap : (g |- unmap M1 C3),
        Dequiv : (g |- cn-equiv C1 C3 t)
      | x : [g |- cn-of (labeled L[] C1) t],
        map :
          [g |- map (labeled L[] C1) (eapp (econst (const/labeled L[])) M1)]
      ; solve
          [_ |-
             invert-map/i _
             (unmap/app (unmap/labeled ) Dunmap)
             (cn-equiv/trans (cn-equiv/symm (cn-equiv/beta (\a.
                                                              \da.
                                                                cn-of/labeled 
                                                                da)
                                            Dof))
             (cn-equiv/app (cn-equiv/refl (cn-of/lam kd-wf/t
                                          (\a. \da. cn-of/labeled da)))
             Dequiv))]
      }
    }
  }
  case cn-of/rec:
  { g : invert-bind,
    K1 : (g |- kind),
    C1 : (g, a : con, a1 : con |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, z : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
    Dof1 : (g |- cn-of C2 K1)
  | x : [g |- cn-of (rec' K1 (\x716. \z716. C1) C2) t],
    map : [g |- map (rec' K1 (\x716. \z716. C1) C2) M]
  ; ?
  }
  case cn-of/tagged:
  { g : invert-bind, M : (g |- eterm)
  | x : [g |- cn-of tagged t], map : [g |- map tagged M]
  ; split map as
    case map/tagged:
    { g : invert-bind
    | x : [g |- cn-of tagged t],
      map : [g |- map tagged (econst const/tagged)]
    ; solve [_ |- invert-map/i _ unmap/tagged (cn-equiv/refl cn-of/tagged)]
    }
  }
  case cn-of/tag:
  { g : invert-bind,
    C1 : (g |- con),
    M : (g |- eterm),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (tag C1) t], map : [g |- map (tag C1) M]
  ; split map as
    case map/tag:
    { g : invert-bind,
      C1 : (g |- con),
      M1 : (g |- eterm),
      Dof : (g |- cn-of C1 t),
      Dmap : (g |- map C1 M1)
    | x : [g |- cn-of (tag C1) t],
      map : [g |- map (tag C1) (eapp (econst const/tag) M1)]
    ; split invert-map [_ |- Dof] [_ |- Dmap] as
      case invert-map/i:
      { g : invert-bind,
        C1 : (g |- con),
        M1 : (g |- eterm),
        Dof : (g |- cn-of C1 t),
        D : (g |- map C1 M1),
        C3 : (g |- con),
        Dunmap : (g |- unmap M1 C3),
        Dequiv : (g |- cn-equiv C1 C3 t)
      | x : [g |- cn-of (tag C1) t],
        map : [g |- map (tag C1) (eapp (econst const/tag) M1)]
      ; solve
          [_ |-
             invert-map/i _
             (unmap/app unmap/tag Dunmap)
             (cn-equiv/trans (cn-equiv/symm (cn-equiv/beta (\a.
                                                              \da.
                                                                cn-of/tag da)
                                            Dof))
             (cn-equiv/app (cn-equiv/refl (cn-of/lam kd-wf/t
                                          (\a. \da. cn-of/tag da)))
             Dequiv))]
      }
    }
  }
  case cn-of/ref:
  { g : invert-bind,
    C1 : (g |- con),
    M : (g |- eterm),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (ref C1) t], map : [g |- map (ref C1) M]
  ; split map as
    case map/ref:
    { g : invert-bind,
      C1 : (g |- con),
      M1 : (g |- eterm),
      Dof : (g |- cn-of C1 t),
      Dmap : (g |- map C1 M1)
    | x : [g |- cn-of (ref C1) t],
      map : [g |- map (ref C1) (eapp (econst const/ref) M1)]
    ; split invert-map [_ |- Dof] [_ |- Dmap] as
      case invert-map/i:
      { g : invert-bind,
        C1 : (g |- con),
        M1 : (g |- eterm),
        Dof : (g |- cn-of C1 t),
        D : (g |- map C1 M1),
        C3 : (g |- con),
        Dunmap : (g |- unmap M1 C3),
        Dequiv : (g |- cn-equiv C1 C3 t)
      | x : [g |- cn-of (ref C1) t],
        map : [g |- map (ref C1) (eapp (econst const/ref) M1)]
      ; solve
          [_ |-
             invert-map/i _
             (unmap/app unmap/ref Dunmap)
             (cn-equiv/trans (cn-equiv/symm (cn-equiv/beta (\a.
                                                              \da.
                                                                cn-of/ref da)
                                            Dof))
             (cn-equiv/app (cn-equiv/refl (cn-of/lam kd-wf/t
                                          (\a. \da. cn-of/ref da)))
             Dequiv))]
      }
    }
  }
  case cn-of/plus:
  { g : invert-bind,
    C1 : (g |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (plus C1 C2) t], map : [g |- map (plus C1 C2) M]
  ; ?
  }
  case cn-of/arrow:
  { g : invert-bind,
    C1 : (g |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (arrow C1 C2) t], map : [g |- map (arrow C1 C2) M]
  ; ?
  }
  case cn-of/prod:
  { g : invert-bind,
    C1 : (g |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (prod C1 C2) t], map : [g |- map (prod C1 C2) M]
  ; ?
  }
  case cn-of/void:
  { g : invert-bind, M : (g |- eterm)
  | x : [g |- cn-of void t], map : [g |- map void M]
  ; split map as
    case map/void:
    { g : invert-bind
    | x : [g |- cn-of void t], map : [g |- map void (econst const/void)]
    ; solve [_ |- invert-map/i _ unmap/void (cn-equiv/refl cn-of/void)]
    }
  }
  case cn-of/unit:
  { g : invert-bind, M : (g |- eterm)
  | x : [g |- cn-of unit t], map : [g |- map unit M]
  ; split map as
    case map/unit:
    { g : invert-bind
    | x : [g |- cn-of unit t], map : [g |- map unit (econst const/unit)]
    ; solve [_ |- invert-map/i _ unmap/unit (cn-equiv/refl cn-of/unit)]
    }
  }
  case cn-of/star:
  { g : invert-bind, M : (g |- eterm)
  | x : [g |- cn-of star one], map : [g |- map star M]
  ; split map as
    case map/star:
    { g : invert-bind
    | x : [g |- cn-of star one], map : [g |- map star estar]
    ; solve [_ |- invert-map/i _ unmap/star (cn-equiv/refl cn-of/star)]
    }
  }
  case cn-of/app:
  { g : invert-bind,
    C1 : (g |- con),
    C2 : (g |- con),
    K2 : (g, a : con |- kind),
    M : (g |- eterm),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 (pi K1 (\x708. K2))),
    Dof1 : (g |- cn-of C2 K1)
  | x : [g |- cn-of (app C1 C2) (K2[.., C2])], map : [g |- map (app C1 C2) M]
  ; ?
  }
  case cn-of/lam:
  { g : invert-bind,
    K1 : (g |- kind),
    C1 : (g, a : con |- con),
    K2 : (g, a : con |- kind),
    M : (g |- eterm),
    Dwf : (g |- kd-wf K1),
    Dof : (g, a : con, y : cn-of a (K1[..]) |- cn-of (C1[.., a]) (K2[.., a]))
  | x : [g |- cn-of (lam K1 (\z711. C1)) (pi K1 (\x708. K2))],
    map : [g |- map (lam K1 (\z711. C1)) M]
  ; ?
  }
  case cn-of/pi2:
  { g : invert-bind,
    C1 : (g |- con),
    K2 : (g, a : con |- kind),
    M : (g |- eterm),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 (sigma K1 (\x709. K2)))
  | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])], map : [g |- map (pi2 C1) M]
  ; split map as
    case map/pi2:
    { g : invert-bind,
      C1 : (g |- con),
      K2 : (g, a : con |- kind),
      M1 : (g |- eterm),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 (sigma K1 (\x709. K2))),
      Dmap : (g |- map C1 M1)
    | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])],
      map : [g |- map (pi2 C1) (epi2 M1)]
    ; split invert-map [_ |- Dof] [_ |- Dmap] as
      case invert-map/i:
      { g : invert-bind,
        C1 : (g |- con),
        K2 : (g, a : con |- kind),
        M1 : (g |- eterm),
        K1 : (g |- kind),
        Dof : (g |- cn-of C1 (sigma K1 (\x709. K2))),
        D : (g |- map C1 M1),
        C3 : (g |- con),
        Dunmap : (g |- unmap M1 C3),
        Dequiv : (g |- cn-equiv C1 C3 (sigma K1 (\x709. K2)))
      | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])],
        map : [g |- map (pi2 C1) (epi2 M1)]
      ; solve [_ |- invert-map/i _ (unmap/pi2 Dunmap) (cn-equiv/pi2 Dequiv)]
      }
    }
  }
  case cn-of/pi1:
  { g : invert-bind,
    C1 : (g |- con),
    K : (g |- kind),
    M : (g |- eterm),
    K2 : (g, a : con |- kind),
    Dof : (g |- cn-of C1 (sigma K (\x709. K2)))
  | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) M]
  ; split map as
    case map/pi1:
    { g : invert-bind,
      C1 : (g |- con),
      K : (g |- kind),
      M1 : (g |- eterm),
      K2 : (g, a : con |- kind),
      Dof : (g |- cn-of C1 (sigma K (\x709. K2))),
      Dmap : (g |- map C1 M1)
    | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) (epi1 M1)]
    ; split invert-map [_ |- Dof] [_ |- Dmap] as
      case invert-map/i:
      { g : invert-bind,
        C1 : (g |- con),
        K : (g |- kind),
        M1 : (g |- eterm),
        K2 : (g, a : con |- kind),
        Dof : (g |- cn-of C1 (sigma K (\x709. K2))),
        D : (g |- map C1 M1),
        C3 : (g |- con),
        Dunmap : (g |- unmap M1 C3),
        Dequiv : (g |- cn-equiv C1 C3 (sigma K (\x709. K2)))
      | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) (epi1 M1)]
      ; solve [_ |- invert-map/i _ (unmap/pi1 Dunmap) (cn-equiv/pi1 Dequiv)]
      }
    }
  }
  case cn-of/pair:
  { g : invert-bind,
    C1 : (g |- con),
    C2 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a : con |- kind),
    M : (g |- eterm),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of C2 (K2[.., C1])),
    Dwf : (g, a : con, x : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of (pair C1 C2) (sigma K1 (\x709. K2))],
    map : [g |- map (pair C1 C2) M]
  ; ?
  }
  case #.2:
  { g : invert-bind,
    K : (g |- kind),
    A1045 : (g |- etp),
    #unmap :
      #(g |-
          block (
            a : con,
            da : cn-of a (K[..]),
            x : eterm,
            dx : eof x (A1045[..]),
            at : map a x,
            xt : unmap x a)),
    M : (g |- eterm),
    K1497 : (g |- kind),
    Dtmap102 : (g |- tmap K A1045),
    Dtunmap94 : (g |- tunmap A1045 K1497),
    Dwf215 : (g |- kd-wf K),
    Dwf153 : (g |- ewf A1045),
    Dequiv104 : (g |- kd-equiv K K1497)
  | x : [g |- cn-of #unmap.1 K], map : [g |- map #unmap.1 M]
  ; split map as
    case #.5:
    { g : invert-bind,
      K : (g |- kind),
      A1045 : (g |- etp),
      #unmap :
        #(g |-
            block (
              a : con,
              da : cn-of a (K[..]),
              x : eterm,
              dx : eof x (A1045[..]),
              at : map a x,
              xt : unmap x a)),
      K1497 : (g |- kind),
      Dtmap102 : (g |- tmap K A1045),
      Dtunmap94 : (g |- tunmap A1045 K1497),
      Dwf215 : (g |- kd-wf K),
      Dwf153 : (g |- ewf A1045),
      Dequiv104 : (g |- kd-equiv K K1497),
      K1541 : (g |- kind),
      Dtmap116 : (g |- tmap K A1045),
      Dtunmap102 : (g |- tunmap A1045 K1541),
      Dwf227 : (g |- kd-wf K),
      Dwf161 : (g |- ewf A1045),
      Dequiv112 : (g |- kd-equiv K K1541)
    | x : [g |- cn-of #unmap.1 K], map : [g |- map #unmap.1 #unmap.3]
    ; solve [_ |- invert-map/i _ #unmap.6 (cn-equiv/refl #unmap.2)]
    }
  }
}

and proof invert-tmap :
  (g : invert-bind)
  [g |- kd-wf K] ->
  [g |- tmap K A] ->
    [g |- invert-tmap/e K A] =
/ total 1 /
intros
{ g : invert-bind, K : (g |- kind), A : (g |- etp)
| x : [g |- kd-wf K], tmap : [g |- tmap K A]
; split x as
  case kd-wf/one:
  { g : invert-bind, A : (g |- etp)
  | x : [g |- kd-wf one], tmap : [g |- tmap one A]
  ; split tmap as
    case tmap/one:
    { g : invert-bind
    | x : [g |- kd-wf one], tmap : [g |- tmap one eone]
    ; solve [_ |- invert-tmap/i _ tunmap/one (kd-equiv/refl kd-wf/one)]
    }
  }
  case kd-wf/sigma:
  { g : invert-bind,
    K1 : (g |- kind),
    K2 : (g, a : con |- kind),
    A : (g |- etp),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, z : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (sigma K1 (\x709. K2))],
    tmap : [g |- tmap (sigma K1 (\x709. K2)) A]
  ; ?
  }
  case kd-wf/pi:
  { g : invert-bind,
    K1 : (g |- kind),
    K2 : (g, a : con |- kind),
    A : (g |- etp),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, z : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (pi K1 (\x708. K2))],
    tmap : [g |- tmap (pi K1 (\x708. K2)) A]
  ; ?
  }
  case kd-wf/sing:
  { g : invert-bind, C : (g |- con), A : (g |- etp), Dof : (g |- cn-of C t)
  | x : [g |- kd-wf (sing C)], tmap : [g |- tmap (sing C) A]
  ; split tmap as
    case tmap/sing:
    { g : invert-bind,
      C : (g |- con),
      M : (g |- eterm),
      Dof : (g |- cn-of C t),
      Dmap : (g |- map C M)
    | x : [g |- kd-wf (sing C)], tmap : [g |- tmap (sing C) (esing M)]
    ; split invert-map [_ |- Dof] [_ |- Dmap] as
      case invert-map/i:
      { g : invert-bind,
        C : (g |- con),
        M : (g |- eterm),
        Dof : (g |- cn-of C t),
        Dmap : (g |- map C M),
        C2 : (g |- con),
        Dunmap : (g |- unmap M C2),
        Dequiv : (g |- cn-equiv C C2 t)
      | x : [g |- kd-wf (sing C)], tmap : [g |- tmap (sing C) (esing M)]
      ; solve
          [_ |- invert-tmap/i _ (tunmap/sing Dunmap) (kd-equiv/sing Dequiv)]
      }
    }
  }
  case kd-wf/t:
  { g : invert-bind, A : (g |- etp)
  | x : [g |- kd-wf t], tmap : [g |- tmap t A]
  ; split tmap as
    case tmap/t:
    { g : invert-bind
    | x : [g |- kd-wf t], tmap : [g |- tmap t et]
    ; solve [_ |- invert-tmap/i _ tunmap/t (kd-equiv/refl kd-wf/t)]
    }
  }
}
;

% Injectivity Lemmas

LF injective-prod/e : con -> con -> con -> con -> type =
| injective-prod/i :
  cn-equiv T1a T2a t ->
  cn-equiv T1b T2b t ->
    injective-prod/e T1a T1b T2a T2b
;

proof injective-prod :
  [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t] ->
    [ |- injective-prod/e T1a T1b T2a T2b] =
/ total /
intros
{ T1a : ( |- con), T1b : ( |- con), T2a : ( |- con), T2b : ( |- con)
| equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
; by equiv as Dequiv unboxed;
  split cn-equiv-reg [ |- Dequiv] as
  case cn-equiv-reg/i:
  { T1a : ( |- con),
    T1b : ( |- con),
    T2a : ( |- con),
    T2b : ( |- con),
    Dequiv : ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
    Dof : ( |- cn-of (prod T1a T1b) t),
    Dof1 : ( |- cn-of (prod T2a T2b) t),
    Dwf : ( |- kd-wf t)
  | equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
  ; split inversion-prod [ |- Dof] as
    case inversion-prod/i:
    { T1a : ( |- con),
      T1b : ( |- con),
      T2a : ( |- con),
      T2b : ( |- con),
      Dequiv : ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
      Dof1 : ( |- cn-of (prod T1a T1b) t),
      Dof2 : ( |- cn-of (prod T2a T2b) t),
      Dwf : ( |- kd-wf t),
      Dof3 : ( |- cn-of T1a t),
      Dof4 : ( |- cn-of T1b t)
    | equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
    ; split inversion-prod [ |- Dof2] as
      case inversion-prod/i:
      { T1a : ( |- con),
        T1b : ( |- con),
        T2a : ( |- con),
        T2b : ( |- con),
        Dequiv : ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
        Dof1 : ( |- cn-of (prod T1a T1b) t),
        Dof2 : ( |- cn-of (prod T2a T2b) t),
        Dwf : ( |- kd-wf t),
        Dof1a : ( |- cn-of T1a t),
        Dof1b : ( |- cn-of T1b t),
        Dof3 : ( |- cn-of T2a t),
        Dof4 : ( |- cn-of T2b t)
      | equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
      ; split map-equiv [ |- _] [ |- _] [ |- Dequiv] as
        case map-equiv/i:
        { T1a : ( |- con),
          T1b : ( |- con),
          T2a : ( |- con),
          T2b : ( |- con),
          Dequiv : ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
          Dof1 : ( |- cn-of (prod T1a T1b) t),
          Dof2 : ( |- cn-of (prod T2a T2b) t),
          Dwf : ( |- kd-wf t),
          Dof1a : ( |- cn-of T1a t),
          Dof1b : ( |- cn-of T1b t),
          Dof2a : ( |- cn-of T2a t),
          Dof2b : ( |- cn-of T2b t),
          M : ( |- eterm),
          M1 : ( |- eterm),
          A : ( |- etp),
          Dmap : ( |- map (prod T1a T1b) M),
          Dmap1 : ( |- map (prod T2a T2b) M1),
          Dtmap : ( |- tmap t A),
          Dequiv1 : ( |- equiv M M1 A)
        | equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
        ; split [ |- Dmap] as
          case map/prod:
          { T1a : ( |- con),
            T1b : ( |- con),
            T2a : ( |- con),
            T2b : ( |- con),
            Dequiv : ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
            Dof1 : ( |- cn-of (prod T1a T1b) t),
            Dof2 : ( |- cn-of (prod T2a T2b) t),
            Dwf : ( |- kd-wf t),
            Dof1a : ( |- cn-of T1a t),
            Dof1b : ( |- cn-of T1b t),
            Dof2a : ( |- cn-of T2a t),
            Dof2b : ( |- cn-of T2b t),
            M2 : ( |- eterm),
            M3 : ( |- eterm),
            M1 : ( |- eterm),
            A : ( |- etp),
            Dmap2 : ( |- map T1a M2),
            Dmap3 : ( |- map T1b M3),
            Dmap1 : ( |- map (prod T2a T2b) M1),
            Dtmap : ( |- tmap t A),
            Dequiv' :
              ( |- equiv (eapp (eapp (econst const/prod) M2) M3) M1 A)
          | equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
          ; split [ |- Dmap1] as
            case map/prod:
            { T1a : ( |- con),
              T1b : ( |- con),
              T2a : ( |- con),
              T2b : ( |- con),
              Dequiv : ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
              Dof1 : ( |- cn-of (prod T1a T1b) t),
              Dof2 : ( |- cn-of (prod T2a T2b) t),
              Dwf : ( |- kd-wf t),
              Dof1a : ( |- cn-of T1a t),
              Dof1b : ( |- cn-of T1b t),
              Dof2a : ( |- cn-of T2a t),
              Dof2b : ( |- cn-of T2b t),
              M1a : ( |- eterm),
              M1b : ( |- eterm),
              M2 : ( |- eterm),
              M3 : ( |- eterm),
              A : ( |- etp),
              Dmap1a : ( |- map T1a M1a),
              Dmap1b : ( |- map T1b M1b),
              Dmap2 : ( |- map T2a M2),
              Dmap3 : ( |- map T2b M3),
              Dtmap : ( |- tmap t A),
              Dequiv' :
                ( |-
                   equiv
                     (eapp (eapp (econst const/prod) M1a) M1b)
                     (eapp (eapp (econst const/prod) M2) M3) A)
            | equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
            ; split [ |- Dtmap] as
              case tmap/t:
              { T1a : ( |- con),
                T1b : ( |- con),
                T2a : ( |- con),
                T2b : ( |- con),
                Dequiv : ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
                Dof1 : ( |- cn-of (prod T1a T1b) t),
                Dof2 : ( |- cn-of (prod T2a T2b) t),
                Dwf : ( |- kd-wf t),
                Dof1a : ( |- cn-of T1a t),
                Dof1b : ( |- cn-of T1b t),
                Dof2a : ( |- cn-of T2a t),
                Dof2b : ( |- cn-of T2b t),
                M1a : ( |- eterm),
                M1b : ( |- eterm),
                M2a : ( |- eterm),
                M2b : ( |- eterm),
                Dmap1a : ( |- map T1a M1a),
                Dmap1b : ( |- map T1b M1b),
                Dmap2a : ( |- map T2a M2a),
                Dmap2b : ( |- map T2b M2b),
                Dequiv' :
                  ( |-
                     equiv
                       (eapp (eapp (econst const/prod) M1a) M1b)
                       (eapp (eapp (econst const/prod) M2a) M2b) et)
              | equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
              ; split
                binary-equiv-inversion
                  [ |-
                     ekof/i ckof/prod
                     (etopen/pi etopen/t
                     etp-skel/t
                     (\l1.
                        \l2.
                          \l3.
                            etopen/pi etopen/t
                            etp-skel/t (\l4. \l5. \l6. etopen/t)))]
                  [ |- Dequiv'] as
                case binary-equiv-inversion/i:
                { T1a : ( |- con),
                  T1b : ( |- con),
                  T2a : ( |- con),
                  T2b : ( |- con),
                  Dequiv : ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
                  Dof1 : ( |- cn-of (prod T1a T1b) t),
                  Dof2 : ( |- cn-of (prod T2a T2b) t),
                  Dwf : ( |- kd-wf t),
                  Dof1a : ( |- cn-of T1a t),
                  Dof1b : ( |- cn-of T1b t),
                  Dof2a : ( |- cn-of T2a t),
                  Dof2b : ( |- cn-of T2b t),
                  M1a : ( |- eterm),
                  M1b : ( |- eterm),
                  M2a : ( |- eterm),
                  M2b : ( |- eterm),
                  Dmap1a : ( |- map T1a M1a),
                  Dmap1b : ( |- map T1b M1b),
                  Dmap2a : ( |- map T2a M2a),
                  Dmap2b : ( |- map T2b M2b),
                  Dequiv' :
                    ( |-
                       equiv
                         (eapp (eapp (econst const/prod) M1a) M1b)
                         (eapp (eapp (econst const/prod) M2a) M2b) et),
                  Dequiv1 : ( |- equiv M1a M2a et),
                  Dequiv2 : ( |- equiv M1b M2b et)
                | equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
                ; split invert-map [ |- Dof1a] [ |- Dmap1a] as
                  case invert-map/i:
                  { T1a : ( |- con),
                    T1b : ( |- con),
                    T2a : ( |- con),
                    T2b : ( |- con),
                    Dequiv : ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
                    Dof1 : ( |- cn-of (prod T1a T1b) t),
                    Dof2 : ( |- cn-of (prod T2a T2b) t),
                    Dwf : ( |- kd-wf t),
                    Dof1a : ( |- cn-of T1a t),
                    Dof1b : ( |- cn-of T1b t),
                    Dof2a : ( |- cn-of T2a t),
                    Dof2b : ( |- cn-of T2b t),
                    M1a : ( |- eterm),
                    M1b : ( |- eterm),
                    M2a : ( |- eterm),
                    M2b : ( |- eterm),
                    Dmap1a : ( |- map T1a M1a),
                    Dmap1b : ( |- map T1b M1b),
                    Dmap2a : ( |- map T2a M2a),
                    Dmap2b : ( |- map T2b M2b),
                    Dequiv' :
                      ( |-
                         equiv
                           (eapp (eapp (econst const/prod) M1a) M1b)
                           (eapp (eapp (econst const/prod) M2a) M2b) et),
                    Dequiv1' : ( |- equiv M1a M2a et),
                    Dequiv2' : ( |- equiv M1b M2b et),
                    C1 : ( |- con),
                    Dunmap : ( |- unmap M1a C1),
                    Dequiv1 : ( |- cn-equiv T1a C1 t)
                  | equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
                  ; split invert-map [ |- Dof1b] [ |- Dmap1b] as
                    case invert-map/i:
                    { T1a : ( |- con),
                      T1b : ( |- con),
                      T2a : ( |- con),
                      T2b : ( |- con),
                      Dequiv : ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
                      Dof1 : ( |- cn-of (prod T1a T1b) t),
                      Dof2 : ( |- cn-of (prod T2a T2b) t),
                      Dwf : ( |- kd-wf t),
                      Dof1a : ( |- cn-of T1a t),
                      Dof1b : ( |- cn-of T1b t),
                      Dof2a : ( |- cn-of T2a t),
                      Dof2b : ( |- cn-of T2b t),
                      M1a : ( |- eterm),
                      M1b : ( |- eterm),
                      M2a : ( |- eterm),
                      M2b : ( |- eterm),
                      Dmap1a : ( |- map T1a M1a),
                      Dmap1b : ( |- map T1b M1b),
                      Dmap2a : ( |- map T2a M2a),
                      Dmap2b : ( |- map T2b M2b),
                      Dequiv' :
                        ( |-
                           equiv
                             (eapp (eapp (econst const/prod) M1a) M1b)
                             (eapp (eapp (econst const/prod) M2a) M2b) et),
                      Dequiv1' : ( |- equiv M1a M2a et),
                      Dequiv2' : ( |- equiv M1b M2b et),
                      T1a' : ( |- con),
                      Dunmap1a : ( |- unmap M1a T1a'),
                      Dequiv1a : ( |- cn-equiv T1a T1a' t),
                      C1 : ( |- con),
                      Dunmap : ( |- unmap M1b C1),
                      Dequiv1 : ( |- cn-equiv T1b C1 t)
                    | equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
                    ; split invert-map [ |- Dof2a] [ |- Dmap2a] as
                      case invert-map/i:
                      { T1a : ( |- con),
                        T1b : ( |- con),
                        T2a : ( |- con),
                        T2b : ( |- con),
                        Dequiv :
                          ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
                        Dof1 : ( |- cn-of (prod T1a T1b) t),
                        Dof2 : ( |- cn-of (prod T2a T2b) t),
                        Dwf : ( |- kd-wf t),
                        Dof1a : ( |- cn-of T1a t),
                        Dof1b : ( |- cn-of T1b t),
                        Dof2a : ( |- cn-of T2a t),
                        Dof2b : ( |- cn-of T2b t),
                        M1a : ( |- eterm),
                        M1b : ( |- eterm),
                        M2a : ( |- eterm),
                        M2b : ( |- eterm),
                        Dmap1a : ( |- map T1a M1a),
                        Dmap1b : ( |- map T1b M1b),
                        Dmap2a : ( |- map T2a M2a),
                        Dmap2b : ( |- map T2b M2b),
                        Dequiv' :
                          ( |-
                             equiv
                               (eapp (eapp (econst const/prod) M1a) M1b)
                               (eapp (eapp (econst const/prod) M2a) M2b) et),
                        Dequiv1' : ( |- equiv M1a M2a et),
                        Dequiv2' : ( |- equiv M1b M2b et),
                        T1a' : ( |- con),
                        Dunmap1a : ( |- unmap M1a T1a'),
                        Dequiv1a : ( |- cn-equiv T1a T1a' t),
                        T1b' : ( |- con),
                        Dunmap1b : ( |- unmap M1b T1b'),
                        Dequiv1b : ( |- cn-equiv T1b T1b' t),
                        C1 : ( |- con),
                        Dunmap : ( |- unmap M2a C1),
                        Dequiv1 : ( |- cn-equiv T2a C1 t)
                      | equiv :
                          [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
                      ; split invert-map [ |- Dof2b] [ |- Dmap2b] as
                        case invert-map/i:
                        { T1a : ( |- con),
                          T1b : ( |- con),
                          T2a : ( |- con),
                          T2b : ( |- con),
                          Dequiv :
                            ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
                          Dof1 : ( |- cn-of (prod T1a T1b) t),
                          Dof2 : ( |- cn-of (prod T2a T2b) t),
                          Dwf : ( |- kd-wf t),
                          Dof1a : ( |- cn-of T1a t),
                          Dof1b : ( |- cn-of T1b t),
                          Dof2a : ( |- cn-of T2a t),
                          Dof2b : ( |- cn-of T2b t),
                          M1a : ( |- eterm),
                          M1b : ( |- eterm),
                          M2a : ( |- eterm),
                          M2b : ( |- eterm),
                          Dmap1a : ( |- map T1a M1a),
                          Dmap1b : ( |- map T1b M1b),
                          Dmap2a : ( |- map T2a M2a),
                          Dmap2b : ( |- map T2b M2b),
                          Dequiv' :
                            ( |-
                               equiv
                                 (eapp (eapp (econst const/prod) M1a) M1b)
                                 (eapp (eapp (econst const/prod) M2a) M2b) et),
                          Dequiv1' : ( |- equiv M1a M2a et),
                          Dequiv2' : ( |- equiv M1b M2b et),
                          T1a' : ( |- con),
                          Dunmap1a : ( |- unmap M1a T1a'),
                          Dequiv1a : ( |- cn-equiv T1a T1a' t),
                          T1b' : ( |- con),
                          Dunmap1b : ( |- unmap M1b T1b'),
                          Dequiv1b : ( |- cn-equiv T1b T1b' t),
                          T2a' : ( |- con),
                          Dunmap2a : ( |- unmap M2a T2a'),
                          Dequiv2a : ( |- cn-equiv T2a T2a' t),
                          C1 : ( |- con),
                          Dunmap : ( |- unmap M2b C1),
                          Dequiv1 : ( |- cn-equiv T2b C1 t)
                        | equiv :
                            [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
                        ; split
                          unmap-equiv [ |- Dunmap1a] [ |- Dunmap2a]
                            [ |- Dequiv1'] as
                          case unmap-equiv/i:
                          { T1a : ( |- con),
                            T1b : ( |- con),
                            T2a : ( |- con),
                            T2b : ( |- con),
                            Dequiv :
                              ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
                            Dof1 : ( |- cn-of (prod T1a T1b) t),
                            Dof2 : ( |- cn-of (prod T2a T2b) t),
                            Dwf : ( |- kd-wf t),
                            Dof1a : ( |- cn-of T1a t),
                            Dof1b : ( |- cn-of T1b t),
                            Dof2a : ( |- cn-of T2a t),
                            Dof2b : ( |- cn-of T2b t),
                            M1a : ( |- eterm),
                            M1b : ( |- eterm),
                            M2a : ( |- eterm),
                            M2b : ( |- eterm),
                            Dmap1a : ( |- map T1a M1a),
                            Dmap1b : ( |- map T1b M1b),
                            Dmap2a : ( |- map T2a M2a),
                            Dmap2b : ( |- map T2b M2b),
                            Dequiv' :
                              ( |-
                                 equiv
                                   (eapp (eapp (econst const/prod) M1a) M1b)
                                   (eapp (eapp (econst const/prod) M2a) M2b)
                                   et),
                            Dequiv1' : ( |- equiv M1a M2a et),
                            Dequiv2' : ( |- equiv M1b M2b et),
                            T1a' : ( |- con),
                            Dunmap1a : ( |- unmap M1a T1a'),
                            Dequiv1a : ( |- cn-equiv T1a T1a' t),
                            T1b' : ( |- con),
                            Dunmap1b : ( |- unmap M1b T1b'),
                            Dequiv1b : ( |- cn-equiv T1b T1b' t),
                            T2a' : ( |- con),
                            Dunmap2a : ( |- unmap M2a T2a'),
                            Dequiv2a : ( |- cn-equiv T2a T2a' t),
                            T2b' : ( |- con),
                            Dunmap2b : ( |- unmap M2b T2b'),
                            Dequiv2b : ( |- cn-equiv T2b T2b' t),
                            K : ( |- kind),
                            Dtunmap : ( |- tunmap et K),
                            Dequiv1 : ( |- cn-equiv T1a' T2a' K)
                          | equiv :
                              [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
                          ; split [ |- Dtunmap] as
                            case tunmap/t:
                            { T1a : ( |- con),
                              T1b : ( |- con),
                              T2a : ( |- con),
                              T2b : ( |- con),
                              Dequiv :
                                ( |- cn-equiv (prod T1a T1b) (prod T2a T2b) t),
                              Dof1 : ( |- cn-of (prod T1a T1b) t),
                              Dof2 : ( |- cn-of (prod T2a T2b) t),
                              Dwf : ( |- kd-wf t),
                              Dof1a : ( |- cn-of T1a t),
                              Dof1b : ( |- cn-of T1b t),
                              Dof2a : ( |- cn-of T2a t),
                              Dof2b : ( |- cn-of T2b t),
                              M1a : ( |- eterm),
                              M1b : ( |- eterm),
                              M2a : ( |- eterm),
                              M2b : ( |- eterm),
                              Dmap1a : ( |- map T1a M1a),
                              Dmap1b : ( |- map T1b M1b),
                              Dmap2a : ( |- map T2a M2a),
                              Dmap2b : ( |- map T2b M2b),
                              Dequiv' :
                                ( |-
                                   equiv
                                     (eapp (eapp (econst const/prod) M1a)
                                     M1b)
                                     (eapp (eapp (econst const/prod) M2a)
                                     M2b) et),
                              Dequiv1' : ( |- equiv M1a M2a et),
                              Dequiv2' : ( |- equiv M1b M2b et),
                              T1a' : ( |- con),
                              Dunmap1a : ( |- unmap M1a T1a'),
                              Dequiv1a : ( |- cn-equiv T1a T1a' t),
                              T1b' : ( |- con),
                              Dunmap1b : ( |- unmap M1b T1b'),
                              Dequiv1b : ( |- cn-equiv T1b T1b' t),
                              T2a' : ( |- con),
                              Dunmap2a : ( |- unmap M2a T2a'),
                              Dequiv2a : ( |- cn-equiv T2a T2a' t),
                              T2b' : ( |- con),
                              Dunmap2b : ( |- unmap M2b T2b'),
                              Dequiv2b : ( |- cn-equiv T2b T2b' t),
                              Dequiv1 : ( |- cn-equiv T1a' T2a' t)
                            | equiv :
                                [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
                            ; split
                              unmap-equiv [ |- Dunmap1b] [ |- Dunmap2b]
                                [ |- Dequiv2'] as
                              case unmap-equiv/i:
                              { T1a : ( |- con),
                                T1b : ( |- con),
                                T2a : ( |- con),
                                T2b : ( |- con),
                                Dequiv :
                                  ( |-
                                     cn-equiv (prod T1a T1b) (prod T2a T2b) t),
                                Dof1 : ( |- cn-of (prod T1a T1b) t),
                                Dof2 : ( |- cn-of (prod T2a T2b) t),
                                Dwf : ( |- kd-wf t),
                                Dof1a : ( |- cn-of T1a t),
                                Dof1b : ( |- cn-of T1b t),
                                Dof2a : ( |- cn-of T2a t),
                                Dof2b : ( |- cn-of T2b t),
                                M1a : ( |- eterm),
                                M1b : ( |- eterm),
                                M2a : ( |- eterm),
                                M2b : ( |- eterm),
                                Dmap1a : ( |- map T1a M1a),
                                Dmap1b : ( |- map T1b M1b),
                                Dmap2a : ( |- map T2a M2a),
                                Dmap2b : ( |- map T2b M2b),
                                Dequiv' :
                                  ( |-
                                     equiv
                                       (eapp (eapp (econst const/prod) M1a)
                                       M1b)
                                       (eapp (eapp (econst const/prod) M2a)
                                       M2b) et),
                                Dequiv1' : ( |- equiv M1a M2a et),
                                Dequiv2' : ( |- equiv M1b M2b et),
                                T1a' : ( |- con),
                                Dunmap1a : ( |- unmap M1a T1a'),
                                Dequiv1a : ( |- cn-equiv T1a T1a' t),
                                T1b' : ( |- con),
                                Dunmap1b : ( |- unmap M1b T1b'),
                                Dequiv1b : ( |- cn-equiv T1b T1b' t),
                                T2a' : ( |- con),
                                Dunmap2a : ( |- unmap M2a T2a'),
                                Dequiv2a : ( |- cn-equiv T2a T2a' t),
                                T2b' : ( |- con),
                                Dunmap2b : ( |- unmap M2b T2b'),
                                Dequiv2b : ( |- cn-equiv T2b T2b' t),
                                Dequiv1 : ( |- cn-equiv T1a' T2a' t),
                                K : ( |- kind),
                                Dtunmap : ( |- tunmap et K),
                                Dequiv2 : ( |- cn-equiv T1b' T2b' K)
                              | equiv :
                                  [ |-
                                     cn-equiv (prod T1a T1b) (prod T2a T2b) t]
                              ; split [ |- Dtunmap] as
                                case tunmap/t:
                                { T1a : ( |- con),
                                  T1b : ( |- con),
                                  T2a : ( |- con),
                                  T2b : ( |- con),
                                  Dequiv :
                                    ( |-
                                       cn-equiv
                                         (prod T1a T1b) (prod T2a T2b) t),
                                  Dof1 : ( |- cn-of (prod T1a T1b) t),
                                  Dof2 : ( |- cn-of (prod T2a T2b) t),
                                  Dwf : ( |- kd-wf t),
                                  Dof1a : ( |- cn-of T1a t),
                                  Dof1b : ( |- cn-of T1b t),
                                  Dof2a : ( |- cn-of T2a t),
                                  Dof2b : ( |- cn-of T2b t),
                                  M1a : ( |- eterm),
                                  M1b : ( |- eterm),
                                  M2a : ( |- eterm),
                                  M2b : ( |- eterm),
                                  Dmap1a : ( |- map T1a M1a),
                                  Dmap1b : ( |- map T1b M1b),
                                  Dmap2a : ( |- map T2a M2a),
                                  Dmap2b : ( |- map T2b M2b),
                                  Dequiv' :
                                    ( |-
                                       equiv
                                         (eapp (eapp (econst const/prod) M1a)
                                         M1b)
                                         (eapp (eapp (econst const/prod) M2a)
                                         M2b) et),
                                  Dequiv1' : ( |- equiv M1a M2a et),
                                  Dequiv2' : ( |- equiv M1b M2b et),
                                  T1a' : ( |- con),
                                  Dunmap1a : ( |- unmap M1a T1a'),
                                  Dequiv1a : ( |- cn-equiv T1a T1a' t),
                                  T1b' : ( |- con),
                                  Dunmap1b : ( |- unmap M1b T1b'),
                                  Dequiv1b : ( |- cn-equiv T1b T1b' t),
                                  T2a' : ( |- con),
                                  Dunmap2a : ( |- unmap M2a T2a'),
                                  Dequiv2a : ( |- cn-equiv T2a T2a' t),
                                  T2b' : ( |- con),
                                  Dunmap2b : ( |- unmap M2b T2b'),
                                  Dequiv2b : ( |- cn-equiv T2b T2b' t),
                                  Dequiv1 : ( |- cn-equiv T1a' T2a' t),
                                  Dequiv2 : ( |- cn-equiv T1b' T2b' t)
                                | equiv :
                                    [ |-
                                       cn-equiv
                                         (prod T1a T1b) (prod T2a T2b) t]
                                ; solve
                                    [ |-
                                       injective-prod/i (cn-equiv/trans 
                                                        Dequiv1a
                                                        (cn-equiv/trans 
                                                        Dequiv1
                                                        (cn-equiv/symm 
                                                        Dequiv2a)))
                                       (cn-equiv/trans Dequiv1b
                                       (cn-equiv/trans Dequiv2
                                       (cn-equiv/symm Dequiv2b)))]
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
;

LF injective-arrow/e : con -> con -> con -> con -> type =
| injective-arrow/i :
  cn-equiv T1a T2a t ->
  cn-equiv T1b T2b t ->
    injective-arrow/e T1a T1b T2a T2b
;

proof injective-arrow :
  [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t] ->
    [ |- injective-arrow/e T1a T1b T2a T2b] =
/ total /
intros
{ T1a : ( |- con), T1b : ( |- con), T2a : ( |- con), T2b : ( |- con)
| equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
; by equiv as Dequiv unboxed;
  split cn-equiv-reg [ |- Dequiv] as
  case cn-equiv-reg/i:
  { T1a : ( |- con),
    T1b : ( |- con),
    T2a : ( |- con),
    T2b : ( |- con),
    Dequiv : ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
    Dof1 : ( |- cn-of (arrow T1a T1b) t),
    Dof2 : ( |- cn-of (arrow T2a T2b) t),
    Dwf : ( |- kd-wf t)
  | equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
  ; split inversion-arrow [ |- Dof1] as
    case inversion-arrow/i:
    { T1a : ( |- con),
      T1b : ( |- con),
      T2a : ( |- con),
      T2b : ( |- con),
      Dequiv : ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
      Dof1 : ( |- cn-of (arrow T1a T1b) t),
      Dof2 : ( |- cn-of (arrow T2a T2b) t),
      Dwf : ( |- kd-wf t),
      Dof1a : ( |- cn-of T1a t),
      Dof1b : ( |- cn-of T1b t)
    | equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
    ; split inversion-arrow [ |- Dof2] as
      case inversion-arrow/i:
      { T1a : ( |- con),
        T1b : ( |- con),
        T2a : ( |- con),
        T2b : ( |- con),
        Dequiv : ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
        Dof1 : ( |- cn-of (arrow T1a T1b) t),
        Dof2 : ( |- cn-of (arrow T2a T2b) t),
        Dwf : ( |- kd-wf t),
        Dof1a : ( |- cn-of T1a t),
        Dof1b : ( |- cn-of T1b t),
        Dof2a : ( |- cn-of T2a t),
        Dof2b : ( |- cn-of T2b t)
      | equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
      ; split map-equiv [ |- _] [ |- _] [ |- Dequiv] as
        case map-equiv/i:
        { T1a : ( |- con),
          T1b : ( |- con),
          T2a : ( |- con),
          T2b : ( |- con),
          Dequiv : ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
          Dof1 : ( |- cn-of (arrow T1a T1b) t),
          Dof2 : ( |- cn-of (arrow T2a T2b) t),
          Dwf : ( |- kd-wf t),
          Dof1a : ( |- cn-of T1a t),
          Dof1b : ( |- cn-of T1b t),
          Dof2a : ( |- cn-of T2a t),
          Dof2b : ( |- cn-of T2b t),
          M : ( |- eterm),
          M' : ( |- eterm),
          A : ( |- etp),
          Dmap : ( |- map (arrow T1a T1b) M),
          Dmap' : ( |- map (arrow T2a T2b) M'),
          Dtmap : ( |- tmap t A),
          Dequiv1 : ( |- equiv M M' A)
        | equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
        ; split [ |- Dmap] as
          case map/arrow:
          { T1a : ( |- con),
            T1b : ( |- con),
            T2a : ( |- con),
            T2b : ( |- con),
            Dequiv : ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
            Dof1 : ( |- cn-of (arrow T1a T1b) t),
            Dof2 : ( |- cn-of (arrow T2a T2b) t),
            Dwf : ( |- kd-wf t),
            Dof1a : ( |- cn-of T1a t),
            Dof1b : ( |- cn-of T1b t),
            Dof2a : ( |- cn-of T2a t),
            Dof2b : ( |- cn-of T2b t),
            M1a : ( |- eterm),
            M1b : ( |- eterm),
            M' : ( |- eterm),
            A : ( |- etp),
            Dmap1a : ( |- map T1a M1a),
            Dmap1b : ( |- map T1b M1b),
            Dmap' : ( |- map (arrow T2a T2b) M'),
            Dtmap : ( |- tmap t A),
            Dequiv' :
              ( |- equiv (eapp (eapp (econst const/arrow) M1a) M1b) M' A)
          | equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
          ; split [ |- Dmap'] as
            case map/arrow:
            { T1a : ( |- con),
              T1b : ( |- con),
              T2a : ( |- con),
              T2b : ( |- con),
              Dequiv : ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
              Dof1 : ( |- cn-of (arrow T1a T1b) t),
              Dof2 : ( |- cn-of (arrow T2a T2b) t),
              Dwf : ( |- kd-wf t),
              Dof1a : ( |- cn-of T1a t),
              Dof1b : ( |- cn-of T1b t),
              Dof2a : ( |- cn-of T2a t),
              Dof2b : ( |- cn-of T2b t),
              M1a : ( |- eterm),
              M1b : ( |- eterm),
              M2a : ( |- eterm),
              M2b : ( |- eterm),
              A : ( |- etp),
              Dmap1a : ( |- map T1a M1a),
              Dmap1b : ( |- map T1b M1b),
              Dmap2a : ( |- map T2a M2a),
              Dmap2b : ( |- map T2b M2b),
              Dtmap : ( |- tmap t A),
              Dequiv' :
                ( |-
                   equiv
                     (eapp (eapp (econst const/arrow) M1a) M1b)
                     (eapp (eapp (econst const/arrow) M2a) M2b) A)
            | equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
            ; split [ |- Dtmap] as
              case tmap/t:
              { T1a : ( |- con),
                T1b : ( |- con),
                T2a : ( |- con),
                T2b : ( |- con),
                Dequiv : ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
                Dof1 : ( |- cn-of (arrow T1a T1b) t),
                Dof2 : ( |- cn-of (arrow T2a T2b) t),
                Dwf : ( |- kd-wf t),
                Dof1a : ( |- cn-of T1a t),
                Dof1b : ( |- cn-of T1b t),
                Dof2a : ( |- cn-of T2a t),
                Dof2b : ( |- cn-of T2b t),
                M1a : ( |- eterm),
                M1b : ( |- eterm),
                M2a : ( |- eterm),
                M2b : ( |- eterm),
                Dmap1a : ( |- map T1a M1a),
                Dmap1b : ( |- map T1b M1b),
                Dmap2a : ( |- map T2a M2a),
                Dmap2b : ( |- map T2b M2b),
                Dequiv' :
                  ( |-
                     equiv
                       (eapp (eapp (econst const/arrow) M1a) M1b)
                       (eapp (eapp (econst const/arrow) M2a) M2b) et)
              | equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
              ; split
                binary-equiv-inversion
                  [ |-
                     ekof/i ckof/arrow
                     (etopen/pi etopen/t
                     etp-skel/t
                     (\l1.
                        \l2.
                          \l3.
                            etopen/pi etopen/t
                            etp-skel/t (\l4. \l5. \l6. etopen/t)))]
                  [ |- Dequiv'] as
                case binary-equiv-inversion/i:
                { T1a : ( |- con),
                  T1b : ( |- con),
                  T2a : ( |- con),
                  T2b : ( |- con),
                  Dequiv : ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
                  Dof1 : ( |- cn-of (arrow T1a T1b) t),
                  Dof2 : ( |- cn-of (arrow T2a T2b) t),
                  Dwf : ( |- kd-wf t),
                  Dof1a : ( |- cn-of T1a t),
                  Dof1b : ( |- cn-of T1b t),
                  Dof2a : ( |- cn-of T2a t),
                  Dof2b : ( |- cn-of T2b t),
                  M1a : ( |- eterm),
                  M1b : ( |- eterm),
                  M2a : ( |- eterm),
                  M2b : ( |- eterm),
                  Dmap1a : ( |- map T1a M1a),
                  Dmap1b : ( |- map T1b M1b),
                  Dmap2a : ( |- map T2a M2a),
                  Dmap2b : ( |- map T2b M2b),
                  Dequiv' :
                    ( |-
                       equiv
                         (eapp (eapp (econst const/arrow) M1a) M1b)
                         (eapp (eapp (econst const/arrow) M2a) M2b) et),
                  Dequiv1' : ( |- equiv M1a M2a et),
                  Dequiv2' : ( |- equiv M1b M2b et)
                | equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
                ; split invert-map [ |- Dof1a] [ |- Dmap1a] as
                  case invert-map/i:
                  { T1a : ( |- con),
                    T1b : ( |- con),
                    T2a : ( |- con),
                    T2b : ( |- con),
                    Dequiv : ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
                    Dof1 : ( |- cn-of (arrow T1a T1b) t),
                    Dof2 : ( |- cn-of (arrow T2a T2b) t),
                    Dwf : ( |- kd-wf t),
                    Dof1a : ( |- cn-of T1a t),
                    Dof1b : ( |- cn-of T1b t),
                    Dof2a : ( |- cn-of T2a t),
                    Dof2b : ( |- cn-of T2b t),
                    M1a : ( |- eterm),
                    M1b : ( |- eterm),
                    M2a : ( |- eterm),
                    M2b : ( |- eterm),
                    Dmap1a : ( |- map T1a M1a),
                    Dmap1b : ( |- map T1b M1b),
                    Dmap2a : ( |- map T2a M2a),
                    Dmap2b : ( |- map T2b M2b),
                    Dequiv' :
                      ( |-
                         equiv
                           (eapp (eapp (econst const/arrow) M1a) M1b)
                           (eapp (eapp (econst const/arrow) M2a) M2b) et),
                    Dequiv1' : ( |- equiv M1a M2a et),
                    Dequiv2' : ( |- equiv M1b M2b et),
                    C1 : ( |- con),
                    Dunmap : ( |- unmap M1a C1),
                    Dequiv1 : ( |- cn-equiv T1a C1 t)
                  | equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
                  ; split invert-map [ |- Dof1b] [ |- Dmap1b] as
                    case invert-map/i:
                    { T1a : ( |- con),
                      T1b : ( |- con),
                      T2a : ( |- con),
                      T2b : ( |- con),
                      Dequiv : ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
                      Dof1 : ( |- cn-of (arrow T1a T1b) t),
                      Dof2 : ( |- cn-of (arrow T2a T2b) t),
                      Dwf : ( |- kd-wf t),
                      Dof1a : ( |- cn-of T1a t),
                      Dof1b : ( |- cn-of T1b t),
                      Dof2a : ( |- cn-of T2a t),
                      Dof2b : ( |- cn-of T2b t),
                      M1a : ( |- eterm),
                      M1b : ( |- eterm),
                      M2a : ( |- eterm),
                      M2b : ( |- eterm),
                      Dmap1a : ( |- map T1a M1a),
                      Dmap1b : ( |- map T1b M1b),
                      Dmap2a : ( |- map T2a M2a),
                      Dmap2b : ( |- map T2b M2b),
                      Dequiv' :
                        ( |-
                           equiv
                             (eapp (eapp (econst const/arrow) M1a) M1b)
                             (eapp (eapp (econst const/arrow) M2a) M2b) et),
                      Dequiv1' : ( |- equiv M1a M2a et),
                      Dequiv2' : ( |- equiv M1b M2b et),
                      T1a' : ( |- con),
                      Dunmap1a : ( |- unmap M1a T1a'),
                      Dequiv1a : ( |- cn-equiv T1a T1a' t),
                      C1 : ( |- con),
                      Dunmap : ( |- unmap M1b C1),
                      Dequiv1 : ( |- cn-equiv T1b C1 t)
                    | equiv : [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
                    ; split invert-map [ |- Dof2a] [ |- Dmap2a] as
                      case invert-map/i:
                      { T1a : ( |- con),
                        T1b : ( |- con),
                        T2a : ( |- con),
                        T2b : ( |- con),
                        Dequiv :
                          ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
                        Dof1 : ( |- cn-of (arrow T1a T1b) t),
                        Dof2 : ( |- cn-of (arrow T2a T2b) t),
                        Dwf : ( |- kd-wf t),
                        Dof1a : ( |- cn-of T1a t),
                        Dof1b : ( |- cn-of T1b t),
                        Dof2a : ( |- cn-of T2a t),
                        Dof2b : ( |- cn-of T2b t),
                        M1a : ( |- eterm),
                        M1b : ( |- eterm),
                        M2a : ( |- eterm),
                        M2b : ( |- eterm),
                        Dmap1a : ( |- map T1a M1a),
                        Dmap1b : ( |- map T1b M1b),
                        Dmap2a : ( |- map T2a M2a),
                        Dmap2b : ( |- map T2b M2b),
                        Dequiv' :
                          ( |-
                             equiv
                               (eapp (eapp (econst const/arrow) M1a) M1b)
                               (eapp (eapp (econst const/arrow) M2a) M2b) et),
                        Dequiv1' : ( |- equiv M1a M2a et),
                        Dequiv2' : ( |- equiv M1b M2b et),
                        T1a' : ( |- con),
                        Dunmap1a : ( |- unmap M1a T1a'),
                        Dequiv1a : ( |- cn-equiv T1a T1a' t),
                        T1b' : ( |- con),
                        Dunmap1b : ( |- unmap M1b T1b'),
                        Dequiv1b : ( |- cn-equiv T1b T1b' t),
                        C1 : ( |- con),
                        Dunmap : ( |- unmap M2a C1),
                        Dequiv1 : ( |- cn-equiv T2a C1 t)
                      | equiv :
                          [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
                      ; split invert-map [ |- Dof2b] [ |- Dmap2b] as
                        case invert-map/i:
                        { T1a : ( |- con),
                          T1b : ( |- con),
                          T2a : ( |- con),
                          T2b : ( |- con),
                          Dequiv :
                            ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
                          Dof1 : ( |- cn-of (arrow T1a T1b) t),
                          Dof2 : ( |- cn-of (arrow T2a T2b) t),
                          Dwf : ( |- kd-wf t),
                          Dof1a : ( |- cn-of T1a t),
                          Dof1b : ( |- cn-of T1b t),
                          Dof2a : ( |- cn-of T2a t),
                          Dof2b : ( |- cn-of T2b t),
                          M1a : ( |- eterm),
                          M1b : ( |- eterm),
                          M2a : ( |- eterm),
                          M2b : ( |- eterm),
                          Dmap1a : ( |- map T1a M1a),
                          Dmap1b : ( |- map T1b M1b),
                          Dmap2a : ( |- map T2a M2a),
                          Dmap2b : ( |- map T2b M2b),
                          Dequiv' :
                            ( |-
                               equiv
                                 (eapp (eapp (econst const/arrow) M1a) M1b)
                                 (eapp (eapp (econst const/arrow) M2a) M2b) et),
                          Dequiv1' : ( |- equiv M1a M2a et),
                          Dequiv2' : ( |- equiv M1b M2b et),
                          T1a' : ( |- con),
                          Dunmap1a : ( |- unmap M1a T1a'),
                          Dequiv1a : ( |- cn-equiv T1a T1a' t),
                          T1b' : ( |- con),
                          Dunmap1b : ( |- unmap M1b T1b'),
                          Dequiv1b : ( |- cn-equiv T1b T1b' t),
                          T2a' : ( |- con),
                          Dunmap2a : ( |- unmap M2a T2a'),
                          Dequiv2a : ( |- cn-equiv T2a T2a' t),
                          C1 : ( |- con),
                          Dunmap : ( |- unmap M2b C1),
                          Dequiv1 : ( |- cn-equiv T2b C1 t)
                        | equiv :
                            [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
                        ; split
                          unmap-equiv [ |- Dunmap1a] [ |- Dunmap2a]
                            [ |- Dequiv1'] as
                          case unmap-equiv/i:
                          { T1a : ( |- con),
                            T1b : ( |- con),
                            T2a : ( |- con),
                            T2b : ( |- con),
                            Dequiv :
                              ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
                            Dof1 : ( |- cn-of (arrow T1a T1b) t),
                            Dof2 : ( |- cn-of (arrow T2a T2b) t),
                            Dwf : ( |- kd-wf t),
                            Dof1a : ( |- cn-of T1a t),
                            Dof1b : ( |- cn-of T1b t),
                            Dof2a : ( |- cn-of T2a t),
                            Dof2b : ( |- cn-of T2b t),
                            M1a : ( |- eterm),
                            M1b : ( |- eterm),
                            M2a : ( |- eterm),
                            M2b : ( |- eterm),
                            Dmap1a : ( |- map T1a M1a),
                            Dmap1b : ( |- map T1b M1b),
                            Dmap2a : ( |- map T2a M2a),
                            Dmap2b : ( |- map T2b M2b),
                            Dequiv' :
                              ( |-
                                 equiv
                                   (eapp (eapp (econst const/arrow) M1a) M1b)
                                   (eapp (eapp (econst const/arrow) M2a) M2b)
                                   et),
                            Dequiv1' : ( |- equiv M1a M2a et),
                            Dequiv2' : ( |- equiv M1b M2b et),
                            T1a' : ( |- con),
                            Dunmap1a : ( |- unmap M1a T1a'),
                            Dequiv1a : ( |- cn-equiv T1a T1a' t),
                            T1b' : ( |- con),
                            Dunmap1b : ( |- unmap M1b T1b'),
                            Dequiv1b : ( |- cn-equiv T1b T1b' t),
                            T2a' : ( |- con),
                            Dunmap2a : ( |- unmap M2a T2a'),
                            Dequiv2a : ( |- cn-equiv T2a T2a' t),
                            T2b' : ( |- con),
                            Dunmap2b : ( |- unmap M2b T2b'),
                            Dequiv2b : ( |- cn-equiv T2b T2b' t),
                            K : ( |- kind),
                            Dtunmap : ( |- tunmap et K),
                            Dequiv1 : ( |- cn-equiv T1a' T2a' K)
                          | equiv :
                              [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
                          ; split [ |- Dtunmap] as
                            case tunmap/t:
                            { T1a : ( |- con),
                              T1b : ( |- con),
                              T2a : ( |- con),
                              T2b : ( |- con),
                              Dequiv :
                                ( |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
                              Dof1 : ( |- cn-of (arrow T1a T1b) t),
                              Dof2 : ( |- cn-of (arrow T2a T2b) t),
                              Dwf : ( |- kd-wf t),
                              Dof1a : ( |- cn-of T1a t),
                              Dof1b : ( |- cn-of T1b t),
                              Dof2a : ( |- cn-of T2a t),
                              Dof2b : ( |- cn-of T2b t),
                              M1a : ( |- eterm),
                              M1b : ( |- eterm),
                              M2a : ( |- eterm),
                              M2b : ( |- eterm),
                              Dmap1a : ( |- map T1a M1a),
                              Dmap1b : ( |- map T1b M1b),
                              Dmap2a : ( |- map T2a M2a),
                              Dmap2b : ( |- map T2b M2b),
                              Dequiv' :
                                ( |-
                                   equiv
                                     (eapp (eapp (econst const/arrow) M1a)
                                     M1b)
                                     (eapp (eapp (econst const/arrow) M2a)
                                     M2b) et),
                              Dequiv1' : ( |- equiv M1a M2a et),
                              Dequiv2' : ( |- equiv M1b M2b et),
                              T1a' : ( |- con),
                              Dunmap1a : ( |- unmap M1a T1a'),
                              Dequiv1a : ( |- cn-equiv T1a T1a' t),
                              T1b' : ( |- con),
                              Dunmap1b : ( |- unmap M1b T1b'),
                              Dequiv1b : ( |- cn-equiv T1b T1b' t),
                              T2a' : ( |- con),
                              Dunmap2a : ( |- unmap M2a T2a'),
                              Dequiv2a : ( |- cn-equiv T2a T2a' t),
                              T2b' : ( |- con),
                              Dunmap2b : ( |- unmap M2b T2b'),
                              Dequiv2b : ( |- cn-equiv T2b T2b' t),
                              Dequiv1 : ( |- cn-equiv T1a' T2a' t)
                            | equiv :
                                [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
                            ; split
                              unmap-equiv [ |- Dunmap1b] [ |- Dunmap2b]
                                [ |- Dequiv2'] as
                              case unmap-equiv/i:
                              { T1a : ( |- con),
                                T1b : ( |- con),
                                T2a : ( |- con),
                                T2b : ( |- con),
                                Dequiv :
                                  ( |-
                                     cn-equiv (arrow T1a T1b) (arrow T2a T2b) t),
                                Dof1 : ( |- cn-of (arrow T1a T1b) t),
                                Dof2 : ( |- cn-of (arrow T2a T2b) t),
                                Dwf : ( |- kd-wf t),
                                Dof1a : ( |- cn-of T1a t),
                                Dof1b : ( |- cn-of T1b t),
                                Dof2a : ( |- cn-of T2a t),
                                Dof2b : ( |- cn-of T2b t),
                                M1a : ( |- eterm),
                                M1b : ( |- eterm),
                                M2a : ( |- eterm),
                                M2b : ( |- eterm),
                                Dmap1a : ( |- map T1a M1a),
                                Dmap1b : ( |- map T1b M1b),
                                Dmap2a : ( |- map T2a M2a),
                                Dmap2b : ( |- map T2b M2b),
                                Dequiv' :
                                  ( |-
                                     equiv
                                       (eapp (eapp (econst const/arrow) M1a)
                                       M1b)
                                       (eapp (eapp (econst const/arrow) M2a)
                                       M2b) et),
                                Dequiv1' : ( |- equiv M1a M2a et),
                                Dequiv2' : ( |- equiv M1b M2b et),
                                T1a' : ( |- con),
                                Dunmap1a : ( |- unmap M1a T1a'),
                                Dequiv1a : ( |- cn-equiv T1a T1a' t),
                                T1b' : ( |- con),
                                Dunmap1b : ( |- unmap M1b T1b'),
                                Dequiv1b : ( |- cn-equiv T1b T1b' t),
                                T2a' : ( |- con),
                                Dunmap2a : ( |- unmap M2a T2a'),
                                Dequiv2a : ( |- cn-equiv T2a T2a' t),
                                T2b' : ( |- con),
                                Dunmap2b : ( |- unmap M2b T2b'),
                                Dequiv2b : ( |- cn-equiv T2b T2b' t),
                                Dequiv1 : ( |- cn-equiv T1a' T2a' t),
                                K : ( |- kind),
                                Dtunmap : ( |- tunmap et K),
                                Dequiv2 : ( |- cn-equiv T1b' T2b' K)
                              | equiv :
                                  [ |-
                                     cn-equiv (arrow T1a T1b) (arrow T2a T2b) t]
                              ; split [ |- Dtunmap] as
                                case tunmap/t:
                                { T1a : ( |- con),
                                  T1b : ( |- con),
                                  T2a : ( |- con),
                                  T2b : ( |- con),
                                  Dequiv :
                                    ( |-
                                       cn-equiv
                                         (arrow T1a T1b) (arrow T2a T2b) t),
                                  Dof1 : ( |- cn-of (arrow T1a T1b) t),
                                  Dof2 : ( |- cn-of (arrow T2a T2b) t),
                                  Dwf : ( |- kd-wf t),
                                  Dof1a : ( |- cn-of T1a t),
                                  Dof1b : ( |- cn-of T1b t),
                                  Dof2a : ( |- cn-of T2a t),
                                  Dof2b : ( |- cn-of T2b t),
                                  M1a : ( |- eterm),
                                  M1b : ( |- eterm),
                                  M2a : ( |- eterm),
                                  M2b : ( |- eterm),
                                  Dmap1a : ( |- map T1a M1a),
                                  Dmap1b : ( |- map T1b M1b),
                                  Dmap2a : ( |- map T2a M2a),
                                  Dmap2b : ( |- map T2b M2b),
                                  Dequiv' :
                                    ( |-
                                       equiv
                                         (eapp (eapp (econst const/arrow) M1a)
                                         M1b)
                                         (eapp (eapp (econst const/arrow) M2a)
                                         M2b) et),
                                  Dequiv1' : ( |- equiv M1a M2a et),
                                  Dequiv2' : ( |- equiv M1b M2b et),
                                  T1a' : ( |- con),
                                  Dunmap1a : ( |- unmap M1a T1a'),
                                  Dequiv1a : ( |- cn-equiv T1a T1a' t),
                                  T1b' : ( |- con),
                                  Dunmap1b : ( |- unmap M1b T1b'),
                                  Dequiv1b : ( |- cn-equiv T1b T1b' t),
                                  T2a' : ( |- con),
                                  Dunmap2a : ( |- unmap M2a T2a'),
                                  Dequiv2a : ( |- cn-equiv T2a T2a' t),
                                  T2b' : ( |- con),
                                  Dunmap2b : ( |- unmap M2b T2b'),
                                  Dequiv2b : ( |- cn-equiv T2b T2b' t),
                                  Dequiv1 : ( |- cn-equiv T1a' T2a' t),
                                  Dequiv2 : ( |- cn-equiv T1b' T2b' t)
                                | equiv :
                                    [ |-
                                       cn-equiv
                                         (arrow T1a T1b) (arrow T2a T2b) t]
                                ; solve
                                    [ |-
                                       injective-arrow/i (cn-equiv/trans
                                                        Dequiv1a
                                                        (cn-equiv/trans
                                                        Dequiv1
                                                        (cn-equiv/symm
                                                        Dequiv2a)))
                                       (cn-equiv/trans Dequiv1b
                                       (cn-equiv/trans Dequiv2
                                       (cn-equiv/symm Dequiv2b)))]
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
;

LF injective-plus/e : con -> con -> con -> con -> type =
| injective-plus/i :
  cn-equiv T1a T2a t ->
  cn-equiv T1b T2b t ->
    injective-plus/e  T1a T1b T2a T2b
;

proof injective-plus :
  [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t] ->
    [ |- injective-plus/e T1a T1b T2a T2b] =
/ total /
intros
{ T1a : ( |- con), T1b : ( |- con), T2a : ( |- con), T2b : ( |- con)
| equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
; by equiv as Dequiv unboxed;
  split cn-equiv-reg [ |- Dequiv] as
  case cn-equiv-reg/i:
  { T1a : ( |- con),
    T1b : ( |- con),
    T2a : ( |- con),
    T2b : ( |- con),
    Dequiv : ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
    Dof1 : ( |- cn-of (plus T1a T1b) t),
    Dof2 : ( |- cn-of (plus T2a T2b) t),
    Dwf : ( |- kd-wf t)
  | equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
  ; split inversion-plus [ |- Dof1] as
    case inversion-plus/i:
    { T1a : ( |- con),
      T1b : ( |- con),
      T2a : ( |- con),
      T2b : ( |- con),
      Dequiv : ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
      Dof1 : ( |- cn-of (plus T1a T1b) t),
      Dof2 : ( |- cn-of (plus T2a T2b) t),
      Dwf : ( |- kd-wf t),
      Dof1a : ( |- cn-of T1a t),
      Dof1b : ( |- cn-of T1b t)
    | equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
    ; split inversion-plus [ |- Dof2] as
      case inversion-plus/i:
      { T1a : ( |- con),
        T1b : ( |- con),
        T2a : ( |- con),
        T2b : ( |- con),
        Dequiv : ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
        Dof1 : ( |- cn-of (plus T1a T1b) t),
        Dof2 : ( |- cn-of (plus T2a T2b) t),
        Dwf : ( |- kd-wf t),
        Dof1a : ( |- cn-of T1a t),
        Dof1b : ( |- cn-of T1b t),
        Dof2a : ( |- cn-of T2a t),
        Dof2b : ( |- cn-of T2b t)
      | equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
      ; split map-equiv [ |- _] [ |- _] [ |- Dequiv] as
        case map-equiv/i:
        { T1a : ( |- con),
          T1b : ( |- con),
          T2a : ( |- con),
          T2b : ( |- con),
          Dequiv : ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
          Dof1 : ( |- cn-of (plus T1a T1b) t),
          Dof2 : ( |- cn-of (plus T2a T2b) t),
          Dwf : ( |- kd-wf t),
          Dof1a : ( |- cn-of T1a t),
          Dof1b : ( |- cn-of T1b t),
          Dof2a : ( |- cn-of T2a t),
          Dof2b : ( |- cn-of T2b t),
          M : ( |- eterm),
          M' : ( |- eterm),
          A : ( |- etp),
          Dmap : ( |- map (plus T1a T1b) M),
          Dmap' : ( |- map (plus T2a T2b) M'),
          Dtmap : ( |- tmap t A),
          Dequiv1 : ( |- equiv M M' A)
        | equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
        ; split [ |- Dmap] as
          case map/plus:
          { T1a : ( |- con),
            T1b : ( |- con),
            T2a : ( |- con),
            T2b : ( |- con),
            Dequiv : ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
            Dof1 : ( |- cn-of (plus T1a T1b) t),
            Dof2 : ( |- cn-of (plus T2a T2b) t),
            Dwf : ( |- kd-wf t),
            Dof1a : ( |- cn-of T1a t),
            Dof1b : ( |- cn-of T1b t),
            Dof2a : ( |- cn-of T2a t),
            Dof2b : ( |- cn-of T2b t),
            M1a : ( |- eterm),
            M1b : ( |- eterm),
            M' : ( |- eterm),
            A : ( |- etp),
            Dmap1a : ( |- map T1a M1a),
            Dmap1b : ( |- map T1b M1b),
            Dmap' : ( |- map (plus T2a T2b) M'),
            Dtmap : ( |- tmap t A),
            Dequiv' :
              ( |- equiv (eapp (eapp (econst const/plus) M1a) M1b) M' A)
          | equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
          ; split [ |- Dmap'] as
            case map/plus:
            { T1a : ( |- con),
              T1b : ( |- con),
              T2a : ( |- con),
              T2b : ( |- con),
              Dequiv : ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
              Dof1 : ( |- cn-of (plus T1a T1b) t),
              Dof2 : ( |- cn-of (plus T2a T2b) t),
              Dwf : ( |- kd-wf t),
              Dof1a : ( |- cn-of T1a t),
              Dof1b : ( |- cn-of T1b t),
              Dof2a : ( |- cn-of T2a t),
              Dof2b : ( |- cn-of T2b t),
              M1a : ( |- eterm),
              M1b : ( |- eterm),
              M2a : ( |- eterm),
              M2b : ( |- eterm),
              A : ( |- etp),
              Dmap1a : ( |- map T1a M1a),
              Dmap1b : ( |- map T1b M1b),
              Dmap2a : ( |- map T2a M2a),
              Dmap2b : ( |- map T2b M2b),
              Dtmap : ( |- tmap t A),
              Dequiv' :
                ( |-
                   equiv
                     (eapp (eapp (econst const/plus) M1a) M1b)
                     (eapp (eapp (econst const/plus) M2a) M2b) A)
            | equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
            ; split [ |- Dtmap] as
              case tmap/t:
              { T1a : ( |- con),
                T1b : ( |- con),
                T2a : ( |- con),
                T2b : ( |- con),
                Dequiv : ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
                Dof1 : ( |- cn-of (plus T1a T1b) t),
                Dof2 : ( |- cn-of (plus T2a T2b) t),
                Dwf : ( |- kd-wf t),
                Dof1a : ( |- cn-of T1a t),
                Dof1b : ( |- cn-of T1b t),
                Dof2a : ( |- cn-of T2a t),
                Dof2b : ( |- cn-of T2b t),
                M1a : ( |- eterm),
                M1b : ( |- eterm),
                M2a : ( |- eterm),
                M2b : ( |- eterm),
                Dmap1a : ( |- map T1a M1a),
                Dmap1b : ( |- map T1b M1b),
                Dmap2a : ( |- map T2a M2a),
                Dmap2b : ( |- map T2b M2b),
                Dequiv' :
                  ( |-
                     equiv
                       (eapp (eapp (econst const/plus) M1a) M1b)
                       (eapp (eapp (econst const/plus) M2a) M2b) et)
              | equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
              ; split
                binary-equiv-inversion
                  [ |-
                     ekof/i ckof/plus
                     (etopen/pi etopen/t
                     etp-skel/t
                     (\l1.
                        \l2.
                          \l3.
                            etopen/pi etopen/t
                            etp-skel/t (\l4. \l5. \l6. etopen/t)))]
                  [ |- Dequiv'] as
                case binary-equiv-inversion/i:
                { T1a : ( |- con),
                  T1b : ( |- con),
                  T2a : ( |- con),
                  T2b : ( |- con),
                  Dequiv : ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
                  Dof1 : ( |- cn-of (plus T1a T1b) t),
                  Dof2 : ( |- cn-of (plus T2a T2b) t),
                  Dwf : ( |- kd-wf t),
                  Dof1a : ( |- cn-of T1a t),
                  Dof1b : ( |- cn-of T1b t),
                  Dof2a : ( |- cn-of T2a t),
                  Dof2b : ( |- cn-of T2b t),
                  M1a : ( |- eterm),
                  M1b : ( |- eterm),
                  M2a : ( |- eterm),
                  M2b : ( |- eterm),
                  Dmap1a : ( |- map T1a M1a),
                  Dmap1b : ( |- map T1b M1b),
                  Dmap2a : ( |- map T2a M2a),
                  Dmap2b : ( |- map T2b M2b),
                  Dequiv' :
                    ( |-
                       equiv
                         (eapp (eapp (econst const/plus) M1a) M1b)
                         (eapp (eapp (econst const/plus) M2a) M2b) et),
                  Dequiv1' : ( |- equiv M1a M2a et),
                  Dequiv2' : ( |- equiv M1b M2b et)
                | equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
                ; split invert-map [ |- Dof1a] [ |- Dmap1a] as
                  case invert-map/i:
                  { T1a : ( |- con),
                    T1b : ( |- con),
                    T2a : ( |- con),
                    T2b : ( |- con),
                    Dequiv : ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
                    Dof1 : ( |- cn-of (plus T1a T1b) t),
                    Dof2 : ( |- cn-of (plus T2a T2b) t),
                    Dwf : ( |- kd-wf t),
                    Dof1a : ( |- cn-of T1a t),
                    Dof1b : ( |- cn-of T1b t),
                    Dof2a : ( |- cn-of T2a t),
                    Dof2b : ( |- cn-of T2b t),
                    M1a : ( |- eterm),
                    M1b : ( |- eterm),
                    M2a : ( |- eterm),
                    M2b : ( |- eterm),
                    Dmap1a : ( |- map T1a M1a),
                    Dmap1b : ( |- map T1b M1b),
                    Dmap2a : ( |- map T2a M2a),
                    Dmap2b : ( |- map T2b M2b),
                    Dequiv' :
                      ( |-
                         equiv
                           (eapp (eapp (econst const/plus) M1a) M1b)
                           (eapp (eapp (econst const/plus) M2a) M2b) et),
                    Dequiv1' : ( |- equiv M1a M2a et),
                    Dequiv2' : ( |- equiv M1b M2b et),
                    C1 : ( |- con),
                    Dunmap : ( |- unmap M1a C1),
                    Dequiv1 : ( |- cn-equiv T1a C1 t)
                  | equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
                  ; split invert-map [ |- Dof1b] [ |- Dmap1b] as
                    case invert-map/i:
                    { T1a : ( |- con),
                      T1b : ( |- con),
                      T2a : ( |- con),
                      T2b : ( |- con),
                      Dequiv : ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
                      Dof1 : ( |- cn-of (plus T1a T1b) t),
                      Dof2 : ( |- cn-of (plus T2a T2b) t),
                      Dwf : ( |- kd-wf t),
                      Dof1a : ( |- cn-of T1a t),
                      Dof1b : ( |- cn-of T1b t),
                      Dof2a : ( |- cn-of T2a t),
                      Dof2b : ( |- cn-of T2b t),
                      M1a : ( |- eterm),
                      M1b : ( |- eterm),
                      M2a : ( |- eterm),
                      M2b : ( |- eterm),
                      Dmap1a : ( |- map T1a M1a),
                      Dmap1b : ( |- map T1b M1b),
                      Dmap2a : ( |- map T2a M2a),
                      Dmap2b : ( |- map T2b M2b),
                      Dequiv' :
                        ( |-
                           equiv
                             (eapp (eapp (econst const/plus) M1a) M1b)
                             (eapp (eapp (econst const/plus) M2a) M2b) et),
                      Dequiv1' : ( |- equiv M1a M2a et),
                      Dequiv2' : ( |- equiv M1b M2b et),
                      T1a' : ( |- con),
                      Dunmap1a : ( |- unmap M1a T1a'),
                      Dequiv1a : ( |- cn-equiv T1a T1a' t),
                      C1 : ( |- con),
                      Dunmap : ( |- unmap M1b C1),
                      Dequiv1 : ( |- cn-equiv T1b C1 t)
                    | equiv : [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
                    ; split invert-map [ |- Dof2a] [ |- Dmap2a] as
                      case invert-map/i:
                      { T1a : ( |- con),
                        T1b : ( |- con),
                        T2a : ( |- con),
                        T2b : ( |- con),
                        Dequiv :
                          ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
                        Dof1 : ( |- cn-of (plus T1a T1b) t),
                        Dof2 : ( |- cn-of (plus T2a T2b) t),
                        Dwf : ( |- kd-wf t),
                        Dof1a : ( |- cn-of T1a t),
                        Dof1b : ( |- cn-of T1b t),
                        Dof2a : ( |- cn-of T2a t),
                        Dof2b : ( |- cn-of T2b t),
                        M1a : ( |- eterm),
                        M1b : ( |- eterm),
                        M2a : ( |- eterm),
                        M2b : ( |- eterm),
                        Dmap1a : ( |- map T1a M1a),
                        Dmap1b : ( |- map T1b M1b),
                        Dmap2a : ( |- map T2a M2a),
                        Dmap2b : ( |- map T2b M2b),
                        Dequiv' :
                          ( |-
                             equiv
                               (eapp (eapp (econst const/plus) M1a) M1b)
                               (eapp (eapp (econst const/plus) M2a) M2b) et),
                        Dequiv1' : ( |- equiv M1a M2a et),
                        Dequiv2' : ( |- equiv M1b M2b et),
                        T1a' : ( |- con),
                        Dunmap1a : ( |- unmap M1a T1a'),
                        Dequiv1a : ( |- cn-equiv T1a T1a' t),
                        T1b' : ( |- con),
                        Dunmap1b : ( |- unmap M1b T1b'),
                        Dequiv1b : ( |- cn-equiv T1b T1b' t),
                        C1 : ( |- con),
                        Dunmap : ( |- unmap M2a C1),
                        Dequiv1 : ( |- cn-equiv T2a C1 t)
                      | equiv :
                          [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
                      ; split invert-map [ |- Dof2b] [ |- Dmap2b] as
                        case invert-map/i:
                        { T1a : ( |- con),
                          T1b : ( |- con),
                          T2a : ( |- con),
                          T2b : ( |- con),
                          Dequiv :
                            ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
                          Dof1 : ( |- cn-of (plus T1a T1b) t),
                          Dof2 : ( |- cn-of (plus T2a T2b) t),
                          Dwf : ( |- kd-wf t),
                          Dof1a : ( |- cn-of T1a t),
                          Dof1b : ( |- cn-of T1b t),
                          Dof2a : ( |- cn-of T2a t),
                          Dof2b : ( |- cn-of T2b t),
                          M1a : ( |- eterm),
                          M1b : ( |- eterm),
                          M2a : ( |- eterm),
                          M2b : ( |- eterm),
                          Dmap1a : ( |- map T1a M1a),
                          Dmap1b : ( |- map T1b M1b),
                          Dmap2a : ( |- map T2a M2a),
                          Dmap2b : ( |- map T2b M2b),
                          Dequiv' :
                            ( |-
                               equiv
                                 (eapp (eapp (econst const/plus) M1a) M1b)
                                 (eapp (eapp (econst const/plus) M2a) M2b) et),
                          Dequiv1' : ( |- equiv M1a M2a et),
                          Dequiv2' : ( |- equiv M1b M2b et),
                          T1a' : ( |- con),
                          Dunmap1a : ( |- unmap M1a T1a'),
                          Dequiv1a : ( |- cn-equiv T1a T1a' t),
                          T1b' : ( |- con),
                          Dunmap1b : ( |- unmap M1b T1b'),
                          Dequiv1b : ( |- cn-equiv T1b T1b' t),
                          T2a' : ( |- con),
                          Dunmap2a : ( |- unmap M2a T2a'),
                          Dequiv2a : ( |- cn-equiv T2a T2a' t),
                          C1 : ( |- con),
                          Dunmap : ( |- unmap M2b C1),
                          Dequiv1 : ( |- cn-equiv T2b C1 t)
                        | equiv :
                            [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
                        ; split
                          unmap-equiv [ |- Dunmap1a] [ |- Dunmap2a]
                            [ |- Dequiv1'] as
                          case unmap-equiv/i:
                          { T1a : ( |- con),
                            T1b : ( |- con),
                            T2a : ( |- con),
                            T2b : ( |- con),
                            Dequiv :
                              ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
                            Dof1 : ( |- cn-of (plus T1a T1b) t),
                            Dof2 : ( |- cn-of (plus T2a T2b) t),
                            Dwf : ( |- kd-wf t),
                            Dof1a : ( |- cn-of T1a t),
                            Dof1b : ( |- cn-of T1b t),
                            Dof2a : ( |- cn-of T2a t),
                            Dof2b : ( |- cn-of T2b t),
                            M1a : ( |- eterm),
                            M1b : ( |- eterm),
                            M2a : ( |- eterm),
                            M2b : ( |- eterm),
                            Dmap1a : ( |- map T1a M1a),
                            Dmap1b : ( |- map T1b M1b),
                            Dmap2a : ( |- map T2a M2a),
                            Dmap2b : ( |- map T2b M2b),
                            Dequiv' :
                              ( |-
                                 equiv
                                   (eapp (eapp (econst const/plus) M1a) M1b)
                                   (eapp (eapp (econst const/plus) M2a) M2b)
                                   et),
                            Dequiv1' : ( |- equiv M1a M2a et),
                            Dequiv2' : ( |- equiv M1b M2b et),
                            T1a' : ( |- con),
                            Dunmap1a : ( |- unmap M1a T1a'),
                            Dequiv1a : ( |- cn-equiv T1a T1a' t),
                            T1b' : ( |- con),
                            Dunmap1b : ( |- unmap M1b T1b'),
                            Dequiv1b : ( |- cn-equiv T1b T1b' t),
                            T2a' : ( |- con),
                            Dunmap2a : ( |- unmap M2a T2a'),
                            Dequiv2a : ( |- cn-equiv T2a T2a' t),
                            T2b' : ( |- con),
                            Dunmap2b : ( |- unmap M2b T2b'),
                            Dequiv2b : ( |- cn-equiv T2b T2b' t),
                            K : ( |- kind),
                            Dtunmap : ( |- tunmap et K),
                            Dequiv1 : ( |- cn-equiv T1a' T2a' K)
                          | equiv :
                              [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
                          ; split [ |- Dtunmap] as
                            case tunmap/t:
                            { T1a : ( |- con),
                              T1b : ( |- con),
                              T2a : ( |- con),
                              T2b : ( |- con),
                              Dequiv :
                                ( |- cn-equiv (plus T1a T1b) (plus T2a T2b) t),
                              Dof1 : ( |- cn-of (plus T1a T1b) t),
                              Dof2 : ( |- cn-of (plus T2a T2b) t),
                              Dwf : ( |- kd-wf t),
                              Dof1a : ( |- cn-of T1a t),
                              Dof1b : ( |- cn-of T1b t),
                              Dof2a : ( |- cn-of T2a t),
                              Dof2b : ( |- cn-of T2b t),
                              M1a : ( |- eterm),
                              M1b : ( |- eterm),
                              M2a : ( |- eterm),
                              M2b : ( |- eterm),
                              Dmap1a : ( |- map T1a M1a),
                              Dmap1b : ( |- map T1b M1b),
                              Dmap2a : ( |- map T2a M2a),
                              Dmap2b : ( |- map T2b M2b),
                              Dequiv' :
                                ( |-
                                   equiv
                                     (eapp (eapp (econst const/plus) M1a)
                                     M1b)
                                     (eapp (eapp (econst const/plus) M2a)
                                     M2b) et),
                              Dequiv1' : ( |- equiv M1a M2a et),
                              Dequiv2' : ( |- equiv M1b M2b et),
                              T1a' : ( |- con),
                              Dunmap1a : ( |- unmap M1a T1a'),
                              Dequiv1a : ( |- cn-equiv T1a T1a' t),
                              T1b' : ( |- con),
                              Dunmap1b : ( |- unmap M1b T1b'),
                              Dequiv1b : ( |- cn-equiv T1b T1b' t),
                              T2a' : ( |- con),
                              Dunmap2a : ( |- unmap M2a T2a'),
                              Dequiv2a : ( |- cn-equiv T2a T2a' t),
                              T2b' : ( |- con),
                              Dunmap2b : ( |- unmap M2b T2b'),
                              Dequiv2b : ( |- cn-equiv T2b T2b' t),
                              Dequiv1 : ( |- cn-equiv T1a' T2a' t)
                            | equiv :
                                [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t]
                            ; split
                              unmap-equiv [ |- Dunmap1b] [ |- Dunmap2b]
                                [ |- Dequiv2'] as
                              case unmap-equiv/i:
                              { T1a : ( |- con),
                                T1b : ( |- con),
                                T2a : ( |- con),
                                T2b : ( |- con),
                                Dequiv :
                                  ( |-
                                     cn-equiv (plus T1a T1b) (plus T2a T2b) t),
                                Dof1 : ( |- cn-of (plus T1a T1b) t),
                                Dof2 : ( |- cn-of (plus T2a T2b) t),
                                Dwf : ( |- kd-wf t),
                                Dof1a : ( |- cn-of T1a t),
                                Dof1b : ( |- cn-of T1b t),
                                Dof2a : ( |- cn-of T2a t),
                                Dof2b : ( |- cn-of T2b t),
                                M1a : ( |- eterm),
                                M1b : ( |- eterm),
                                M2a : ( |- eterm),
                                M2b : ( |- eterm),
                                Dmap1a : ( |- map T1a M1a),
                                Dmap1b : ( |- map T1b M1b),
                                Dmap2a : ( |- map T2a M2a),
                                Dmap2b : ( |- map T2b M2b),
                                Dequiv' :
                                  ( |-
                                     equiv
                                       (eapp (eapp (econst const/plus) M1a)
                                       M1b)
                                       (eapp (eapp (econst const/plus) M2a)
                                       M2b) et),
                                Dequiv1' : ( |- equiv M1a M2a et),
                                Dequiv2' : ( |- equiv M1b M2b et),
                                T1a' : ( |- con),
                                Dunmap1a : ( |- unmap M1a T1a'),
                                Dequiv1a : ( |- cn-equiv T1a T1a' t),
                                T1b' : ( |- con),
                                Dunmap1b : ( |- unmap M1b T1b'),
                                Dequiv1b : ( |- cn-equiv T1b T1b' t),
                                T2a' : ( |- con),
                                Dunmap2a : ( |- unmap M2a T2a'),
                                Dequiv2a : ( |- cn-equiv T2a T2a' t),
                                T2b' : ( |- con),
                                Dunmap2b : ( |- unmap M2b T2b'),
                                Dequiv2b : ( |- cn-equiv T2b T2b' t),
                                Dequiv1 : ( |- cn-equiv T1a' T2a' t),
                                K : ( |- kind),
                                Dtunmap : ( |- tunmap et K),
                                Dequiv2 : ( |- cn-equiv T1b' T2b' K)
                              | equiv :
                                  [ |-
                                     cn-equiv (plus T1a T1b) (plus T2a T2b) t]
                              ; split [ |- Dtunmap] as
                                case tunmap/t:
                                { T1a : ( |- con),
                                  T1b : ( |- con),
                                  T2a : ( |- con),
                                  T2b : ( |- con),
                                  Dequiv :
                                    ( |-
                                       cn-equiv
                                         (plus T1a T1b) (plus T2a T2b) t),
                                  Dof1 : ( |- cn-of (plus T1a T1b) t),
                                  Dof2 : ( |- cn-of (plus T2a T2b) t),
                                  Dwf : ( |- kd-wf t),
                                  Dof1a : ( |- cn-of T1a t),
                                  Dof1b : ( |- cn-of T1b t),
                                  Dof2a : ( |- cn-of T2a t),
                                  Dof2b : ( |- cn-of T2b t),
                                  M1a : ( |- eterm),
                                  M1b : ( |- eterm),
                                  M2a : ( |- eterm),
                                  M2b : ( |- eterm),
                                  Dmap1a : ( |- map T1a M1a),
                                  Dmap1b : ( |- map T1b M1b),
                                  Dmap2a : ( |- map T2a M2a),
                                  Dmap2b : ( |- map T2b M2b),
                                  Dequiv' :
                                    ( |-
                                       equiv
                                         (eapp (eapp (econst const/plus) M1a)
                                         M1b)
                                         (eapp (eapp (econst const/plus) M2a)
                                         M2b) et),
                                  Dequiv1' : ( |- equiv M1a M2a et),
                                  Dequiv2' : ( |- equiv M1b M2b et),
                                  T1a' : ( |- con),
                                  Dunmap1a : ( |- unmap M1a T1a'),
                                  Dequiv1a : ( |- cn-equiv T1a T1a' t),
                                  T1b' : ( |- con),
                                  Dunmap1b : ( |- unmap M1b T1b'),
                                  Dequiv1b : ( |- cn-equiv T1b T1b' t),
                                  T2a' : ( |- con),
                                  Dunmap2a : ( |- unmap M2a T2a'),
                                  Dequiv2a : ( |- cn-equiv T2a T2a' t),
                                  T2b' : ( |- con),
                                  Dunmap2b : ( |- unmap M2b T2b'),
                                  Dequiv2b : ( |- cn-equiv T2b T2b' t),
                                  Dequiv1 : ( |- cn-equiv T1a' T2a' t),
                                  Dequiv2 : ( |- cn-equiv T1b' T2b' t)
                                | equiv :
                                    [ |-
                                       cn-equiv
                                         (plus T1a T1b) (plus T2a T2b) t]
                                ; solve
                                    [ |-
                                       injective-plus/i (cn-equiv/trans
                                                        Dequiv1a
                                                        (cn-equiv/trans
                                                        Dequiv1
                                                        (cn-equiv/symm
                                                        Dequiv2a)))
                                       (cn-equiv/trans Dequiv1b
                                       (cn-equiv/trans Dequiv2
                                       (cn-equiv/symm Dequiv2b)))]
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
;

proof injective-ref :
  [ |- cn-equiv (ref T1) (ref T2) t] ->
    [ |- cn-equiv T1 T2 t] =
/ total /
intros
{ T1 : ( |- con), T2 : ( |- con)
| equiv : [ |- cn-equiv (ref T1) (ref T2) t]
; by equiv as Dequiv unboxed;
  split cn-equiv-reg [ |- Dequiv] as
  case cn-equiv-reg/i:
  { T1 : ( |- con),
    T2 : ( |- con),
    Dequiv : ( |- cn-equiv (ref T1) (ref T2) t),
    Dof1 : ( |- cn-of (ref T1) t),
    Dof2 : ( |- cn-of (ref T2) t),
    Dwf : ( |- kd-wf t)
  | equiv : [ |- cn-equiv (ref T1) (ref T2) t]
  ; by inversion-ref [ |- Dof1] as Dof1' unboxed;
    by inversion-ref [ |- Dof2] as Dof2' unboxed;
    split map-equiv [ |- ref T1] [ |- ref T2] [ |- Dequiv] as
    case map-equiv/i:
    { T1 : ( |- con),
      T2 : ( |- con),
      Dequiv : ( |- cn-equiv (ref T1) (ref T2) t),
      Dof1 : ( |- cn-of (ref T1) t),
      Dof2 : ( |- cn-of (ref T2) t),
      Dwf : ( |- kd-wf t),
      Dof1' : ( |- cn-of T1 t),
      Dof2' : ( |- cn-of T2 t),
      M1 : ( |- eterm),
      M2 : ( |- eterm),
      A : ( |- etp),
      Dmap1 : ( |- map (ref T1) M1),
      Dmap2 : ( |- map (ref T2) M2),
      Dtmap : ( |- tmap t A),
      DequivSing : ( |- equiv M1 M2 A)
    | equiv : [ |- cn-equiv (ref T1) (ref T2) t]
    ; split [ |- Dmap1] as
      case map/ref:
      { T1 : ( |- con),
        T2 : ( |- con),
        Dequiv : ( |- cn-equiv (ref T1) (ref T2) t),
        Dof1 : ( |- cn-of (ref T1) t),
        Dof2 : ( |- cn-of (ref T2) t),
        Dwf : ( |- kd-wf t),
        Dof1' : ( |- cn-of T1 t),
        Dof2' : ( |- cn-of T2 t),
        M1 : ( |- eterm),
        M2 : ( |- eterm),
        A : ( |- etp),
        Dmap1 : ( |- map T1 M1),
        Dmap2 : ( |- map (ref T2) M2),
        Dtmap : ( |- tmap t A),
        DequivSing : ( |- equiv (eapp (econst const/ref) M1) M2 A)
      | equiv : [ |- cn-equiv (ref T1) (ref T2) t]
      ; split [ |- Dmap2] as
        case map/ref:
        { T1 : ( |- con),
          T2 : ( |- con),
          Dequiv : ( |- cn-equiv (ref T1) (ref T2) t),
          Dof1 : ( |- cn-of (ref T1) t),
          Dof2 : ( |- cn-of (ref T2) t),
          Dwf : ( |- kd-wf t),
          Dof1' : ( |- cn-of T1 t),
          Dof2' : ( |- cn-of T2 t),
          M1 : ( |- eterm),
          M2 : ( |- eterm),
          A : ( |- etp),
          Dmap1 : ( |- map T1 M1),
          Dmap2 : ( |- map T2 M2),
          Dtmap : ( |- tmap t A),
          DequivSing :
            ( |-
               equiv
                 (eapp (econst const/ref) M1) (eapp (econst const/ref) M2) A)
        | equiv : [ |- cn-equiv (ref T1) (ref T2) t]
        ; split [ |- Dtmap] as
          case tmap/t:
          { T1 : ( |- con),
            T2 : ( |- con),
            Dequiv : ( |- cn-equiv (ref T1) (ref T2) t),
            Dof1 : ( |- cn-of (ref T1) t),
            Dof2 : ( |- cn-of (ref T2) t),
            Dwf : ( |- kd-wf t),
            Dof1' : ( |- cn-of T1 t),
            Dof2' : ( |- cn-of T2 t),
            M1 : ( |- eterm),
            M2 : ( |- eterm),
            Dmap1 : ( |- map T1 M1),
            Dmap2 : ( |- map T2 M2),
            DequivSing :
              ( |-
                 equiv
                   (eapp (econst const/ref) M1)
                   (eapp (econst const/ref) M2) et)
          | equiv : [ |- cn-equiv (ref T1) (ref T2) t]
          ; by unary-equiv-inversion
     [ |-
        ekof/i ckof/ref
        (etopen/pi etopen/t etp-skel/t (\l1. \l2. \l3. etopen/t))]
     [ |- DequivSing]
as DequivSing' unboxed;
            split invert-map [ |- Dof1'] [ |- Dmap1] as
            case invert-map/i:
            { T1 : ( |- con),
              T2 : ( |- con),
              Dequiv : ( |- cn-equiv (ref T1) (ref T2) t),
              Dof1 : ( |- cn-of (ref T1) t),
              Dof2 : ( |- cn-of (ref T2) t),
              Dwf : ( |- kd-wf t),
              Dof1' : ( |- cn-of T1 t),
              Dof2' : ( |- cn-of T2 t),
              M1 : ( |- eterm),
              M2 : ( |- eterm),
              Dmap1 : ( |- map T1 M1),
              Dmap2 : ( |- map T2 M2),
              DequivSing :
                ( |-
                   equiv
                     (eapp (econst const/ref) M1)
                     (eapp (econst const/ref) M2) et),
              DequivSing' : ( |- equiv M1 M2 et),
              C1 : ( |- con),
              Dunmap1 : ( |- unmap M1 C1),
              Dequiv1 : ( |- cn-equiv T1 C1 t)
            | equiv : [ |- cn-equiv (ref T1) (ref T2) t]
            ; split invert-map [ |- Dof2'] [ |- Dmap2] as
              case invert-map/i:
              { T1 : ( |- con),
                T2 : ( |- con),
                Dequiv : ( |- cn-equiv (ref T1) (ref T2) t),
                Dof1 : ( |- cn-of (ref T1) t),
                Dof2 : ( |- cn-of (ref T2) t),
                Dwf : ( |- kd-wf t),
                Dof1' : ( |- cn-of T1 t),
                Dof2' : ( |- cn-of T2 t),
                M1 : ( |- eterm),
                M2 : ( |- eterm),
                Dmap1 : ( |- map T1 M1),
                Dmap2 : ( |- map T2 M2),
                DequivSing :
                  ( |-
                     equiv
                       (eapp (econst const/ref) M1)
                       (eapp (econst const/ref) M2) et),
                DequivSing' : ( |- equiv M1 M2 et),
                C1 : ( |- con),
                Dunmap1 : ( |- unmap M1 C1),
                Dequiv1 : ( |- cn-equiv T1 C1 t),
                C2 : ( |- con),
                Dunmap2 : ( |- unmap M2 C2),
                Dequiv2 : ( |- cn-equiv T2 C2 t)
              | equiv : [ |- cn-equiv (ref T1) (ref T2) t]
              ; split
                unmap-equiv [ |- Dunmap1] [ |- Dunmap2] [ |- DequivSing'] as
                case unmap-equiv/i:
                { T1 : ( |- con),
                  T2 : ( |- con),
                  Dequiv : ( |- cn-equiv (ref T1) (ref T2) t),
                  Dof1 : ( |- cn-of (ref T1) t),
                  Dof2 : ( |- cn-of (ref T2) t),
                  Dwf : ( |- kd-wf t),
                  Dof1' : ( |- cn-of T1 t),
                  Dof2' : ( |- cn-of T2 t),
                  M1 : ( |- eterm),
                  M2 : ( |- eterm),
                  Dmap1 : ( |- map T1 M1),
                  Dmap2 : ( |- map T2 M2),
                  DequivSing :
                    ( |-
                       equiv
                         (eapp (econst const/ref) M1)
                         (eapp (econst const/ref) M2) et),
                  DequivSing' : ( |- equiv M1 M2 et),
                  C1 : ( |- con),
                  Dunmap1 : ( |- unmap M1 C1),
                  Dequiv1 : ( |- cn-equiv T1 C1 t),
                  C2 : ( |- con),
                  Dunmap2 : ( |- unmap M2 C2),
                  Dequiv2 : ( |- cn-equiv T2 C2 t),
                  K : ( |- kind),
                  Dtunmap : ( |- tunmap et K),
                  Dequiv' : ( |- cn-equiv C1 C2 K)
                | equiv : [ |- cn-equiv (ref T1) (ref T2) t]
                ; split [ |- Dtunmap] as
                  case tunmap/t:
                  { T1 : ( |- con),
                    T2 : ( |- con),
                    Dequiv : ( |- cn-equiv (ref T1) (ref T2) t),
                    Dof1 : ( |- cn-of (ref T1) t),
                    Dof2 : ( |- cn-of (ref T2) t),
                    Dwf : ( |- kd-wf t),
                    Dof1' : ( |- cn-of T1 t),
                    Dof2' : ( |- cn-of T2 t),
                    M1 : ( |- eterm),
                    M2 : ( |- eterm),
                    Dmap1 : ( |- map T1 M1),
                    Dmap2 : ( |- map T2 M2),
                    DequivSing :
                      ( |-
                         equiv
                           (eapp (econst const/ref) M1)
                           (eapp (econst const/ref) M2) et),
                    DequivSing' : ( |- equiv M1 M2 et),
                    C1 : ( |- con),
                    Dunmap1 : ( |- unmap M1 C1),
                    Dequiv1 : ( |- cn-equiv T1 C1 t),
                    C2 : ( |- con),
                    Dunmap2 : ( |- unmap M2 C2),
                    Dequiv2 : ( |- cn-equiv T2 C2 t),
                    Dequiv' : ( |- cn-equiv C1 C2 t)
                  | equiv : [ |- cn-equiv (ref T1) (ref T2) t]
                  ; solve
                      [ |-
                         cn-equiv/trans Dequiv1
                         (cn-equiv/trans Dequiv' (cn-equiv/symm Dequiv2))]
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
;

proof injective-tag :
  [ |- cn-equiv (tag T1) (tag T2) t] ->
    [ |- cn-equiv T1 T2 t] =
/ total /
intros
{ T1 : ( |- con), T2 : ( |- con)
| equiv : [ |- cn-equiv (tag T1) (tag T2) t]
; by equiv as Dequiv unboxed;
  split cn-equiv-reg [ |- Dequiv] as
  case cn-equiv-reg/i:
  { T1 : ( |- con),
    T2 : ( |- con),
    Dequiv : ( |- cn-equiv (tag T1) (tag T2) t),
    Dof1 : ( |- cn-of (tag T1) t),
    Dof2 : ( |- cn-of (tag T2) t),
    Dwf : ( |- kd-wf t)
  | equiv : [ |- cn-equiv (tag T1) (tag T2) t]
  ; by inversion-tag [ |- Dof1] as Dof1' unboxed;
    by inversion-tag [ |- Dof2] as Dof2' unboxed;
    split map-equiv [ |- tag T1] [ |- tag T2] [ |- Dequiv] as
    case map-equiv/i:
    { T1 : ( |- con),
      T2 : ( |- con),
      Dequiv : ( |- cn-equiv (tag T1) (tag T2) t),
      Dof1 : ( |- cn-of (tag T1) t),
      Dof2 : ( |- cn-of (tag T2) t),
      Dwf : ( |- kd-wf t),
      Dof1' : ( |- cn-of T1 t),
      Dof2' : ( |- cn-of T2 t),
      M1 : ( |- eterm),
      M2 : ( |- eterm),
      A : ( |- etp),
      Dmap1 : ( |- map (tag T1) M1),
      Dmap2 : ( |- map (tag T2) M2),
      Dtmap : ( |- tmap t A),
      DequivSing : ( |- equiv M1 M2 A)
    | equiv : [ |- cn-equiv (tag T1) (tag T2) t]
    ; split [ |- Dmap1] as
      case map/tag:
      { T1 : ( |- con),
        T2 : ( |- con),
        Dequiv : ( |- cn-equiv (tag T1) (tag T2) t),
        Dof1 : ( |- cn-of (tag T1) t),
        Dof2 : ( |- cn-of (tag T2) t),
        Dwf : ( |- kd-wf t),
        Dof1' : ( |- cn-of T1 t),
        Dof2' : ( |- cn-of T2 t),
        M1 : ( |- eterm),
        M2 : ( |- eterm),
        A : ( |- etp),
        Dmap1 : ( |- map T1 M1),
        Dmap2 : ( |- map (tag T2) M2),
        Dtmap : ( |- tmap t A),
        DequivSing : ( |- equiv (eapp (econst const/tag) M1) M2 A)
      | equiv : [ |- cn-equiv (tag T1) (tag T2) t]
      ; split [ |- Dmap2] as
        case map/tag:
        { T1 : ( |- con),
          T2 : ( |- con),
          Dequiv : ( |- cn-equiv (tag T1) (tag T2) t),
          Dof1 : ( |- cn-of (tag T1) t),
          Dof2 : ( |- cn-of (tag T2) t),
          Dwf : ( |- kd-wf t),
          Dof1' : ( |- cn-of T1 t),
          Dof2' : ( |- cn-of T2 t),
          M1 : ( |- eterm),
          M2 : ( |- eterm),
          A : ( |- etp),
          Dmap1 : ( |- map T1 M1),
          Dmap2 : ( |- map T2 M2),
          Dtmap : ( |- tmap t A),
          DequivSing :
            ( |-
               equiv
                 (eapp (econst const/tag) M1) (eapp (econst const/tag) M2) A)
        | equiv : [ |- cn-equiv (tag T1) (tag T2) t]
        ; split [ |- Dtmap] as
          case tmap/t:
          { T1 : ( |- con),
            T2 : ( |- con),
            Dequiv : ( |- cn-equiv (tag T1) (tag T2) t),
            Dof1 : ( |- cn-of (tag T1) t),
            Dof2 : ( |- cn-of (tag T2) t),
            Dwf : ( |- kd-wf t),
            Dof1' : ( |- cn-of T1 t),
            Dof2' : ( |- cn-of T2 t),
            M1 : ( |- eterm),
            M2 : ( |- eterm),
            Dmap1 : ( |- map T1 M1),
            Dmap2 : ( |- map T2 M2),
            DequivSing :
              ( |-
                 equiv
                   (eapp (econst const/tag) M1)
                   (eapp (econst const/tag) M2) et)
          | equiv : [ |- cn-equiv (tag T1) (tag T2) t]
          ; by unary-equiv-inversion
     [ |-
        ekof/i ckof/tag
        (etopen/pi etopen/t etp-skel/t (\l1. \l2. \l3. etopen/t))]
     [ |- DequivSing]
as DequivSing' unboxed;
            split invert-map [ |- Dof1'] [ |- Dmap1] as
            case invert-map/i:
            { T1 : ( |- con),
              T2 : ( |- con),
              Dequiv : ( |- cn-equiv (tag T1) (tag T2) t),
              Dof1 : ( |- cn-of (tag T1) t),
              Dof2 : ( |- cn-of (tag T2) t),
              Dwf : ( |- kd-wf t),
              Dof1' : ( |- cn-of T1 t),
              Dof2' : ( |- cn-of T2 t),
              M1 : ( |- eterm),
              M2 : ( |- eterm),
              Dmap1 : ( |- map T1 M1),
              Dmap2 : ( |- map T2 M2),
              DequivSing :
                ( |-
                   equiv
                     (eapp (econst const/tag) M1)
                     (eapp (econst const/tag) M2) et),
              DequivSing' : ( |- equiv M1 M2 et),
              C1 : ( |- con),
              Dunmap1 : ( |- unmap M1 C1),
              Dequiv1 : ( |- cn-equiv T1 C1 t)
            | equiv : [ |- cn-equiv (tag T1) (tag T2) t]
            ; split invert-map [ |- Dof2'] [ |- Dmap2] as
              case invert-map/i:
              { T1 : ( |- con),
                T2 : ( |- con),
                Dequiv : ( |- cn-equiv (tag T1) (tag T2) t),
                Dof1 : ( |- cn-of (tag T1) t),
                Dof2 : ( |- cn-of (tag T2) t),
                Dwf : ( |- kd-wf t),
                Dof1' : ( |- cn-of T1 t),
                Dof2' : ( |- cn-of T2 t),
                M1 : ( |- eterm),
                M2 : ( |- eterm),
                Dmap1 : ( |- map T1 M1),
                Dmap2 : ( |- map T2 M2),
                DequivSing :
                  ( |-
                     equiv
                       (eapp (econst const/tag) M1)
                       (eapp (econst const/tag) M2) et),
                DequivSing' : ( |- equiv M1 M2 et),
                C1 : ( |- con),
                Dunmap1 : ( |- unmap M1 C1),
                Dequiv1 : ( |- cn-equiv T1 C1 t),
                C2 : ( |- con),
                Dunmap2 : ( |- unmap M2 C2),
                Dequiv2 : ( |- cn-equiv T2 C2 t)
              | equiv : [ |- cn-equiv (tag T1) (tag T2) t]
              ; split
                unmap-equiv [ |- Dunmap1] [ |- Dunmap2] [ |- DequivSing'] as
                case unmap-equiv/i:
                { T1 : ( |- con),
                  T2 : ( |- con),
                  Dequiv : ( |- cn-equiv (tag T1) (tag T2) t),
                  Dof1 : ( |- cn-of (tag T1) t),
                  Dof2 : ( |- cn-of (tag T2) t),
                  Dwf : ( |- kd-wf t),
                  Dof1' : ( |- cn-of T1 t),
                  Dof2' : ( |- cn-of T2 t),
                  M1 : ( |- eterm),
                  M2 : ( |- eterm),
                  Dmap1 : ( |- map T1 M1),
                  Dmap2 : ( |- map T2 M2),
                  DequivSing :
                    ( |-
                       equiv
                         (eapp (econst const/tag) M1)
                         (eapp (econst const/tag) M2) et),
                  DequivSing' : ( |- equiv M1 M2 et),
                  C1 : ( |- con),
                  Dunmap1 : ( |- unmap M1 C1),
                  Dequiv1 : ( |- cn-equiv T1 C1 t),
                  C2 : ( |- con),
                  Dunmap2 : ( |- unmap M2 C2),
                  Dequiv2 : ( |- cn-equiv T2 C2 t),
                  K : ( |- kind),
                  Dtunmap : ( |- tunmap et K),
                  Dequiv' : ( |- cn-equiv C1 C2 K)
                | equiv : [ |- cn-equiv (tag T1) (tag T2) t]
                ; split [ |- Dtunmap] as
                  case tunmap/t:
                  { T1 : ( |- con),
                    T2 : ( |- con),
                    Dequiv : ( |- cn-equiv (tag T1) (tag T2) t),
                    Dof1 : ( |- cn-of (tag T1) t),
                    Dof2 : ( |- cn-of (tag T2) t),
                    Dwf : ( |- kd-wf t),
                    Dof1' : ( |- cn-of T1 t),
                    Dof2' : ( |- cn-of T2 t),
                    M1 : ( |- eterm),
                    M2 : ( |- eterm),
                    Dmap1 : ( |- map T1 M1),
                    Dmap2 : ( |- map T2 M2),
                    DequivSing :
                      ( |-
                         equiv
                           (eapp (econst const/tag) M1)
                           (eapp (econst const/tag) M2) et),
                    DequivSing' : ( |- equiv M1 M2 et),
                    C1 : ( |- con),
                    Dunmap1 : ( |- unmap M1 C1),
                    Dequiv1 : ( |- cn-equiv T1 C1 t),
                    C2 : ( |- con),
                    Dunmap2 : ( |- unmap M2 C2),
                    Dequiv2 : ( |- cn-equiv T2 C2 t),
                    Dequiv' : ( |- cn-equiv C1 C2 t)
                  | equiv : [ |- cn-equiv (tag T1) (tag T2) t]
                  ; solve
                      [ |-
                         cn-equiv/trans Dequiv1
                         (cn-equiv/trans Dequiv' (cn-equiv/symm Dequiv2))]
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
;

LF injective-rec/e :
  kind -> (con -> con -> con) -> con ->
  kind -> (con -> con -> con) -> con -> type =
| injective-rec/i :
  kd-equiv K1 K2 ->
  ({ a : con } cn-of a (pi K1 (\l. t)) ->
   { b : con } cn-of b K1 ->
   cn-equiv (C1a a b) (C2a a b) t) ->
  cn-equiv C1b C2b K1 ->
    injective-rec/e K1 C1a C1b K2 C2a C2b
;

proof injective-rec :
  [ |- cn-equiv
        (rec' K1 (\c1. \c2. C1a) C1b)
        (rec' K2 (\c1. \c2. C2a) C2b) t] ->
    [ |- injective-rec/e K1 (\c1. \c2. C1a) C1b K2 (\c1. \c2. C2a) C2b] =
/ total /
intros
{ K : ( |- kind),
  C1a : (z529 : con, y530 : con |- con),
  C1b : ( |- con),
  K1 : ( |- kind),
  C2a : (z529 : con, y530 : con |- con),
  C2b : ( |- con)
| equiv :
    [ |-
       cn-equiv (rec' K (\c1. \c2. C1a) C1b) (rec' K1 (\c1. \c2. C2a) C2b) t]
; ?
}
;

LF injective-labeled/e : label -> con -> label -> con -> type =
| injective-labeled/i :
  label-eq L1 L2 ->
  cn-equiv T1 T2 t ->
    injective-labeled/e L1 T1 L2 T2
;

proof injective-labeled :
  [ |- cn-equiv (labeled L1 T1) (labeled L2 T2) t] ->
    [ |- injective-labeled/e L1 T1 L2 T2] =
/ total /
intros
{ L : ( |- label), T : ( |- con), L1 : ( |- label), T1 : ( |- con)
| equiv : [ |- cn-equiv (labeled L T) (labeled L1 T1) t]
; ?
}
;
