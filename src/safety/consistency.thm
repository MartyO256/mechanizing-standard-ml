% Map into the singleton language

LF map : con -> eterm -> type =
| map/pair :
  map C1 M1 ->
  map C2 M2 ->
    map (pair C1 C2) (epair M1 M2)

| map/pi1 :
  map C M ->
    map (pi1 C) (epi1 M)

| map/pi2 :
  map C M ->
    map (pi2 C) (epi2 M)

| map/lam :
  tmap K A ->
  ({a : con} {x : eterm} map a x ->
   map (C a) (M x)) ->
    map (lam K C) (elam A M)

| map/app :
  map C1 M1 ->
  map C2 M2 ->
    map (app C1 C2) (eapp M1 M2)

| map/star : map star estar

| map/unit : map unit (econst const/unit)

| map/void : map void (econst const/void)

| map/prod :
  map C1 M1 ->
  map C2 M2 ->
    map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)

| map/arrow :
  map C1 M1 ->
  map C2 M2 ->
    map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)

| map/plus :
  map C1 M1 ->
  map C2 M2 ->
    map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)

| map/ref :
  map C M ->
    map (ref C) (eapp (econst const/ref) M)

| map/tag :
  map C M ->
    map (tag C) (eapp (econst const/tag) M)

| map/tagged : map tagged (econst const/tagged)

| map/rec :
  tmap K A ->
  ({a : con} {x : eterm} map a x ->
   {b : con} {y : eterm} map b y ->
   map (C1 a b) (M1 x y)) ->
  map C2 M2 ->
  flay A SK MA ->
    map (rec' K C1 C2)
      (eapp (econst (const/rec SK))
      (epair
        MA
        (epair (elam (epi A (\x. et))
        (\x. elam A (\y. M1 x y))) M2))
      )

| map/labeled :
  map C M ->
    map (labeled I C) (eapp (econst (const/labeled I)) M)

and tmap : kind -> etp -> type =
| tmap/t : tmap t et

| tmap/sing : map C M -> tmap (sing C) (esing M)

| tmap/pi :
  tmap K1 A1 ->
  ({a : con} {x : eterm} map a x -> tmap (K2 a) (A2 x)) ->
    tmap (pi K1 K2) (epi A1 A2)

| tmap/sigma :
  tmap K1 A1 ->
  ({a : con} {x : eterm} map a x -> tmap (K2 a) (A2 x)) ->
    tmap (sigma K1 K2) (esigma A1 A2)

| tmap/one : tmap one eone
;

% Map from the singleton language

LF unmap : eterm -> con -> type =
| unmap/app :
  unmap M1 C1 ->
  unmap M2 C2 ->
    unmap (eapp M1 M2) (app C1 C2)

| unmap/pi1 :
  unmap M C ->
    unmap (epi1 M) (pi1 C)

| unmap/pi2 :
  unmap M C ->
    unmap (epi2 M) (pi2 C)

| unmap/lam :
  tunmap A K ->
  ({x : eterm} {a : con} unmap x a -> unmap (M x) (C a)) ->
    unmap (elam A M) (lam K C)

| unmap/pair :
  unmap M1 C1 ->
  unmap M2 C2 ->
    unmap (epair M1 M2) (pair C1 C2)

| unmap/star : unmap estar star

| unmap/unit : unmap (econst const/unit) unit

| unmap/void : unmap (econst const/void) void

| unmap/prod : unmap (econst const/prod) (lam t (\a. lam t (\b. prod a b)))

| unmap/arrow : unmap (econst const/arrow) (lam t (\a. lam t (\b. arrow a b)))

| unmap/plus : unmap (econst const/plus) (lam t (\a. lam t (\b. plus a b)))

| unmap/ref : unmap (econst const/ref) (lam t (\a. ref a))

| unmap/tag : unmap (econst const/tag) (lam t (\a. tag a))

| unmap/tagged : unmap (econst const/tagged) tagged

| unmap/rec :
  skof-il SK K L ->
    unmap (econst (const/rec SK))
      (lam
        (sigma K
          (\a. sigma
            (pi (pi (L a) (\l. t)) (\k. (pi (L a) (\l. t))))
            (\l. (L a))
          )
        )
        (\b. rec'
          (L (pi1 b)) (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))
        )
      )

| unmap/labeled : unmap (econst (const/labeled I)) (lam t (\a. labeled I a))

and tunmap : etp -> kind -> type =
| tunmap/t : tunmap et t

| tunmap/sing : unmap M C -> tunmap (esing M) (sing C)

| tunmap/pi :
  tunmap A1 K1 ->
  ({x : eterm} {a : con} unmap x a ->
   tunmap (A2 x) (K2 a)) ->
    tunmap (epi A1 A2) (pi K1 K2)

| tunmap/sigma :
  tunmap A1 K1 ->
  ({x : eterm} {a : con} unmap x a ->
   tunmap (A2 x) (K2 a)) ->
    tunmap (esigma A1 A2) (sigma K1 K2)

| tunmap/one : tunmap eone one
;
--name map Dmap map.
--name tmap Dtmap tmap.
--name unmap Dunmap unmap.
--name tunmap Dtunmap tunmap.

schema unmap-block = some [a : con] block (x : eterm, xt : unmap x a);

schema conblock+unmap-block = block (a : con)
                            + some [a : con] block (x : eterm, xt : unmap x a);

proof unmap-resp :
  (g : conblock+unmap-block)
  [g |- eterm-eq M M'] ->
  [g |- con-eq C C'] ->
  [g |- unmap M C] ->
    [g |- unmap M' C'] =
/ total /
intros
{ g : conblock+unmap-block,
  M : (g |- eterm),
  M' : (g |- eterm),
  C : (g |- con),
  C' : (g |- con)
| eq : [g |- eterm-eq M M'],
  eq1 : [g |- con-eq C C'],
  unmap : [g |- unmap M C]
; split eq as
  case eterm-eq/i:
  { g : conblock+unmap-block,
    M' : (g |- eterm),
    C : (g |- con),
    C' : (g |- con)
  | eq : [g |- eterm-eq M' M'],
    eq1 : [g |- con-eq C C'],
    unmap : [g |- unmap M' C]
  ; split eq1 as
    case con-eq/i:
    { g : conblock+unmap-block, M' : (g |- eterm), C' : (g |- con)
    | eq : [g |- eterm-eq M' M'],
      eq1 : [g |- con-eq C' C'],
      unmap : [g |- unmap M' C']
    ; solve unmap
    }
  }
}
;

proof tunmap-resp :
  (g : conblock+unmap-block)
  [g |- etp-eq A A'] ->
  [g |- kind-eq K K'] ->
  [g |- tunmap A K] ->
    [g |- tunmap A' K'] =
/ total /
intros
{ g : conblock+unmap-block,
  A : (g |- etp),
  A' : (g |- etp),
  K : (g |- kind),
  K' : (g |- kind)
| eq : [g |- etp-eq A A'],
  eq1 : [g |- kind-eq K K'],
  tunmap : [g |- tunmap A K]
; split eq as
  case etp-eq/i:
  { g : conblock+unmap-block,
    A' : (g |- etp),
    K : (g |- kind),
    K' : (g |- kind)
  | eq : [g |- etp-eq A' A'],
    eq1 : [g |- kind-eq K K'],
    tunmap : [g |- tunmap A' K]
  ; split eq1 as
    case kind-eq/i:
    { g : conblock+unmap-block, A' : (g |- etp), K' : (g |- kind)
    | eq : [g |- etp-eq A' A'],
      eq1 : [g |- kind-eq K' K'],
      tunmap : [g |- tunmap A' K']
    ; solve tunmap
    }
  }
}
;

% Map Effectiveness

schema can-map-ctx =
  % evar
  block (ex : eterm) +
  % can-map-bind
  some [m : eterm]
  block (a : con, at : map a m) +
  % map-bind-for-can-map
  some [b : etp, k : kind]
  block (
    x : eterm, d : evof x b,
    a : con, e : cn-of a k,
    at : map a x
  ) +
  % invert-bind-for-can-map
  some [
    K : kind, K' : kind,
    B : etp,
    DmapK : tmap K B, DmapB : tunmap B K',
    DwfK : kd-wf K,
    DwfB : ewf B,
    DequivK : kd-equiv K K'
  ]
  block (
    a : con, da : cn-of a K,
    x : eterm, dx : evof x B,
    at : map a x, xt : unmap x a
  );

LF can-map/e : con -> type =
| can-map/i :
  { M : eterm }
  map C M ->
    can-map/e C
;

LF can-tmap/e : kind -> type =
| can-tmap/i :
  { A : etp }
  tmap K A ->
    can-tmap/e K
;

proof can-map :
  (g : can-map-ctx)
  { C : [g |- con] }
  [g |- can-map/e C] =
/ total 1 /
intros
{ g : can-map-ctx,
  C : (g |- con)
|
; split [_ |- C] as
  case labeled:
  { g : can-map-ctx,
    X : ( |- label),
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      X : ( |- label),
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i _ (map/labeled Dmap)]
    }
  }
  case rec':
  { g : can-map-ctx,
    K : (g |- kind),
    C1 : (g, y180 : con, x180 : con |- con),
    C2 : (g |- con)
  |
  ; split can-tmap [g |- K] as
    case can-tmap/i:
    { g : can-map-ctx,
      K : (g |- kind),
      C1 : (g, y180 : con, x180 : con |- con),
      C2 : (g |- con),
      A : (g |- etp),
      Dtmap : (g |- tmap K A)
    |
    ; %{ FIXME: Totality checking for complete induction error. https://github.com/Beluga-lang/Beluga/issues/227
         invert can-map [_, b1 : block (x : eterm, d1 : evof x (A[..]), a : con, e1 : cn-of a (K[..]), at1 : map a x), b2 : block (y : eterm, d2 : evof y (A[..]), b : con, e1 : cn-of b (K[..]), at2 : map b y) |- C1[.., b1.a, b2.b]]
         FIXME: Wrong projections after inversion. https://github.com/Beluga-lang/Beluga/issues/228
      }%
      ?
    }
  }
  case tagged:
  { g : can-map-ctx
  |
  ; solve [g |- can-map/i _ map/tagged]
  }
  case tag:
  { g : can-map-ctx,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i _ (map/tag Dmap)]
    }
  }
  case ref:
  { g : can-map-ctx,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i _ (map/ref Dmap)]
    }
  }
  case plus:
  { g : can-map-ctx,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : can-map-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i _ (map/plus Dmap Dmap1)]
      }
    }
  }
  case arrow:
  { g : can-map-ctx,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : can-map-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i _ (map/arrow Dmap Dmap1)]
      }
    }
  }
  case prod:
  { g : can-map-ctx,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : can-map-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve
          [g |-
             can-map/i (eapp (eapp (econst const/prod) M) M1)
             (map/prod Dmap Dmap1)]
      }
    }
  }
  case void:
  { g : can-map-ctx
  |
  ; solve [g |- can-map/i _ map/void]
  }
  case unit:
  { g : can-map-ctx
  |
  ; solve [g |- can-map/i _ map/unit]
  }
  case star:
  { g : can-map-ctx
  |
  ; solve [g |- can-map/i _ map/star]
  }
  case app:
  { g : can-map-ctx,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : can-map-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i (eapp M M1) (map/app Dmap Dmap1)]
      }
    }
  }
  case lam:
  { g : can-map-ctx,
    K : (g |- kind),
    C1 : (g, x175 : con |- con)
  |
  ; split can-tmap [g |- K] as
    case can-tmap/i:
    { g : can-map-ctx,
      K : (g |- kind),
      C1 : (g, x175 : con |- con),
      A : (g |- etp),
      Dtmap : (g |- tmap K A)
    |
    ; split
      can-map
        [g,
         b :
           block (
             x : eterm,
             d : evof x (A[..]),
             a : con,
             e : cn-of a (K[..]),
             at : map a x) |- C1[.., b.3]] as
      case can-map/i:
      { g : can-map-ctx,
        K : (g |- kind),
        C2 : (g, a : con |- con),
        A : (g |- etp),
        Dtmap : (g |- tmap K A),
        M : (g, x : eterm |- eterm),
        Dmap :
          (g, x : eterm, a : con, y1059 : map a x |-
             map (C2[.., a]) (M[.., x]))
      |
      ; by [g |- map/lam Dtmap (\a. \x. \at. Dmap[.., x, a, at])]
        as Dmap' unboxed;
        solve [g |- can-map/i _ Dmap']
      }
    }
  }
  case pi2:
  { g : can-map-ctx,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i (epi2 M) (map/pi2 Dmap)]
    }
  }
  case pi1:
  { g : can-map-ctx,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i (epi1 M) (map/pi1 Dmap)]
    }
  }
  case pair:
  { g : can-map-ctx,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : can-map-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : can-map-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i (epair M M1) (map/pair Dmap Dmap1)]
      }
    }
  }
  %{ FIXME: File "src/core/reconstruct.ml", line 2248, characters 11-16: Pattern matching failed
  case #.1:
  { g : can-map-ctx,
    K433 : (g |- kind),
    A20 : (g |- etp),
    #unmap :
      #(g |-
          block (
            a : con,
            da : cn-of a (K433[..]),
            x : eterm,
            dx : evof x (A20[..]),
            at : map a x,
            xt : unmap x a)),
    K434 : (g |- kind),
    Dtmap4 : (g |- tmap K433 A20),
    Dtunmap : (g |- tunmap A20 K434),
    Dwf61 : (g |- kd-wf K433),
    Y : (g |- ewf A20),
    Dequiv37 : (g |- kd-equiv K433 K434)
  |
  ; solve [_ |- can-map/i #unmap.3 #unmap.5]
  }
  case #.3:
  { g : can-map-ctx,
    A21 : (g |- etp),
    K435 : (g |- kind),
    #map :
      #(g |-
          block (
            x : eterm,
            d : evof x (A21[..]),
            a : con,
            e : cn-of a (K435[..]),
            at : map a x))
  |
  ; solve [_ |- can-map/i #map.1 #map.5]
  }
  case #.1:
  { g : can-map-ctx,
    M9 : (g |- eterm),
    #map : #(g |- block (a : con, at : map a (M9[..])))
  |
  ; solve [_ |- can-map/i _ #map.2]
  }
  }%
}

and proof can-tmap :
  (g : can-map-ctx)
  { K : [g |- kind] }
  [g |- can-tmap/e K] =
/ total 1 /
intros
{ g : can-map-ctx,
  K : (g |- kind)
|
; split [_ |- K] as
  case one:
  { g : can-map-ctx
  |
  ; solve [g |- can-tmap/i _ tmap/one]
  }
  case sigma:
  { g : can-map-ctx,
    K1 : (g |- kind),
    K2 : (g, y173 : con |- kind)
  |
  ; split can-tmap [g |- K1] as
    case can-tmap/i:
    { g : can-map-ctx,
      K1 : (g |- kind),
      K2 : (g, y173 : con |- kind),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A)
    |
    ; split
      can-tmap
        [g,
         b :
           block (
             x : eterm,
             d : evof x (A[..]),
             a : con,
             e : cn-of a (K1[..]),
             at : map a x) |- K2[.., b.3]] as
      case can-tmap/i:
      { g : can-map-ctx,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x1057 : map a x |-
             tmap (K3[.., a]) (A1[.., x]))
      |
      ; by [g |- tmap/sigma Dtmap (\a. \x. \xt. Dtmap1[.., x, a, xt])]
        as Dtmap' unboxed;
        solve [g |- can-tmap/i _ Dtmap']
      }
    }
  }
  case pi:
  { g : can-map-ctx,
    K1 : (g |- kind),
    K2 : (g, y172 : con |- kind)
  |
  ; split can-tmap [g |- K1] as
    case can-tmap/i:
    { g : can-map-ctx,
      K1 : (g |- kind),
      K2 : (g, y172 : con |- kind),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A)
    |
    ; split
      can-tmap
        [g,
         b :
           block (
             x : eterm,
             d : evof x (A[..]),
             a : con,
             e : cn-of a (K1[..]),
             at : map a x) |- K2[.., b.3]] as
      case can-tmap/i:
      { g : can-map-ctx,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x4 : map a x |-
             tmap (K3[.., a]) (A1[.., x]))
      |
      ; by [g |- tmap/pi Dtmap (\a. \x. \at. Dtmap1[.., x, a, at])] as Dtmap' unboxed;
        solve [g |- can-tmap/i _ Dtmap']
      }
    }
  }
  case sing:
  { g : can-map-ctx,
    C : (g |- con)
  |
  ; split can-map [g |- C] as
    case can-map/i:
    { g : can-map-ctx,
      C : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C M)
    |
    ; solve [g |- can-tmap/i _ (tmap/sing Dmap)]
    }
  }
  case t:
  { g : can-map-ctx
  |
  ; solve [g |- can-tmap/i _ tmap/t]
  }
}
;

% Map Functionality

schema map-fun-ctx =
  % evar
  block (ex : eterm) +
  % map-fun-bind
  some [x : eterm]
  block (a : con, at : map a x) +
  % map-bind-for-map-fun
  some [b : etp, k : kind]
  block (
    x : eterm, d : evof x b,
    a : con, e : cn-of a k,
    at : map a x
  ) +
  % invert-bind-for-map-fun
  some [K : kind, B : etp]
  block (
    a : con, da : cn-of a K,
    x : eterm, dx : evof x B,
    at : map a x
  );

proof map-fun :
  (g : map-fun-ctx)
  [g |- map C M] ->
  [g |- map C M'] ->
    [g |- eterm-eq M M'] =
/ trust / % FIXME: See issue #4
intros
{ g : map-fun-ctx, C : (g |- con), M : (g |- eterm), M' : (g |- eterm)
| x : [g |- map C M], map : [g |- map C M']
; split x as
  case map/labeled:
  { g : map-fun-ctx,
    X : ( |- label),
    C1 : (g |- con),
    M1 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1)
  | x : [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)],
    map : [g |- map (labeled X[] C1) M']
  ; split map as
    case map/labeled:
    { g : map-fun-ctx,
      X : ( |- label),
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C1 M2)
    | x : [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)],
      map :
        [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M2)]
    ; split map-fun [g |- Dmap] [g |- Dmap1] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        X : ( |- label),
        C1 : (g |- con),
        M2 : (g |- eterm),
        Dmap : (g |- map C1 M2),
        Dmap1 : (g |- map C1 M2)
      | x :
          [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M2)],
        map :
          [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M2)]
      ; solve [g |- eterm-eq/i ]
      }
    }
  }
  case map/rec:
  { g : map-fun-ctx,
    K : (g |- kind),
    C1 : (g, a158 : con, a157 : con |- con),
    C2 : (g |- con),
    Dskel : ( |- skel),
    M3 : (g |- eterm),
    A : (g |- etp),
    M1 : (g, x923 : eterm, y923 : eterm |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dtmap : (g |- tmap K A),
    Dmap :
      (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
       z922 : map b y |- map (C1[.., a, b]) (M1[.., x, y])),
    Dmap1 : (g |- map C2 M2),
    Dflay : (g |- flay A Dskel[] M3)
  | x :
      [g |-
         map
           (rec' K (\z335. \y336. C1) C2)
           (eapp (econst (const/rec Dskel[]))
           (epair M3
           (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M1))) M2)))],
    map : [g |- map (rec' K (\z335. \y336. C1) C2) M']
  ; split map as
    case map/rec:
    { g : map-fun-ctx,
      K : (g |- kind),
      C1 : (g, a158 : con, a157 : con |- con),
      C2 : (g |- con),
      Dskel : ( |- skel),
      M3 : (g |- eterm),
      A : (g |- etp),
      M1 : (g, x923 : eterm, y923 : eterm |- eterm),
      M2 : (g |- eterm),
      Dskel1 : ( |- skel),
      M6 : (g |- eterm),
      A1 : (g |- etp),
      M4 : (g, x923 : eterm, y923 : eterm |- eterm),
      M5 : (g |- eterm),
      Dtmap : (g |- tmap K A),
      Dmap :
        (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
         z922 : map b y |- map (C1[.., a, b]) (M1[.., x, y])),
      Dmap1 : (g |- map C2 M2),
      Dflay : (g |- flay A Dskel[] M3),
      Dtmap1 : (g |- tmap K A1),
      Dmap2 :
        (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
         z922 : map b y |- map (C1[.., a, b]) (M4[.., x, y])),
      Dmap3 : (g |- map C2 M5),
      Dflay1 : (g |- flay A1 Dskel1[] M6)
    | x :
        [g |-
           map
             (rec' K (\z335. \y336. C1) C2)
             (eapp (econst (const/rec Dskel[]))
             (epair M3
             (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M1))) M2)))],
      map :
        [g |-
           map
             (rec' K (\z335. \y336. C1) C2)
             (eapp (econst (const/rec Dskel1[]))
             (epair M6
             (epair (elam (epi A1 (\x. et)) (\x. elam (A1[..]) (\y. M4))) M5)))]
    ; split map-fun [g |- Dmap1] [g |- Dmap3] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        K : (g |- kind),
        C1 : (g, a158 : con, a157 : con |- con),
        C2 : (g |- con),
        Dskel : ( |- skel),
        M3 : (g |- eterm),
        A : (g |- etp),
        M1 : (g, x923 : eterm, y923 : eterm |- eterm),
        M5 : (g |- eterm),
        Dskel1 : ( |- skel),
        M6 : (g |- eterm),
        A1 : (g |- etp),
        M4 : (g, x923 : eterm, y923 : eterm |- eterm),
        Dtmap : (g |- tmap K A),
        Dmap :
          (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
           z922 : map b y |- map (C1[.., a, b]) (M1[.., x, y])),
        Dmap1 : (g |- map C2 M5),
        Dflay : (g |- flay A Dskel[] M3),
        Dtmap1 : (g |- tmap K A1),
        Dmap2 :
          (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
           z922 : map b y |- map (C1[.., a, b]) (M4[.., x, y])),
        Dmap3 : (g |- map C2 M5),
        Dflay1 : (g |- flay A1 Dskel1[] M6)
      | x :
          [g |-
             map
               (rec' K (\z335. \y336. C1) C2)
               (eapp (econst (const/rec Dskel[]))
               (epair M3
               (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M1))) M5)))],
        map :
          [g |-
             map
               (rec' K (\z335. \y336. C1) C2)
               (eapp (econst (const/rec Dskel1[]))
               (epair M6
               (epair (elam (epi A1 (\x. et)) (\x. elam (A1[..]) (\y. M4)))
               M5)))]
      ; split
map-fun
  [g,
   b1 :
     block (
       x : eterm,
       d : evof x (A1[..]),
       a : con,
       e : cn-of a (K[..]),
       at : map a x),
   b2 :
     block (
       x : eterm,
       d : evof x (A1[..]),
       a : con,
       e : cn-of a (K[..]),
       at : map a x) |- Dmap[.., b1.3, b1.1, b1.5, b2.3, b2.1, b2.5]]
  [g,
   b1 :
     block (
       x : eterm,
       d : evof x (A1[..]),
       a : con,
       e : cn-of a (K[..]),
       at : map a x),
   b2 :
     block (
       x : eterm,
       d : evof x (A1[..]),
       a : con,
       e : cn-of a (K[..]),
       at : map a x) |- Dmap2[.., b1.3, b1.1, b1.5, b2.3, b2.1, b2.5]] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          K : (g |- kind),
          C1 : (g, a158 : con, a157 : con |- con),
          C2 : (g |- con),
          Dskel : ( |- skel),
          M3 : (g |- eterm),
          A : (g |- etp),
          M7 : (g, x : eterm, x : eterm |- eterm),
          M5 : (g |- eterm),
          Dskel1 : ( |- skel),
          M6 : (g |- eterm),
          A1 : (g |- etp),
          Dtmap : (g |- tmap K A),
          Dmap :
            (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
             z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
          Dmap1 : (g |- map C2 M5),
          Dflay : (g |- flay A Dskel[] M3),
          Dtmap1 : (g |- tmap K A1),
          Dmap2 :
            (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
             z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
          Dmap3 : (g |- map C2 M5),
          Dflay1 : (g |- flay A1 Dskel1[] M6)
        | x :
            [g |-
               map
                 (rec' K (\z335. \y336. C1) C2)
                 (eapp (econst (const/rec Dskel[]))
                 (epair M3
                 (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M7)))
                 M5)))],
          map :
            [g |-
               map
                 (rec' K (\z335. \y336. C1) C2)
                 (eapp (econst (const/rec Dskel1[]))
                 (epair M6
                 (epair (elam (epi A1 (\x. et)) (\x. elam (A1[..]) (\y. M7)))
                 M5)))]
        ; by tmap-fun [g |- Dtmap] [g |- Dtmap1] as DeqA unboxed;
          by flay-resp [g |- DeqA] [ |- skel-eq/i ] [g |- eterm-eq/i ]
               [g |- Dflay]
          as Dflay'' unboxed;
          split flay-fun [g |- Dflay''] [g |- Dflay1] as
          case flay-fun/i:
          { g : map-fun-ctx,
            K : (g |- kind),
            C1 : (g, a158 : con, a157 : con |- con),
            C2 : (g |- con),
            Dskel : ( |- skel),
            M3 : (g |- eterm),
            A : (g |- etp),
            M7 : (g, x : eterm, x : eterm |- eterm),
            M5 : (g |- eterm),
            Dskel1 : ( |- skel),
            M6 : (g |- eterm),
            A1 : (g |- etp),
            Dtmap : (g |- tmap K A),
            Dmap :
              (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
               z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
            Dmap1 : (g |- map C2 M5),
            Dflay : (g |- flay A Dskel[] M3),
            Dtmap1 : (g |- tmap K A1),
            Dmap2 :
              (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
               z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
            Dmap3 : (g |- map C2 M5),
            Dflay1 : (g |- flay A1 Dskel1[] M6),
            DeqA : (g |- etp-eq A A1),
            Dflay'' : (g |- flay A1 Dskel[] M3),
            Deq : ( |- skel-eq Dskel Dskel1),
            Deq1 : (g |- eterm-eq M3 M6)
          | x :
              [g |-
                 map
                   (rec' K (\z335. \y336. C1) C2)
                   (eapp (econst (const/rec Dskel[]))
                   (epair M3
                   (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M7)))
                   M5)))],
            map :
              [g |-
                 map
                   (rec' K (\z335. \y336. C1) C2)
                   (eapp (econst (const/rec Dskel1[]))
                   (epair M6
                   (epair (elam (epi A1 (\x. et))
                          (\x. elam (A1[..]) (\y. M7)))
                   M5)))]
          ; split [ |- Deq] as
            case skel-eq/i:
            { g : map-fun-ctx,
              K : (g |- kind),
              C1 : (g, a158 : con, a157 : con |- con),
              C2 : (g |- con),
              Dskel1 : ( |- skel),
              M3 : (g |- eterm),
              A : (g |- etp),
              M7 : (g, x : eterm, x : eterm |- eterm),
              M5 : (g |- eterm),
              M6 : (g |- eterm),
              A1 : (g |- etp),
              Dtmap : (g |- tmap K A),
              Dmap :
                (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
                 z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
              Dmap1 : (g |- map C2 M5),
              Dflay : (g |- flay A Dskel1[] M3),
              Dtmap1 : (g |- tmap K A1),
              Dmap2 :
                (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
                 z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
              Dmap3 : (g |- map C2 M5),
              Dflay1 : (g |- flay A1 Dskel1[] M6),
              DeqA : (g |- etp-eq A A1),
              Dflay'' : (g |- flay A1 Dskel1[] M3),
              Deq1 : (g |- eterm-eq M3 M6)
            | x :
                [g |-
                   map
                     (rec' K (\z335. \y336. C1) C2)
                     (eapp (econst (const/rec Dskel1[]))
                     (epair M3
                     (epair (elam (epi A (\x. et))
                            (\x. elam (A[..]) (\y. M7)))
                     M5)))],
              map :
                [g |-
                   map
                     (rec' K (\z335. \y336. C1) C2)
                     (eapp (econst (const/rec Dskel1[]))
                     (epair M6
                     (epair (elam (epi A1 (\x. et))
                            (\x. elam (A1[..]) (\y. M7)))
                     M5)))]
            ; split [g |- Deq1] as
              case eterm-eq/i:
              { g : map-fun-ctx,
                K : (g |- kind),
                C1 : (g, a158 : con, a157 : con |- con),
                C2 : (g |- con),
                Dskel1 : ( |- skel),
                M6 : (g |- eterm),
                A : (g |- etp),
                M7 : (g, x : eterm, x : eterm |- eterm),
                M5 : (g |- eterm),
                A1 : (g |- etp),
                Dtmap : (g |- tmap K A),
                Dmap :
                  (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
                   z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
                Dmap1 : (g |- map C2 M5),
                Dflay : (g |- flay A Dskel1[] M6),
                Dtmap1 : (g |- tmap K A1),
                Dmap2 :
                  (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
                   z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
                Dmap3 : (g |- map C2 M5),
                Dflay1 : (g |- flay A1 Dskel1[] M6),
                DeqA : (g |- etp-eq A A1),
                Dflay'' : (g |- flay A1 Dskel1[] M6)
              | x :
                  [g |-
                     map
                       (rec' K (\z335. \y336. C1) C2)
                       (eapp (econst (const/rec Dskel1[]))
                       (epair M6
                       (epair (elam (epi A (\x. et))
                              (\x. elam (A[..]) (\y. M7)))
                       M5)))],
                map :
                  [g |-
                     map
                       (rec' K (\z335. \y336. C1) C2)
                       (eapp (econst (const/rec Dskel1[]))
                       (epair M6
                       (epair (elam (epi A1 (\x. et))
                              (\x. elam (A1[..]) (\y. M7)))
                       M5)))]
              ; split [g |- DeqA] as
                case etp-eq/i:
                { g : map-fun-ctx,
                  K : (g |- kind),
                  C1 : (g, a158 : con, a157 : con |- con),
                  C2 : (g |- con),
                  Dskel1 : ( |- skel),
                  M6 : (g |- eterm),
                  A1 : (g |- etp),
                  M7 : (g, x : eterm, x : eterm |- eterm),
                  M5 : (g |- eterm),
                  Dtmap : (g |- tmap K A1),
                  Dmap :
                    (g, a : con, x : eterm, x922 : map a x, b : con,
                     y : eterm,
                     z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
                  Dmap1 : (g |- map C2 M5),
                  Dflay : (g |- flay A1 Dskel1[] M6),
                  Dtmap1 : (g |- tmap K A1),
                  Dmap2 :
                    (g, a : con, x : eterm, x922 : map a x, b : con,
                     y : eterm,
                     z922 : map b y |- map (C1[.., a, b]) (M7[.., x, y])),
                  Dmap3 : (g |- map C2 M5),
                  Dflay1 : (g |- flay A1 Dskel1[] M6),
                  Dflay'' : (g |- flay A1 Dskel1[] M6)
                | x :
                    [g |-
                       map
                         (rec' K (\z335. \y336. C1) C2)
                         (eapp (econst (const/rec Dskel1[]))
                         (epair M6
                         (epair (elam (epi A1 (\x. et))
                                (\x. elam (A1[..]) (\y. M7)))
                         M5)))],
                  map :
                    [g |-
                       map
                         (rec' K (\z335. \y336. C1) C2)
                         (eapp (econst (const/rec Dskel1[]))
                         (epair M6
                         (epair (elam (epi A1 (\x. et))
                                (\x. elam (A1[..]) (\y. M7)))
                         M5)))]
                ; solve [g |- eterm-eq/i ]
                }
              }
            }
          }
        }
      }
    }
  }
  case map/tagged:
  { g : map-fun-ctx, M' : (g |- eterm)
  | x : [g |- map tagged (econst const/tagged)], map : [g |- map tagged M']
  ; split map as
    case map/tagged:
    { g : map-fun-ctx
    | x : [g |- map tagged (econst const/tagged)],
      map : [g |- map tagged (econst const/tagged)]
    ; solve [g |- eterm-eq/i ]
    }
  }
  case map/tag:
  { g : map-fun-ctx,
    C1 : (g |- con),
    M1 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1)
  | x : [g |- map (tag C1) (eapp (econst const/tag) M1)],
    map : [g |- map (tag C1) M']
  ; split map as
    case map/tag:
    { g : map-fun-ctx,
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C1 M2)
    | x : [g |- map (tag C1) (eapp (econst const/tag) M1)],
      map : [g |- map (tag C1) (eapp (econst const/tag) M2)]
    ; split map-fun [g |- Dmap] [g |- Dmap1] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        M2 : (g |- eterm),
        Dmap : (g |- map C1 M2),
        Dmap1 : (g |- map C1 M2)
      | x : [g |- map (tag C1) (eapp (econst const/tag) M2)],
        map : [g |- map (tag C1) (eapp (econst const/tag) M2)]
      ; solve [g |- eterm-eq/i ]
      }
    }
  }
  case map/ref:
  { g : map-fun-ctx,
    C1 : (g |- con),
    M1 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1)
  | x : [g |- map (ref C1) (eapp (econst const/ref) M1)],
    map : [g |- map (ref C1) M']
  ; split map as
    case map/ref:
    { g : map-fun-ctx,
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C1 M2)
    | x : [g |- map (ref C1) (eapp (econst const/ref) M1)],
      map : [g |- map (ref C1) (eapp (econst const/ref) M2)]
    ; split map-fun [g |- Dmap] [g |- Dmap1] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        M2 : (g |- eterm),
        Dmap : (g |- map C1 M2),
        Dmap1 : (g |- map C1 M2)
      | x : [g |- map (ref C1) (eapp (econst const/ref) M2)],
        map : [g |- map (ref C1) (eapp (econst const/ref) M2)]
      ; solve [g |- eterm-eq/i ]
      }
    }
  }
  case map/plus:
  { g : map-fun-ctx,
    C1 : (g |- con),
    C2 : (g |- con),
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1),
    Dmap1 : (g |- map C2 M2)
  | x : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)],
    map : [g |- map (plus C1 C2) M']
  ; split map as
    case map/plus:
    { g : map-fun-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M4 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C2 M2),
      Dmap2 : (g |- map C1 M3),
      Dmap3 : (g |- map C2 M4)
    | x : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)],
      map : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M3) M4)]
    ; split map-fun [g |- Dmap] [g |- Dmap2] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M3 : (g |- eterm),
        M2 : (g |- eterm),
        M4 : (g |- eterm),
        Dmap : (g |- map C1 M3),
        Dmap1 : (g |- map C2 M2),
        Dmap2 : (g |- map C1 M3),
        Dmap3 : (g |- map C2 M4)
      | x : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M3) M2)],
        map : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M3) M4)]
      ; split map-fun [g |- Dmap1] [g |- Dmap3] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          C1 : (g |- con),
          C2 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dmap : (g |- map C1 M3),
          Dmap1 : (g |- map C2 M4),
          Dmap2 : (g |- map C1 M3),
          Dmap3 : (g |- map C2 M4)
        | x : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M3) M4)],
          map :
            [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M3) M4)]
        ; solve [g |- eterm-eq/i ]
        }
      }
    }
  }
  case map/arrow:
  { g : map-fun-ctx,
    C1 : (g |- con),
    C2 : (g |- con),
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1),
    Dmap1 : (g |- map C2 M2)
  | x : [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)],
    map : [g |- map (arrow C1 C2) M']
  ; split map as
    case map/arrow:
    { g : map-fun-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M4 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C2 M2),
      Dmap2 : (g |- map C1 M3),
      Dmap3 : (g |- map C2 M4)
    | x : [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)],
      map : [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M3) M4)]
    ; split map-fun [g |- Dmap] [g |- Dmap2] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M3 : (g |- eterm),
        M2 : (g |- eterm),
        M4 : (g |- eterm),
        Dmap : (g |- map C1 M3),
        Dmap1 : (g |- map C2 M2),
        Dmap2 : (g |- map C1 M3),
        Dmap3 : (g |- map C2 M4)
      | x : [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M3) M2)],
        map :
          [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M3) M4)]
      ; split map-fun [g |- Dmap1] [g |- Dmap3] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          C1 : (g |- con),
          C2 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dmap : (g |- map C1 M3),
          Dmap1 : (g |- map C2 M4),
          Dmap2 : (g |- map C1 M3),
          Dmap3 : (g |- map C2 M4)
        | x :
            [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M3) M4)],
          map :
            [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M3) M4)]
        ; solve [g |- eterm-eq/i ]
        }
      }
    }
  }
  case map/prod:
  { g : map-fun-ctx,
    C1 : (g |- con),
    C2 : (g |- con),
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1),
    Dmap1 : (g |- map C2 M2)
  | x : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)],
    map : [g |- map (prod C1 C2) M']
  ; split map as
    case map/prod:
    { g : map-fun-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M4 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C2 M2),
      Dmap2 : (g |- map C1 M3),
      Dmap3 : (g |- map C2 M4)
    | x : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)],
      map : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M3) M4)]
    ; split map-fun [g |- Dmap] [g |- Dmap2] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M3 : (g |- eterm),
        M2 : (g |- eterm),
        M4 : (g |- eterm),
        Dmap : (g |- map C1 M3),
        Dmap1 : (g |- map C2 M2),
        Dmap2 : (g |- map C1 M3),
        Dmap3 : (g |- map C2 M4)
      | x : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M3) M2)],
        map : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M3) M4)]
      ; split map-fun [g |- Dmap1] [g |- Dmap3] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          C1 : (g |- con),
          C2 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dmap : (g |- map C1 M3),
          Dmap1 : (g |- map C2 M4),
          Dmap2 : (g |- map C1 M3),
          Dmap3 : (g |- map C2 M4)
        | x : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M3) M4)],
          map :
            [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M3) M4)]
        ; solve [g |- eterm-eq/i ]
        }
      }
    }
  }
  case map/void:
  { g : map-fun-ctx, M' : (g |- eterm)
  | x : [g |- map void (econst const/void)], map : [g |- map void M']
  ; split map as
    case map/void:
    { g : map-fun-ctx
    | x : [g |- map void (econst const/void)],
      map : [g |- map void (econst const/void)]
    ; solve [g |- eterm-eq/i ]
    }
  }
  case map/unit:
  { g : map-fun-ctx, M' : (g |- eterm)
  | x : [g |- map unit (econst const/unit)], map : [g |- map unit M']
  ; split map as
    case map/unit:
    { g : map-fun-ctx
    | x : [g |- map unit (econst const/unit)],
      map : [g |- map unit (econst const/unit)]
    ; solve [g |- eterm-eq/i ]
    }
  }
  case map/star:
  { g : map-fun-ctx, M' : (g |- eterm)
  | x : [g |- map star estar], map : [g |- map star M']
  ; split map as
    case map/star:
    { g : map-fun-ctx
    | x : [g |- map star estar], map : [g |- map star estar]
    ; solve [g |- eterm-eq/i ]
    }
  }
  case map/app:
  { g : map-fun-ctx,
    C1 : (g |- con),
    C2 : (g |- con),
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1),
    Dmap1 : (g |- map C2 M2)
  | x : [g |- map (app C1 C2) (eapp M1 M2)], map : [g |- map (app C1 C2) M']
  ; split map as
    case map/app:
    { g : map-fun-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M4 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C2 M2),
      Dmap2 : (g |- map C1 M3),
      Dmap3 : (g |- map C2 M4)
    | x : [g |- map (app C1 C2) (eapp M1 M2)],
      map : [g |- map (app C1 C2) (eapp M3 M4)]
    ; split map-fun [g |- Dmap] [g |- Dmap2] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C1 : (g |- con),
        C2 : (g |- con),
        M3 : (g |- eterm),
        M2 : (g |- eterm),
        M4 : (g |- eterm),
        Dmap : (g |- map C1 M3),
        Dmap1 : (g |- map C2 M2),
        Dmap2 : (g |- map C1 M3),
        Dmap3 : (g |- map C2 M4)
      | x : [g |- map (app C1 C2) (eapp M3 M2)],
        map : [g |- map (app C1 C2) (eapp M3 M4)]
      ; split map-fun [g |- Dmap1] [g |- Dmap3] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          C1 : (g |- con),
          C2 : (g |- con),
          M3 : (g |- eterm),
          M4 : (g |- eterm),
          Dmap : (g |- map C1 M3),
          Dmap1 : (g |- map C2 M4),
          Dmap2 : (g |- map C1 M3),
          Dmap3 : (g |- map C2 M4)
        | x : [g |- map (app C1 C2) (eapp M3 M4)],
          map : [g |- map (app C1 C2) (eapp M3 M4)]
        ; solve [g |- eterm-eq/i ]
        }
      }
    }
  }
  case map/lam:
  { g : map-fun-ctx,
    K : (g |- kind),
    C1 : (g, a156 : con |- con),
    A : (g |- etp),
    M1 : (g, x917 : eterm |- eterm),
    M' : (g |- eterm),
    Dtmap : (g |- tmap K A),
    Dmap :
      (g, a : con, x : eterm, y917 : map a x |- map (C1[.., a]) (M1[.., x]))
  | x : [g |- map (lam K (\y331. C1)) (elam A (\y146. M1))],
    map : [g |- map (lam K (\y331. C1)) M']
  ; split map as
    case map/lam:
    { g : map-fun-ctx,
      K : (g |- kind),
      C1 : (g, a156 : con |- con),
      A : (g |- etp),
      M1 : (g, x917 : eterm |- eterm),
      A1 : (g |- etp),
      M2 : (g, x917 : eterm |- eterm),
      Dtmap : (g |- tmap K A),
      Dmap :
        (g, a : con, x : eterm, y917 : map a x |- map (C1[.., a]) (M1[.., x])),
      Dtmap1 : (g |- tmap K A1),
      Dmap1 :
        (g, a : con, x : eterm, y917 : map a x |- map (C1[.., a]) (M2[.., x]))
    | x : [g |- map (lam K (\y331. C1)) (elam A (\y146. M1))],
      map : [g |- map (lam K (\y331. C1)) (elam A1 (\y146. M2))]
    ; split tmap-fun [g |- Dtmap] [g |- Dtmap1] as
      case etp-eq/i:
      { g : map-fun-ctx,
        K : (g |- kind),
        C1 : (g, a156 : con |- con),
        A1 : (g |- etp),
        M1 : (g, x917 : eterm |- eterm),
        M2 : (g, x917 : eterm |- eterm),
        Dtmap : (g |- tmap K A1),
        Dmap :
          (g, a : con, x : eterm, y917 : map a x |-
             map (C1[.., a]) (M1[.., x])),
        Dtmap1 : (g |- tmap K A1),
        Dmap1 :
          (g, a : con, x : eterm, y917 : map a x |-
             map (C1[.., a]) (M2[.., x]))
      | x : [g |- map (lam K (\y331. C1)) (elam A1 (\y146. M1))],
        map : [g |- map (lam K (\y331. C1)) (elam A1 (\y146. M2))]
      ; split
        map-fun
          [g,
           b :
             block (
               x : eterm,
               d : evof x (A1[..]),
               a : con,
               e : cn-of a (K[..]),
               at : map a x) |- Dmap[.., b.3, b.1, b.5]]
          [g,
           b :
             block (
               x : eterm,
               d : evof x (A1[..]),
               a : con,
               e : cn-of a (K[..]),
               at : map a x) |- Dmap1[.., b.3, b.1, b.5]] as
        case eterm-eq/i:
        { g : map-fun-ctx,
          K : (g |- kind),
          C1 : (g, a156 : con |- con),
          A1 : (g |- etp),
          M3 : (g, x : eterm |- eterm),
          Dtmap : (g |- tmap K A1),
          Dmap :
            (g, a : con, x : eterm, y917 : map a x |-
               map (C1[.., a]) (M3[.., x])),
          Dtmap1 : (g |- tmap K A1),
          Dmap1 :
            (g, a : con, x : eterm, y917 : map a x |-
               map (C1[.., a]) (M3[.., x]))
        | x : [g |- map (lam K (\y331. C1)) (elam A1 (\y146. M3))],
          map : [g |- map (lam K (\y331. C1)) (elam A1 (\y146. M3))]
        ; solve [g |- eterm-eq/i ]
        }
      }
    }
  }
  case map/pi2:
  { g : map-fun-ctx,
    C1 : (g |- con),
    M1 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1)
  | x : [g |- map (pi2 C1) (epi2 M1)], map : [g |- map (pi2 C1) M']
  ; split map as
    case map/pi2:
    { g : map-fun-ctx,
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C1 M2)
    | x : [g |- map (pi2 C1) (epi2 M1)], map : [g |- map (pi2 C1) (epi2 M2)]
    ; by map-fun [g |- Dmap] [g |- Dmap1] as Deq1 unboxed;
      solve eterm-resp-eterm [x : eterm |- epi2 x] [g |- Deq1]
    }
  }
  case map/pi1:
  { g : map-fun-ctx,
    C1 : (g |- con),
    M1 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1)
  | x : [g |- map (pi1 C1) (epi1 M1)], map : [g |- map (pi1 C1) M']
  ; split map as
    case map/pi1:
    { g : map-fun-ctx,
      C1 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C1 M2)
    | x : [g |- map (pi1 C1) (epi1 M1)], map : [g |- map (pi1 C1) (epi1 M2)]
    ; by map-fun [g |- Dmap] [g |- Dmap1] as Deq1 unboxed;
      solve eterm-resp-eterm [x : eterm |- epi1 x] [g |- Deq1]
    }
  }
  case map/pair:
  { g : map-fun-ctx,
    C1 : (g |- con),
    C2 : (g |- con),
    M1 : (g |- eterm),
    M2 : (g |- eterm),
    M' : (g |- eterm),
    Dmap : (g |- map C1 M1),
    Dmap1 : (g |- map C2 M2)
  | x : [g |- map (pair C1 C2) (epair M1 M2)],
    map : [g |- map (pair C1 C2) M']
  ; split map as
    case map/pair:
    { g : map-fun-ctx,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      M3 : (g |- eterm),
      M4 : (g |- eterm),
      Dmap : (g |- map C1 M1),
      Dmap1 : (g |- map C2 M2),
      Dmap2 : (g |- map C1 M3),
      Dmap3 : (g |- map C2 M4)
    | x : [g |- map (pair C1 C2) (epair M1 M2)],
      map : [g |- map (pair C1 C2) (epair M3 M4)]
    ; by map-fun [g |- Dmap] [g |- Dmap2] as Deq1 unboxed;
      by map-fun [g |- Dmap1] [g |- Dmap3] as Deq2 unboxed;
      solve
        eterm-resp-eterm2 [x : eterm, y : eterm |- epair x y] [g |- Deq1]
          [g |- Deq2]
    }
  }
  %{ FIXME: File "src/core/reconstruct.ml", line 2248, characters 11-16: Pattern matching failed
  case #.5:
  { g : map-fun-ctx,
    K888 : (g |- kind),
    A157 : (g |- etp),
    #map :
      #(g |-
          block (
            a : con,
            da : cn-of a (K888[..]),
            x : eterm,
            dx : evof x (A157[..]),
            at : map a x)),
    M' : (g |- eterm)
  | x : [g |- map #map.1 #map.3], map : [g |- map #map.1 M']
  ; split map as
    case #.5:
    { g : map-fun-ctx,
      K888 : (g |- kind),
      A157 : (g |- etp),
      #map :
        #(g |-
            block (
              a : con,
              da : cn-of a (K888[..]),
              x : eterm,
              dx : evof x (A157[..]),
              at : map a x))
    | x : [g |- map #map.1 #map.3], map : [g |- map #map.1 #map.3]
    ; solve [_ |- eterm-eq/i ]
    }
  }
  case #.5:
  { g : map-fun-ctx,
    A158 : (g |- etp),
    K889 : (g |- kind),
    #map :
      #(g |-
          block (
            x : eterm,
            d : evof x (A158[..]),
            a : con,
            e : cn-of a (K889[..]),
            at : map a x)),
    M' : (g |- eterm)
  | x : [g |- map #map.3 #map.1], map : [g |- map #map.3 M']
  ; split map as
    case #.5:
    { g : map-fun-ctx,
      A158 : (g |- etp),
      K889 : (g |- kind),
      #map :
        #(g |-
            block (
              x : eterm,
              d : evof x (A158[..]),
              a : con,
              e : cn-of a (K889[..]),
              at : map a x))
    | x : [g |- map #map.3 #map.1], map : [g |- map #map.3 #map.1]
    ; solve [_ |- eterm-eq/i ]
    }
  }
  case #.2:
  { g : map-fun-ctx,
    M : (g |- eterm),
    #map : #(g |- block (a : con, at : map a (M[..]))),
    M' : (g |- eterm)
  | x : [g |- map #map.1 M], map : [g |- map #map.1 M']
  ; split map as
    case #.2:
    { g : map-fun-ctx,
      M' : (g |- eterm),
      #map : #(g |- block (a : con, at : map a (M'[..])))
    | x : [g |- map #map.1 M'], map : [g |- map #map.1 M']
    ; solve [_ |- eterm-eq/i ]
    }
  }
  }%
}

and proof tmap-fun :
  (g : map-fun-ctx)
  [g |- tmap K A] ->
  [g |- tmap K A'] ->
    [g |- etp-eq A A'] =
/ trust / % FIXME: See issue #4
intros
{ g : map-fun-ctx, K : (g |- kind), A : (g |- etp), A' : (g |- etp)
| x : [g |- tmap K A], tmap : [g |- tmap K A']
; split x as
  case tmap/one:
  { g : map-fun-ctx, A' : (g |- etp)
  | x : [g |- tmap one eone], tmap : [g |- tmap one A']
  ; split tmap as
    case tmap/one:
    { g : map-fun-ctx
    | x : [g |- tmap one eone], tmap : [g |- tmap one eone]
    ; solve [_ |- etp-eq/i ]
    }
  }
  case tmap/sigma:
  { g : map-fun-ctx,
    K1 : (g |- kind),
    K2 : (g, a160 : con |- kind),
    A1 : (g |- etp),
    A2 : (g, z926 : eterm |- etp),
    A' : (g |- etp),
    Dtmap : (g |- tmap K1 A1),
    Dtmap1 :
      (g, a : con, x : eterm, x926 : map a x |- tmap (K2[.., a]) (A2[.., x]))
  | x : [g |- tmap (sigma K1 (\z328. K2)) (esigma A1 (\y143. A2))],
    tmap : [g |- tmap (sigma K1 (\z328. K2)) A']
  ; split tmap as
    case tmap/sigma:
    { g : map-fun-ctx,
      K1 : (g |- kind),
      K2 : (g, a160 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, z926 : eterm |- etp),
      A3 : (g |- etp),
      A4 : (g, z926 : eterm |- etp),
      Dtmap : (g |- tmap K1 A1),
      Dtmap1 :
        (g, a : con, x : eterm, x926 : map a x |-
           tmap (K2[.., a]) (A2[.., x])),
      Dtmap2 : (g |- tmap K1 A3),
      Dtmap3 :
        (g, a : con, x : eterm, x926 : map a x |-
           tmap (K2[.., a]) (A4[.., x]))
    | x : [g |- tmap (sigma K1 (\z328. K2)) (esigma A1 (\y143. A2))],
      tmap : [g |- tmap (sigma K1 (\z328. K2)) (esigma A3 (\y143. A4))]
    ; split tmap-fun [_ |- Dtmap] [_ |- Dtmap2] as
      case etp-eq/i:
      { g : map-fun-ctx,
        K1 : (g |- kind),
        K2 : (g, a160 : con |- kind),
        A3 : (g |- etp),
        A2 : (g, z926 : eterm |- etp),
        A4 : (g, z926 : eterm |- etp),
        Dtmap : (g |- tmap K1 A3),
        Dtmap1 :
          (g, a : con, x : eterm, x926 : map a x |-
             tmap (K2[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K1 A3),
        Dtmap3 :
          (g, a : con, x : eterm, x926 : map a x |-
             tmap (K2[.., a]) (A4[.., x]))
      | x : [g |- tmap (sigma K1 (\z328. K2)) (esigma A3 (\y143. A2))],
        tmap : [g |- tmap (sigma K1 (\z328. K2)) (esigma A3 (\y143. A4))]
      ; split
tmap-fun
  [g,
   b :
     block (
       x : eterm,
       d : evof x (A3[..]),
       a : con,
       e : cn-of a (K1[..]),
       at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
  [g,
   b :
     block (
       x : eterm,
       d : evof x (A3[..]),
       a : con,
       e : cn-of a (K1[..]),
       at : map a x) |- Dtmap3[.., b.3, b.1, b.5]] as
        case etp-eq/i:
        { g : map-fun-ctx,
          K1 : (g |- kind),
          K2 : (g, a160 : con |- kind),
          A3 : (g |- etp),
          A5 : (g, x : eterm |- etp),
          Dtmap : (g |- tmap K1 A3),
          Dtmap1 :
            (g, a : con, x : eterm, x926 : map a x |-
               tmap (K2[.., a]) (A5[.., x])),
          Dtmap2 : (g |- tmap K1 A3),
          Dtmap3 :
            (g, a : con, x : eterm, x926 : map a x |-
               tmap (K2[.., a]) (A5[.., x]))
        | x : [g |- tmap (sigma K1 (\z328. K2)) (esigma A3 (\y143. A5))],
          tmap : [g |- tmap (sigma K1 (\z328. K2)) (esigma A3 (\y143. A5))]
        ; solve [g |- etp-eq/i ]
        }
      }
    }
  }
  case tmap/pi:
  { g : map-fun-ctx,
    K1 : (g |- kind),
    K2 : (g, a159 : con |- kind),
    A1 : (g |- etp),
    A2 : (g, x925 : eterm |- etp),
    A' : (g |- etp),
    Dtmap : (g |- tmap K1 A1),
    Dtmap1 :
      (g, a : con, x : eterm, y925 : map a x |- tmap (K2[.., a]) (A2[.., x]))
  | x : [g |- tmap (pi K1 (\z327. K2)) (epi A1 (\y142. A2))],
    tmap : [g |- tmap (pi K1 (\z327. K2)) A']
  ; split tmap as
    case tmap/pi:
    { g : map-fun-ctx,
      K1 : (g |- kind),
      K2 : (g, a159 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, x925 : eterm |- etp),
      A3 : (g |- etp),
      A4 : (g, x925 : eterm |- etp),
      Dtmap : (g |- tmap K1 A1),
      Dtmap1 :
        (g, a : con, x : eterm, y925 : map a x |-
           tmap (K2[.., a]) (A2[.., x])),
      Dtmap2 : (g |- tmap K1 A3),
      Dtmap3 :
        (g, a : con, x : eterm, y925 : map a x |-
           tmap (K2[.., a]) (A4[.., x]))
    | x : [g |- tmap (pi K1 (\z327. K2)) (epi A1 (\y142. A2))],
      tmap : [g |- tmap (pi K1 (\z327. K2)) (epi A3 (\y142. A4))]
    ; split tmap-fun [_ |- Dtmap] [_ |- Dtmap2] as
      case etp-eq/i:
      { g : map-fun-ctx,
        K1 : (g |- kind),
        K2 : (g, a159 : con |- kind),
        A3 : (g |- etp),
        A2 : (g, x925 : eterm |- etp),
        A4 : (g, x925 : eterm |- etp),
        Dtmap : (g |- tmap K1 A3),
        Dtmap1 :
          (g, a : con, x : eterm, y925 : map a x |-
             tmap (K2[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K1 A3),
        Dtmap3 :
          (g, a : con, x : eterm, y925 : map a x |-
             tmap (K2[.., a]) (A4[.., x]))
      | x : [g |- tmap (pi K1 (\z327. K2)) (epi A3 (\y142. A2))],
        tmap : [g |- tmap (pi K1 (\z327. K2)) (epi A3 (\y142. A4))]
      ; split
tmap-fun
  [g,
   b :
     block (
       x : eterm,
       d : evof x (A3[..]),
       a : con,
       e : cn-of a (K1[..]),
       at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
  [g,
   b :
     block (
       x : eterm,
       d : evof x (A3[..]),
       a : con,
       e : cn-of a (K1[..]),
       at : map a x) |- Dtmap3[.., b.3, b.1, b.5]] as
        case etp-eq/i:
        { g : map-fun-ctx,
          K1 : (g |- kind),
          K2 : (g, a159 : con |- kind),
          A3 : (g |- etp),
          A5 : (g, x : eterm |- etp),
          Dtmap : (g |- tmap K1 A3),
          Dtmap1 :
            (g, a : con, x : eterm, y925 : map a x |-
               tmap (K2[.., a]) (A5[.., x])),
          Dtmap2 : (g |- tmap K1 A3),
          Dtmap3 :
            (g, a : con, x : eterm, y925 : map a x |-
               tmap (K2[.., a]) (A5[.., x]))
        | x : [g |- tmap (pi K1 (\z327. K2)) (epi A3 (\y142. A5))],
          tmap : [g |- tmap (pi K1 (\z327. K2)) (epi A3 (\y142. A5))]
        ; solve [g |- etp-eq/i ]
        }
      }
    }
  }
  case tmap/sing:
  { g : map-fun-ctx,
    C : (g |- con),
    M : (g |- eterm),
    A' : (g |- etp),
    Dmap : (g |- map C M)
  | x : [g |- tmap (sing C) (esing M)], tmap : [g |- tmap (sing C) A']
  ; split tmap as
    case tmap/sing:
    { g : map-fun-ctx,
      C : (g |- con),
      M : (g |- eterm),
      M1 : (g |- eterm),
      Dmap : (g |- map C M),
      Dmap1 : (g |- map C M1)
    | x : [g |- tmap (sing C) (esing M)],
      tmap : [g |- tmap (sing C) (esing M1)]
    ; split map-fun [_ |- Dmap] [_ |- Dmap1] as
      case eterm-eq/i:
      { g : map-fun-ctx,
        C : (g |- con),
        M1 : (g |- eterm),
        Dmap : (g |- map C M1),
        Dmap1 : (g |- map C M1)
      | x : [g |- tmap (sing C) (esing M1)],
        tmap : [g |- tmap (sing C) (esing M1)]
      ; solve [_ |- etp-eq/i ]
      }
    }
  }
  case tmap/t:
  { g : map-fun-ctx, A' : (g |- etp)
  | x : [g |- tmap t et], tmap : [g |- tmap t A']
  ; split tmap as
    case tmap/t:
    { g : map-fun-ctx
    | x : [g |- tmap t et], tmap : [g |- tmap t et]
    ; solve [_ |- etp-eq/i ]
    }
  }
}
;

% Map Preserves Typing

schema map-bind+invert-bind-for-map-of =
  some [B : etp, K : kind, Dmap : tmap K B, Dwf : ewf B]
  block (
    x : eterm, dx : evof x B,
    a : con, da : cn-of a K,
    at : map a x
  ) +
  some [
    K : kind, K' : kind,
    B : etp,
    DmapK : tmap K B,
    DmapB : tunmap B K',
    DwfK : kd-wf K,
    DwfB : ewf B,
    DequivK : kd-equiv K K'
  ]
  block (
    a : con, da : cn-of a K,
    x : eterm, dx : evof x B,
    at : map a x, xt : unmap x a
  );

LF map-of/e : kind -> eterm -> type =
| map-of/i :
  { A : etp }
  tmap K A ->
  eof M A ->
    map-of/e K M
;

LF map-wf/e : kind -> type =
| map-wf/i :
  { A : etp }
  tmap K A ->
  ewf A ->
    map-wf/e K
;

LF map-equiv'/e : eterm -> eterm -> kind -> type =
| map-equiv'/i :
  { A : etp }
  tmap K A ->
  equiv M N A ->
    map-equiv'/e M N K
;

proof map-of :
  (g : map-bind+invert-bind-for-map-of)
  [g |- cn-of C K] ->
  [g |- map C M] ->
    [g |- map-of/e K M] =
/ trust / % FIXME: See issue #4
intros
{ g : map-bind+invert-bind-for-map-of,
  C : (g |- con),
  K : (g |- kind),
  M : (g |- eterm)
| x : [g |- cn-of C K], map : [g |- map C M]
; by map as Dmap unboxed;
  split x as
  case cn-of/subsume:
  { g : map-bind+invert-bind-for-map-of,
    C : (g |- con),
    K : (g |- kind),
    M : (g |- eterm),
    Dmap : (g |- map C M),
    K1 : (g |- kind),
    Dof : (g |- cn-of C K1),
    Dsub : (g |- kd-sub K1 K)
  | x : [g |- cn-of C K], map : [g |- map C M]
  ; split map-of [_ |- Dof] [_ |- Dmap] as
    case map-of/i:
    { g : map-bind+invert-bind-for-map-of,
      C : (g |- con),
      K : (g |- kind),
      M : (g |- eterm),
      Dmap : (g |- map C M),
      K1 : (g |- kind),
      Dof : (g |- cn-of C K1),
      Dsub : (g |- kd-sub K1 K),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A),
      Dof1 : (g |- eof M A)
    | x : [g |- cn-of C K], map : [g |- map C M]
    ; split can-tmap [_ |- K] as
      case can-tmap/i:
      { g : map-bind+invert-bind-for-map-of,
        C : (g |- con),
        K : (g |- kind),
        M : (g |- eterm),
        Dmap : (g |- map C M),
        K1 : (g |- kind),
        Dof : (g |- cn-of C K1),
        Dsub : (g |- kd-sub K1 K),
        A : (g |- etp),
        DmapA : (g |- tmap K1 A),
        Dof' : (g |- eof M A),
        A1 : (g |- etp),
        Dtmap : (g |- tmap K A1)
      | x : [g |- cn-of C K], map : [g |- map C M]
      ; by map-subtp [_ |- Dsub] [_ |- DmapA] [_ |- Dtmap] as Dsub' unboxed;
        solve [_ |- map-of/i A1 Dtmap (eof/subsume Dof' Dsub')]
      }
    }
  }
  case cn-of/extsigma:
  { g : map-bind+invert-bind-for-map-of,
    C : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a23 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map C M),
    Dof : (g |- cn-of (pi1 C) K1),
    Dof1 : (g |- cn-of (pi2 C) (K2[.., pi1 C])),
    Dwf : (g, a : con, y328 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of C (sigma K1 (\x248. K2))], map : [g |- map C M]
  ; split map-of [g |- Dof] [g |- map/pi1 Dmap] as
    case map-of/i:
    { g : map-bind+invert-bind-for-map-of,
      C : (g |- con),
      K1 : (g |- kind),
      K2 : (g, a23 : con |- kind),
      M : (g |- eterm),
      Dmap : (g |- map C M),
      Dof : (g |- cn-of (pi1 C) K1),
      Dof1 : (g |- cn-of (pi2 C) (K2[.., pi1 C])),
      Dwf : (g, a : con, y328 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A),
      Dof2 : (g |- eof (epi1 M) A)
    | x : [g |- cn-of C (sigma K1 (\z328. K2))], map : [g |- map C M]
    ; split
      map-wf
        [g,
         b :
           block (
             x : eterm,
             dx : evof x (A[..]),
             a : con,
             da : cn-of a (K1[..]),
             at : map a x) |- Dwf[.., b.3, b.4]] as
      case map-wf/i:
      { g : map-bind+invert-bind-for-map-of,
        C : (g |- con),
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        M : (g |- eterm),
        Dmap : (g |- map C M),
        Dof : (g |- cn-of (pi1 C) K1),
        Dof1 : (g |- cn-of (pi2 C) (K3[.., pi1 C])),
        Dwf : (g, a : con, y328 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        Dof2 : (g |- eof (epi1 M) A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x1284 : map a x |-
             tmap (K3[.., a]) (A1[.., x])),
        Dwf1 : (g, x : eterm, dx : evof x (A[..]) |- ewf (A1[.., x]))
      | x : [g |- cn-of C (sigma K1 (\z328. K3))], map : [g |- map C M]
      ; by map-of' [g |- Dof1] [g |- map/pi2 Dmap]
             [g |- Dtmap1[.., _, _, map/pi1 Dmap]]
        as Dof2' unboxed;
        by [g |- tmap/sigma Dtmap (\a. \x. \at. Dtmap1[.., x, a, _])]
as Dtmap' unboxed;
        by [g |- eof/extsigma Dof2 Dof2' (\x. \dx. Dwf1)] as Dof' unboxed;
        solve [g |- map-of/i _ Dtmap' Dof']
      }
    }
  }
  case cn-of/extpi:
  { g : map-bind+invert-bind-for-map-of,
    C : (g |- con),
    K1 : (g |- kind),
    K3 : (g, a22 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map C M),
    K2 : (g, a21 : con |- kind),
    Dof : (g |- cn-of C (pi K1 (\x247. K2))),
    Dof1 :
      (g, a : con, z326 : cn-of a (K1[..]) |-
         cn-of (app (C[..]) a) (K3[.., a]))
  | x : [g |- cn-of C (pi K1 (\x247. K3))], map : [g |- map C M]
  ; split map-of [g |- Dof] [g |- Dmap] as
    case map-of/i:
    { g : map-bind+invert-bind-for-map-of,
      C : (g |- con),
      K1 : (g |- kind),
      K3 : (g, a22 : con |- kind),
      M : (g |- eterm),
      Dmap : (g |- map C M),
      K2 : (g, a21 : con |- kind),
      Dof : (g |- cn-of C (pi K1 (\x247. K2))),
      Dof1 :
        (g, a : con, z326 : cn-of a (K1[..]) |-
           cn-of (app (C[..]) a) (K3[.., a])),
      A : (g |- etp),
      Dtmap : (g |- tmap (pi K1 (\x247. K2)) A),
      Dof2 : (g |- eof M A)
    | x : [g |- cn-of C (pi K1 (\z327. K3))], map : [g |- map C M]
    ; split
      map-of
        [g,
         b :
           block (
             x : eterm,
             dx : evof x (A[..]),
             a : con,
             da : cn-of a (K1[..]),
             at : map a x) |- Dof1[.., b.3, b.4]]
        [g,
         b :
           block (
             x : eterm,
             dx : evof x (A[..]),
             a : con,
             da : cn-of a (K1[..]),
             at : map a x) |- map/app (Dmap[..]) b.5] as
      case map-of/i:
      { g : map-bind+invert-bind-for-map-of,
        C : (g |- con),
        K1 : (g |- kind),
        K4 : (g, a : con |- kind),
        M : (g |- eterm),
        Dmap : (g |- map C M),
        K2 : (g, a21 : con |- kind),
        Dof : (g |- cn-of C (pi K1 (\x247. K2))),
        Dof1 :
          (g, a : con, z326 : cn-of a (K1[..]) |-
             cn-of (app (C[..]) a) (K4[.., a])),
        A : (g |- etp),
        Dtmap : (g |- tmap (pi K1 (\x247. K2)) A),
        Dof2 : (g |- eof M A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x1283 : map a x |-
             tmap (K4[.., a]) (A1[.., x])),
        Dof3 :
          (g, x : eterm, dx : evof x (A[..]) |-
             eof (eapp (M[..]) x) (A1[.., x]))
      | x : [g |- cn-of C (pi K1 (\z327. K4))], map : [g |- map C M]
      ; split [g |- Dtmap] as
        case tmap/pi:
        { g : map-bind+invert-bind-for-map-of,
          C : (g |- con),
          K1 : (g |- kind),
          K4 : (g, a : con |- kind),
          M : (g |- eterm),
          Dmap : (g |- map C M),
          K2 : (g, a21 : con |- kind),
          Dof : (g |- cn-of C (pi K1 (\x247. K2))),
          Dof1 :
            (g, a : con, z326 : cn-of a (K1[..]) |-
               cn-of (app (C[..]) a) (K4[.., a])),
          A2 : (g |- etp),
          A3 : (g, x925 : eterm |- etp),
          Dtmap2 : (g |- tmap K1 A2),
          Dtmap3 :
            (g, a : con, x : eterm, y925 : map a x |-
               tmap (K2[.., a]) (A3[.., x])),
          Dof2 : (g |- eof M (epi A2 (\y142. A3))),
          A1 : (g, x : eterm |- etp),
          Dtmap1 :
            (g, x : eterm, a : con, x1283 : map a x |-
               tmap (K4[.., a]) (A1[.., x])),
          Dof3 :
            (g, x : eterm, dx : evof x (epi (A2[..]) (\y142. A3[.., y142])) |-
               eof (eapp (M[..]) x) (A1[.., x]))
        | x : [g |- cn-of C (pi K1 (\z327. K4))], map : [g |- map C M]
        ; by [g |- tmap/pi Dtmap2 (\a. \x. \at. Dtmap1[.., x, a, at])]
as Dtmap' unboxed;
          by [g |- eof/extpi Dof2 (\x. \dx. Dof3[.., x, _])] as Dof' unboxed;
          solve [g |- map-of/i _ Dtmap' Dof']
        }
      }
    }
  }
  case cn-of/sing:
  { g : map-bind+invert-bind-for-map-of,
    C : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map C M),
    Dof : (g |- cn-of C t)
  | x : [g |- cn-of C (sing C)], map : [g |- map C M]
  ; by map-of' [g |- Dof] [g |- Dmap] [g |- tmap/t] as Dof' unboxed;
    solve [g |- map-of/i _ (tmap/sing Dmap) (eof/sing Dof')]
  }
  case cn-of/labeled:
  { g : map-bind+invert-bind-for-map-of,
    X : ( |- label),
    C1 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (labeled X[] C1) M),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (labeled X[] C1) t], map : [g |- map (labeled X[] C1) M]
  ; split map as
    case map/labeled:
    { g : map-bind+invert-bind-for-map-of,
      X : ( |- label),
      C1 : (g |- con),
      M1 : (g |- eterm),
      Dmap : (g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)),
      Dof : (g |- cn-of C1 t),
      Dmap1 : (g |- map C1 M1)
    | x : [g |- cn-of (labeled X[] C1) t],
      map : [g |- map (labeled X[] C1) (eapp (econst (const/labeled X[])) M1)]
    ; by map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as Dof' unboxed;
      solve [g |- map-of/i _ tmap/t
        (eof/app (eof/const (ekof/i (ckof/labeled )
                            (etopen/pi etopen/t
                            etp-skel/t (\x. \xc. \y. etopen/t)))
                  (ewf/pi ewf/t (\x. \dx. ewf/t)))
        Dof')]
    }
  }
  case cn-of/rec:
  { g : map-bind+invert-bind-for-map-of,
    K1 : (g |- kind),
    C1 : (g, a20 : con, a19 : con |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (rec' K1 (\x255. \z255. C1) C2) M),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, z324 : cn-of a (pi (K1[..]) (\l. t)), b : con,
       y325 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
    Dof1 : (g |- cn-of C2 K1)
  | x : [g |- cn-of (rec' K1 (\x255. \z255. C1) C2) t],
    map : [g |- map (rec' K1 (\x255. \z255. C1) C2) M]
  ; split map as
    case map/rec:
    { g : map-bind+invert-bind-for-map-of,
      K1 : (g |- kind),
      C1 : (g, a20 : con, a19 : con |- con),
      C2 : (g |- con),
      Dskel : ( |- skel),
      M3 : (g |- eterm),
      A : (g |- etp),
      M1 : (g, x923 : eterm, y923 : eterm |- eterm),
      M2 : (g |- eterm),
      Dmap :
        (g |-
           map
             (rec' K1 (\x255. \z255. C1) C2)
             (eapp (econst (const/rec Dskel[]))
             (epair M3
             (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M1))) M2)))),
      Dwf : (g |- kd-wf K1),
      Dof :
        (g, a : con, z324 : cn-of a (pi (K1[..]) (\l. t)), b : con,
         y325 : cn-of b (K1[..]) |- cn-of (C1[.., a, b]) t),
      Dof1 : (g |- cn-of C2 K1),
      Dtmap : (g |- tmap K1 A),
      Dmap1 :
        (g, a : con, x : eterm, x922 : map a x, b : con, y : eterm,
         z922 : map b y |- map (C1[.., a, b]) (M1[.., x, y])),
      Dmap2 : (g |- map C2 M2),
      Dflay : (g |- flay A Dskel[] M3)
    | x : [g |- cn-of (rec' K1 (\z335. \y336. C1) C2) t],
      map :
        [g |-
           map
             (rec' K1 (\z335. \y336. C1) C2)
             (eapp (econst (const/rec Dskel[]))
             (epair M3
             (epair (elam (epi A (\x. et)) (\x. elam (A[..]) (\y. M1))) M2)))]
    ; by map-wf' [g |- Dwf] [g |- Dtmap] as DwfA unboxed;
      by map-of'
     [g,
      b1 :
        block (
          x : eterm,
          dx : evof x (A[..]),
          a : con,
          da : cn-of a _,
          at : map a x),
      b2 :
        block (
          y : eterm,
          dy : evof y (A[..]),
          b : con,
          db : cn-of b (K1[..]),
          bt : map b y) |- Dof[.., b1.3, b1.4, b2.3, b2.4]]
     [g,
      b1 :
        block (
          x : eterm,
          dx : evof x (A[..]),
          a : con,
          da : cn-of a _,
          at : map a x),
      b2 :
        block (
          y : eterm,
          dy : evof y (A[..]),
          b : con,
          db : cn-of b (K1[..]),
          bt : map b y) |- Dmap1[.., b1.3, b1.1, b1.5, b2.3, b2.1, b2.5]]
     [g,
      b1 :
        block (
          x : eterm,
          dx : evof x (A[..]),
          a : con,
          da : cn-of a _,
          at : map a x),
      b2 :
        block (
          y : eterm,
          dy : evof y (A[..]),
          b : con,
          db : cn-of b (K1[..]),
          bt : map b y) |- tmap/t]
as DofM1 unboxed;
      by map-of' [g |- Dof1] [g |- Dmap2] [g |- Dtmap] as DofM2 unboxed;
      ?
    }
  }
  case cn-of/tagged:
  { g : map-bind+invert-bind-for-map-of,
    M : (g |- eterm),
    Dmap : (g |- map tagged M)
  | x : [g |- cn-of tagged t], map : [g |- map tagged M]
  ; split map as
    case map/tagged:
    { g : map-bind+invert-bind-for-map-of,
      Dmap : (g |- map tagged (econst const/tagged))
    | x : [g |- cn-of tagged t],
      map : [g |- map tagged (econst const/tagged)]
    ; solve
        [g |-
           map-of/i _ tmap/t (eof/const (ekof/i ckof/tagged etopen/t) ewf/t)]
    }
  }
  case cn-of/tag:
  { g : map-bind+invert-bind-for-map-of,
    C1 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (tag C1) M),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (tag C1) t], map : [g |- map (tag C1) M]
  ; split map as
    case map/tag:
    { g : map-bind+invert-bind-for-map-of,
      C1 : (g |- con),
      M1 : (g |- eterm),
      Dmap : (g |- map (tag C1) (eapp (econst const/tag) M1)),
      Dof : (g |- cn-of C1 t),
      Dmap1 : (g |- map C1 M1)
    | x : [g |- cn-of (tag C1) t],
      map : [g |- map (tag C1) (eapp (econst const/tag) M1)]
    ; by map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as Dof' unboxed;
      solve
        [g |-
           map-of/i _
           tmap/t
           (eof/app (eof/const (ekof/i ckof/tag
                               (etopen/pi etopen/t
                               etp-skel/t (\x. \xc. \y. etopen/t)))
                    (ewf/pi ewf/t (\x. \dx. ewf/t)))
           Dof')]
    }
  }
  case cn-of/ref:
  { g : map-bind+invert-bind-for-map-of,
    C1 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (ref C1) M),
    Dof : (g |- cn-of C1 t)
  | x : [g |- cn-of (ref C1) t], map : [g |- map (ref C1) M]
  ; split map as
    case map/ref:
    { g : map-bind+invert-bind-for-map-of,
      C1 : (g |- con),
      M1 : (g |- eterm),
      Dmap : (g |- map (ref C1) (eapp (econst const/ref) M1)),
      Dof : (g |- cn-of C1 t),
      Dmap1 : (g |- map C1 M1)
    | x : [g |- cn-of (ref C1) t],
      map : [g |- map (ref C1) (eapp (econst const/ref) M1)]
    ; by map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as Dof' unboxed;
      solve
        [g |-
           map-of/i _
           tmap/t
           (eof/app (eof/const (ekof/i ckof/ref
                               (etopen/pi etopen/t
                               etp-skel/t (\x. \xc. \y. etopen/t)))
                    (ewf/pi ewf/t (\x. \dx. ewf/t)))
           Dof')]
    }
  }
  case cn-of/plus:
  { g : map-bind+invert-bind-for-map-of,
    C1 : (g |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (plus C1 C2) M),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (plus C1 C2) t], map : [g |- map (plus C1 C2) M]
  ; split map as
    case map/plus:
    { g : map-bind+invert-bind-for-map-of,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)),
      Dof : (g |- cn-of C1 t),
      Dof1 : (g |- cn-of C2 t),
      Dmap1 : (g |- map C1 M1),
      Dmap2 : (g |- map C2 M2)
    | x : [g |- cn-of (plus C1 C2) t],
      map : [g |- map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)]
    ; by map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as Dof1' unboxed;
      by map-of' [g |- Dof1] [g |- Dmap2] [g |- tmap/t] as Dof2' unboxed;
      solve
        [g |-
           map-of/i _
           tmap/t
           (eof/app (eof/app (eof/const (ekof/i ckof/plus
                                        (etopen/pi etopen/t
                                        etp-skel/t
                                        (\x.
                                           \xc.
                                             \y.
                                               etopen/pi etopen/t
                                               etp-skel/t
                                               (\x1. \xc1. \y1. etopen/t))))
                             (ewf/pi ewf/t
                             (\x. \dx. ewf/pi ewf/t (\x1. \dx1. ewf/t))))
                    Dof1')
           Dof2')]
    }
  }
  case cn-of/arrow:
  { g : map-bind+invert-bind-for-map-of,
    C1 : (g |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (arrow C1 C2) M),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (arrow C1 C2) t], map : [g |- map (arrow C1 C2) M]
  ; split map as
    case map/arrow:
    { g : map-bind+invert-bind-for-map-of,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap :
        (g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)),
      Dof : (g |- cn-of C1 t),
      Dof1 : (g |- cn-of C2 t),
      Dmap1 : (g |- map C1 M1),
      Dmap2 : (g |- map C2 M2)
    | x : [g |- cn-of (arrow C1 C2) t],
      map : [g |- map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)]
    ; by map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as Dof1' unboxed;
      by map-of' [g |- Dof1] [g |- Dmap2] [g |- tmap/t] as Dof2' unboxed;
      solve
        [g |-
           map-of/i _
           tmap/t
           (eof/app (eof/app (eof/const (ekof/i ckof/arrow
                                        (etopen/pi etopen/t
                                        etp-skel/t
                                        (\x.
                                           \xc.
                                             \y.
                                               etopen/pi etopen/t
                                               etp-skel/t
                                               (\x1. \xc1. \y1. etopen/t))))
                             (ewf/pi ewf/t
                             (\x. \dx. ewf/pi ewf/t (\x1. \dx1. ewf/t))))
                    Dof1')
           Dof2')]
    }
  }
  case cn-of/prod:
  { g : map-bind+invert-bind-for-map-of,
    C1 : (g |- con),
    C2 : (g |- con),
    M : (g |- eterm),
    Dmap : (g |- map (prod C1 C2) M),
    Dof : (g |- cn-of C1 t),
    Dof1 : (g |- cn-of C2 t)
  | x : [g |- cn-of (prod C1 C2) t], map : [g |- map (prod C1 C2) M]
  ; split map as
    case map/prod:
    { g : map-bind+invert-bind-for-map-of,
      C1 : (g |- con),
      C2 : (g |- con),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)),
      Dof : (g |- cn-of C1 t),
      Dof1 : (g |- cn-of C2 t),
      Dmap1 : (g |- map C1 M1),
      Dmap2 : (g |- map C2 M2)
    | x : [g |- cn-of (prod C1 C2) t],
      map : [g |- map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)]
    ; by map-of' [g |- Dof] [g |- Dmap1] [g |- tmap/t] as Dof1' unboxed;
      by map-of' [g |- Dof1] [g |- Dmap2] [g |- tmap/t] as Dof2' unboxed;
      solve
        [g |-
           map-of/i _
           tmap/t
           (eof/app (eof/app (eof/const (ekof/i ckof/prod
                                        (etopen/pi etopen/t
                                        etp-skel/t
                                        (\x.
                                           \xc.
                                             \y.
                                               etopen/pi etopen/t
                                               etp-skel/t
                                               (\x1. \xc1. \y1. etopen/t))))
                             (ewf/pi ewf/t
                             (\x. \dx. ewf/pi ewf/t (\x1. \dx1. ewf/t))))
                    Dof1')
           Dof2')]
    }
  }
  case cn-of/void:
  { g : map-bind+invert-bind-for-map-of,
    M : (g |- eterm),
    Dmap : (g |- map void M)
  | x : [g |- cn-of void t], map : [g |- map void M]
  ; split map as
    case map/void:
    { g : map-bind+invert-bind-for-map-of,
      Dmap : (g |- map void (econst const/void))
    | x : [g |- cn-of void t], map : [g |- map void (econst const/void)]
    ; solve
        [g |- map-of/i _ tmap/t (eof/const (ekof/i ckof/void etopen/t) ewf/t)]
    }
  }
  case cn-of/unit:
  { g : map-bind+invert-bind-for-map-of,
    M : (g |- eterm),
    Dmap : (g |- map unit M)
  | x : [g |- cn-of unit t], map : [g |- map unit M]
  ; split map as
    case map/unit:
    { g : map-bind+invert-bind-for-map-of,
      Dmap : (g |- map unit (econst const/unit))
    | x : [g |- cn-of unit t], map : [g |- map unit (econst const/unit)]
    ; solve
        [g |- map-of/i _ tmap/t (eof/const (ekof/i ckof/unit etopen/t) ewf/t)]
    }
  }
  case cn-of/star:
  { g : map-bind+invert-bind-for-map-of,
    M : (g |- eterm),
    Dmap : (g |- map star M)
  | x : [g |- cn-of star one], map : [g |- map star M]
  ; split map as
    case map/star:
    { g : map-bind+invert-bind-for-map-of, Dmap : (g |- map star estar)
    | x : [g |- cn-of star one], map : [g |- map star estar]
    ; solve [g |- map-of/i _ tmap/one eof/star]
    }
  }
  case cn-of/app:
  { g : map-bind+invert-bind-for-map-of,
    C2 : (g |- con),
    C1 : (g |- con),
    K2 : (g, a18 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map (app C2 C1) M),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of C2 (pi K1 (\x247. K2)))
  | x : [g |- cn-of (app C2 C1) (K2[.., C1])], map : [g |- map (app C2 C1) M]
  ; split map as
    case map/app:
    { g : map-bind+invert-bind-for-map-of,
      C2 : (g |- con),
      C1 : (g |- con),
      K2 : (g, a18 : con |- kind),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map (app C2 C1) (eapp M1 M2)),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 K1),
      Dof1 : (g |- cn-of C2 (pi K1 (\x247. K2))),
      Dmap1 : (g |- map C2 M1),
      Dmap2 : (g |- map C1 M2)
    | x : [g |- cn-of (app C2 C1) (K2[.., C1])],
      map : [g |- map (app C2 C1) (eapp M1 M2)]
    ; split map-of [g |- Dof1] [g |- Dmap1] as
      case map-of/i:
      { g : map-bind+invert-bind-for-map-of,
        C2 : (g |- con),
        C1 : (g |- con),
        K2 : (g, a18 : con |- kind),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        Dmap : (g |- map (app C2 C1) (eapp M1 M2)),
        K1 : (g |- kind),
        Dof : (g |- cn-of C1 K1),
        Dof1 : (g |- cn-of C2 (pi K1 (\x247. K2))),
        Dmap1 : (g |- map C2 M1),
        Dmap2 : (g |- map C1 M2),
        A : (g |- etp),
        Dtmap : (g |- tmap (pi K1 (\x247. K2)) A),
        Dof2 : (g |- eof M1 A)
      | x : [g |- cn-of (app C2 C1) (K2[.., C1])],
        map : [g |- map (app C2 C1) (eapp M1 M2)]
      ; split [g |- Dtmap] as
        case tmap/pi:
        { g : map-bind+invert-bind-for-map-of,
          C2 : (g |- con),
          C1 : (g |- con),
          K2 : (g, a18 : con |- kind),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          Dmap : (g |- map (app C2 C1) (eapp M1 M2)),
          K1 : (g |- kind),
          Dof : (g |- cn-of C1 K1),
          Dof1 : (g |- cn-of C2 (pi K1 (\x247. K2))),
          Dmap1 : (g |- map C2 M1),
          Dmap2 : (g |- map C1 M2),
          A1 : (g |- etp),
          A2 : (g, x925 : eterm |- etp),
          Dtmap1 : (g |- tmap K1 A1),
          Dtmap2 :
            (g, a : con, x : eterm, y925 : map a x |-
               tmap (K2[.., a]) (A2[.., x])),
          Dof2 : (g |- eof M1 (epi A1 (\y142. A2)))
        | x : [g |- cn-of (app C2 C1) (K2[.., C1])],
          map : [g |- map (app C2 C1) (eapp M1 M2)]
        ; by map-of' [g |- Dof] [g |- Dmap2] [g |- Dtmap1] as Dof2' unboxed;
          solve
            [g |- map-of/i _ (Dtmap2[.., C1, _, Dmap2]) (eof/app Dof2 Dof2')]
        }
      }
    }
  }
  case cn-of/lam:
  { g : map-bind+invert-bind-for-map-of,
    K1 : (g |- kind),
    C1 : (g, a16 : con |- con),
    K2 : (g, a17 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map (lam K1 (\z250. C1)) M),
    Dwf : (g |- kd-wf K1),
    Dof :
      (g, a : con, y320 : cn-of a (K1[..]) |- cn-of (C1[.., a]) (K2[.., a]))
  | x : [g |- cn-of (lam K1 (\z250. C1)) (pi K1 (\x247. K2))],
    map : [g |- map (lam K1 (\z250. C1)) M]
  ; split map as
    case map/lam:
    { g : map-bind+invert-bind-for-map-of,
      K1 : (g |- kind),
      C1 : (g, a16 : con |- con),
      K2 : (g, a17 : con |- kind),
      A : (g |- etp),
      M1 : (g, x917 : eterm |- eterm),
      Dmap : (g |- map (lam K1 (\z250. C1)) (elam A (\y146. M1))),
      Dwf : (g |- kd-wf K1),
      Dof :
        (g, a : con, y320 : cn-of a (K1[..]) |- cn-of (C1[.., a]) (K2[.., a])),
      Dtmap : (g |- tmap K1 A),
      Dmap1 :
        (g, a : con, x : eterm, y917 : map a x |- map (C1[.., a]) (M1[.., x]))
    | x : [g |- cn-of (lam K1 (\y331. C1)) (pi K1 (\z327. K2))],
      map : [g |- map (lam K1 (\y331. C1)) (elam A (\y146. M1))]
    ; split
map-of
  [g,
   b :
     block (
       x : eterm,
       dx : evof x (A[..]),
       a : con,
       da : cn-of a (K1[..]),
       at : map a x) |- Dof[.., b.3, b.4]]
  [g,
   b :
     block (
       x : eterm,
       dx : evof x (A[..]),
       a : con,
       da : cn-of a (K1[..]),
       at : map a x) |- Dmap1[.., b.3, b.1, b.5]] as
      case map-of/i:
      { g : map-bind+invert-bind-for-map-of,
        K1 : (g |- kind),
        C1 : (g, a16 : con |- con),
        K3 : (g, a : con |- kind),
        A : (g |- etp),
        M2 : (g, x : eterm |- eterm),
        Dmap : (g |- map (lam K1 (\z250. C1)) (elam A (\y146. M2))),
        Dwf : (g |- kd-wf K1),
        Dof :
          (g, a : con, y320 : cn-of a (K1[..]) |-
             cn-of (C1[.., a]) (K3[.., a])),
        Dtmap : (g |- tmap K1 A),
        Dmap1 :
          (g, a : con, x : eterm, y917 : map a x |-
             map (C1[.., a]) (M2[.., x])),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x1291 : map a x |-
             tmap (K3[.., a]) (A1[.., x])),
        Dof1 :
          (g, x : eterm, dx : evof x (A[..]) |- eof (M2[.., x]) (A1[.., x]))
      | x : [g |- cn-of (lam K1 (\y331. C1)) (pi K1 (\z327. K3))],
        map : [g |- map (lam K1 (\y331. C1)) (elam A (\y146. M2))]
      ; by [g |- tmap/pi Dtmap (\a. \x. \at. Dtmap1[.., x, a, at])] as Dtmap' unboxed;
        by map-wf' [g |- Dwf] [g |- Dtmap] as Dwf' unboxed;
        by [g |- eof/lam Dwf' (\x. \dx. Dof1)] as Dof' unboxed;
        solve [g |- map-of/i _ Dtmap' Dof']
      }
    }
  }
  case cn-of/pi2:
  { g : map-bind+invert-bind-for-map-of,
    C1 : (g |- con),
    K2 : (g, a15 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map (pi2 C1) M),
    K1 : (g |- kind),
    Dof : (g |- cn-of C1 (sigma K1 (\x248. K2)))
  | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])], map : [g |- map (pi2 C1) M]
  ; split map as
    case map/pi2:
    { g : map-bind+invert-bind-for-map-of,
      C1 : (g |- con),
      K2 : (g, a15 : con |- kind),
      M1 : (g |- eterm),
      Dmap : (g |- map (pi2 C1) (epi2 M1)),
      K1 : (g |- kind),
      Dof : (g |- cn-of C1 (sigma K1 (\x248. K2))),
      Dmap1 : (g |- map C1 M1)
    | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])],
      map : [g |- map (pi2 C1) (epi2 M1)]
    ; split map-of [g |- Dof] [g |- Dmap1] as
      case map-of/i:
      { g : map-bind+invert-bind-for-map-of,
        C1 : (g |- con),
        K2 : (g, a15 : con |- kind),
        M1 : (g |- eterm),
        Dmap : (g |- map (pi2 C1) (epi2 M1)),
        K1 : (g |- kind),
        Dof : (g |- cn-of C1 (sigma K1 (\x248. K2))),
        Dmap1 : (g |- map C1 M1),
        A : (g |- etp),
        Dtmap : (g |- tmap (sigma K1 (\x248. K2)) A),
        Dof1 : (g |- eof M1 A)
      | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])],
        map : [g |- map (pi2 C1) (epi2 M1)]
      ; split [g |- Dtmap] as
        case tmap/sigma:
        { g : map-bind+invert-bind-for-map-of,
          C1 : (g |- con),
          K2 : (g, a15 : con |- kind),
          M1 : (g |- eterm),
          Dmap : (g |- map (pi2 C1) (epi2 M1)),
          K1 : (g |- kind),
          Dof : (g |- cn-of C1 (sigma K1 (\x248. K2))),
          Dmap1 : (g |- map C1 M1),
          A1 : (g |- etp),
          A2 : (g, z926 : eterm |- etp),
          Dtmap1 : (g |- tmap K1 A1),
          Dtmap2 :
            (g, a : con, x : eterm, x926 : map a x |-
               tmap (K2[.., a]) (A2[.., x])),
          Dof1 : (g |- eof M1 (esigma A1 (\y143. A2)))
        | x : [g |- cn-of (pi2 C1) (K2[.., pi1 C1])],
          map : [g |- map (pi2 C1) (epi2 M1)]
        ; solve
            [g |- map-of/i _ (Dtmap2[.., _, _, map/pi1 Dmap1]) (eof/pi2 Dof1)]
        }
      }
    }
  }
  case cn-of/pi1:
  { g : map-bind+invert-bind-for-map-of,
    C1 : (g |- con),
    K : (g |- kind),
    M : (g |- eterm),
    Dmap : (g |- map (pi1 C1) M),
    K2 : (g, a14 : con |- kind),
    Dof : (g |- cn-of C1 (sigma K (\x248. K2)))
  | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) M]
  ; split map as
    case map/pi1:
    { g : map-bind+invert-bind-for-map-of,
      C1 : (g |- con),
      K : (g |- kind),
      M1 : (g |- eterm),
      Dmap : (g |- map (pi1 C1) (epi1 M1)),
      K2 : (g, a14 : con |- kind),
      Dof : (g |- cn-of C1 (sigma K (\x248. K2))),
      Dmap1 : (g |- map C1 M1)
    | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) (epi1 M1)]
    ; split map-of [g |- Dof] [g |- Dmap1] as
      case map-of/i:
      { g : map-bind+invert-bind-for-map-of,
        C1 : (g |- con),
        K : (g |- kind),
        M1 : (g |- eterm),
        Dmap : (g |- map (pi1 C1) (epi1 M1)),
        K2 : (g, a14 : con |- kind),
        Dof : (g |- cn-of C1 (sigma K (\x248. K2))),
        Dmap1 : (g |- map C1 M1),
        A : (g |- etp),
        Dtmap : (g |- tmap (sigma K (\x248. K2)) A),
        Dof1 : (g |- eof M1 A)
      | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) (epi1 M1)]
      ; split [g |- Dtmap] as
        case tmap/sigma:
        { g : map-bind+invert-bind-for-map-of,
          C1 : (g |- con),
          K : (g |- kind),
          M1 : (g |- eterm),
          Dmap : (g |- map (pi1 C1) (epi1 M1)),
          K2 : (g, a14 : con |- kind),
          Dof : (g |- cn-of C1 (sigma K (\x248. K2))),
          Dmap1 : (g |- map C1 M1),
          A1 : (g |- etp),
          A2 : (g, z926 : eterm |- etp),
          Dtmap1 : (g |- tmap K A1),
          Dtmap2 :
            (g, a : con, x : eterm, x926 : map a x |-
               tmap (K2[.., a]) (A2[.., x])),
          Dof1 : (g |- eof M1 (esigma A1 (\y143. A2)))
        | x : [g |- cn-of (pi1 C1) K], map : [g |- map (pi1 C1) (epi1 M1)]
        ; solve [g |- map-of/i _ Dtmap1 (eof/pi1 Dof1)]
        }
      }
    }
  }
  case cn-of/pair:
  { g : map-bind+invert-bind-for-map-of,
    C1 : (g |- con),
    C2 : (g |- con),
    K1 : (g |- kind),
    K2 : (g, a13 : con |- kind),
    M : (g |- eterm),
    Dmap : (g |- map (pair C1 C2) M),
    Dof : (g |- cn-of C1 K1),
    Dof1 : (g |- cn-of C2 (K2[.., C1])),
    Dwf : (g, a : con, x318 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- cn-of (pair C1 C2) (sigma K1 (\x248. K2))],
    map : [g |- map (pair C1 C2) M]
  ; split map as
    case map/pair:
    { g : map-bind+invert-bind-for-map-of,
      C1 : (g |- con),
      C2 : (g |- con),
      K1 : (g |- kind),
      K2 : (g, a13 : con |- kind),
      M1 : (g |- eterm),
      M2 : (g |- eterm),
      Dmap : (g |- map (pair C1 C2) (epair M1 M2)),
      Dof : (g |- cn-of C1 K1),
      Dof1 : (g |- cn-of C2 (K2[.., C1])),
      Dwf : (g, a : con, x318 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      Dmap1 : (g |- map C1 M1),
      Dmap2 : (g |- map C2 M2)
    | x : [g |- cn-of (pair C1 C2) (sigma K1 (\z328. K2))],
      map : [g |- map (pair C1 C2) (epair M1 M2)]
    ; split map-of [g |- Dof] [g |- Dmap1] as
      case map-of/i:
      { g : map-bind+invert-bind-for-map-of,
        C1 : (g |- con),
        C2 : (g |- con),
        K1 : (g |- kind),
        K2 : (g, a13 : con |- kind),
        M1 : (g |- eterm),
        M2 : (g |- eterm),
        Dmap : (g |- map (pair C1 C2) (epair M1 M2)),
        Dof : (g |- cn-of C1 K1),
        Dof1 : (g |- cn-of C2 (K2[.., C1])),
        Dwf : (g, a : con, x318 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
        Dmap1 : (g |- map C1 M1),
        Dmap2 : (g |- map C2 M2),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        Dof2 : (g |- eof M1 A)
      | x : [g |- cn-of (pair C1 C2) (sigma K1 (\z328. K2))],
        map : [g |- map (pair C1 C2) (epair M1 M2)]
      ; split
        map-wf
          [g,
           b :
             block (
               x : eterm,
               dx : evof x (A[..]),
               a : con,
               da : cn-of a (K1[..]),
               at : map a x) |- Dwf[.., b.3, b.4]] as
        case map-wf/i:
        { g : map-bind+invert-bind-for-map-of,
          C1 : (g |- con),
          C2 : (g |- con),
          K1 : (g |- kind),
          K3 : (g, a : con |- kind),
          M1 : (g |- eterm),
          M2 : (g |- eterm),
          Dmap : (g |- map (pair C1 C2) (epair M1 M2)),
          Dof : (g |- cn-of C1 K1),
          Dof1 : (g |- cn-of C2 (K3[.., C1])),
          Dwf : (g, a : con, x318 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
          Dmap1 : (g |- map C1 M1),
          Dmap2 : (g |- map C2 M2),
          A : (g |- etp),
          Dtmap : (g |- tmap K1 A),
          Dof2 : (g |- eof M1 A),
          A1 : (g, x : eterm |- etp),
          Dtmap1 :
            (g, x : eterm, a : con, y5 : map a x |-
               tmap (K3[.., a]) (A1[.., x])),
          Dwf1 : (g, x : eterm, dx : evof x (A[..]) |- ewf (A1[.., x]))
        | x : [g |- cn-of (pair C1 C2) (sigma K1 (\z328. K3))],
          map : [g |- map (pair C1 C2) (epair M1 M2)]
        ; by map-of' [g |- Dof1] [g |- Dmap2] [g |- Dtmap1[.., _, _, Dmap1]]
          as Dof2' unboxed;
          by [g |- tmap/sigma Dtmap (\a. \x. \at. Dtmap1[.., x, a, at])]
as Dtmap' unboxed;
          by [g |- eof/pair Dof2 Dof2' (\x. \dx. Dwf1)] as Dof' unboxed;
          solve [g |- map-of/i _ Dtmap' Dof']
        }
      }
    }
  }
  %{ FIXME: Type-checking error
  case #.2:
  { g : map-bind+invert-bind-for-map-of,
    K : (g |- kind),
    A57 : (g |- etp),
    #unmap :
      #(g |-
          block (
            a : con,
            da : cn-of a (K[..]),
            x : eterm,
            dx : evof x (A57[..]),
            at : map a x,
            xt : unmap x a)),
    M : (g |- eterm),
    Dmap : (g |- map #unmap.1 M),
    K452 : (g |- kind),
    Dtmap18 : (g |- tmap K A57),
    Dtunmap : (g |- tunmap A57 K452),
    Dwf61 : (g |- kd-wf K),
    Dwf : (g |- ewf A57),
    Dequiv37 : (g |- kd-equiv K K452)
  | x : [g |- cn-of #unmap.1 K], map : [g |- map #unmap.1 M]
  ; ?
  }
  case #.4:
  { g : map-bind+invert-bind-for-map-of,
    A58 : (g |- etp),
    K : (g |- kind),
    #map :
      #(g |-
          block (
            x : eterm,
            dx : evof x (A58[..]),
            a : con,
            da : cn-of a (K[..]),
            at : map a x)),
    M : (g |- eterm),
    Dmap : (g |- map #map.3 M),
    Dtmap19 : (g |- tmap K A58),
    Dwf1 : (g |- ewf A58)
  | x : [g |- cn-of #map.3 K], map : [g |- map #map.3 M]
  ; ?
  }
  }%
}

and proof map-of' :
  (g : map-bind+invert-bind-for-map-of)
  [g |- cn-of C K] ->
  [g |- map C M] ->
  [g |- tmap K A] ->
    [g |- eof M A] =
/ trust / % FIXME: See issue #4
intros
{ g : map-bind+invert-bind-for-map-of,
  C : (g |- con),
  K : (g |- kind),
  M : (g |- eterm),
  A : (g |- etp)
| x : [g |- cn-of C K], map : [g |- map C M], tmap : [g |- tmap K A]
; by x as Dof unboxed;
  by map as Dmap unboxed;
  by tmap as DmapA unboxed;
  split map-of [_ |- Dof] [_ |- Dmap] as
  case map-of/i:
  { g : map-bind+invert-bind-for-map-of,
    C : (g |- con),
    K : (g |- kind),
    M : (g |- eterm),
    A : (g |- etp),
    Dof : (g |- cn-of C K),
    Dmap : (g |- map C M),
    DmapA : (g |- tmap K A),
    A1 : (g |- etp),
    Dtmap : (g |- tmap K A1),
    Dof1 : (g |- eof M A1)
  | x : [g |- cn-of C K], map : [g |- map C M], tmap : [g |- tmap K A]
  ; by tmap-fun [_ |- Dtmap] [_ |- DmapA] as Deq unboxed;
    split [_ |- Deq] as
    case etp-eq/i:
    { g : map-bind+invert-bind-for-map-of,
      C : (g |- con),
      K : (g |- kind),
      M : (g |- eterm),
      A : (g |- etp),
      Dof : (g |- cn-of C K),
      Dmap : (g |- map C M),
      DmapA : (g |- tmap K A),
      DmapA' : (g |- tmap K A),
      Dof' : (g |- eof M A)
    | x : [g |- cn-of C K], map : [g |- map C M], tmap : [g |- tmap K A]
    ; solve [_ |- Dof']
    }
  }
}

and proof map-wf :
  (g : map-bind+invert-bind-for-map-of)
  [g |- kd-wf K] ->
    [g |- map-wf/e K] =
/ trust / % FIXME: See issue #4
intros
{ g : map-bind+invert-bind-for-map-of, K : (g |- kind)
| x : [g |- kd-wf K]
; split x as
  case kd-wf/one:
  { g : map-bind+invert-bind-for-map-of
  | x : [g |- kd-wf one]
  ; solve [_ |- map-wf/i _ tmap/one ewf/one]
  }
  case kd-wf/sigma:
  { g : map-bind+invert-bind-for-map-of,
    K1 : (g |- kind),
    K2 : (g, a4 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, y389 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (sigma K1 (\z328. K2))]
  ; split map-wf [g |- Dwf] as
    case map-wf/i:
    { g : map-bind+invert-bind-for-map-of,
      K1 : (g |- kind),
      K2 : (g, a4 : con |- kind),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, y389 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A),
      Dwf2 : (g |- ewf A)
    | x : [g |- kd-wf (sigma K1 (\z328. K2))]
    ; split
      map-wf
        [g,
         b :
           block (
             x : eterm,
             dx : evof x (A[..]),
             a : con,
             da : cn-of a (K1[..]),
             at : map a x) |- Dwf1[.., b.3, b.4]] as
      case map-wf/i:
      { g : map-bind+invert-bind-for-map-of,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g, a : con, y389 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        Dwf2 : (g |- ewf A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, z1268 : map a x |-
             tmap (K3[.., a]) (A1[.., x])),
        Dwf3 : (g, x : eterm, dx : evof x (A[..]) |- ewf (A1[.., x]))
      | x : [g |- kd-wf (sigma K1 (\z328. K3))]
      ; by [g |- tmap/sigma Dtmap (\a. \x. \at. Dtmap1[.., x, a, at])]
as Dtmap' unboxed;
        by [g |- ewf/sigma Dwf2 (\x. \dx. Dwf3)] as Dwf' unboxed;
        solve [g |- map-wf/i _ Dtmap' Dwf']
      }
    }
  }
  case kd-wf/pi:
  { g : map-bind+invert-bind-for-map-of,
    K1 : (g |- kind),
    K2 : (g, a3 : con |- kind),
    Dwf : (g |- kd-wf K1),
    Dwf1 : (g, a : con, y388 : cn-of a (K1[..]) |- kd-wf (K2[.., a]))
  | x : [g |- kd-wf (pi K1 (\z327. K2))]
  ; split map-wf [g |- Dwf] as
    case map-wf/i:
    { g : map-bind+invert-bind-for-map-of,
      K1 : (g |- kind),
      K2 : (g, a3 : con |- kind),
      Dwf : (g |- kd-wf K1),
      Dwf1 : (g, a : con, y388 : cn-of a (K1[..]) |- kd-wf (K2[.., a])),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A),
      Dwf2 : (g |- ewf A)
    | x : [g |- kd-wf (pi K1 (\x363. K2))]
    ; split
      map-wf
        [g,
         b :
           block (
             x : eterm,
             dx : evof x (A[..]),
             a : con,
             da : cn-of a (K1[..]),
             at : map a x) |- Dwf1[.., b.3, b.4]] as
      case map-wf/i:
      { g : map-bind+invert-bind-for-map-of,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        Dwf : (g |- kd-wf K1),
        Dwf1 : (g, a : con, y388 : cn-of a (K1[..]) |- kd-wf (K3[.., a])),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        Dwf2 : (g |- ewf A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, x1333 : map a x |-
             tmap (K3[.., a]) (A1[.., x])),
        Dwf3 : (g, x : eterm, dx : evof x (A[..]) |- ewf (A1[.., x]))
      | x : [g |- kd-wf (pi K1 (\x363. K3))]
      ; by [g |- tmap/pi Dtmap (\a. \x. \at. Dtmap1[.., x, a, at])]
        as Dtmap' unboxed;
        by [g |- ewf/pi Dwf2 (\x. \dx. Dwf3)] as Dwf' unboxed;
        solve [g |- map-wf/i _ Dtmap' Dwf']
      }
    }
  }
  case kd-wf/sing:
  { g : map-bind+invert-bind-for-map-of,
    C : (g |- con),
    Dof : (g |- cn-of C t)
  | x : [g |- kd-wf (sing C)]
  ; split can-map [g |- C] as
    case can-map/i:
    { g : map-bind+invert-bind-for-map-of,
      C : (g |- con),
      Dof : (g |- cn-of C t),
      M : (g |- eterm),
      Dmap : (g |- map C M)
    | x : [g |- kd-wf (sing C)]
    ; by map-of' [g |- Dof] [g |- Dmap] [g |- tmap/t] as Dof' unboxed;
      solve [g |- map-wf/i _ (tmap/sing Dmap) (ewf/sing Dof')]
    }
  }
  case kd-wf/t:
  { g : map-bind+invert-bind-for-map-of
  | x : [g |- kd-wf t]
  ; solve [g |- map-wf/i _ tmap/t ewf/t]
  }
}

and proof map-wf' :
  (g : map-bind+invert-bind-for-map-of)
  [g |- kd-wf K] ->
  [g |- tmap K A] ->
    [g |- ewf A] =
/ trust / % FIXME: See issue #4
intros
{ g : map-bind+invert-bind-for-map-of, K : (g |- kind), A : (g |- etp)
| x : [g |- kd-wf K], tmap : [g |- tmap K A]
; by x as Dwf unboxed;
  by tmap as Dmap unboxed;
  split map-wf [_ |- Dwf] as
  case map-wf/i:
  { g : map-bind+invert-bind-for-map-of,
    K : (g |- kind),
    A : (g |- etp),
    Dwf : (g |- kd-wf K),
    Dmap : (g |- tmap K A),
    A1 : (g |- etp),
    Dtmap : (g |- tmap K A1),
    Dwf1 : (g |- ewf A1)
  | x : [g |- kd-wf K], tmap : [g |- tmap K A]
  ; split tmap-fun [_ |- Dmap] [_ |- Dtmap] as
    case etp-eq/i:
    { g : map-bind+invert-bind-for-map-of,
      K : (g |- kind),
      A' : (g |- etp),
      Dwf : (g |- kd-wf K),
      Dmap : (g |- tmap K A'),
      Dmap' : (g |- tmap K A'),
      Dwf' : (g |- ewf A')
    | x : [g |- kd-wf K], tmap : [g |- tmap K A']
    ; solve [_ |- Dwf']
    }
  }
}

and proof map-subtp :
  (g : map-bind+invert-bind-for-map-of)
  [g |- kd-sub K L] ->
  [g |- tmap K A] ->
  [g |- tmap L B] ->
    [g |- subtp A B] =
/ trust / % FIXME: See issue #4
intros
{ g : map-bind+invert-bind-for-map-of,
  K : (g |- kind),
  L : (g |- kind),
  A : (g |- etp),
  B : (g |- etp)
| sub : [g |- kd-sub K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
; split sub as
  case kd-sub/sigma:
  { g : map-bind+invert-bind-for-map-of,
    K1 : (g |- kind),
    K3 : (g, a11 : con |- kind),
    K2 : (g |- kind),
    K4 : (g, a12 : con |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dsub : (g |- kd-sub K1 K2),
    Dsub1 :
      (g, a : con, y433 : cn-of a (K1[..]) |- kd-sub (K3[.., a]) (K4[.., a])),
    Dwf : (g, a : con, z432 : cn-of a (K2[..]) |- kd-wf (K4[.., a]))
  | sub : [g |- kd-sub (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
    tmap : [g |- tmap (sigma K1 (\x364. K3)) A],
    tmap1 : [g |- tmap (sigma K2 (\x364. K4)) B]
  ; split tmap as
    case tmap/sigma:
    { g : map-bind+invert-bind-for-map-of,
      K1 : (g |- kind),
      K3 : (g, a11 : con |- kind),
      K2 : (g |- kind),
      K4 : (g, a12 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, x962 : eterm |- etp),
      B : (g |- etp),
      Dsub : (g |- kd-sub K1 K2),
      Dsub1 :
        (g, a : con, y433 : cn-of a (K1[..]) |-
           kd-sub (K3[.., a]) (K4[.., a])),
      Dwf : (g, a : con, z432 : cn-of a (K2[..]) |- kd-wf (K4[.., a])),
      Dtmap : (g |- tmap K1 A1),
      Dtmap1 :
        (g, a : con, x : eterm, y962 : map a x |-
           tmap (K3[.., a]) (A2[.., x]))
    | sub : [g |- kd-sub (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
      tmap : [g |- tmap (sigma K1 (\x364. K3)) (esigma A1 (\y149. A2))],
      tmap1 : [g |- tmap (sigma K2 (\x364. K4)) B]
    ; split tmap1 as
      case tmap/sigma:
      { g : map-bind+invert-bind-for-map-of,
        K1 : (g |- kind),
        K3 : (g, a11 : con |- kind),
        K2 : (g |- kind),
        K4 : (g, a12 : con |- kind),
        A1 : (g |- etp),
        A2 : (g, x962 : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, x962 : eterm |- etp),
        Dsub : (g |- kd-sub K1 K2),
        Dsub1 :
          (g, a : con, y433 : cn-of a (K1[..]) |-
             kd-sub (K3[.., a]) (K4[.., a])),
        Dwf : (g, a : con, z432 : cn-of a (K2[..]) |- kd-wf (K4[.., a])),
        Dtmap : (g |- tmap K1 A1),
        Dtmap1 :
          (g, a : con, x : eterm, y962 : map a x |-
             tmap (K3[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K2 A3),
        Dtmap3 :
          (g, a : con, x : eterm, y962 : map a x |-
             tmap (K4[.., a]) (A4[.., x]))
      | sub : [g |- kd-sub (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
        tmap : [g |- tmap (sigma K1 (\x364. K3)) (esigma A1 (\y149. A2))],
        tmap1 : [g |- tmap (sigma K2 (\x364. K4)) (esigma A3 (\y149. A4))]
      ; by map-subtp [g |- Dsub] [g |- Dtmap] [g |- Dtmap2] as Dsub1' unboxed;
        by map-subtp
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dsub1[.., b.3, b.4]]
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dtmap3[.., b.3, b.1, b.5]]
        as Dsub2' unboxed;
        by map-wf'
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K2[..]),
                  at : map a x) |- Dwf[.., b.3, b.4]]
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K2[..]),
                  at : map a x) |- Dtmap3[.., b.3, b.1, b.5]]
        as Dwf' unboxed;
        solve [g |-
              subtp/sigma Dsub1'
              (\x. \dx. Dsub2'[.., <x; dx; _; _; _>])
              (\x. \dx. Dwf'[.., <x; dx; _; _; _>])]
      }
    }
  }
  case kd-sub/pi:
  { g : map-bind+invert-bind-for-map-of,
    K2 : (g |- kind),
    K3 : (g, a9 : con |- kind),
    K1 : (g |- kind),
    K4 : (g, a10 : con |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dsub : (g |- kd-sub K1 K2),
    Dsub1 :
      (g, a : con, x431 : cn-of a (K1[..]) |- kd-sub (K3[.., a]) (K4[.., a])),
    Dwf : (g, a : con, y431 : cn-of a (K2[..]) |- kd-wf (K3[.., a]))
  | sub : [g |- kd-sub (pi K2 (\x363. K3)) (pi K1 (\x363. K4))],
    tmap : [g |- tmap (pi K2 (\x363. K3)) A],
    tmap1 : [g |- tmap (pi K1 (\x363. K4)) B]
  ; split tmap as
    case tmap/pi:
    { g : map-bind+invert-bind-for-map-of,
      K2 : (g |- kind),
      K3 : (g, a9 : con |- kind),
      K1 : (g |- kind),
      K4 : (g, a10 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, y961 : eterm |- etp),
      B : (g |- etp),
      Dsub : (g |- kd-sub K1 K2),
      Dsub1 :
        (g, a : con, x431 : cn-of a (K1[..]) |-
           kd-sub (K3[.., a]) (K4[.., a])),
      Dwf : (g, a : con, y431 : cn-of a (K2[..]) |- kd-wf (K3[.., a])),
      Dtmap : (g |- tmap K2 A1),
      Dtmap1 :
        (g, a : con, x : eterm, z960 : map a x |-
           tmap (K3[.., a]) (A2[.., x]))
    | sub : [g |- kd-sub (pi K2 (\x363. K3)) (pi K1 (\x363. K4))],
      tmap : [g |- tmap (pi K2 (\x363. K3)) (epi A1 (\y148. A2))],
      tmap1 : [g |- tmap (pi K1 (\x363. K4)) B]
    ; split tmap1 as
      case tmap/pi:
      { g : map-bind+invert-bind-for-map-of,
        K2 : (g |- kind),
        K3 : (g, a9 : con |- kind),
        K1 : (g |- kind),
        K4 : (g, a10 : con |- kind),
        A1 : (g |- etp),
        A2 : (g, y961 : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, y961 : eterm |- etp),
        Dsub : (g |- kd-sub K1 K2),
        Dsub1 :
          (g, a : con, x431 : cn-of a (K1[..]) |-
             kd-sub (K3[.., a]) (K4[.., a])),
        Dwf : (g, a : con, y431 : cn-of a (K2[..]) |- kd-wf (K3[.., a])),
        Dtmap : (g |- tmap K2 A1),
        Dtmap1 :
          (g, a : con, x : eterm, z960 : map a x |-
             tmap (K3[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K1 A3),
        Dtmap3 :
          (g, a : con, x : eterm, z960 : map a x |-
             tmap (K4[.., a]) (A4[.., x]))
      | sub : [g |- kd-sub (pi K2 (\x363. K3)) (pi K1 (\x363. K4))],
        tmap : [g |- tmap (pi K2 (\x363. K3)) (epi A1 (\y148. A2))],
        tmap1 : [g |- tmap (pi K1 (\x363. K4)) (epi A3 (\y148. A4))]
      ; by map-subtp [g |- Dsub] [g |- Dtmap2] [g |- Dtmap] as Dsub1' unboxed;
        by map-subtp
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dsub1[.., b.3, b.4]]
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dtmap3[.., b.3, b.1, b.5]]
        as Dsub2' unboxed;
        by map-wf'
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K2[..]),
                  at : map a x) |- Dwf[.., b.3, b.4]]
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K2[..]),
                  at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
        as Dwf' unboxed;
        solve [g |-
              subtp/pi Dsub1'
              (\x. \dx. Dsub2'[.., <x; dx; _; _; _>])
              (\x. \dx. Dwf'[.., <x; dx; _; _; _>])]
      }
    }
  }
  case kd-sub/sing-t:
  { g : map-bind+invert-bind-for-map-of,
    C : (g |- con),
    A : (g |- etp),
    B : (g |- etp),
    Dof : (g |- cn-of C t)
  | sub : [g |- kd-sub (sing C) t],
    tmap : [g |- tmap (sing C) A],
    tmap1 : [g |- tmap t B]
  ; split tmap as
    case tmap/sing:
    { g : map-bind+invert-bind-for-map-of,
      C : (g |- con),
      M : (g |- eterm),
      B : (g |- etp),
      Dof : (g |- cn-of C t),
      Dmap : (g |- map C M)
    | sub : [g |- kd-sub (sing C) t],
      tmap : [g |- tmap (sing C) (esing M)],
      tmap1 : [g |- tmap t B]
    ; split tmap1 as
      case tmap/t:
      { g : map-bind+invert-bind-for-map-of,
        C : (g |- con),
        M : (g |- eterm),
        Dof : (g |- cn-of C t),
        Dmap : (g |- map C M)
      | sub : [g |- kd-sub (sing C) t],
        tmap : [g |- tmap (sing C) (esing M)],
        tmap1 : [g |- tmap t et]
      ; by map-of' [g |- Dof] [g |- Dmap] [g |- tmap/t] as Dof' unboxed;
        solve [g |- subtp/sing_t Dof']
      }
    }
  }
  case kd-sub/trans:
  { g : map-bind+invert-bind-for-map-of,
    K : (g |- kind),
    L : (g |- kind),
    A : (g |- etp),
    B : (g |- etp),
    K2 : (g |- kind),
    Dsub : (g |- kd-sub K K2),
    Dsub1 : (g |- kd-sub K2 L)
  | sub : [g |- kd-sub K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
  ; by tmap as DmapA unboxed;
    by tmap1 as DmapC unboxed;
    split can-tmap [g |- K2] as
    case can-tmap/i:
    { g : map-bind+invert-bind-for-map-of,
      K : (g |- kind),
      K'' : (g |- kind),
      A : (g |- etp),
      C : (g |- etp),
      K' : (g |- kind),
      DsubAB : (g |- kd-sub K K'),
      DsubBC : (g |- kd-sub K' K''),
      DmapA : (g |- tmap K A),
      DmapC : (g |- tmap K'' C),
      A1 : (g |- etp),
      Dtmap : (g |- tmap K' A1)
    | sub : [g |- kd-sub K K''],
      tmap : [g |- tmap K A],
      tmap1 : [g |- tmap K'' C]
    ; by map-subtp [g |- DsubAB] [g |- DmapA] [g |- Dtmap] as DsubAB' unboxed;
      by map-subtp [g |- DsubBC] [g |- Dtmap] [g |- DmapC] as DsubBC' unboxed;
      solve [g |- subtp/trans DsubAB' DsubBC']
    }
  }
  case kd-sub/refl:
  { g : map-bind+invert-bind-for-map-of,
    K : (g |- kind),
    L : (g |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dequiv : (g |- kd-equiv K L)
  | sub : [g |- kd-sub K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
  ; by tmap as DmapA unboxed;
    by tmap1 as DmapB unboxed;
    by map-tequiv [g |- Dequiv] [g |- DmapA] [g |- DmapB] as Dequiv' unboxed;
    solve [g |- subtp/reflex Dequiv']
  }
}

and proof map-tequiv :
  (g : map-bind+invert-bind-for-map-of)
  [g |- kd-equiv K L] ->
  [g |- tmap K A] ->
  [g |- tmap L B] ->
    [g |- tequiv A B] =
/ trust / % FIXME: See issue #4
intros
{ g : map-bind+invert-bind-for-map-of,
  K : (g |- kind),
  L : (g |- kind),
  A : (g |- etp),
  B : (g |- etp)
| x : [g |- kd-equiv K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
; split x as
  case kd-equiv/sigma:
  { g : map-bind+invert-bind-for-map-of,
    K1 : (g |- kind),
    K3 : (g, a7 : con |- kind),
    K2 : (g |- kind),
    K4 : (g, a8 : con |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, x428 : cn-of a (K1[..]) |-
         kd-equiv (K3[.., a]) (K4[.., a]))
  | x : [g |- kd-equiv (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
    tmap : [g |- tmap (sigma K1 (\x364. K3)) A],
    tmap1 : [g |- tmap (sigma K2 (\x364. K4)) B]
  ; split tmap as
    case tmap/sigma:
    { g : map-bind+invert-bind-for-map-of,
      K1 : (g |- kind),
      K3 : (g, a7 : con |- kind),
      K2 : (g |- kind),
      K4 : (g, a8 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, x962 : eterm |- etp),
      B : (g |- etp),
      Dequiv : (g |- kd-equiv K1 K2),
      Dequiv1 :
        (g, a : con, x428 : cn-of a (K1[..]) |-
           kd-equiv (K3[.., a]) (K4[.., a])),
      Dtmap : (g |- tmap K1 A1),
      Dtmap1 :
        (g, a : con, x : eterm, y962 : map a x |-
           tmap (K3[.., a]) (A2[.., x]))
    | x : [g |- kd-equiv (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
      tmap : [g |- tmap (sigma K1 (\x364. K3)) (esigma A1 (\y149. A2))],
      tmap1 : [g |- tmap (sigma K2 (\x364. K4)) B]
    ; split tmap1 as
      case tmap/sigma:
      { g : map-bind+invert-bind-for-map-of,
        K1 : (g |- kind),
        K3 : (g, a7 : con |- kind),
        K2 : (g |- kind),
        K4 : (g, a8 : con |- kind),
        A1 : (g |- etp),
        A2 : (g, x962 : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, x962 : eterm |- etp),
        Dequiv : (g |- kd-equiv K1 K2),
        Dequiv1 :
          (g, a : con, x428 : cn-of a (K1[..]) |-
             kd-equiv (K3[.., a]) (K4[.., a])),
        Dtmap : (g |- tmap K1 A1),
        Dtmap1 :
          (g, a : con, x : eterm, y962 : map a x |-
             tmap (K3[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K2 A3),
        Dtmap3 :
          (g, a : con, x : eterm, y962 : map a x |-
             tmap (K4[.., a]) (A4[.., x]))
      | x : [g |- kd-equiv (sigma K1 (\x364. K3)) (sigma K2 (\x364. K4))],
        tmap : [g |- tmap (sigma K1 (\x364. K3)) (esigma A1 (\y149. A2))],
        tmap1 : [g |- tmap (sigma K2 (\x364. K4)) (esigma A3 (\y149. A4))]
      ; by map-tequiv [_ |- Dequiv] [_ |- Dtmap] [_ |- Dtmap2]
        as Dequiv1' unboxed;
        by map-tequiv
             [_,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dequiv1[.., b.3, b.4]]
             [_,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
             [_,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dtmap3[.., b.3, b.1, b.5]]
        as Dequiv2' unboxed;
        solve [_ |-
              tequiv/sigma Dequiv1' (\x. \dx. Dequiv2'[.., <x; dx; _; _; _>])]
      }
    }
  }
  case kd-equiv/pi:
  { g : map-bind+invert-bind-for-map-of,
    K1 : (g |- kind),
    K3 : (g, a5 : con |- kind),
    K2 : (g |- kind),
    K4 : (g, a6 : con |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dequiv : (g |- kd-equiv K1 K2),
    Dequiv1 :
      (g, a : con, x427 : cn-of a (K1[..]) |-
         kd-equiv (K3[.., a]) (K4[.., a]))
  | x : [g |- kd-equiv (pi K1 (\x363. K3)) (pi K2 (\x363. K4))],
    tmap : [g |- tmap (pi K1 (\x363. K3)) A],
    tmap1 : [g |- tmap (pi K2 (\x363. K4)) B]
  ; split tmap as
    case tmap/pi:
    { g : map-bind+invert-bind-for-map-of,
      K1 : (g |- kind),
      K3 : (g, a5 : con |- kind),
      K2 : (g |- kind),
      K4 : (g, a6 : con |- kind),
      A1 : (g |- etp),
      A2 : (g, y961 : eterm |- etp),
      B : (g |- etp),
      Dequiv : (g |- kd-equiv K1 K2),
      Dequiv1 :
        (g, a : con, x427 : cn-of a (K1[..]) |-
           kd-equiv (K3[.., a]) (K4[.., a])),
      Dtmap : (g |- tmap K1 A1),
      Dtmap1 :
        (g, a : con, x : eterm, z960 : map a x |-
           tmap (K3[.., a]) (A2[.., x]))
    | x : [g |- kd-equiv (pi K1 (\x363. K3)) (pi K2 (\x363. K4))],
      tmap : [g |- tmap (pi K1 (\x363. K3)) (epi A1 (\y148. A2))],
      tmap1 : [g |- tmap (pi K2 (\x363. K4)) B]
    ; split tmap1 as
      case tmap/pi:
      { g : map-bind+invert-bind-for-map-of,
        K1 : (g |- kind),
        K3 : (g, a5 : con |- kind),
        K2 : (g |- kind),
        K4 : (g, a6 : con |- kind),
        A1 : (g |- etp),
        A2 : (g, y961 : eterm |- etp),
        A3 : (g |- etp),
        A4 : (g, y961 : eterm |- etp),
        Dequiv : (g |- kd-equiv K1 K2),
        Dequiv1 :
          (g, a : con, x427 : cn-of a (K1[..]) |-
             kd-equiv (K3[.., a]) (K4[.., a])),
        Dtmap : (g |- tmap K1 A1),
        Dtmap1 :
          (g, a : con, x : eterm, z960 : map a x |-
             tmap (K3[.., a]) (A2[.., x])),
        Dtmap2 : (g |- tmap K2 A3),
        Dtmap3 :
          (g, a : con, x : eterm, z960 : map a x |-
             tmap (K4[.., a]) (A4[.., x]))
      | x : [g |- kd-equiv (pi K1 (\x363. K3)) (pi K2 (\x363. K4))],
        tmap : [g |- tmap (pi K1 (\x363. K3)) (epi A1 (\y148. A2))],
        tmap1 : [g |- tmap (pi K2 (\x363. K4)) (epi A3 (\y148. A4))]
      ; by map-tequiv [g |- Dequiv] [g |- Dtmap] [g |- Dtmap2]
        as Dequiv1' unboxed;
        by map-tequiv
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dequiv1[.., b.3, b.4]]
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dtmap1[.., b.3, b.1, b.5]]
             [g,
              b :
                block (
                  x : eterm,
                  dx : evof x _,
                  a : con,
                  da : cn-of a (K1[..]),
                  at : map a x) |- Dtmap3[.., b.3, b.1, b.5]]
        as Dequiv2' unboxed;
        solve [g |- tequiv/pi Dequiv1' (\x. \dx. Dequiv2'[.., <x; dx; _; _; _>])]
      }
    }
  }
  case kd-equiv/sing:
  { g : map-bind+invert-bind-for-map-of,
    C : (g |- con),
    C1 : (g |- con),
    A : (g |- etp),
    B : (g |- etp),
    Dequiv : (g |- cn-equiv C C1 t)
  | x : [g |- kd-equiv (sing C) (sing C1)],
    tmap : [g |- tmap (sing C) A],
    tmap1 : [g |- tmap (sing C1) B]
  ; split tmap as
    case tmap/sing:
    { g : map-bind+invert-bind-for-map-of,
      C : (g |- con),
      C1 : (g |- con),
      M : (g |- eterm),
      B : (g |- etp),
      Dequiv : (g |- cn-equiv C C1 t),
      Dmap : (g |- map C M)
    | x : [g |- kd-equiv (sing C) (sing C1)],
      tmap : [g |- tmap (sing C) (esing M)],
      tmap1 : [g |- tmap (sing C1) B]
    ; split tmap1 as
      case tmap/sing:
      { g : map-bind+invert-bind-for-map-of,
        C : (g |- con),
        C1 : (g |- con),
        M : (g |- eterm),
        M1 : (g |- eterm),
        Dequiv : (g |- cn-equiv C C1 t),
        Dmap : (g |- map C M),
        Dmap1 : (g |- map C1 M1)
      | x : [g |- kd-equiv (sing C) (sing C1)],
        tmap : [g |- tmap (sing C) (esing M)],
        tmap1 : [g |- tmap (sing C1) (esing M1)]
      ; by map-equiv'' [g |- Dmap] [g |- Dmap1] [g |- Dequiv] [g |- tmap/t]
        as Dequiv' unboxed;
        solve [g |- tequiv/sing Dequiv']
      }
    }
  }
  case kd-equiv/trans:
  { g : map-bind+invert-bind-for-map-of,
    K : (g |- kind),
    L : (g |- kind),
    A : (g |- etp),
    B : (g |- etp),
    K2 : (g |- kind),
    Dequiv : (g |- kd-equiv K K2),
    Dequiv1 : (g |- kd-equiv K2 L)
  | x : [g |- kd-equiv K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
  ; by tmap as DmapA unboxed;
    by tmap1 as DmapC unboxed;
    split can-tmap [g |- K2] as
    case can-tmap/i:
    { g : map-bind+invert-bind-for-map-of,
      K : (g |- kind),
      K'' : (g |- kind),
      A : (g |- etp),
      C : (g |- etp),
      K' : (g |- kind),
      DequivAB : (g |- kd-equiv K K'),
      DequivBC : (g |- kd-equiv K' K''),
      DmapA : (g |- tmap K A),
      DmapC : (g |- tmap K'' C),
      A1 : (g |- etp),
      Dtmap : (g |- tmap K' A1)
    | x : [g |- kd-equiv K K''],
      tmap : [g |- tmap K A],
      tmap1 : [g |- tmap K'' C]
    ; by map-tequiv [g |- DequivAB] [g |- DmapA] [g |- Dtmap]
      as DequivAB' unboxed;
      by map-tequiv [g |- DequivBC] [g |- Dtmap] [g |- DmapC]
      as DequivBC' unboxed;
      solve [g |- tequiv/trans DequivAB' DequivBC']
    }
  }
  case kd-equiv/symm:
  { g : map-bind+invert-bind-for-map-of,
    K : (g |- kind),
    L : (g |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dequiv : (g |- kd-equiv L K)
  | x : [g |- kd-equiv K L], tmap : [g |- tmap K A], tmap1 : [g |- tmap L B]
  ; by tmap as Dmap unboxed;
    by tmap1 as Dmap' unboxed;
    by map-tequiv [g |- Dequiv] [g |- Dmap'] [g |- Dmap] as Dequiv' unboxed;
    solve [g |- tequiv/symm Dequiv']
  }
  case kd-equiv/refl:
  { g : map-bind+invert-bind-for-map-of,
    L : (g |- kind),
    A : (g |- etp),
    B : (g |- etp),
    Dwf : (g |- kd-wf L)
  | x : [g |- kd-equiv L L], tmap : [g |- tmap L A], tmap1 : [g |- tmap L B]
  ; by tmap as Dmap unboxed;
    by tmap1 as Dmap' unboxed;
    by map-wf' [g |- Dwf] [g |- Dmap] as Dwf' unboxed;
    split tmap-fun [g |- Dmap] [g |- Dmap'] as
    case etp-eq/i:
    { g : map-bind+invert-bind-for-map-of,
      L : (g |- kind),
      B : (g |- etp),
      Dwf : (g |- kd-wf L),
      Dmap : (g |- tmap L B),
      Dmap' : (g |- tmap L B),
      Dwf' : (g |- ewf B)
    | x : [g |- kd-equiv L L],
      tmap : [g |- tmap L B],
      tmap1 : [g |- tmap L B]
    ; solve [g |- tequiv/reflex Dwf']
    }
  }
}

and proof map-equiv' :
  (g : map-bind+invert-bind-for-map-of)
  [g |- map C M] ->
  [g |- map D N] ->
  [g |- cn-equiv C D K] ->
    [g |- map-equiv'/e M N K] =
/ total 1 /
?

and proof map-equiv'' :
  (g : map-bind+invert-bind-for-map-of)
  [g |- map C M] ->
  [g |- map D N] ->
  [g |- cn-equiv C D K] ->
  [g |- tmap K A] ->
    [g |- equiv M N A] =
/ trust / % FIXME: See issue #4
intros
{ g : map-bind+invert-bind-for-map-of,
  C : (g |- con),
  M : (g |- eterm),
  D : (g |- con),
  N : (g |- eterm),
  K : (g |- kind),
  A : (g |- etp)
| map : [g |- map C M],
  map1 : [g |- map D N],
  equiv : [g |- cn-equiv C D K],
  tmap : [g |- tmap K A]
; by map as Dmap unboxed;
  by map1 as Dmap' unboxed;
  by equiv as Dequiv unboxed;
  by tmap as DmapA unboxed;
  split map-equiv' [_ |- Dmap] [_ |- Dmap'] [_ |- Dequiv] as
  case map-equiv'/i:
  { g : map-bind+invert-bind-for-map-of,
    C : (g |- con),
    M : (g |- eterm),
    D : (g |- con),
    N : (g |- eterm),
    K : (g |- kind),
    A : (g |- etp),
    Dmap : (g |- map C M),
    Dmap' : (g |- map D N),
    Dequiv : (g |- cn-equiv C D K),
    DmapA : (g |- tmap K A),
    A1 : (g |- etp),
    Dtmap : (g |- tmap K A1),
    Dequiv1 : (g |- equiv M N A1)
  | map : [g |- map C M],
    map1 : [g |- map D N],
    equiv : [g |- cn-equiv C D K],
    tmap : [g |- tmap K A]
  ; split tmap-fun [_ |- Dtmap] [_ |- DmapA] as
    case etp-eq/i:
    { g : map-bind+invert-bind-for-map-of,
      C : (g |- con),
      M : (g |- eterm),
      D : (g |- con),
      N : (g |- eterm),
      K : (g |- kind),
      A : (g |- etp),
      Dmap : (g |- map C M),
      Dmap' : (g |- map D N),
      Dequiv : (g |- cn-equiv C D K),
      DmapA : (g |- tmap K A),
      DmapA' : (g |- tmap K A),
      Dequiv' : (g |- equiv M N A)
    | map : [g |- map C M],
      map1 : [g |- map D N],
      equiv : [g |- cn-equiv C D K],
      tmap : [g |- tmap K A]
    ; solve [_ |- Dequiv']
    }
  }
}
;

schema map-bind =
  some [B : etp, K : kind, Dmap : tmap K B, Dwf : ewf B]
  block (
    x : eterm, dx : evof x B,
    a : con, da : cn-of a K,
    at : map a x
  );

LF map-equiv/e : con -> con -> kind -> type =
| map-equiv/i :
  { M : eterm } { N : eterm } { A : etp }
  map C M ->
  map D N ->
  tmap K A ->
  equiv M N A ->
    map-equiv/e C D K
;

% FIXME: C, D, K are not in scope, `invert can-map [_ |- C]`, `invert can-map [_ |- D]`.
% Note: `invert can-map [_ |- _]` yields `File "src/core/lfcheck.ml", line 957, characters 5-10: Pattern matching failed`.
% Note: `invert can-map [_, b : block (x : eterm, dx : evof x B, a : con, da : cn-of a k, at : map a x) |- b.a]` yields `File "src/core/lfcheck.ml", line 957, characters 5-10: Pattern matching failed`.
% Note: `split equiv`, (case cn-equiv/beta2) `split equiv` yields `Stack overflow`.
proof map-equiv :
  (g : map-bind)
  [g |- cn-equiv C D K] ->
    [g |- map-equiv/e C D K] =
/ total /
?
;

% Injectivity Lemmas

LF injective-prod/e : con -> con -> con -> con -> type =
| injective-prod/i :
  cn-equiv T1a T2a t ->
  cn-equiv T1b T2b t ->
    injective-prod/e T1a T1b T2a T2b
;

proof injective-prod :
  [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t] ->
    [ |- injective-prod/e T1a T1b T2a T2b] =
/ total /
?
;

LF injective-arrow/e : con -> con -> con -> con -> type =
| injective-arrow/i :
  cn-equiv T1a T2a t ->
  cn-equiv T1b T2b t ->
    injective-arrow/e T1a T1b T2a T2b
;

proof injective-arrow :
  [ |- cn-equiv (arrow T1a T1b) (arrow T2a T2b) t] ->
    [ |- injective-arrow/e T1a T1b T2a T2b] =
/ total /
?
;

LF injective-plus/e : con -> con -> con -> con -> type =
| injective-plus/i :
  cn-equiv T1a T2a t ->
  cn-equiv T1b T2b t ->
    injective-plus/e  T1a T1b T2a T2b
;

proof injective-plus :
  [ |- cn-equiv (plus T1a T1b) (plus T2a T2b) t] ->
    [ |- injective-plus/e T1a T1b T2a T2b] =
/ total /
?
;

proof injective-ref :
  [ |- cn-equiv (ref T1) (ref T2) t] ->
    [ |- cn-equiv T1 T2 t] =
/ total /
?
;

proof injective-tag :
  [ |- cn-equiv (tag T1) (tag T2) t] ->
    [ |- cn-equiv T1 T2 t] =
/ total /
?
;

LF injective-rec/e :
  kind -> (con -> con -> con) -> con ->
  kind -> (con -> con -> con) -> con -> type =
| injective-rec/i :
  kd-equiv K1 K2 ->
  ({ a : con } cn-of a (pi K1 (\l. t)) ->
   { b : con } cn-of b K1 ->
   cn-equiv (C1a a b) (C2a a b) t) ->
  cn-equiv C1b C2b K1 ->
    injective-rec/e K1 C1a C1b K2 C2a C2b
;

proof injective-rec :
  [ |- cn-equiv
        (rec' K1 (\c1. \c2. C1a) C1b)
        (rec' K2 (\c1. \c2. C2a) C2b) t] ->
    [ |- injective-rec/e K1 (\c1. \c2. C1a) C1b K2 (\c1. \c2. C2a) C2b] =
/ total /
?
;

LF injective-labeled/e : label -> con -> label -> con -> type =
| injective-labeled/i :
  label-eq L1 L2 ->
  cn-equiv T1 T2 t ->
    injective-labeled/e L1 T1 L2 T2
;

proof injective-labeled :
  [ |- cn-equiv (labeled L1 T1) (labeled L2 T2) t] ->
    [ |- injective-labeled/e L1 T1 L2 T2] =
/ total /
?
;
