% Map into the singleton language

LF map : con -> eterm -> type =
| map/pair : map C1 M1 ->
               map C2 M2 ->
               map (pair C1 C2) (epair M1 M2)

| map/pi1 : map C M ->
              map (pi1 C) (epi1 M)

| map/pi2 : map C M ->
              map (pi2 C) (epi2 M)

| map/lam : ({a : con} {x : eterm} map a x ->
              map (C a) (M x)) ->
              tmap K A ->
              map (lam K C) (elam A M)

| map/app : map C1 M1 ->
              map C2 M2 ->
              map (app C1 C2) (eapp M1 M2)

| map/star : map star estar

| map/unit : map unit (econst const/unit)

| map/void : map void (econst const/void)

| map/prod : map C1 M1 ->
               map C2 M2 ->
               map (prod C1 C2) (eapp (eapp (econst const/prod) M1) M2)

| map/arrow : map C1 M1 ->
                map C2 M2 ->
                map (arrow C1 C2) (eapp (eapp (econst const/arrow) M1) M2)

| map/plus : map C1 M1 ->
               map C2 M2 ->
               map (plus C1 C2) (eapp (eapp (econst const/plus) M1) M2)

| map/ref : map C M ->
              map (ref C) (eapp (econst const/ref) M)

| map/tag : map C M ->
              map (tag C) (eapp (econst const/tag) M)

| map/tagged : map tagged (econst const/tagged)

| map/rec : flay A SK MA ->
              map C2 M2 ->
              ({a : con} {x : eterm} map a x ->
                {b : con} {y : eterm} map b y ->
                map (C1 a b) (M1 x y)) ->
              tmap K A ->
              map (rec' K C1 C2)
                (eapp (econst (const/rec SK))
                (epair
                  MA
                  (epair (elam (epi A (\x. et))
                  (\x. elam A (\y. M1 x y))) M2))
                )

| map/labeled : map C M ->
                  map (labeled I C) (eapp (econst (const/labeled I)) M)

and tmap : kind -> etp -> type =
| tmap/t : tmap t et

| tmap/sing : map C M -> tmap (sing C) (esing M)

| tmap/pi : ({a : con} {x : eterm} map a x -> tmap (K2 a) (A2 x)) ->
              tmap K1 A1 -> tmap (pi K1 K2) (epi A1 A2)

| tmap/sigma : ({a : con} {x : eterm} map a x -> tmap (K2 a) (A2 x)) ->
                 tmap K1 A1 -> tmap (sigma K1 K2) (esigma A1 A2)

| tmap/one : tmap one eone
;

% Map from the singleton language

LF unmap : eterm -> con -> type =
| unmap/app : unmap M1 C1 -> unmap M2 C2 -> unmap (eapp M1 M2) (app C1 C2)

| unmap/pi1 : unmap M C -> unmap (epi1 M) (pi1 C)

| unmap/pi2 : unmap M C -> unmap (epi2 M) (pi2 C)

| unmap/lam : tunmap A K ->
                ({x : eterm} {a : con} unmap x a -> unmap (M x) (C a)) ->
                unmap (elam A M) (lam K C)

| unmap/pair : unmap M1 C1 -> unmap M2 C2 -> unmap (epair M1 M2) (pair C1 C2)

| unmap/star : unmap estar star

| unmap/unit : unmap (econst const/unit) unit

| unmap/void : unmap (econst const/void) void

| unmap/prod : unmap (econst const/prod) (lam t (\a. lam t (\b. prod a b)))

| unmap/arrow : unmap (econst const/arrow) (lam t (\a. lam t (\b. arrow a b)))

| unmap/plus : unmap (econst const/plus) (lam t (\a. lam t (\b. plus a b)))

| unmap/ref : unmap (econst const/ref) (lam t (\a. ref a))

| unmap/tag : unmap (econst const/tag) (lam t (\a. tag a))

| unmap/tagged : unmap (econst const/tagged) tagged

| unmap/rec :
    skof-il SK K L ->
      unmap (econst (const/rec SK))
        (lam
          (sigma K
            (\a. sigma
              (pi (pi (L a) (\l. t)) (\k. (pi (L a) (\l. t))))
              (\l. (L a))
            )
          )
          (\b. rec'
            (L (pi1 b)) (\c. \d. app (app (pi1 (pi2 b)) c) d) (pi2 (pi2 b))
          )
        )

| unmap/labeled : unmap (econst (const/labeled I)) (lam t (\a. labeled I a))

and tunmap : etp -> kind -> type =
| tunmap/t : tunmap et t

| tunmap/sing : unmap M C -> tunmap (esing M) (sing C)

| tunmap/pi : tunmap A1 K1 ->
                ({x : eterm} {a : con} unmap x a -> tunmap (A2 x) (K2 a)) ->
                tunmap (epi A1 A2) (pi K1 K2)

| tunmap/sigma : tunmap A1 K1 ->
                   ({x : eterm} {a : con} unmap x a -> tunmap (A2 x) (K2 a)) ->
                   tunmap (esigma A1 A2) (sigma K1 K2)

| tunmap/one : tunmap eone one
;
--name map Dmap map.
--name tmap Dtmap tmap.
--name unmap Dunmap unmap.
--name tunmap Dtunmap tunmap.

schema unmap-block = some [a : con] block (x : eterm, xt : unmap x a);

schema conblock+unmap-block = block (a : con)
                            + some [a : con] block (x : eterm, xt : unmap x a);

proof unmap-resp :
  (g : conblock+unmap-block)
  [g |- eterm-eq M M'] ->
  [g |- con-eq C C'] ->
  [g |- unmap M C] ->
    [g |- unmap M' C'] =
/ total /
intros
{ g : conblock+unmap-block,
  M : (g |- eterm),
  M' : (g |- eterm),
  C : (g |- con),
  C' : (g |- con)
| eq : [g |- eterm-eq M M'],
  eq1 : [g |- con-eq C C'],
  unmap : [g |- unmap M C]
; split eq as
  case eterm-eq/i:
  { g : conblock+unmap-block,
    M' : (g |- eterm),
    C : (g |- con),
    C' : (g |- con)
  | eq : [g |- eterm-eq M' M'],
    eq1 : [g |- con-eq C C'],
    unmap : [g |- unmap M' C]
  ; split eq1 as
    case con-eq/i:
    { g : conblock+unmap-block, M' : (g |- eterm), C' : (g |- con)
    | eq : [g |- eterm-eq M' M'],
      eq1 : [g |- con-eq C' C'],
      unmap : [g |- unmap M' C']
    ; solve unmap
    }
  }
}
;

proof tunmap-resp :
  (g : conblock+unmap-block)
  [g |- etp-eq A A'] ->
  [g |- kind-eq K K'] ->
  [g |- tunmap A K] ->
    [g |- tunmap A' K'] =
/ total /
intros
{ g : conblock+unmap-block,
  A : (g |- etp),
  A' : (g |- etp),
  K : (g |- kind),
  K' : (g |- kind)
| eq : [g |- etp-eq A A'],
  eq1 : [g |- kind-eq K K'],
  tunmap : [g |- tunmap A K]
; split eq as
  case etp-eq/i:
  { g : conblock+unmap-block,
    A' : (g |- etp),
    K : (g |- kind),
    K' : (g |- kind)
  | eq : [g |- etp-eq A' A'],
    eq1 : [g |- kind-eq K K'],
    tunmap : [g |- tunmap A' K]
  ; split eq1 as
    case kind-eq/i:
    { g : conblock+unmap-block, A' : (g |- etp), K' : (g |- kind)
    | eq : [g |- etp-eq A' A'],
      eq1 : [g |- kind-eq K' K'],
      tunmap : [g |- tunmap A' K']
    ; solve tunmap
    }
  }
}
;

% Map Effectiveness

schema can-map-bind =
  some [m : eterm]
  block (a : con, at : map a m);

schema map-bind-for-can-map =
  some [b : etp, k : kind]
  block (
    x : eterm, d : evof x b,
    a : con, e : cn-of a k,
    at : map a x
  );

schema invert-bind-for-can-map =
  some [
    K : kind, K' : kind,
    B : etp,
    DmapK : tmap K B, DmapB : tunmap B K',
    DwfK : kd-wf K,
    DwfB : ewf B,
    DequivK : kd-equiv K K'
  ]
  block (
    a : con, da : cn-of a K,
    x : eterm, dx : evof x B,
    at : map a x, xt : unmap x a
  );

schema evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map =
  block (ex : eterm) +
  some [m : eterm]
  block (a : con, at : map a m) +
  some [b : etp, k : kind]
  block (
    x : eterm, d : evof x b,
    a : con, e : cn-of a k,
    at : map a x
  ) +
  some [
    K : kind, K' : kind,
    B : etp,
    DmapK : tmap K B, DmapB : tunmap B K',
    DwfK : kd-wf K,
    DwfB : ewf B,
    DequivK : kd-equiv K K'
  ]
  block (
    a : con, da : cn-of a K,
    x : eterm, dx : evof x B,
    at : map a x, xt : unmap x a
  );

LF can-map/e : con -> type =
| can-map/i :
  { M : eterm }
  map C M ->
    can-map/e C
;

LF can-tmap/e : kind -> type =
| can-tmap/i :
  { A : etp }
  tmap K A ->
    can-tmap/e K
;

proof can-map :
  (g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map)
  { C : [g |- con] }
  [g |- can-map/e C] =
/ total 1 /
intros
{ g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
  C : (g |- con)
|
; split [_ |- C] as
  case labeled:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    X : (g |- label),
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      X : (g |- label),
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i _ (map/labeled Dmap)]
    }
  }
  case rec':
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    K : (g |- kind),
    C1 : (g, y180 : con, x180 : con |- con),
    C2 : (g |- con)
  |
  ; split can-tmap [g |- K] as
    case can-tmap/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      K : (g |- kind),
      C1 : (g, y180 : con, x180 : con |- con),
      C2 : (g |- con),
      A : (g |- etp),
      Dtmap : (g |- tmap K A)
    |
    ; %{ FIXME: Totality checking for complete induction error.
         invert can-map [_, b1 : block (x : eterm, d1 : evof x (A[..]), a : con, e1 : cn-of a (K[..]), at1 : map a x), b2 : block (y : eterm, d2 : evof y (A[..]), b : con, e1 : cn-of b (K[..]), at2 : map b y) |- C1[.., b1.a, b2.b]]
      }%
      ?
    }
  }
  case tagged:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map
  |
  ; solve [g |- can-map/i _ map/tagged]
  }
  case tag:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i _ (map/tag Dmap)]
    }
  }
  case ref:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i _ (map/ref Dmap)]
    }
  }
  case plus:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i _ (map/plus Dmap Dmap1)]
      }
    }
  }
  case arrow:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i _ (map/arrow Dmap Dmap1)]
      }
    }
  }
  case prod:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve
          [g |-
             can-map/i (eapp (eapp (econst const/prod) M) M1)
             (map/prod Dmap Dmap1)]
      }
    }
  }
  case void:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map
  |
  ; solve [g |- can-map/i _ map/void]
  }
  case unit:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map
  |
  ; solve [g |- can-map/i _ map/unit]
  }
  case star:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map
  |
  ; solve [g |- can-map/i _ map/star]
  }
  case app:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i (eapp M M1) (map/app Dmap Dmap1)]
      }
    }
  }
  case lam:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    K : (g |- kind),
    C1 : (g, x175 : con |- con)
  |
  ; split can-tmap [g |- K] as
    case can-tmap/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      K : (g |- kind),
      C1 : (g, x175 : con |- con),
      A : (g |- etp),
      Dtmap : (g |- tmap K A)
    |
    ; split
can-map
  [g,
   b :
     block (
       x : eterm,
       d : evof x (A[..]),
       a : con,
       e : cn-of a (K[..]),
       at : map a x) |- C1[.., b.3]] as
      case can-map/i:
      { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
        K : (g |- kind),
        C2 : (g, a : con |- con),
        A : (g |- etp),
        Dtmap : (g |- tmap K A),
        M : (g, x : eterm |- eterm),
        Dmap :
          (g, x : eterm, a : con, e : cn-of a (K[..]), z808 : map a x |-
             map (C2[.., a]) (M[.., x]))
      |
      ; %{ FIXME: Solution contains uninstantiated metavariables.
           Type matches subgoal.
           solve [_|- can-map/i (elam A (\l. M)) (map/lam (\a. \x. \xt. Dmap[.., x, a, _, xt]) Dtmap)]
        }%
        ?
      }
    }
  }
  case pi2:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i (epi2 M) (map/pi2 Dmap)]
    }
  }
  case pi1:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    C1 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      C1 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; solve [g |- can-map/i (epi1 M) (map/pi1 Dmap)]
    }
  }
  case pair:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    C1 : (g |- con),
    C2 : (g |- con)
  |
  ; split can-map [g |- C1] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      C1 : (g |- con),
      C2 : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C1 M)
    |
    ; split can-map [g |- C2] as
      case can-map/i:
      { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
        C1 : (g |- con),
        C2 : (g |- con),
        M : (g |- eterm),
        Dmap : (g |- map C1 M),
        M1 : (g |- eterm),
        Dmap1 : (g |- map C2 M1)
      |
      ; solve [g |- can-map/i (epair M M1) (map/pair Dmap Dmap1)]
      }
    }
  }
  %{ FIXME: File "src/core/reconstruct.ml", line 2248, characters 11-16: Pattern matching failed
  case #.1:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    K433 : (g |- kind),
    A20 : (g |- etp),
    #unmap :
      #(g |-
          block (
            a : con,
            da : cn-of a (K433[..]),
            x : eterm,
            dx : evof x (A20[..]),
            at : map a x,
            xt : unmap x a)),
    K434 : (g |- kind),
    Dtmap4 : (g |- tmap K433 A20),
    Dtunmap : (g |- tunmap A20 K434),
    Dwf61 : (g |- kd-wf K433),
    Y : (g |- ewf A20),
    Dequiv37 : (g |- kd-equiv K433 K434)
  |
  ; solve [_ |- can-map/i #unmap.3 #unmap.5]
  }
  case #.3:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    A21 : (g |- etp),
    K435 : (g |- kind),
    #map :
      #(g |-
          block (
            x : eterm,
            d : evof x (A21[..]),
            a : con,
            e : cn-of a (K435[..]),
            at : map a x))
  |
  ; solve [_ |- can-map/i #map.1 #map.5]
  }
  case #.1:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    M9 : (g |- eterm),
    #map : #(g |- block (a : con, at : map a (M9[..])))
  |
  ; solve [_ |- can-map/i _ #map.2]
  }
  }%
}

and proof can-tmap :
  (g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map)
  { K : [g |- kind] }
  [g |- can-tmap/e K] =
/ total 1 /
intros
{ g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
  K : (g |- kind)
|
; split [_ |- K] as
  case one:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map
  |
  ; solve [g |- can-tmap/i _ tmap/one]
  }
  case sigma:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    K1 : (g |- kind),
    K2 : (g, y173 : con |- kind)
  |
  ; split can-tmap [g |- K1] as
    case can-tmap/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      K1 : (g |- kind),
      K2 : (g, y173 : con |- kind),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A)
    |
    ; split
can-tmap
  [g,
   b :
     block (
       x : eterm,
       d : evof x (A[..]),
       a : con,
       e : cn-of a (K1[..]),
       at : map a x) |- K2[.., b.3]] as
      case can-tmap/i:
      { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, e : cn-of a (K1[..]), y3 : map a x |-
             tmap (K3[.., a]) (A1[.., x]))
      |
      ; %{ FIXME: Solution contains uninstantiated metavariables.
           Type matches subgoal.
           solve [_|- can-tmap/i (esigma A (\l. A1)) (tmap/sigma (\a. \x. \xt. Dtmap1[.., x, a, _, xt]) Dtmap)]
        }%
        ?
      }
    }
  }
  case pi:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    K1 : (g |- kind),
    K2 : (g, y172 : con |- kind)
  |
  ; split can-tmap [g |- K1] as
    case can-tmap/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      K1 : (g |- kind),
      K2 : (g, y172 : con |- kind),
      A : (g |- etp),
      Dtmap : (g |- tmap K1 A)
    |
    ; split
can-tmap
  [g,
   b :
     block (
       x : eterm,
       d : evof x (A[..]),
       a : con,
       e : cn-of a (K1[..]),
       at : map a x) |- K2[.., b.3]] as
      case can-tmap/i:
      { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
        K1 : (g |- kind),
        K3 : (g, a : con |- kind),
        A : (g |- etp),
        Dtmap : (g |- tmap K1 A),
        A1 : (g, x : eterm |- etp),
        Dtmap1 :
          (g, x : eterm, a : con, e : cn-of a (K1[..]), y6 : map a x |-
             tmap (K3[.., a]) (A1[.., x]))
      |
      ; %{ FIXME: Solution contains uninstantiated metavariables.
          Type matches subgoal.
          solve [_|- can-tmap/i (epi A (\l. A1)) (tmap/pi (\a. \x. \xt. Dtmap1[.., x, a, _, xt]) Dtmap)]
        }%
        ?
      }
    }
  }
  case sing:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
    C : (g |- con)
  |
  ; split can-map [g |- C] as
    case can-map/i:
    { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map,
      C : (g |- con),
      M : (g |- eterm),
      Dmap : (g |- map C M)
    |
    ; solve [g |- can-tmap/i _ (tmap/sing Dmap)]
    }
  }
  case t:
  { g : evar+can-map-bind+map-bind-for-can-map+invert-bind-for-can-map
  |
  ; solve [g |- can-tmap/i _ tmap/t]
  }
}
;

% Injectivity Lemmas

proof injective-prod/a :
  [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t] ->
    [ |- cn-equiv T1a T2a t] =
/ total /
intros
{ T1a : ( |- con), T1b : ( |- con), T2a : ( |- con), T2b : ( |- con)
| equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
; ?
}
;

proof injective-prod/b :
  [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t] ->
    [ |- cn-equiv T1b T2b t] =
/ total /
intros
{ T1a : ( |- con), T1b : ( |- con), T2a : ( |- con), T2b : ( |- con)
| equiv : [ |- cn-equiv (prod T1a T1b) (prod T2a T2b) t]
; ?
}
;
