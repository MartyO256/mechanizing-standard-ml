% Definitions

LF expand-il : con -> kind -> con -> type =
| expand-il/t : expand-il R t R

| expand-il/pi :
  ({x : con} expand-il x A (M x)) ->
    ({x : con} expand-il (app R (M x)) (B x) (N x)) ->
    expand-il R (pi A B) (lam A N)

| expand-il/sigma :
  expand-il (pi1 R) A M ->
    expand-il (pi2 R) (B (pi1 R)) N ->
    expand-il R (sigma A B) (pair M N)

| expand-il/sing : expand-il R (sing R') R'

| expand-il/one : expand-il R one star
;
--name expand-il Dexpand-il expand.

LF skof-il : skel -> kind -> (con -> kind) -> type =
| skof-il/t : skof-il kt one (\l. t)

| skof-il/pi :
  skof-il As C (\y. A y) ->
    skof-il Bs D (\z. B z) ->
    ({y : con} {x : con} expand-il x (A y) (X y x)) ->
    skof-il
      (kpi As Bs)
      (sigma C (\y. pi (A y) (\l. D)))
      (\w. pi (A (pi1 w)) (\x. B (app (pi2 w) (X (pi1 w) x))))

| skof-il/sigma :
  skof-il As C (\y. A y) ->
    skof-il Bs D (\z. B z) ->
    ({y : con} {x : con} expand-il x (A y) (X y x)) ->
    skof-il
      (ksigma As Bs)
      (sigma C (\y. pi (A y) (\l. D)))
      (\w. sigma (A (pi1 w)) (\x. B (app (pi2 w) (X (pi1 w) x))))

| skof-il/sing : skof-il ksing t (\x. sing x)

| skof-il/one : skof-il kone one (\l. one)
;
--name skof-il Dskof-il.

% Expand-Il Theorems

LF simp-il : kind -> stp -> type =
| simp-il/t : simp-il t st

| simp-il/pi :
  simp-il A S ->
  ({ x : con } simp-il (B x) T) ->
    simp-il (pi A B) (spi S T)

| simp-il/sigma :
  simp-il A S ->
  ({ x : con } simp-il (B x) T) ->
    simp-il (sigma A B) (ssigma S T)

| simp-il/sing : simp-il (sing R) st

| simp-il/one : simp-il one sone
;
--name simp-il D.

LF can-simp-il/e : kind -> type =
| can-simp-il/i : { T : stp} simp-il A T -> can-simp-il/e A
;

proof can-simp-il :
  (g : conblock)
  { A : [g |- kind] }
  [g |- can-simp-il/e A] =
/ total 1 /
intros
{ g : conblock, A : (g |- kind)
|
; split [_ |- A] as
  case one:
  { g : conblock
  |
  ; solve [_ |- can-simp-il/i _ simp-il/one]
  }
  case sigma:
  { g : conblock, K : (g |- kind), K1 : (g, y471 : con |- kind)
  |
  ; split can-simp-il [_ |- K] as
    case can-simp-il/i:
    { g : conblock,
      K : (g |- kind),
      K1 : (g, y471 : con |- kind),
      T : ( |- stp),
      D : (g |- simp-il K T[])
    |
    ; split can-simp-il [_, a : con |- K1] as
      case can-simp-il/i:
      { g : conblock,
        K : (g |- kind),
        K1 : (g, y471 : con |- kind),
        T : ( |- stp),
        D : (g |- simp-il K T[]),
        T1 : ( |- stp),
        D1 : (g, a : con |- simp-il K1 T1[])
      |
      ; solve [_ |- can-simp-il/i _ (simp-il/sigma D (\a. D1))]
      }
    }
  }
  case pi:
  { g : conblock, K : (g |- kind), K1 : (g, y470 : con |- kind)
  |
  ; split can-simp-il [_ |- K] as
    case can-simp-il/i:
    { g : conblock,
      K : (g |- kind),
      K1 : (g, y470 : con |- kind),
      T : ( |- stp),
      D : (g |- simp-il K T[])
    |
    ; split can-simp-il [_, a : con |- K1] as
      case can-simp-il/i:
      { g : conblock,
        K : (g |- kind),
        K1 : (g, y470 : con |- kind),
        T : ( |- stp),
        D : (g |- simp-il K T[]),
        T1 : ( |- stp),
        D1 : (g, a : con |- simp-il K1 T1[])
      |
      ; solve [_ |- can-simp-il/i _ (simp-il/pi D (\a. D1))]
      }
    }
  }
  case sing:
  { g : conblock, C : (g |- con)
  |
  ; solve [_ |- can-simp-il/i _ (simp-il/sing )]
  }
  case t:
  { g : conblock
  |
  ; solve [_ |- can-simp-il/i _ simp-il/t]
  }
}
;

LF can-expand-il/e : con -> kind -> type =
| can-expand-il/i :
  { M : con }
  expand-il R A M ->
    can-expand-il/e R A
;

proof can-expand-il* :
  (g : conblock)
  { R : [g |- con] }
  { T : [g |- stp] }
  [g |- simp-il A T] ->
    [g |- can-expand-il/e R A] =
/ trust / % FIXME: See issue #4
intros
{ g : conblock, A : (g |- kind), R : (g |- con), T : (g |- stp)
| x : [g |- simp-il A T]
; split x as
  case simp-il/one:
  { g : conblock, R : (g |- con)
  | x : [g |- simp-il one sone]
  ; solve [_ |- can-expand-il/i _ (expand-il/one )]
  }
  case simp-il/sing:
  { g : conblock, C : (g |- con), R : (g |- con)
  | x : [g |- simp-il (sing C) st]
  ; solve [_ |- can-expand-il/i _ (expand-il/sing )]
  }
  case simp-il/sigma:
  { g : conblock,
    K : (g |- kind),
    K1 : (g, a124 : con |- kind),
    R : (g |- con),
    T1 : ( |- stp),
    T2 : ( |- stp),
    D : (g |- simp-il K T1[]),
    D1 : (g, x : con |- simp-il K1 T2[])
  | x : [g |- simp-il (sigma K (\y471. K1)) (ssigma T1[] T2[])]
  ; split can-expand-il* [g |- pi1 R] [g |- T1[]] [g |- D] as
    case can-expand-il/i:
    { g : conblock,
      K : (g |- kind),
      K1 : (g, a124 : con |- kind),
      R : (g |- con),
      T1 : ( |- stp),
      T2 : ( |- stp),
      D : (g |- simp-il K T1[]),
      D1 : (g, x : con |- simp-il K1 T2[]),
      C1 : (g |- con),
      Dexpand-il : (g |- expand-il (pi1 R) K C1)
    | x : [g |- simp-il (sigma K (\y471. K1)) (ssigma T1[] T2[])]
    ; split can-expand-il* [g |- pi2 R] [g |- T2[]] [g |- D1[.., pi1 R]] as
      case can-expand-il/i:
      { g : conblock,
        K : (g |- kind),
        K1 : (g, a124 : con |- kind),
        R : (g |- con),
        T1 : ( |- stp),
        T2 : ( |- stp),
        D : (g |- simp-il K T1[]),
        D1 : (g, x : con |- simp-il K1 T2[]),
        C1 : (g |- con),
        Dexpand-il : (g |- expand-il (pi1 R) K C1),
        C3 : (g |- con),
        Dexpand-il1 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C3)
      | x : [g |- simp-il (sigma K (\y471. K1)) (ssigma T1[] T2[])]
      ; solve [g |- can-expand-il/i _ (expand-il/sigma Dexpand-il Dexpand-il1)]
      }
    }
  }
  case simp-il/pi:
  { g : conblock,
    K : (g |- kind),
    K1 : (g, a123 : con |- kind),
    R : (g |- con),
    T1 : ( |- stp),
    T2 : ( |- stp),
    D : (g |- simp-il K T1[]),
    D1 : (g, x : con |- simp-il K1 T2[])
  | x : [g |- simp-il (pi K (\y470. K1)) (spi T1[] T2[])]
  ; split
can-expand-il* [g, b : block (x : con) |- b.1]
  [g, b : block (x : con) |- T1[]] [g, b : block (x : con) |- D[..]] as
    case can-expand-il/i:
    { g : conblock,
      K : (g |- kind),
      K1 : (g, a123 : con |- kind),
      R : (g |- con),
      T1 : ( |- stp),
      T2 : ( |- stp),
      D : (g |- simp-il K T1[]),
      D1 : (g, x : con |- simp-il K1 T2[]),
      C1 : (g, z5 : con |- con),
      Dexpand-il : (g, y6 : con |- expand-il y6 (K[..]) C1)
    | x : [g |- simp-il (pi K (\y470. K1)) (spi T1[] T2[])]
    ; split
      can-expand-il* [g, x : con |- app (R[..]) C1] [g, x : con |- T2[]]
        [g, x : con |- D1] as
      case can-expand-il/i:
      { g : conblock,
        K : (g |- kind),
        K1 : (g, a123 : con |- kind),
        R : (g |- con),
        T1 : ( |- stp),
        T2 : ( |- stp),
        D : (g |- simp-il K T1[]),
        D1 : (g, x : con |- simp-il K1 T2[]),
        C1 : (g, z5 : con |- con),
        Dexpand-il : (g, y6 : con |- expand-il y6 (K[..]) C1),
        C3 : (g, x : con |- con),
        Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C1) K1 C3)
      | x : [g |- simp-il (pi K (\y470. K1)) (spi T1[] T2[])]
      ; solve
          [g |-
             can-expand-il/i _
             (expand-il/pi (\x. Dexpand-il) (\x. Dexpand-il1))]
      }
    }
  }
  case simp-il/t:
  { g : conblock, R : (g |- con)
  | x : [g |- simp-il t st]
  ; solve [g |- can-expand-il/i _ (expand-il/t )]
  }
}
;

proof can-expand-il :
  (g : conblock)
  { R : [g |- con] }
  { A : [g |- kind] }
  [g |- can-expand-il/e R A] =
/ total /
intros
{ g : conblock, R : (g |- con), A : (g |- kind)
|
; split can-simp-il [_ |- A] as
  case can-simp-il/i:
  { g : conblock,
    R : (g |- con),
    A : (g |- kind),
    T : ( |- stp),
    D : (g |- simp-il A T[])
  |
  ; solve can-expand-il* [_ |- _] [_ |- _] [_ |- D]
  }
}
;

proof expand-il-fun :
  (g : conblock)
  [g |- expand-il R A M] ->
  [g |- expand-il R A M'] ->
    [g |- con-eq M M'] =
/ total 1 /
intros
{ g : conblock,
  R : (g |- con),
  A : (g |- kind),
  M : (g |- con),
  M' : (g |- con)
| x : [g |- expand-il R A M], expand : [g |- expand-il R A M']
; split x as
  case expand-il/one:
  { g : conblock, R : (g |- con), M' : (g |- con)
  | x : [g |- expand-il R one star], expand : [g |- expand-il R one M']
  ; split expand as
    case expand-il/one:
    { g : conblock, R : (g |- con)
    | x : [g |- expand-il R one star], expand : [g |- expand-il R one star]
    ; solve [_ |- con-eq/i ]
    }
  }
  case expand-il/sing:
  { g : conblock, R : (g |- con), M : (g |- con), M' : (g |- con)
  | x : [g |- expand-il R (sing M) M],
    expand : [g |- expand-il R (sing M) M']
  ; split expand as
    case expand-il/sing:
    { g : conblock, R : (g |- con), M' : (g |- con)
    | x : [g |- expand-il R (sing M') M'],
      expand : [g |- expand-il R (sing M') M']
    ; solve [_ |- con-eq/i ]
    }
  }
  case expand-il/sigma:
  { g : conblock,
    R : (g |- con),
    K : (g |- kind),
    K1 : (g, a114 : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    M' : (g |- con),
    Dexpand-il : (g |- expand-il (pi1 R) K C1),
    Dexpand-il1 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C2)
  | x : [g |- expand-il R (sigma K (\y471. K1)) (pair C1 C2)],
    expand : [g |- expand-il R (sigma K (\y471. K1)) M']
  ; split expand as
    case expand-il/sigma:
    { g : conblock,
      R : (g |- con),
      K : (g |- kind),
      K1 : (g, a114 : con |- kind),
      C1 : (g |- con),
      C2 : (g |- con),
      C4 : (g |- con),
      C5 : (g |- con),
      Dexpand-il : (g |- expand-il (pi1 R) K C1),
      Dexpand-il1 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C2),
      Dexpand-il2 : (g |- expand-il (pi1 R) K C4),
      Dexpand-il3 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C5)
    | x : [g |- expand-il R (sigma K (\y471. K1)) (pair C1 C2)],
      expand : [g |- expand-il R (sigma K (\y471. K1)) (pair C4 C5)]
    ; split expand-il-fun [_ |- Dexpand-il] [_ |- Dexpand-il2] as
      case con-eq/i:
      { g : conblock,
        R : (g |- con),
        K : (g |- kind),
        K1 : (g, a114 : con |- kind),
        C4 : (g |- con),
        C2 : (g |- con),
        C5 : (g |- con),
        D1 : (g |- expand-il (pi1 R) K C4),
        D2 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C2),
        D1' : (g |- expand-il (pi1 R) K C4),
        D2' : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C5)
      | x : [g |- expand-il R (sigma K (\y471. K1)) (pair C4 C2)],
        expand : [g |- expand-il R (sigma K (\y471. K1)) (pair C4 C5)]
      ; split expand-il-fun [_ |- D2] [_ |- D2'] as
        case con-eq/i:
        { g : conblock,
          R : (g |- con),
          K : (g |- kind),
          K1 : (g, a114 : con |- kind),
          C4 : (g |- con),
          C5 : (g |- con),
          D1 : (g |- expand-il (pi1 R) K C4),
          D2 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C5),
          D1' : (g |- expand-il (pi1 R) K C4),
          D2' : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C5)
        | x : [g |- expand-il R (sigma K (\y471. K1)) (pair C4 C5)],
          expand : [g |- expand-il R (sigma K (\y471. K1)) (pair C4 C5)]
        ; solve [_ |- con-eq/i ]
        }
      }
    }
  }
  case expand-il/pi:
  { g : conblock,
    R : (g |- con),
    K : (g |- kind),
    K1 : (g, a112 : con |- kind),
    C2 : (g, a113 : con |- con),
    M' : (g |- con),
    C : (g, a111 : con |- con),
    Dexpand-il : (g, x : con |- expand-il x (K[..]) C),
    Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C) K1 C2)
  | x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C2))],
    expand : [g |- expand-il R (pi K (\y470. K1)) M']
  ; split expand as
    case expand-il/pi:
    { g : conblock,
      R : (g |- con),
      K : (g |- kind),
      K1 : (g, a112 : con |- kind),
      C2 : (g, a113 : con |- con),
      C5 : (g, a113 : con |- con),
      C : (g, a111 : con |- con),
      Dexpand-il : (g, x : con |- expand-il x (K[..]) C),
      Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C) K1 C2),
      C3 : (g, a111 : con |- con),
      Dexpand-il2 : (g, x : con |- expand-il x (K[..]) C3),
      Dexpand-il3 : (g, x : con |- expand-il (app (R[..]) C3) K1 C5)
    | x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C2))],
      expand : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C5))]
    ; split
      expand-il-fun [_, x : con |- Dexpand-il] [_, x : con |- Dexpand-il2] as
      case con-eq/i:
      { g : conblock,
        R : (g |- con),
        K : (g |- kind),
        K1 : (g, a112 : con |- kind),
        C2 : (g, a113 : con |- con),
        C5 : (g, a113 : con |- con),
        C3 : (g, a111 : con |- con),
        D1 : (g, x : con |- expand-il x (K[..]) C3),
        D2 : (g, x : con |- expand-il (app (R[..]) C3) K1 C2),
        D1' : (g, x : con |- expand-il x (K[..]) C3),
        D2' : (g, x : con |- expand-il (app (R[..]) C3) K1 C5)
      | x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C2))],
        expand : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C5))]
      ; split expand-il-fun [_, x : con |- D2] [_, x : con |- D2'] as
        case con-eq/i:
        { g : conblock,
          R : (g |- con),
          K : (g |- kind),
          K1 : (g, a112 : con |- kind),
          C5 : (g, a113 : con |- con),
          C3 : (g, a111 : con |- con),
          D1 : (g, x : con |- expand-il x (K[..]) C3),
          D2 : (g, x : con |- expand-il (app (R[..]) C3) K1 C5),
          D1' : (g, x : con |- expand-il x (K[..]) C3),
          D2' : (g, x : con |- expand-il (app (R[..]) C3) K1 C5)
        | x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C5))],
          expand : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C5))]
        ; solve [_ |- con-eq/i ]
        }
      }
    }
  }
  case expand-il/t:
  { g : conblock, M : (g |- con), M' : (g |- con)
  | x : [g |- expand-il M t M], expand : [g |- expand-il M t M']
  ; split expand as
    case expand-il/t:
    { g : conblock, M' : (g |- con)
    | x : [g |- expand-il M' t M'], expand : [g |- expand-il M' t M']
    ; solve [_ |- con-eq/i ]
    }
  }
}
;

proof expand-il-equiv :
  (g : conbind-reg)
  [g |- cn-of R A] ->
  [g |- expand-il R A M] ->
    [g |- cn-equiv R M A] =
/ total 2 /
intros
{ g : conbind-reg, R : (g |- con), A : (g |- kind), M : (g |- con)
| cof : [g |- cn-of R A], x : [g |- expand-il R A M]
; by cof as DofR unboxed;
  split x as
  case expand-il/one:
  { g : conbind-reg, R : (g |- con), DofR : (g |- cn-of R one)
  | cof : [g |- cn-of R one], x : [g |- expand-il R one star]
  ; solve [_ |- cn-equiv/one DofR cn-of/star]
  }
  case expand-il/sing:
  { g : conbind-reg,
    R : (g |- con),
    M : (g |- con),
    DofR : (g |- cn-of R (sing M))
  | cof : [g |- cn-of R (sing M)], x : [g |- expand-il R (sing M) M]
  ; solve
      [_ |-
         cn-equiv/symm (cn-equiv/sing (cn-equiv/symm (cn-equiv/singelim DofR)))]
  }
  case expand-il/sigma:
  { g : conbind-reg,
    R : (g |- con),
    K : (g |- kind),
    K1 : (g, a114 : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    DofR : (g |- cn-of R (sigma K (\y471. K1))),
    Dexpand-il : (g |- expand-il (pi1 R) K C1),
    Dexpand-il1 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C2)
  | cof : [g |- cn-of R (sigma K (\y471. K1))],
    x : [g |- expand-il R (sigma K (\y471. K1)) (pair C1 C2)]
  ; split cn-of-reg [_ |- DofR] as
    case kd-wf/sigma:
    { g : conbind-reg,
      R : (g |- con),
      K : (g |- kind),
      K1 : (g, a114 : con |- kind),
      C1 : (g |- con),
      C2 : (g |- con),
      DofR : (g |- cn-of R (sigma K (\y471. K1))),
      Dexpand-il : (g |- expand-il (pi1 R) K C1),
      Dexpand-il1 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C2),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g, a : con, x531 : cn-of a (K[..]) |- kd-wf (K1[.., a]))
    | cof : [g |- cn-of R (sigma K (\y471. K1))],
      x : [g |- expand-il R (sigma K (\y471. K1)) (pair C1 C2)]
    ; by expand-il-equiv [_ |- cn-of/pi1 DofR] [_ |- Dexpand-il]
      as Dequiv1 unboxed;
      by expand-il-equiv [_ |- cn-of/pi2 DofR] [_ |- Dexpand-il1]
      as Dequiv2 unboxed;
      solve
  [g |-
     cn-equiv/trans (cn-equiv/extsigma (cn-equiv/symm (cn-equiv/beta1
                                                      (cn-of/pi1 DofR)
                                                      (cn-of/pi2 DofR)))
                    (cn-equiv/symm (cn-equiv/beta2 (cn-of/pi1 DofR)
                                   (cn-of/pi2 DofR)))
                    (\a. \da. Dwf1))
     (cn-equiv/pair Dequiv1 Dequiv2 (\a. \da. Dwf1))]
    }
  }
  case expand-il/pi:
  { g : conbind-reg,
    R : (g |- con),
    K : (g |- kind),
    K1 : (g, a112 : con |- kind),
    C2 : (g, a113 : con |- con),
    DofR : (g |- cn-of R (pi K (\y470. K1))),
    C : (g, a111 : con |- con),
    Dexpand-il : (g, x : con |- expand-il x (K[..]) C),
    Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C) K1 C2)
  | cof : [g |- cn-of R (pi K (\y470. K1))],
    x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C2))]
  ; split cn-of-reg [_ |- DofR] as
    case kd-wf/pi:
    { g : conbind-reg,
      R : (g |- con),
      K : (g |- kind),
      K1 : (g, a112 : con |- kind),
      C2 : (g, a113 : con |- con),
      DofR : (g |- cn-of R (pi K (\y470. K1))),
      C : (g, a111 : con |- con),
      Dexpand-il : (g, x : con |- expand-il x (K[..]) C),
      Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C) K1 C2),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g, a : con, x530 : cn-of a (K[..]) |- kd-wf (K1[.., a]))
    | cof : [g |- cn-of R (pi K (\y470. K1))],
      x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C2))]
    ; by expand-il-equiv [g, b : block (a : con, da : cn-of a (K[..])) |- b.2]
     [g, b : block (a : con, da : cn-of a (K[..])) |- Dexpand-il[.., b.1]]
as DequivX unboxed;
      split
      cn-equiv-reg [g, b : block (a : con, da : cn-of a (K[..])) |- DequivX] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        R : (g |- con),
        K2 : (g |- kind),
        K1 : (g, a112 : con |- kind),
        C2 : (g, a113 : con |- con),
        DofR : (g |- cn-of R (pi K2 (\y470. K1))),
        C4 : (g, a : con |- con),
        Dexpand-il : (g, x : con |- expand-il x (K2[..]) C4),
        Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C4) K1 C2),
        Dwf : (g |- kd-wf K2),
        Dwf1 : (g, a : con, x530 : cn-of a (K2[..]) |- kd-wf (K1[.., a])),
        DequivX :
          (g, b : block (a : con, da : cn-of a (K2[..])) |-
             cn-equiv b.1 (C4[.., b.1]) (K2[..])),
        Dof : (g, a : con, z1623 : cn-of a (K2[..]) |- cn-of a (K2[..])),
        Dof1 :
          (g, a : con, y1624 : cn-of a (K2[..]) |- cn-of (C4[.., a]) (K2[..])),
        Dwf2 : (g, a : con, x1624 : cn-of a (K2[..]) |- kd-wf (K2[..]))
      | cof : [g |- cn-of R (pi K2 (\y470. K1))],
        x : [g |- expand-il R (pi K2 (\y470. K1)) (lam K2 (\x473. C2))]
      ; by functionality-kd
             [g, b : block (a : con, da : cn-of a (K2[..])), b : con,
              db : cn-of b (K2[..]) |- Dwf1[.., b, db]]
             [g, b : block (a : con, da : cn-of a (K2[..])) |- DequivX]
        as DequivBx unboxed;
        by [g, b : block (a : con, da : cn-of a (K2[..])) |-
              cn-of/subsume (cn-of/app (Dof1[.., b.1, b.2]) (DofR[..]))
              (kd-sub/refl (kd-equiv/symm DequivBx))]
        as Dof' unboxed;
        by expand-il-equiv
             [g, b : block (a : con, da : cn-of a (K2[..])) |- Dof']
             [g, b : block (a : con, da : cn-of a (K2[..])) |-
                Dexpand-il1[.., b.1]]
        as DequivRX unboxed;
        by [g, b : block (a : con, da : cn-of a (K2[..])) |-
      cn-equiv/trans (cn-equiv/app (cn-equiv/refl (DofR[..])) DequivX)
      DequivRX]
as Dequiv' unboxed;
        solve
          [g |-
             cn-equiv/trans (cn-equiv/extpi DofR
                            (cn-of/lam Dwf
                            (\a. \da. cn-of/app da (DofR[..])))
                            (\a.
                               \da.
                                 cn-equiv/symm (cn-equiv/beta da
                                               (\a1.
                                                  \da1.
                                                    cn-of/app da1 (DofR[..])))))
             (cn-equiv/lam (kd-equiv/refl Dwf)
             (\a. \da. Dequiv'[.., <a; da>]))]
      }
    }
  }
  case expand-il/t:
  { g : conbind-reg, M : (g |- con), DofR : (g |- cn-of M t)
  | cof : [g |- cn-of M t], x : [g |- expand-il M t M]
  ; solve [g |- cn-equiv/refl DofR]
  }
}
;

proof expand-il-reg :
  (g : conbind-reg)
  [g |- cn-of R A] ->
  [g |- expand-il R A M] ->
    [g |- cn-of M A] =
/ total /
intros
{ g : conbind-reg, R : (g |- con), A : (g |- kind), M : (g |- con)
| cof : [g |- cn-of R A], expand : [g |- expand-il R A M]
; by expand-il-equiv cof expand as Dequiv unboxed;
  split cn-equiv-reg [_ |- Dequiv] as
  case cn-equiv-reg/i:
  { g : conbind-reg,
    R : (g |- con),
    A : (g |- kind),
    M : (g |- con),
    Dequiv : (g |- cn-equiv R M A),
    Dof : (g |- cn-of R A),
    Dof1 : (g |- cn-of M A),
    Dwf : (g |- kd-wf A)
  | cof : [g |- cn-of R A], expand : [g |- expand-il R A M]
  ; solve [_ |- Dof1]
  }
}
;

% Skof-Il Theorems

LF can-skof-il/e : skel -> type =
| can-skof-il/i :
  { A : kind } { B : con -> kind }
  skof-il K A B ->
    can-skof-il/e K
;

proof can-skof-il :
  (g : conblock)
  { K : [g |- skel] }
  [g |- can-skof-il/e K] =
/ total 1 /
intros
{ g : conblock, K : (g |- skel)
|
; split [_ |- K] as
  case kone:
  { g : conblock
  |
  ; solve [_ |- can-skof-il/i _ (\a. _) skof-il/one]
  }
  case ksing:
  { g : conblock
  |
  ; solve [_ |- can-skof-il/i _ (\a. _) skof-il/sing]
  }
  case ksigma:
  { g : conblock, Dskel : ( |- skel), Dskel1 : ( |- skel)
  |
  ; split can-skof-il [ |- Dskel] as
    case can-skof-il/i:
    { g : conblock,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      K : ( |- kind),
      K1 : (z934 : con |- kind),
      Dskof-il : ( |- skof-il Dskel K (\z931. K1))
    |
    ; split can-skof-il [ |- Dskel1] as
      case can-skof-il/i:
      { g : conblock,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        K : ( |- kind),
        K1 : (z934 : con |- kind),
        Dskof-il : ( |- skof-il Dskel K (\z931. K1)),
        K2 : ( |- kind),
        K3 : (z934 : con |- kind),
        Dskof-il1 : ( |- skof-il Dskel1 K2 (\z931. K3))
      |
      ; split can-expand-il [x : con, y : con |- x] [x : con, y : con |- K1[y]] as
        case can-expand-il/i:
        { g : conblock,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          K : ( |- kind),
          K1 : (z934 : con |- kind),
          Dskof-il : ( |- skof-il Dskel K (\z931. K1[z931])),
          K2 : ( |- kind),
          K3 : (z934 : con |- kind),
          Dskof-il1 : ( |- skof-il Dskel1 K2 (\z931. K3)),
          C1 : (x : con, y : con |- con),
          Dexpand-il : (x : con, y : con |- expand-il x (K1[y]) C1)
        |
        ; solve
            [g |-
               can-skof-il/i _
               (\a. _)
               (skof-il/sigma Dskof-il[]
               Dskof-il1[] (\x. \y. Dexpand-il[y, x]))]
        }
      }
    }
  }
  case kpi:
  { g : conblock, Dskel : ( |- skel), Dskel1 : ( |- skel)
  |
  ; split can-skof-il [ |- Dskel] as
    case can-skof-il/i:
    { g : conblock,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      K : ( |- kind),
      K1 : (z934 : con |- kind),
      Dskof-il : ( |- skof-il Dskel K (\z931. K1))
    |
    ; split can-skof-il [ |- Dskel1] as
      case can-skof-il/i:
      { g : conblock,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        K : ( |- kind),
        K1 : (z934 : con |- kind),
        Dskof-il : ( |- skof-il Dskel K (\z931. K1)),
        K2 : ( |- kind),
        K3 : (z934 : con |- kind),
        Dskof-il1 : ( |- skof-il Dskel1 K2 (\z931. K3))
      |
      ; split can-expand-il [x : con, y : con |- x] [x : con, y : con |- K1[y]] as
        case can-expand-il/i:
        { g : conblock,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          K : ( |- kind),
          K1 : (z934 : con |- kind),
          Dskof-il : ( |- skof-il Dskel K (\z931. K1[z931])),
          K2 : ( |- kind),
          K3 : (z934 : con |- kind),
          Dskof-il1 : ( |- skof-il Dskel1 K2 (\z931. K3)),
          C1 : (x : con, y : con |- con),
          Dexpand-il : (x : con, y : con |- expand-il x (K1[y]) C1)
        |
        ; solve
            [g |-
               can-skof-il/i _
               (\a. _)
               (skof-il/pi Dskof-il[] Dskof-il1[] (\x. \y. Dexpand-il[y, x]))]
        }
      }
    }
  }
  case kt:
  { g : conblock
  |
  ; solve [_ |- can-skof-il/i _ (\a. _) skof-il/t]
  }
}
;

LF skof-il-fun/e : kind -> kind -> (con -> kind) -> (con -> kind) -> type =
| skof-il-fun/i :
  kind-eq A A' ->
  ({ x : con } kind-eq (B x) (B' x)) ->
    skof-il-fun/e A A' B B'
;

proof skof-il-fun :
  (g : conblock)
  [g |- skof-il K A (\x. B)] ->
  [g |- skof-il K A' (\x. B')] ->
    [g |- skof-il-fun/e A A' (\x. B) (\x. B')] =
/ total 1 /
intros
{ g : conblock,
  K : (g |- skel),
  A : (g |- kind),
  B : (g, x1003 : con |- kind),
  A' : (g |- kind),
  B' : (g, x1003 : con |- kind)
| x : [g |- skof-il K A (\x. B)], x1 : [g |- skof-il K A' (\x. B')]
; split x as
  case skof-il/one:
  { g : conblock, A' : (g |- kind), B' : (g, x1003 : con |- kind)
  | x : [g |- skof-il kone one (\x. one)],
    x1 : [g |- skof-il kone A' (\x. B')]
  ; split x1 as
    case skof-il/one:
    { g : conblock
    | x : [g |- skof-il kone one (\x. one)],
      x1 : [g |- skof-il kone one (\x. one)]
    ; solve [_ |- skof-il-fun/i (kind-eq/i ) (\x. kind-eq/i )]
    }
  }
  case skof-il/sing:
  { g : conblock, A' : (g |- kind), B' : (g, x1003 : con |- kind)
  | x : [g |- skof-il ksing t (\x. sing x)],
    x1 : [g |- skof-il ksing A' (\x. B')]
  ; split x1 as
    case skof-il/sing:
    { g : conblock
    | x : [g |- skof-il ksing t (\x. sing x)],
      x1 : [g |- skof-il ksing t (\x. sing x)]
    ; solve [_ |- skof-il-fun/i (kind-eq/i ) (\x. kind-eq/i )]
    }
  }
  case skof-il/sigma:
  { g : conblock,
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    K1 : (g |- kind),
    K2 : (g, a119 : con |- kind),
    K3 : (g |- kind),
    K4 : (g, a120 : con |- kind),
    C : (g, a122 : con, a121 : con |- con),
    A' : (g |- kind),
    B' : (g, x1003 : con |- kind),
    Dskof-il : (g |- skof-il Dskel[] K1 (\y. K2)),
    Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
    Dexpand-il : (g, y : con, x : con |- expand-il x (K2[.., y]) C)
  | x :
      [g |-
         skof-il
           (ksigma Dskel[] Dskel1[])
           (sigma K1 (\y. pi K2 (\l. K3[..])))
           (\x.
              sigma (K2[.., pi1 x])
              (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
    x1 : [g |- skof-il (ksigma Dskel[] Dskel1[]) A' (\x. B')]
  ; split x1 as
    case skof-il/sigma:
    { g : conblock,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      K1 : (g |- kind),
      K2 : (g, a119 : con |- kind),
      K3 : (g |- kind),
      K4 : (g, a120 : con |- kind),
      C : (g, a122 : con, a121 : con |- con),
      K5 : (g |- kind),
      K6 : (g, a119 : con |- kind),
      K7 : (g |- kind),
      K8 : (g, a120 : con |- kind),
      C1 : (g, a122 : con, a121 : con |- con),
      Dskof-il : (g |- skof-il Dskel[] K1 (\y. K2)),
      Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
      Dexpand-il : (g, y : con, x : con |- expand-il x (K2[.., y]) C),
      Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
      Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
      Dexpand-il1 : (g, y : con, x : con |- expand-il x (K6[.., y]) C1)
    | x :
        [g |-
           skof-il
             (ksigma Dskel[] Dskel1[])
             (sigma K1 (\y. pi K2 (\l. K3[..])))
             (\x.
                sigma (K2[.., pi1 x])
                (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
      x1 :
        [g |-
           skof-il
             (ksigma Dskel[] Dskel1[])
             (sigma K5 (\y. pi K6 (\l. K7[..])))
             (\x.
                sigma (K6[.., pi1 x])
                (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
    ; split skof-il-fun [_ |- Dskof-il] [_ |- Dskof-il2] as
      case skof-il-fun/i:
      { g : conblock,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        K1 : (g |- kind),
        K2 : (g, a119 : con |- kind),
        K3 : (g |- kind),
        K4 : (g, a120 : con |- kind),
        C : (g, a122 : con, a121 : con |- con),
        K5 : (g |- kind),
        K6 : (g, a119 : con |- kind),
        K7 : (g |- kind),
        K8 : (g, a120 : con |- kind),
        C1 : (g, a122 : con, a121 : con |- con),
        Dskof-il : (g |- skof-il Dskel[] K1 (\y. K2)),
        Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
        Dexpand-il : (g, y : con, x : con |- expand-il x (K2[.., y]) C),
        Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
        Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
        Dexpand-il1 : (g, y : con, x : con |- expand-il x (K6[.., y]) C1),
        Deq : (g |- kind-eq K1 K5),
        Deq1 : (g, x : con |- kind-eq K2 K6)
      | x :
          [g |-
             skof-il
               (ksigma Dskel[] Dskel1[])
               (sigma K1 (\y. pi K2 (\l. K3[..])))
               (\x.
                  sigma (K2[.., pi1 x])
                  (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
        x1 :
          [g |-
             skof-il
               (ksigma Dskel[] Dskel1[])
               (sigma K5 (\y. pi K6 (\l. K7[..])))
               (\x.
                  sigma (K6[.., pi1 x])
                  (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
      ; split [_ |- Deq] as
        case kind-eq/i:
        { g : conblock,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          K5 : (g |- kind),
          K2 : (g, a119 : con |- kind),
          K3 : (g |- kind),
          K4 : (g, a120 : con |- kind),
          C : (g, a122 : con, a121 : con |- con),
          K6 : (g, a119 : con |- kind),
          K7 : (g |- kind),
          K8 : (g, a120 : con |- kind),
          C1 : (g, a122 : con, a121 : con |- con),
          Dskof-il : (g |- skof-il Dskel[] K5 (\y. K2)),
          Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
          Dexpand-il : (g, y : con, x : con |- expand-il x (K2[.., y]) C),
          Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
          Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
          Dexpand-il1 : (g, y : con, x : con |- expand-il x (K6[.., y]) C1),
          Deq1 : (g, x : con |- kind-eq K2 K6)
        | x :
            [g |-
               skof-il
                 (ksigma Dskel[] Dskel1[])
                 (sigma K5 (\y. pi K2 (\l. K3[..])))
                 (\x.
                    sigma (K2[.., pi1 x])
                    (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
          x1 :
            [g |-
               skof-il
                 (ksigma Dskel[] Dskel1[])
                 (sigma K5 (\y. pi K6 (\l. K7[..])))
                 (\x.
                    sigma (K6[.., pi1 x])
                    (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
        ; split [_, x : con |- Deq1] as
          case kind-eq/i:
          { g : conblock,
            Dskel : ( |- skel),
            Dskel1 : ( |- skel),
            K5 : (g |- kind),
            K6 : (g, a119 : con |- kind),
            K3 : (g |- kind),
            K4 : (g, a120 : con |- kind),
            C : (g, a122 : con, a121 : con |- con),
            K7 : (g |- kind),
            K8 : (g, a120 : con |- kind),
            C1 : (g, a122 : con, a121 : con |- con),
            Dskof-il : (g |- skof-il Dskel[] K5 (\y. K6)),
            Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
            Dexpand-il : (g, y : con, x : con |- expand-il x (K6[.., y]) C),
            Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
            Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
            Dexpand-il1 : (g, y : con, x : con |- expand-il x (K6[.., y]) C1)
          | x :
              [g |-
                 skof-il
                   (ksigma Dskel[] Dskel1[])
                   (sigma K5 (\y. pi K6 (\l. K3[..])))
                   (\x.
                      sigma (K6[.., pi1 x])
                      (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
            x1 :
              [g |-
                 skof-il
                   (ksigma Dskel[] Dskel1[])
                   (sigma K5 (\y. pi K6 (\l. K7[..])))
                   (\x.
                      sigma (K6[.., pi1 x])
                      (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
          ; split skof-il-fun [_ |- Dskof-il1] [_ |- Dskof-il3] as
            case skof-il-fun/i:
            { g : conblock,
              Dskel : ( |- skel),
              Dskel1 : ( |- skel),
              K5 : (g |- kind),
              K6 : (g, a119 : con |- kind),
              K3 : (g |- kind),
              K4 : (g, a120 : con |- kind),
              C : (g, a122 : con, a121 : con |- con),
              K7 : (g |- kind),
              K8 : (g, a120 : con |- kind),
              C1 : (g, a122 : con, a121 : con |- con),
              Dskof-il : (g |- skof-il Dskel[] K5 (\y. K6)),
              Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
              Dexpand-il : (g, y : con, x : con |- expand-il x (K6[.., y]) C),
              Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
              Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
              Dexpand-il1 :
                (g, y : con, x : con |- expand-il x (K6[.., y]) C1),
              Deq : (g |- kind-eq K3 K7),
              Deq1 : (g, x : con |- kind-eq K4 K8)
            | x :
                [g |-
                   skof-il
                     (ksigma Dskel[] Dskel1[])
                     (sigma K5 (\y. pi K6 (\l. K3[..])))
                     (\x.
                        sigma (K6[.., pi1 x])
                        (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
              x1 :
                [g |-
                   skof-il
                     (ksigma Dskel[] Dskel1[])
                     (sigma K5 (\y. pi K6 (\l. K7[..])))
                     (\x.
                        sigma (K6[.., pi1 x])
                        (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
            ; split [_ |- Deq] as
              case kind-eq/i:
              { g : conblock,
                Dskel : ( |- skel),
                Dskel1 : ( |- skel),
                K5 : (g |- kind),
                K6 : (g, a119 : con |- kind),
                K7 : (g |- kind),
                K4 : (g, a120 : con |- kind),
                C : (g, a122 : con, a121 : con |- con),
                K8 : (g, a120 : con |- kind),
                C1 : (g, a122 : con, a121 : con |- con),
                Dskof-il : (g |- skof-il Dskel[] K5 (\y. K6)),
                Dskof-il1 : (g |- skof-il Dskel1[] K7 (\z. K4)),
                Dexpand-il :
                  (g, y : con, x : con |- expand-il x (K6[.., y]) C),
                Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
                Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
                Dexpand-il1 :
                  (g, y : con, x : con |- expand-il x (K6[.., y]) C1),
                Deq1 : (g, x : con |- kind-eq K4 K8)
              | x :
                  [g |-
                     skof-il
                       (ksigma Dskel[] Dskel1[])
                       (sigma K5 (\y. pi K6 (\l. K7[..])))
                       (\x.
                          sigma (K6[.., pi1 x])
                          (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
                x1 :
                  [g |-
                     skof-il
                       (ksigma Dskel[] Dskel1[])
                       (sigma K5 (\y. pi K6 (\l. K7[..])))
                       (\x.
                          sigma (K6[.., pi1 x])
                          (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
              ; split [_, x : con |- Deq1] as
                case kind-eq/i:
                { g : conblock,
                  Dskel : ( |- skel),
                  Dskel1 : ( |- skel),
                  K5 : (g |- kind),
                  K6 : (g, a119 : con |- kind),
                  K7 : (g |- kind),
                  K8 : (g, a120 : con |- kind),
                  C : (g, a122 : con, a121 : con |- con),
                  C1 : (g, a122 : con, a121 : con |- con),
                  Dskof-il : (g |- skof-il Dskel[] K5 (\y. K6)),
                  Dskof-il1 : (g |- skof-il Dskel1[] K7 (\z. K8)),
                  Dexpand-il :
                    (g, y : con, x : con |- expand-il x (K6[.., y]) C),
                  Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
                  Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
                  Dexpand-il1 :
                    (g, y : con, x : con |- expand-il x (K6[.., y]) C1)
                | x :
                    [g |-
                       skof-il
                         (ksigma Dskel[] Dskel1[])
                         (sigma K5 (\y. pi K6 (\l. K7[..])))
                         (\x.
                            sigma (K6[.., pi1 x])
                            (\x1. K8[.., app (pi2 x) (C[.., pi1 x, x1])]))],
                  x1 :
                    [g |-
                       skof-il
                         (ksigma Dskel[] Dskel1[])
                         (sigma K5 (\y. pi K6 (\l. K7[..])))
                         (\x.
                            sigma (K6[.., pi1 x])
                            (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
                ; split
                  expand-il-fun [_, y : con, x : con |- Dexpand-il]
                    [_, y : con, x : con |- Dexpand-il1] as
                  case con-eq/i:
                  { g : conblock,
                    Dskel : ( |- skel),
                    Dskel1 : ( |- skel),
                    K5 : (g |- kind),
                    K6 : (g, a119 : con |- kind),
                    K7 : (g |- kind),
                    K8 : (g, a120 : con |- kind),
                    C1 : (g, a122 : con, a121 : con |- con),
                    Dskof-il : (g |- skof-il Dskel[] K5 (\y. K6)),
                    Dskof-il1 : (g |- skof-il Dskel1[] K7 (\z. K8)),
                    Dexpand-il :
                      (g, y : con, x : con |- expand-il x (K6[.., y]) C1),
                    Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
                    Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
                    Dexpand-il1 :
                      (g, y : con, x : con |- expand-il x (K6[.., y]) C1)
                  | x :
                      [g |-
                         skof-il
                           (ksigma Dskel[] Dskel1[])
                           (sigma K5 (\y. pi K6 (\l. K7[..])))
                           (\x.
                              sigma (K6[.., pi1 x])
                              (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))],
                    x1 :
                      [g |-
                         skof-il
                           (ksigma Dskel[] Dskel1[])
                           (sigma K5 (\y. pi K6 (\l. K7[..])))
                           (\x.
                              sigma (K6[.., pi1 x])
                              (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
                  ; solve [_ |- skof-il-fun/i (kind-eq/i ) (\x. kind-eq/i )]
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  case skof-il/pi:
  { g : conblock,
    Dskel : ( |- skel),
    Dskel1 : ( |- skel),
    K1 : (g |- kind),
    K2 : (g, a115 : con |- kind),
    K3 : (g |- kind),
    K4 : (g, a116 : con |- kind),
    C : (g, a118 : con, a117 : con |- con),
    A' : (g |- kind),
    B' : (g, x1003 : con |- kind),
    Dskof-il : (g |- skof-il Dskel[] K1 (\y. K2)),
    Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
    Dexpand-il : (g, y : con, x : con |- expand-il x (K2[.., y]) C)
  | x :
      [g |-
         skof-il
           (kpi Dskel[] Dskel1[])
           (sigma K1 (\y. pi K2 (\l. K3[..])))
           (\x.
              pi (K2[.., pi1 x])
              (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
    x1 : [g |- skof-il (kpi Dskel[] Dskel1[]) A' (\x. B')]
  ; split x1 as
    case skof-il/pi:
    { g : conblock,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      K1 : (g |- kind),
      K2 : (g, a115 : con |- kind),
      K3 : (g |- kind),
      K4 : (g, a116 : con |- kind),
      C : (g, a118 : con, a117 : con |- con),
      K5 : (g |- kind),
      K6 : (g, a115 : con |- kind),
      K7 : (g |- kind),
      K8 : (g, a116 : con |- kind),
      C1 : (g, a118 : con, a117 : con |- con),
      Dskof-il : (g |- skof-il Dskel[] K1 (\y. K2)),
      Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
      Dexpand-il : (g, y : con, x : con |- expand-il x (K2[.., y]) C),
      Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
      Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
      Dexpand-il1 : (g, y : con, x : con |- expand-il x (K6[.., y]) C1)
    | x :
        [g |-
           skof-il
             (kpi Dskel[] Dskel1[])
             (sigma K1 (\y. pi K2 (\l. K3[..])))
             (\x.
                pi (K2[.., pi1 x])
                (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
      x1 :
        [g |-
           skof-il
             (kpi Dskel[] Dskel1[])
             (sigma K5 (\y. pi K6 (\l. K7[..])))
             (\x.
                pi (K6[.., pi1 x])
                (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
    ; split skof-il-fun [_ |- Dskof-il] [_ |- Dskof-il2] as
      case skof-il-fun/i:
      { g : conblock,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        K1 : (g |- kind),
        K2 : (g, a115 : con |- kind),
        K3 : (g |- kind),
        K4 : (g, a116 : con |- kind),
        C : (g, a118 : con, a117 : con |- con),
        K5 : (g |- kind),
        K6 : (g, a115 : con |- kind),
        K7 : (g |- kind),
        K8 : (g, a116 : con |- kind),
        C1 : (g, a118 : con, a117 : con |- con),
        Dskof-il : (g |- skof-il Dskel[] K1 (\y. K2)),
        Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
        Dexpand-il : (g, y : con, x : con |- expand-il x (K2[.., y]) C),
        Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
        Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
        Dexpand-il1 : (g, y : con, x : con |- expand-il x (K6[.., y]) C1),
        Deq : (g |- kind-eq K1 K5),
        Deq1 : (g, x : con |- kind-eq K2 K6)
      | x :
          [g |-
             skof-il
               (kpi Dskel[] Dskel1[])
               (sigma K1 (\y. pi K2 (\l. K3[..])))
               (\x.
                  pi (K2[.., pi1 x])
                  (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
        x1 :
          [g |-
             skof-il
               (kpi Dskel[] Dskel1[])
               (sigma K5 (\y. pi K6 (\l. K7[..])))
               (\x.
                  pi (K6[.., pi1 x])
                  (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
      ; split [_ |- Deq] as
        case kind-eq/i:
        { g : conblock,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          K5 : (g |- kind),
          K2 : (g, a115 : con |- kind),
          K3 : (g |- kind),
          K4 : (g, a116 : con |- kind),
          C : (g, a118 : con, a117 : con |- con),
          K6 : (g, a115 : con |- kind),
          K7 : (g |- kind),
          K8 : (g, a116 : con |- kind),
          C1 : (g, a118 : con, a117 : con |- con),
          Dskof-il : (g |- skof-il Dskel[] K5 (\y. K2)),
          Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
          Dexpand-il : (g, y : con, x : con |- expand-il x (K2[.., y]) C),
          Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
          Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
          Dexpand-il1 : (g, y : con, x : con |- expand-il x (K6[.., y]) C1),
          Deq1 : (g, x : con |- kind-eq K2 K6)
        | x :
            [g |-
               skof-il
                 (kpi Dskel[] Dskel1[])
                 (sigma K5 (\y. pi K2 (\l. K3[..])))
                 (\x.
                    pi (K2[.., pi1 x])
                    (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
          x1 :
            [g |-
               skof-il
                 (kpi Dskel[] Dskel1[])
                 (sigma K5 (\y. pi K6 (\l. K7[..])))
                 (\x.
                    pi (K6[.., pi1 x])
                    (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
        ; split [_, x : con |- Deq1] as
          case kind-eq/i:
          { g : conblock,
            Dskel : ( |- skel),
            Dskel1 : ( |- skel),
            K5 : (g |- kind),
            K6 : (g, a115 : con |- kind),
            K3 : (g |- kind),
            K4 : (g, a116 : con |- kind),
            C : (g, a118 : con, a117 : con |- con),
            K7 : (g |- kind),
            K8 : (g, a116 : con |- kind),
            C1 : (g, a118 : con, a117 : con |- con),
            Dskof-il : (g |- skof-il Dskel[] K5 (\y. K6)),
            Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
            Dexpand-il : (g, y : con, x : con |- expand-il x (K6[.., y]) C),
            Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
            Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
            Dexpand-il1 : (g, y : con, x : con |- expand-il x (K6[.., y]) C1)
          | x :
              [g |-
                 skof-il
                   (kpi Dskel[] Dskel1[])
                   (sigma K5 (\y. pi K6 (\l. K3[..])))
                   (\x.
                      pi (K6[.., pi1 x])
                      (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
            x1 :
              [g |-
                 skof-il
                   (kpi Dskel[] Dskel1[])
                   (sigma K5 (\y. pi K6 (\l. K7[..])))
                   (\x.
                      pi (K6[.., pi1 x])
                      (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
          ; split skof-il-fun [_ |- Dskof-il1] [_ |- Dskof-il3] as
            case skof-il-fun/i:
            { g : conblock,
              Dskel : ( |- skel),
              Dskel1 : ( |- skel),
              K5 : (g |- kind),
              K6 : (g, a115 : con |- kind),
              K3 : (g |- kind),
              K4 : (g, a116 : con |- kind),
              C : (g, a118 : con, a117 : con |- con),
              K7 : (g |- kind),
              K8 : (g, a116 : con |- kind),
              C1 : (g, a118 : con, a117 : con |- con),
              Dskof-il : (g |- skof-il Dskel[] K5 (\y. K6)),
              Dskof-il1 : (g |- skof-il Dskel1[] K3 (\z. K4)),
              Dexpand-il : (g, y : con, x : con |- expand-il x (K6[.., y]) C),
              Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
              Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
              Dexpand-il1 :
                (g, y : con, x : con |- expand-il x (K6[.., y]) C1),
              Deq : (g |- kind-eq K3 K7),
              Deq1 : (g, x : con |- kind-eq K4 K8)
            | x :
                [g |-
                   skof-il
                     (kpi Dskel[] Dskel1[])
                     (sigma K5 (\y. pi K6 (\l. K3[..])))
                     (\x.
                        pi (K6[.., pi1 x])
                        (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
              x1 :
                [g |-
                   skof-il
                     (kpi Dskel[] Dskel1[])
                     (sigma K5 (\y. pi K6 (\l. K7[..])))
                     (\x.
                        pi (K6[.., pi1 x])
                        (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
            ; split [_ |- Deq] as
              case kind-eq/i:
              { g : conblock,
                Dskel : ( |- skel),
                Dskel1 : ( |- skel),
                K5 : (g |- kind),
                K6 : (g, a115 : con |- kind),
                K7 : (g |- kind),
                K4 : (g, a116 : con |- kind),
                C : (g, a118 : con, a117 : con |- con),
                K8 : (g, a116 : con |- kind),
                C1 : (g, a118 : con, a117 : con |- con),
                Dskof-il : (g |- skof-il Dskel[] K5 (\y. K6)),
                Dskof-il1 : (g |- skof-il Dskel1[] K7 (\z. K4)),
                Dexpand-il :
                  (g, y : con, x : con |- expand-il x (K6[.., y]) C),
                Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
                Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
                Dexpand-il1 :
                  (g, y : con, x : con |- expand-il x (K6[.., y]) C1),
                Deq1 : (g, x : con |- kind-eq K4 K8)
              | x :
                  [g |-
                     skof-il
                       (kpi Dskel[] Dskel1[])
                       (sigma K5 (\y. pi K6 (\l. K7[..])))
                       (\x.
                          pi (K6[.., pi1 x])
                          (\x1. K4[.., app (pi2 x) (C[.., pi1 x, x1])]))],
                x1 :
                  [g |-
                     skof-il
                       (kpi Dskel[] Dskel1[])
                       (sigma K5 (\y. pi K6 (\l. K7[..])))
                       (\x.
                          pi (K6[.., pi1 x])
                          (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
              ; split [_, x : con |- Deq1] as
                case kind-eq/i:
                { g : conblock,
                  Dskel : ( |- skel),
                  Dskel1 : ( |- skel),
                  K5 : (g |- kind),
                  K6 : (g, a115 : con |- kind),
                  K7 : (g |- kind),
                  K8 : (g, a116 : con |- kind),
                  C : (g, a118 : con, a117 : con |- con),
                  C1 : (g, a118 : con, a117 : con |- con),
                  Dskof-il : (g |- skof-il Dskel[] K5 (\y. K6)),
                  Dskof-il1 : (g |- skof-il Dskel1[] K7 (\z. K8)),
                  Dexpand-il :
                    (g, y : con, x : con |- expand-il x (K6[.., y]) C),
                  Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
                  Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
                  Dexpand-il1 :
                    (g, y : con, x : con |- expand-il x (K6[.., y]) C1)
                | x :
                    [g |-
                       skof-il
                         (kpi Dskel[] Dskel1[])
                         (sigma K5 (\y. pi K6 (\l. K7[..])))
                         (\x.
                            pi (K6[.., pi1 x])
                            (\x1. K8[.., app (pi2 x) (C[.., pi1 x, x1])]))],
                  x1 :
                    [g |-
                       skof-il
                         (kpi Dskel[] Dskel1[])
                         (sigma K5 (\y. pi K6 (\l. K7[..])))
                         (\x.
                            pi (K6[.., pi1 x])
                            (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
                ; split
                  expand-il-fun [_, y : con, x : con |- Dexpand-il]
                    [_, y : con, x : con |- Dexpand-il1] as
                  case con-eq/i:
                  { g : conblock,
                    Dskel : ( |- skel),
                    Dskel1 : ( |- skel),
                    K5 : (g |- kind),
                    K6 : (g, a115 : con |- kind),
                    K7 : (g |- kind),
                    K8 : (g, a116 : con |- kind),
                    C1 : (g, a118 : con, a117 : con |- con),
                    Dskof-il : (g |- skof-il Dskel[] K5 (\y. K6)),
                    Dskof-il1 : (g |- skof-il Dskel1[] K7 (\z. K8)),
                    Dexpand-il :
                      (g, y : con, x : con |- expand-il x (K6[.., y]) C1),
                    Dskof-il2 : (g |- skof-il Dskel[] K5 (\y. K6)),
                    Dskof-il3 : (g |- skof-il Dskel1[] K7 (\z. K8)),
                    Dexpand-il1 :
                      (g, y : con, x : con |- expand-il x (K6[.., y]) C1)
                  | x :
                      [g |-
                         skof-il
                           (kpi Dskel[] Dskel1[])
                           (sigma K5 (\y. pi K6 (\l. K7[..])))
                           (\x.
                              pi (K6[.., pi1 x])
                              (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))],
                    x1 :
                      [g |-
                         skof-il
                           (kpi Dskel[] Dskel1[])
                           (sigma K5 (\y. pi K6 (\l. K7[..])))
                           (\x.
                              pi (K6[.., pi1 x])
                              (\x1. K8[.., app (pi2 x) (C1[.., pi1 x, x1])]))]
                  ; solve [_ |- skof-il-fun/i (kind-eq/i ) (\x. kind-eq/i )]
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  case skof-il/t:
  { g : conblock, A' : (g |- kind), B' : (g, x1003 : con |- kind)
  | x : [g |- skof-il kt one (\x. t)], x1 : [g |- skof-il kt A' (\x. B')]
  ; split x1 as
    case skof-il/t:
    { g : conblock
    | x : [g |- skof-il kt one (\x. t)], x1 : [g |- skof-il kt one (\x. t)]
    ; solve [_ |- skof-il-fun/i (kind-eq/i ) (\x. kind-eq/i )]
    }
  }
}
;
