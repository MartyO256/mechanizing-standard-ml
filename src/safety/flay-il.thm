% Definitions

LF expand-il : con -> kind -> con -> type =
| expand-il/t : expand-il R t R

| expand-il/pi :
  ({x : con} expand-il x A (M x)) ->
    ({x : con} expand-il (app R (M x)) (B x) (N x)) ->
    expand-il R (pi A B) (lam A N)

| expand-il/sigma :
  expand-il (pi1 R) A M ->
    expand-il (pi2 R) (B (pi1 R)) N ->
    expand-il R (sigma A B) (pair M N)

| expand-il/sing : expand-il R (sing R') R'

| expand-il/one : expand-il R one star
;
--name expand-il Dexpand-il expand.

LF skof-il : skel -> kind -> (con -> kind) -> type =
| skof-il/t : skof-il kt one (\l. t)

| skof-il/pi :
  skof-il As C (\y. A y) ->
    skof-il Bs D (\z. B z) ->
    ({y : con} {x : con} expand-il x (A y) (X y x)) ->
    skof-il
      (kpi As Bs)
      (sigma C (\y. pi (A y) (\l. D)))
      (\w. pi (A (pi1 w)) (\x. B (app (pi2 w) (X (pi1 w) x))))

| skof-il/sigma :
  skof-il As C (\y. A y) ->
    skof-il Bs D (\z. B z) ->
    ({y : con} {x : con} expand-il x (A y) (X y x)) ->
    skof-il
      (ksigma As Bs)
      (sigma C (\y. pi (A y) (\l. D)))
      (\w. sigma (A (pi1 w)) (\x. B (app (pi2 w) (X (pi1 w) x))))

| skof-il/sing : skof-il ksing t (\x. sing x)

| skof-il/one : skof-il kone one (\l. one)
;
--name skof-il Dskof-il.

% Expand-Il Theorems

LF simp-il : kind -> stp -> type =
| simp-il/t : simp-il t st

| simp-il/pi :
  simp-il A S ->
  ({ x : con } simp-il (B x) T) ->
    simp-il (pi A B) (spi S T)

| simp-il/sigma :
  simp-il A S ->
  ({ x : con } simp-il (B x) T) ->
    simp-il (sigma A B) (ssigma S T)

| simp-il/sing : simp-il (sing R) st

| simp-il/one : simp-il one sone
;
--name simp-il D.

LF can-simp-il/e : kind -> type =
| can-simp-il/i : { T : stp} simp-il A T -> can-simp-il/e A
;

proof can-simp-il :
  (g : conblock)
  { A : [g |- kind] }
  [g |- can-simp-il/e A] =
/ total 1 /
intros
{ g : conblock, A : (g |- kind)
|
; split [_ |- A] as
  case one:
  { g : conblock
  |
  ; solve [_ |- can-simp-il/i _ simp-il/one]
  }
  case sigma:
  { g : conblock, K : (g |- kind), K1 : (g, y471 : con |- kind)
  |
  ; split can-simp-il [_ |- K] as
    case can-simp-il/i:
    { g : conblock,
      K : (g |- kind),
      K1 : (g, y471 : con |- kind),
      T : ( |- stp),
      D : (g |- simp-il K T[])
    |
    ; split can-simp-il [_, a : con |- K1] as
      case can-simp-il/i:
      { g : conblock,
        K : (g |- kind),
        K1 : (g, y471 : con |- kind),
        T : ( |- stp),
        D : (g |- simp-il K T[]),
        T1 : ( |- stp),
        D1 : (g, a : con |- simp-il K1 T1[])
      |
      ; solve [_ |- can-simp-il/i _ (simp-il/sigma D (\a. D1))]
      }
    }
  }
  case pi:
  { g : conblock, K : (g |- kind), K1 : (g, y470 : con |- kind)
  |
  ; split can-simp-il [_ |- K] as
    case can-simp-il/i:
    { g : conblock,
      K : (g |- kind),
      K1 : (g, y470 : con |- kind),
      T : ( |- stp),
      D : (g |- simp-il K T[])
    |
    ; split can-simp-il [_, a : con |- K1] as
      case can-simp-il/i:
      { g : conblock,
        K : (g |- kind),
        K1 : (g, y470 : con |- kind),
        T : ( |- stp),
        D : (g |- simp-il K T[]),
        T1 : ( |- stp),
        D1 : (g, a : con |- simp-il K1 T1[])
      |
      ; solve [_ |- can-simp-il/i _ (simp-il/pi D (\a. D1))]
      }
    }
  }
  case sing:
  { g : conblock, C : (g |- con)
  |
  ; solve [_ |- can-simp-il/i _ (simp-il/sing )]
  }
  case t:
  { g : conblock
  |
  ; solve [_ |- can-simp-il/i _ simp-il/t]
  }
}
;

LF can-expand-il/e : con -> kind -> type =
| can-expand-il/i :
  { M : con }
  expand-il R A M ->
    can-expand-il/e R A
;

proof can-expand-il* :
  (g : conblock)
  { R : [g |- con] }
  { T : [g |- stp] }
  [g |- simp-il A T] ->
    [g |- can-expand-il/e R A] =
/ trust / % FIXME: See issue #4
intros
{ g : conblock, A : (g |- kind), R : (g |- con), T : (g |- stp)
| x : [g |- simp-il A T]
; split x as
  case simp-il/one:
  { g : conblock, R : (g |- con)
  | x : [g |- simp-il one sone]
  ; solve [_ |- can-expand-il/i _ (expand-il/one )]
  }
  case simp-il/sing:
  { g : conblock, C : (g |- con), R : (g |- con)
  | x : [g |- simp-il (sing C) st]
  ; solve [_ |- can-expand-il/i _ (expand-il/sing )]
  }
  case simp-il/sigma:
  { g : conblock,
    K : (g |- kind),
    K1 : (g, a124 : con |- kind),
    R : (g |- con),
    T1 : ( |- stp),
    T2 : ( |- stp),
    D : (g |- simp-il K T1[]),
    D1 : (g, x : con |- simp-il K1 T2[])
  | x : [g |- simp-il (sigma K (\y471. K1)) (ssigma T1[] T2[])]
  ; split can-expand-il* [g |- pi1 R] [g |- T1[]] [g |- D] as
    case can-expand-il/i:
    { g : conblock,
      K : (g |- kind),
      K1 : (g, a124 : con |- kind),
      R : (g |- con),
      T1 : ( |- stp),
      T2 : ( |- stp),
      D : (g |- simp-il K T1[]),
      D1 : (g, x : con |- simp-il K1 T2[]),
      C1 : (g |- con),
      Dexpand-il : (g |- expand-il (pi1 R) K C1)
    | x : [g |- simp-il (sigma K (\y471. K1)) (ssigma T1[] T2[])]
    ; split can-expand-il* [g |- pi2 R] [g |- T2[]] [g |- D1[.., pi1 R]] as
      case can-expand-il/i:
      { g : conblock,
        K : (g |- kind),
        K1 : (g, a124 : con |- kind),
        R : (g |- con),
        T1 : ( |- stp),
        T2 : ( |- stp),
        D : (g |- simp-il K T1[]),
        D1 : (g, x : con |- simp-il K1 T2[]),
        C1 : (g |- con),
        Dexpand-il : (g |- expand-il (pi1 R) K C1),
        C3 : (g |- con),
        Dexpand-il1 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C3)
      | x : [g |- simp-il (sigma K (\y471. K1)) (ssigma T1[] T2[])]
      ; solve [g |- can-expand-il/i _ (expand-il/sigma Dexpand-il Dexpand-il1)]
      }
    }
  }
  case simp-il/pi:
  { g : conblock,
    K : (g |- kind),
    K1 : (g, a123 : con |- kind),
    R : (g |- con),
    T1 : ( |- stp),
    T2 : ( |- stp),
    D : (g |- simp-il K T1[]),
    D1 : (g, x : con |- simp-il K1 T2[])
  | x : [g |- simp-il (pi K (\y470. K1)) (spi T1[] T2[])]
  ; split
can-expand-il* [g, b : block (x : con) |- b.1]
  [g, b : block (x : con) |- T1[]] [g, b : block (x : con) |- D[..]] as
    case can-expand-il/i:
    { g : conblock,
      K : (g |- kind),
      K1 : (g, a123 : con |- kind),
      R : (g |- con),
      T1 : ( |- stp),
      T2 : ( |- stp),
      D : (g |- simp-il K T1[]),
      D1 : (g, x : con |- simp-il K1 T2[]),
      C1 : (g, z5 : con |- con),
      Dexpand-il : (g, y6 : con |- expand-il y6 (K[..]) C1)
    | x : [g |- simp-il (pi K (\y470. K1)) (spi T1[] T2[])]
    ; split
      can-expand-il* [g, x : con |- app (R[..]) C1] [g, x : con |- T2[]]
        [g, x : con |- D1] as
      case can-expand-il/i:
      { g : conblock,
        K : (g |- kind),
        K1 : (g, a123 : con |- kind),
        R : (g |- con),
        T1 : ( |- stp),
        T2 : ( |- stp),
        D : (g |- simp-il K T1[]),
        D1 : (g, x : con |- simp-il K1 T2[]),
        C1 : (g, z5 : con |- con),
        Dexpand-il : (g, y6 : con |- expand-il y6 (K[..]) C1),
        C3 : (g, x : con |- con),
        Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C1) K1 C3)
      | x : [g |- simp-il (pi K (\y470. K1)) (spi T1[] T2[])]
      ; solve
          [g |-
             can-expand-il/i _
             (expand-il/pi (\x. Dexpand-il) (\x. Dexpand-il1))]
      }
    }
  }
  case simp-il/t:
  { g : conblock, R : (g |- con)
  | x : [g |- simp-il t st]
  ; solve [g |- can-expand-il/i _ (expand-il/t )]
  }
}
;

proof can-expand-il :
  (g : conblock)
  { R : [g |- con] }
  { A : [g |- kind] }
  [g |- can-expand-il/e R A] =
/ total /
intros
{ g : conblock, R : (g |- con), A : (g |- kind)
|
; split can-simp-il [_ |- A] as
  case can-simp-il/i:
  { g : conblock,
    R : (g |- con),
    A : (g |- kind),
    T : ( |- stp),
    D : (g |- simp-il A T[])
  |
  ; solve can-expand-il* [_ |- _] [_ |- _] [_ |- D]
  }
}
;

proof expand-il-fun :
  (g : conblock)
  [g |- expand-il R A M] ->
  [g |- expand-il R A M'] ->
    [g |- con-eq M M'] =
/ total 1 /
intros
{ g : conblock,
  R : (g |- con),
  A : (g |- kind),
  M : (g |- con),
  M' : (g |- con)
| x : [g |- expand-il R A M], expand : [g |- expand-il R A M']
; split x as
  case expand-il/one:
  { g : conblock, R : (g |- con), M' : (g |- con)
  | x : [g |- expand-il R one star], expand : [g |- expand-il R one M']
  ; split expand as
    case expand-il/one:
    { g : conblock, R : (g |- con)
    | x : [g |- expand-il R one star], expand : [g |- expand-il R one star]
    ; solve [_ |- con-eq/i ]
    }
  }
  case expand-il/sing:
  { g : conblock, R : (g |- con), M : (g |- con), M' : (g |- con)
  | x : [g |- expand-il R (sing M) M],
    expand : [g |- expand-il R (sing M) M']
  ; split expand as
    case expand-il/sing:
    { g : conblock, R : (g |- con), M' : (g |- con)
    | x : [g |- expand-il R (sing M') M'],
      expand : [g |- expand-il R (sing M') M']
    ; solve [_ |- con-eq/i ]
    }
  }
  case expand-il/sigma:
  { g : conblock,
    R : (g |- con),
    K : (g |- kind),
    K1 : (g, a114 : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    M' : (g |- con),
    Dexpand-il : (g |- expand-il (pi1 R) K C1),
    Dexpand-il1 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C2)
  | x : [g |- expand-il R (sigma K (\y471. K1)) (pair C1 C2)],
    expand : [g |- expand-il R (sigma K (\y471. K1)) M']
  ; split expand as
    case expand-il/sigma:
    { g : conblock,
      R : (g |- con),
      K : (g |- kind),
      K1 : (g, a114 : con |- kind),
      C1 : (g |- con),
      C2 : (g |- con),
      C4 : (g |- con),
      C5 : (g |- con),
      Dexpand-il : (g |- expand-il (pi1 R) K C1),
      Dexpand-il1 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C2),
      Dexpand-il2 : (g |- expand-il (pi1 R) K C4),
      Dexpand-il3 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C5)
    | x : [g |- expand-il R (sigma K (\y471. K1)) (pair C1 C2)],
      expand : [g |- expand-il R (sigma K (\y471. K1)) (pair C4 C5)]
    ; split expand-il-fun [_ |- Dexpand-il] [_ |- Dexpand-il2] as
      case con-eq/i:
      { g : conblock,
        R : (g |- con),
        K : (g |- kind),
        K1 : (g, a114 : con |- kind),
        C4 : (g |- con),
        C2 : (g |- con),
        C5 : (g |- con),
        D1 : (g |- expand-il (pi1 R) K C4),
        D2 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C2),
        D1' : (g |- expand-il (pi1 R) K C4),
        D2' : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C5)
      | x : [g |- expand-il R (sigma K (\y471. K1)) (pair C4 C2)],
        expand : [g |- expand-il R (sigma K (\y471. K1)) (pair C4 C5)]
      ; split expand-il-fun [_ |- D2] [_ |- D2'] as
        case con-eq/i:
        { g : conblock,
          R : (g |- con),
          K : (g |- kind),
          K1 : (g, a114 : con |- kind),
          C4 : (g |- con),
          C5 : (g |- con),
          D1 : (g |- expand-il (pi1 R) K C4),
          D2 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C5),
          D1' : (g |- expand-il (pi1 R) K C4),
          D2' : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C5)
        | x : [g |- expand-il R (sigma K (\y471. K1)) (pair C4 C5)],
          expand : [g |- expand-il R (sigma K (\y471. K1)) (pair C4 C5)]
        ; solve [_ |- con-eq/i ]
        }
      }
    }
  }
  case expand-il/pi:
  { g : conblock,
    R : (g |- con),
    K : (g |- kind),
    K1 : (g, a112 : con |- kind),
    C2 : (g, a113 : con |- con),
    M' : (g |- con),
    C : (g, a111 : con |- con),
    Dexpand-il : (g, x : con |- expand-il x (K[..]) C),
    Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C) K1 C2)
  | x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C2))],
    expand : [g |- expand-il R (pi K (\y470. K1)) M']
  ; split expand as
    case expand-il/pi:
    { g : conblock,
      R : (g |- con),
      K : (g |- kind),
      K1 : (g, a112 : con |- kind),
      C2 : (g, a113 : con |- con),
      C5 : (g, a113 : con |- con),
      C : (g, a111 : con |- con),
      Dexpand-il : (g, x : con |- expand-il x (K[..]) C),
      Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C) K1 C2),
      C3 : (g, a111 : con |- con),
      Dexpand-il2 : (g, x : con |- expand-il x (K[..]) C3),
      Dexpand-il3 : (g, x : con |- expand-il (app (R[..]) C3) K1 C5)
    | x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C2))],
      expand : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C5))]
    ; split
      expand-il-fun [_, x : con |- Dexpand-il] [_, x : con |- Dexpand-il2] as
      case con-eq/i:
      { g : conblock,
        R : (g |- con),
        K : (g |- kind),
        K1 : (g, a112 : con |- kind),
        C2 : (g, a113 : con |- con),
        C5 : (g, a113 : con |- con),
        C3 : (g, a111 : con |- con),
        D1 : (g, x : con |- expand-il x (K[..]) C3),
        D2 : (g, x : con |- expand-il (app (R[..]) C3) K1 C2),
        D1' : (g, x : con |- expand-il x (K[..]) C3),
        D2' : (g, x : con |- expand-il (app (R[..]) C3) K1 C5)
      | x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C2))],
        expand : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C5))]
      ; split expand-il-fun [_, x : con |- D2] [_, x : con |- D2'] as
        case con-eq/i:
        { g : conblock,
          R : (g |- con),
          K : (g |- kind),
          K1 : (g, a112 : con |- kind),
          C5 : (g, a113 : con |- con),
          C3 : (g, a111 : con |- con),
          D1 : (g, x : con |- expand-il x (K[..]) C3),
          D2 : (g, x : con |- expand-il (app (R[..]) C3) K1 C5),
          D1' : (g, x : con |- expand-il x (K[..]) C3),
          D2' : (g, x : con |- expand-il (app (R[..]) C3) K1 C5)
        | x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C5))],
          expand : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C5))]
        ; solve [_ |- con-eq/i ]
        }
      }
    }
  }
  case expand-il/t:
  { g : conblock, M : (g |- con), M' : (g |- con)
  | x : [g |- expand-il M t M], expand : [g |- expand-il M t M']
  ; split expand as
    case expand-il/t:
    { g : conblock, M' : (g |- con)
    | x : [g |- expand-il M' t M'], expand : [g |- expand-il M' t M']
    ; solve [_ |- con-eq/i ]
    }
  }
}
;

proof expand-il-equiv :
  (g : conbind-reg)
  [g |- cn-of R A] ->
  [g |- expand-il R A M] ->
    [g |- cn-equiv R M A] =
/ total 2 /
intros
{ g : conbind-reg, R : (g |- con), A : (g |- kind), M : (g |- con)
| cof : [g |- cn-of R A], x : [g |- expand-il R A M]
; by cof as DofR unboxed;
  split x as
  case expand-il/one:
  { g : conbind-reg, R : (g |- con), DofR : (g |- cn-of R one)
  | cof : [g |- cn-of R one], x : [g |- expand-il R one star]
  ; solve [_ |- cn-equiv/one DofR cn-of/star]
  }
  case expand-il/sing:
  { g : conbind-reg,
    R : (g |- con),
    M : (g |- con),
    DofR : (g |- cn-of R (sing M))
  | cof : [g |- cn-of R (sing M)], x : [g |- expand-il R (sing M) M]
  ; solve
      [_ |-
         cn-equiv/symm (cn-equiv/sing (cn-equiv/symm (cn-equiv/singelim DofR)))]
  }
  case expand-il/sigma:
  { g : conbind-reg,
    R : (g |- con),
    K : (g |- kind),
    K1 : (g, a114 : con |- kind),
    C1 : (g |- con),
    C2 : (g |- con),
    DofR : (g |- cn-of R (sigma K (\y471. K1))),
    Dexpand-il : (g |- expand-il (pi1 R) K C1),
    Dexpand-il1 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C2)
  | cof : [g |- cn-of R (sigma K (\y471. K1))],
    x : [g |- expand-il R (sigma K (\y471. K1)) (pair C1 C2)]
  ; split cn-of-reg [_ |- DofR] as
    case kd-wf/sigma:
    { g : conbind-reg,
      R : (g |- con),
      K : (g |- kind),
      K1 : (g, a114 : con |- kind),
      C1 : (g |- con),
      C2 : (g |- con),
      DofR : (g |- cn-of R (sigma K (\y471. K1))),
      Dexpand-il : (g |- expand-il (pi1 R) K C1),
      Dexpand-il1 : (g |- expand-il (pi2 R) (K1[.., pi1 R]) C2),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g, a : con, x531 : cn-of a (K[..]) |- kd-wf (K1[.., a]))
    | cof : [g |- cn-of R (sigma K (\y471. K1))],
      x : [g |- expand-il R (sigma K (\y471. K1)) (pair C1 C2)]
    ; by expand-il-equiv [_ |- cn-of/pi1 DofR] [_ |- Dexpand-il]
      as Dequiv1 unboxed;
      by expand-il-equiv [_ |- cn-of/pi2 DofR] [_ |- Dexpand-il1]
      as Dequiv2 unboxed;
      solve
  [g |-
     cn-equiv/trans (cn-equiv/extsigma (cn-equiv/symm (cn-equiv/beta1 
                                                      (cn-of/pi1 DofR)
                                                      (cn-of/pi2 DofR)))
                    (cn-equiv/symm (cn-equiv/beta2 (cn-of/pi1 DofR)
                                   (cn-of/pi2 DofR)))
                    (\a. \da. Dwf1))
     (cn-equiv/pair Dequiv1 Dequiv2 (\a. \da. Dwf1))]
    }
  }
  case expand-il/pi:
  { g : conbind-reg,
    R : (g |- con),
    K : (g |- kind),
    K1 : (g, a112 : con |- kind),
    C2 : (g, a113 : con |- con),
    DofR : (g |- cn-of R (pi K (\y470. K1))),
    C : (g, a111 : con |- con),
    Dexpand-il : (g, x : con |- expand-il x (K[..]) C),
    Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C) K1 C2)
  | cof : [g |- cn-of R (pi K (\y470. K1))],
    x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C2))]
  ; split cn-of-reg [_ |- DofR] as
    case kd-wf/pi:
    { g : conbind-reg,
      R : (g |- con),
      K : (g |- kind),
      K1 : (g, a112 : con |- kind),
      C2 : (g, a113 : con |- con),
      DofR : (g |- cn-of R (pi K (\y470. K1))),
      C : (g, a111 : con |- con),
      Dexpand-il : (g, x : con |- expand-il x (K[..]) C),
      Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C) K1 C2),
      Dwf : (g |- kd-wf K),
      Dwf1 : (g, a : con, x530 : cn-of a (K[..]) |- kd-wf (K1[.., a]))
    | cof : [g |- cn-of R (pi K (\y470. K1))],
      x : [g |- expand-il R (pi K (\y470. K1)) (lam K (\x473. C2))]
    ; by expand-il-equiv [g, b : block (a : con, da : cn-of a (K[..])) |- b.2]
     [g, b : block (a : con, da : cn-of a (K[..])) |- Dexpand-il[.., b.1]]
as DequivX unboxed;
      split
      cn-equiv-reg [g, b : block (a : con, da : cn-of a (K[..])) |- DequivX] as
      case cn-equiv-reg/i:
      { g : conbind-reg,
        R : (g |- con),
        K2 : (g |- kind),
        K1 : (g, a112 : con |- kind),
        C2 : (g, a113 : con |- con),
        DofR : (g |- cn-of R (pi K2 (\y470. K1))),
        C4 : (g, a : con |- con),
        Dexpand-il : (g, x : con |- expand-il x (K2[..]) C4),
        Dexpand-il1 : (g, x : con |- expand-il (app (R[..]) C4) K1 C2),
        Dwf : (g |- kd-wf K2),
        Dwf1 : (g, a : con, x530 : cn-of a (K2[..]) |- kd-wf (K1[.., a])),
        DequivX :
          (g, b : block (a : con, da : cn-of a (K2[..])) |-
             cn-equiv b.1 (C4[.., b.1]) (K2[..])),
        Dof : (g, a : con, z1623 : cn-of a (K2[..]) |- cn-of a (K2[..])),
        Dof1 :
          (g, a : con, y1624 : cn-of a (K2[..]) |- cn-of (C4[.., a]) (K2[..])),
        Dwf2 : (g, a : con, x1624 : cn-of a (K2[..]) |- kd-wf (K2[..]))
      | cof : [g |- cn-of R (pi K2 (\y470. K1))],
        x : [g |- expand-il R (pi K2 (\y470. K1)) (lam K2 (\x473. C2))]
      ; by functionality-kd
             [g, b : block (a : con, da : cn-of a (K2[..])), b : con,
              db : cn-of b (K2[..]) |- Dwf1[.., b, db]]
             [g, b : block (a : con, da : cn-of a (K2[..])) |- DequivX]
        as DequivBx unboxed;
        by [g, b : block (a : con, da : cn-of a (K2[..])) |-
              cn-of/subsume (cn-of/app (Dof1[.., b.1, b.2]) (DofR[..]))
              (kd-sub/refl (kd-equiv/symm DequivBx))]
        as Dof' unboxed;
        by expand-il-equiv
             [g, b : block (a : con, da : cn-of a (K2[..])) |- Dof']
             [g, b : block (a : con, da : cn-of a (K2[..])) |-
                Dexpand-il1[.., b.1]]
        as DequivRX unboxed;
        by [g, b : block (a : con, da : cn-of a (K2[..])) |-
      cn-equiv/trans (cn-equiv/app (cn-equiv/refl (DofR[..])) DequivX)
      DequivRX]
as Dequiv' unboxed;
        solve
          [g |-
             cn-equiv/trans (cn-equiv/extpi DofR
                            (cn-of/lam Dwf
                            (\a. \da. cn-of/app da (DofR[..])))
                            (\a.
                               \da.
                                 cn-equiv/symm (cn-equiv/beta da
                                               (\a1.
                                                  \da1.
                                                    cn-of/app da1 (DofR[..])))))
             (cn-equiv/lam (kd-equiv/refl Dwf)
             (\a. \da. Dequiv'[.., <a; da>]))]
      }
    }
  }
  case expand-il/t:
  { g : conbind-reg, M : (g |- con), DofR : (g |- cn-of M t)
  | cof : [g |- cn-of M t], x : [g |- expand-il M t M]
  ; solve [g |- cn-equiv/refl DofR]
  }
}
;

% Skof-Il Theorems

LF can-skof-il/e : skel -> type =
| can-skof-il/i :
  { A : kind } { B : con -> kind }
  skof-il K A B ->
    can-skof-il/e K
;

proof can-skof-il :
  (g : conblock)
  { K : [g |- skel] }
  [g |- can-skof-il/e K] =
/ total 1 /
intros
{ g : conblock, K : (g |- skel)
|
; split [_ |- K] as
  case kone:
  { g : conblock
  |
  ; solve [_ |- can-skof-il/i _ (\a. _) skof-il/one]
  }
  case ksing:
  { g : conblock
  |
  ; solve [_ |- can-skof-il/i _ (\a. _) skof-il/sing]
  }
  case ksigma:
  { g : conblock, Dskel : ( |- skel), Dskel1 : ( |- skel)
  |
  ; split can-skof-il [ |- Dskel] as
    case can-skof-il/i:
    { g : conblock,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      K : ( |- kind),
      K1 : (z934 : con |- kind),
      Dskof-il : ( |- skof-il Dskel K (\z931. K1))
    |
    ; split can-skof-il [ |- Dskel1] as
      case can-skof-il/i:
      { g : conblock,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        K : ( |- kind),
        K1 : (z934 : con |- kind),
        Dskof-il : ( |- skof-il Dskel K (\z931. K1)),
        K2 : ( |- kind),
        K3 : (z934 : con |- kind),
        Dskof-il1 : ( |- skof-il Dskel1 K2 (\z931. K3))
      |
      ; split can-expand-il [x : con, y : con |- x] [x : con, y : con |- K1[y]] as
        case can-expand-il/i:
        { g : conblock,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          K : ( |- kind),
          K1 : (z934 : con |- kind),
          Dskof-il : ( |- skof-il Dskel K (\z931. K1[z931])),
          K2 : ( |- kind),
          K3 : (z934 : con |- kind),
          Dskof-il1 : ( |- skof-il Dskel1 K2 (\z931. K3)),
          C1 : (x : con, y : con |- con),
          Dexpand-il : (x : con, y : con |- expand-il x (K1[y]) C1)
        |
        ; solve
            [g |-
               can-skof-il/i _
               (\a. _)
               (skof-il/sigma Dskof-il[]
               Dskof-il1[] (\x. \y. Dexpand-il[y, x]))]
        }
      }
    }
  }
  case kpi:
  { g : conblock, Dskel : ( |- skel), Dskel1 : ( |- skel)
  |
  ; split can-skof-il [ |- Dskel] as
    case can-skof-il/i:
    { g : conblock,
      Dskel : ( |- skel),
      Dskel1 : ( |- skel),
      K : ( |- kind),
      K1 : (z934 : con |- kind),
      Dskof-il : ( |- skof-il Dskel K (\z931. K1))
    |
    ; split can-skof-il [ |- Dskel1] as
      case can-skof-il/i:
      { g : conblock,
        Dskel : ( |- skel),
        Dskel1 : ( |- skel),
        K : ( |- kind),
        K1 : (z934 : con |- kind),
        Dskof-il : ( |- skof-il Dskel K (\z931. K1)),
        K2 : ( |- kind),
        K3 : (z934 : con |- kind),
        Dskof-il1 : ( |- skof-il Dskel1 K2 (\z931. K3))
      |
      ; split can-expand-il [x : con, y : con |- x] [x : con, y : con |- K1[y]] as
        case can-expand-il/i:
        { g : conblock,
          Dskel : ( |- skel),
          Dskel1 : ( |- skel),
          K : ( |- kind),
          K1 : (z934 : con |- kind),
          Dskof-il : ( |- skof-il Dskel K (\z931. K1[z931])),
          K2 : ( |- kind),
          K3 : (z934 : con |- kind),
          Dskof-il1 : ( |- skof-il Dskel1 K2 (\z931. K3)),
          C1 : (x : con, y : con |- con),
          Dexpand-il : (x : con, y : con |- expand-il x (K1[y]) C1)
        |
        ; solve
            [g |-
               can-skof-il/i _
               (\a. _)
               (skof-il/pi Dskof-il[] Dskof-il1[] (\x. \y. Dexpand-il[y, x]))]
        }
      }
    }
  }
  case kt:
  { g : conblock
  |
  ; solve [_ |- can-skof-il/i _ (\a. _) skof-il/t]
  }
}
;
